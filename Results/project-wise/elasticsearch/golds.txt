use AbstractRunnable? Then you don't need the try catch :)
you can use the common method `refresh()` here which checks also if there are failures in the response.
this seems high
You can use `expectThrows(MapperParsingException.class, () -> { /* code that throws */});`, then check the message on the returned exception.
Does this change come from the boost change or something else? It feels related but not the same.
this should just catch Throwable I think
Is it necessary to call a public non-final method from a constructor? This can cause issues when somebody subclasses `IcuTokenizerFactory` as initialization order gets important. I'd opt for making `#getIcuConfig()` private which avoids the issue. Alternatives: Declare `#getIcuConfig()` or the class as `final`.
I think isn't needed as the registry is closed via the pipeline store.
They can be added as direct arguments in a separate PR. There should also be deprecation messages along with that so we can remove inserting them into params.
we swallow the exception from the master here. We should do something with (log it?). Also - I'm only OK with committing this now as is (i.e., potentially ignoring shard failures due to timeouts) if we plan to follow up with some proper retry mechanism in the next step. If not, I rather not have a timeout for now.
Can you collapse the check into a single line, it's awkward to read ``` java explain ? "..." : null ``` Since it splits the check and the result, so maybe ``` java return ShardAllocationDecision.no(AllocationStatus.NO_VALID_SHARD_COPY, explain ? "shard was ... in the cluster" : null)); ```
nit: add an import for Settings
nit: please use lowercase start for variable names
if PrefixQueryBuilder won't extend BaseTermQueryBuilder anymore I think we can't extend BaseTermQueryTestCase either here
This is actually an important case. We probably need a whole suite of tests for how things fail when `.ml-config` becomes unavailable. It could happen for example when all the data nodes are shut down before all the ML nodes during a full cluster restart. Also, it would be undesirable for jobs to go into the `failed` state if `.ml-config` has query failures for a fraction of a second when the node holding the primary shard fails and the replica needs to become primary. But such tests can wait for a followup PR.
by passing in "", null I think? you can skip randomizing with such a simple query if you want though, just add the case where you have both errors at the same time.
that works for me, let's just make sure that we have a unit test that sets both the slop and the boost on a phrase query
I think we only need to write out an unchanged index metadata file if the manifest file was missing. If it's present in a manifest file then we know it was fsynced, and I think rewriting every index's metadata on startup will substantially slow down the startup of a node. (The same is true of the global metadata, but the effects of that on startup time will be less pronounced.)
add a note that this be opened concurrently with another engine? It think that's not obvious.
I am now wondering if we still need this queryShardContext instance member if we (almost) always create a new one.
I'm all for 256 bit, but the Oracle JDK 8 ships with a limited JCE policy that restricts key length for AES to 128 bits. To prevent friction with using our secret settings, we need to use 128 bit keys until we have Java 9 as the minimum supported version, http://www.oracle.com/technetwork/java/javase/terms/readme/jdk9-readme-3852447.html#jce
should we have some docs around what this is for and why? I know that I will look at it in a few months and wonder...but maybe just reading "this resolves all of the fields besides runtime fields etc." would help me
ok. fair enough.. > On 04 Nov 2015, at 13:22, Yannick Welsch notifications@github.com wrote: > > In core/src/main/java/org/elasticsearch/action/support/master/TransportMasterNodeAction.java: > > > @@ -48,6 +50,19 @@ > > - A base class for operations that needs to be performed on the master node. > > */ > > public abstract class TransportMasterNodeAction<Request extends MasterNodeRequest, Response extends ActionResponse> extends HandledTransportAction<Request, Response> { > > - private static final ClusterStateObserver.ChangePredicate masterNodeChangedPredicate = new ClusterStateObserver.ChangePredicate() { > > yes, but then it cannot be static anymore (as inner class does not allow static member) > > â > Reply to this email directly or view it on GitHub.
nit: coordinating node sends..
I think we can use the unbounded wildcard here since SuggestBuilder will just add to `List<SuggestionBuilder<?>> suggestions` anyway.
I think the whole point of this PR is to add this new parameter and make it required, so I don't think we should fall back? Otherwise the leniency that we are trying to fix is still here.
Maybe leave a message about why iteration order matters here because this is where the reader of this class first sees that it might.
assertBusy uses by default 10 seconds, no need to specify it here again
ok can be a followup
not sure what we should do in master, seems like things are broken either way. This is fine in our branch cause that's how we move forward for now, till we have found a better solution.
randomInt cannot be within the loop, otherwise it changes at every iteration...
I think println should be rewritten to use this? ``` public final void println(Verbosity verbosity, String msg) { print(verbosity, msg + lineSeparator); } ```
+1 to that but we don't have do that - lets just stick to what we have
hmm is that true? i wonder if this is equivalent to a match all? I could be very wrong.
talking about not using clone here, but simply doing `new QueryShardContext(...all the needed deps)`
I'd prefer warning :smile: Mentally I reserve error for issues like "oh no I'm going to lose data" or "oh boy I have to crash now" rather than "sorry, I'm busted and can't do what you wanted". That feels like solid warning territory for me.
that's not whats happening here. If a snapshot with the name exists in the repository only the snapshot in the repository is deleted. The running snapshot is not canceled. We should do both imo.
I think you can move this to the inner catch then you don't need to remove it from the connectedNodes....
would it work if we called MappedFieldType.valueForDisplay instead? I'm concerned some fields are stored as bytesrefs too but do not represent utf8 strings, like ip addresses
beware it might not do what you think: https://stackoverflow.com/questions/8819738/why-does-double-nan-double-nan-return-false
How do you feel about not setting this and forcing a user of the Java API to be explicit about the rethrottling amount? Otherwise someone can accidentally un-throttle because they forgot to call `.setRequestsPerSecond`
super minor nit: in general, when creating maps and lists and knowing the size you could pass it in.
Maybe add check for object reference equality.
It's totally insignificant, but the actual AD realm type is `active_directory`.
I'd rather not introduce more code paths. I would vote to always have the callback pattern. If people have nothing to do they can call onSuccess on the same thread.
I think this should be done on the top level try no? before we call acquireSearcher.
This seems like as super critical thing not to have a stronger assertion about. I think it is worth brainstorming a better test for a followup.
make it final
Why is this put into a local var? It's only used once.
make it an IllegalStateException please
I wonder if we should do this with no timeout at all. Potentially log warning after 30s and retry.
There is history around the azure plugin so I won't take this as an example. > Unless you have other thoughts I will go ahead and have a simple private method inside the BlobStore that returns the Storage instance. Code inside the Blobstore is responsible for not caching the instance. :+1: Let's do that and not block this PR. This is something we can still revisit later on.
Maybe call this `getNativeScripts()`? I think that makes it more clear what is returned, vs just following exactly the fact that native scripts are implemented through a factory.
I know this correct, but can we use `semaphore.tryAcquire(1,0,TimeUnits.SECONDS)` - It got me worried that we ask for 0 permits :)
done as part of https://github.com/elastic/elasticsearch/pull/15020 too
That's certainly a funky corner case, right? Its a broken plugin that does that.
please wrap on StaticCircuitBreakerService , so it will be easy to read
can we move to the new `write / readLongArray`
remove the static and name it `parse`
since parent is an object, can you use .equals instead? (or Objects.equal like for type)
I don't think `operation` belongs in equals or hashCode.
I think this is not needed. It should use the default account available.
I think I was not really woke up. I thought it was a test assert... ``` java assertThat(Discovery.REFRESH_SETTING.getKey(), is("5s")); ``` Stupid me! :)
as soon as I get #13284 we should have a randomMinimumShouldMatch method...
I'd call this `nestedHit` and make it final
same thing here. We could just call `abortIfNotCompleted`, and then take a snapshot and then act based on FINALIZE, DONE, FAILURE
A lot of the instantiations (of the derived classes) in the tests and a few other places that ultimately pass through this constructor use an explicit `-1`.
This loop tries to insert the closing bracket at the same level as the newly inserted object, right? Also maybe add a short reminder about that in front of the loop so its a bit quicker to figure that out again later.
The code in SortParseElement also seems to support `reverse`, which seems kind of the same as order. Was that deprecated along the way? I'd be in favour of that, seems redundant.
just for kicks should we `assert currentGen >= 0;`
nit: IOException never thrown
I think this is ok, the isFilter() flag should be set when parent queries that are already using toQuery() produce some inner query in a filter context.
> nit: Collections.emptyList() to avoid unchecked assignment warnings. See #15187.
super.equals already ensures this, since it does: `if (getClass() != obj.getClass()) return false;`
I wonder if we need to do this or if we can just wrap the StreamOutput on writeTo when we write the operation in `TranslogStreams#writeTranslogOperation`
I don't think a `finally` block is enough though. If we crash hard between the creation and destruction of the file the finally block won't do anything. Say we lose power or something. Sure, these are exceptional situations, but there isn't really any reason why we can't recover in this case and move forward. Not recovering here means that you have to read elasticsearch's code to figure out to delete the temp file.
let's add an assertion that this method is only called from the snapshot thread.
does it need to be protected? Also maybe rename to something like collectValue ? I find it weird to call add against the script itself
Perhaps this function would be easier if it were structured like `detailedMessage(t)`? Then this function can just return when it finds an ES exc, and exhausting the loop can have a single return statement at the end. I think the null case should be extracted out since it is the same whether we do simple or detailed exceptions? The caller locations in convert will look more inline then, like: ``` if (t == null) { buidler.field("error", "Unknown"); } else if (channel.emitStackTrace()) { builder.field("error", detailedMessage(t)); } else { builder.field("error", simpleMessage(t)); } ```
we need to take care of 5.x indices indeed, but the condition in the if statement should be `context.getIndexSettings().isSingleType() == false`
I think you forgot to change it to request.shardId as a single parameter, instead of the index name and shard id both
nit: please use lowercase start for variable names
for style can we maybe invert the if statements here ie `if (!masterCopy.isEmpty)` and `if (!success)`? I like to have only one return statement at the end of the method
missing error message
nit: space after `connectTimeout`
Rather than `long_size`, it would be better to name this parameter something like `forNewKey` so it describes the logical purpose of the parameter.
Those token names are important, as they tell you what type of JSON token was expected. They may not make sense to you yet, but they are invaluable for figuring out what to look for, eg I was expecting `VALUE_STRING` but got `START_OBJECT` (ie i was expecting `"something"` and got `{`)
I am not sure about this one. I feel like if it's part of `RepositoryData` it needs to be in json. Otherwise it cause things like `fromXContent` with additional parameters. Would it be a huge deal to pass gen id alone as an additional parameter instead of adding it to `RepositoryData` itself. I feel like it's not really a repositories concern, if you see what I mean.
Would be nice to add this as part of this PR unless something big blocks it.
`ignoreMalformed()` would also be true for `GeoValidationMethod.COERCE`, I understand this doesn't change much in terms of the parser logic but maybe it would be more consistent to just use the getters here and rely on the logic they hide.
I think we'll run into an NPE in the failAndRemoveShard code: ``` private void failAndRemoveShard(ShardRouting shardRouting, IndexService indexService, boolean sendShardFailure, String message, @Nullable Throwable failure) { if (indexService.hasShard(shardRouting.getId())) { ```
Maybe it's worth being explicit that this needs to map variable names to paths, given that it is one of the most important params of this agg
good point.... we should be able to get rid of it.
can this be moved to securityutils please? we don't want to expose a lot of this as public
can we deprecate the INDEX_RECOVERY_INITIAL_SHARDS setting? also add a breaking change note + remove docs for it? I'm fine with doing this in another PR, but we need to update the meta issue
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
+1 on removing this
as I said above, not sure I see the added value of this class, I think I would drop it for now
I think we can add here the loading for the simple id cache, if that is used. (gettable from: indexService.cache().idCache())
please use constants here
This seems to work fine for me? ``` diff --git a/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java index db037ad..2cd1d8e 100644 --- a/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportReplicationAction.java @@ -1040,7 +1040,7 @@ public abstract class TransportReplicationAction< * shards. It also encapsulates the logic required for failing the replica * if deemed necessary as well as marking it as stale when needed. */ - final class ReplicasProxy implements ReplicationOperation.Replicas<ReplicaRequest> { + class ReplicasProxy implements ReplicationOperation.Replicas<ReplicaRequest> { @Override public void performOn(ShardRouting replica, ReplicaRequest request, ActionListener<ReplicationOperation.ReplicaResponse> listener) { diff --git a/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java b/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java index ac79a8c..8a168ca 100644 --- a/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java +++ b/core/src/main/java/org/elasticsearch/action/support/replication/TransportWriteAction.java @@ -74,7 +74,7 @@ public abstract class TransportWriteAction< @Override protected ReplicationOperation.Replicas newReplicasProxy() { - return new WriteActionReplicasProxy(shardStateAction); + return new WriteActionReplicasProxy(); } /** @@ -335,26 +335,7 @@ public abstract class TransportWriteAction< * replicas, where a failure to execute the operation should fail * the replica shard and/or mark the replica as stale. */ - final class WriteActionReplicasProxy implements ReplicationOperation.Replicas<ReplicaRequest> { - - private final ShardStateAction shardStateAction; - - WriteActionReplicasProxy(ShardStateAction shardStateAction) { - this.shardStateAction = shardStateAction; - } - - @Override - public void performOn(ShardRouting replica, ReplicaRequest request, ActionListener<ReplicationOperation.ReplicaResponse> listener) { - String nodeId = replica.currentNodeId(); - final DiscoveryNode node = clusterService.state().nodes().get(nodeId); - if (node == null) { - listener.onFailure(new NoNodeAvailableException("unknown node [" + nodeId + "]")); - return; - } - final ConcreteShardRequest<ReplicaRequest> concreteShardRequest = - new ConcreteShardRequest<>(request, replica.allocationId().getId()); - sendReplicaRequest(concreteShardRequest, node, listener); - } + class WriteActionReplicasProxy extends ReplicasProxy { @Override public void failShardIfNeeded(ShardRouting replica, long primaryTerm, String message, Exception exception, ```
A simple change to the message can make this assertion fit on one line: ``` diff diff --git a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java index 5ccb541..ca172f8 100644 --- a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java +++ b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java @@ -54,8 +54,7 @@ public class CheckpointsIT extends ESIntegTestCase { IndicesStatsResponse stats = client().admin().indices().prepareStats("test").clear().get(); for (ShardStats shardStats : stats.getShards()) { if (shardStats.getSeqNoStats() == null) { - assertFalse("didn't get seq no stats for a primary " + shardStats.getShardRouting(), - shardStats.getShardRouting().primary()); + assertFalse("no seq_no stats for primary " + shardStats.getShardRouting(), shardStats.getShardRouting().primary()); continue; } logger.debug("seq_no stats for {}: {}", shardStats.getShardRouting(), ```
hopefully the `System.nanoTime` goes away once you merge master in.
I think it's better to throw an exception, at least in master. I don't think we need a `max_expansion` option though, we can just honor `BooleanQuery#getMaxClauseCount()` and fails the query if there are more terms. The span scoring rewrite does not allow to limit the number of expansions, it is all or nothing and I think it's a good property since it will not confuse the users by returning partial responses on prefix queries that match more than 1024 terms. This is the main reason why I opened the issue in the first place, we should never build a disjunction on more than `BooleanQuery.getMaxClauseCount()`.
the current `to` parameter represents a hard upper bound this request is responsible for. Can we name it something that reflects this `requireOperationsUpTo` and also never set it to null? if need be we can set it to `from` or the leader global checkpoint (and it shouldn't be used as the size limit of the request).
yeah make it an assert
i think this is the right workaround for now...
this should go away here I think it's impl details of a bwc layer in S/R
thanks, that explains it.
OK. It was just a suggestion. UweSays: Switch statements are very non-java like and must die :-)
shall we make some of these protected? sounds quite wrong to be using this exception without providing a status. Would be nice to remove some of these variants but I guess they are needed by EsSecurityException.
You need to override `withCircuitBreaking` so that it returns a MockBigArrays as well
I feel like this can be simplified further, but this is a good start.
I thought this query would be useful to users as well but looks like we prefer to keep it internal only. In that case we can remove this parser class, it will be similar to EmptyQueryBuilder. A query that can be streamed but has no corresponding parser. We register it via `namedWriteableRegistry.registerPrototype(QueryBuilder.class, MatchNoneQueryBuilder.PROTOTYPE);` in `IndicesQueriesRegistry`, like we do with `EmptyQueryBuilder`.
Mocks would only help hopefully trimming the test down and not requiring to throw an exception to properly test things, which is what feels wrong here. They won't help testing it further than this test already does.
thanks for adding this!
another upside of using permits is that it guarantees the sync runs after history gaps have been filled in
I see. I just tend to encode these constraints in the type system, that's why I've asked.
Where is this done? I think to make things cleaner we in `doBuild()` we should check if sourceFieldNames is null and if so set it to `fieldName` in the factory. This means that everything past that point can deal with fieldName and sourceFieldNames as if they are different field even if they are the same.
this should not be `AnalyzerScope.INDEX`, cause its cached on the enum level, so the scope should probably `AnalyzerScope.INDICES`. I would simply use the scope provided in the constructor (which will be the INDICES one).
should we add a new UNASSIGNED_PRIMARY_TERM constant? There are too many of these magic 0 terms sprinkled all over.
I'd prefer percents/keyed/docValueFormat to be declared and instantiated here if there is no other reason I am missing atm.
"now" -> "not"
I think you use it indirectly through `parser. isBooleanValueLenient`.
there's a typo in the method name ;)
need to wrap in try ... finally block and close the parser
I like these simplifications ;)
docCount is a a long so it's totally fine, sorry.
can we remove this? I don't think it's needed.
> TimeZoneRounding.Builder expects everything thats returned to be an instance of TimeZoneRounding TimeZoneRounding doesn't add anything on top of Rounding so I think it's ok to return/expect Rounding instances here.
Really you just need to look @ the first int of the segments_N ... if that's == CodecUtil.CODEC_MAGIC, the index was already upgraded to 4.0+. Then you don't need to step through each info.
lets' introduce a dedicated exception for this. We can upgrade discovery.zen.NotMasterException to be in the cluster package and use that.
I think we can just access the member directly.
we typically don't like using tuple return values. In this case I think we can just return a HashSet.
Can this be package private? I think its not needed except by bootstrap and bootstrap for testing.
I think maybe just "return Math.log(doc.popularity) \* 100;", you don't need the "<idOrCode>" bit.
Boost will be set in BaseQueryTestCase. No harm here, but doppelt gemoppelt (I want to try to gradually introduce this expression into the english vocabulary like Kindergarten and Schadenfreude) ;-)
This might be redundant now.
I get that, but given that this going to be used in the indexing logic as well (we should share the code) - I rather avoid the boxing. We can add request level/serialization validation that the values are proper.
To be clear, I don't think we should change this to an I/O error. I think I'd be okay with a configuration error though.
Nah - you are right. Don't fight the IDE - without a strict policy its just silly. And we'd need a nice IDE configuration to make them never happen.
We should also get rid of this local variable (The map is not needed as `DiscoveryNodes` has a method `get()`). We could write `this.nodes[i] = clusterState.nodes().get(nodesIds[i]);` a few lines below. If `clusterState.nodes()` is too verbose, we can extract that one into a local variable.
this is not concurrency-safe. Closing can be happening concurrently to this.
Can you rename it to something else? This is close to `ordinal` which also exists on enums but should not be used for serialization as it would change if we added/removed entries in that enum.
I have a similar concern here for when entry.getValue is not a Map
no need for this, that's the default..
Maybe the max should be more? Something like 5
Can the collapse the multiplying by 50 into the setting itself? It feels arbitrary and I have no idea where the 50 came from
make class final
@javanna Yeah, that's exactly what I have in mind.
Indentation is off here and the line below (super minor)
the code that exists now, doesn't bother me :)
This shows up as unused for me.
This could return an immutable list
can we specify that only complex metadata (object and arrays) are not parsed? This will have to be updated though if we move subclasses to use addMetadata whenever possible, later. Also, I wonder if we can do better. We could parse this unknown info into a map, but then there wouldn't be a place for it in the ElasticsearchException, unless we make metadata `Map<String, Object>`. Let's think about it, it may make sense for the future, not now maybe.
I think the indentation was better before, indicating these lines are a continuation of the try with resources.
are we considering all of the description etc a contract that we need to validate does not change? The reason i ask is cuz maybe it does not make sense to test this much detail as to what the output of the strings are.. I get that we can easily check available/enabled, but id hate to see a test fail here cuz we changed the description (unless we view it as a contract)
perhaps this check should be for versions before 5 instead, otherwise we'll need to fix this for 6.0 as well
s/Assumption: // Its part of the contract for the bulk api.
can we make this `private final` :)
Would you break each of the separate test cases into a separate test? `testValidateNameComma`, `testValidateNameLeadingUnderscore`, ... Also, I'm not seeing a test that a name can otherwise contain an underscore as long as it's not the leader character.
++ to do that
This is entirely too harsh, this will fail the node if we get this wrong. We should fail the shard for sure though.
with the new close logic, I'm worried about unneeded warn messages in the logs during shutdown. I wonder if we should add a global close flag to the entire class that can be used to suppress this.
Is there a way we can check this property on startup as well/instead? Maybe we could check it in SearchModule or MapperService? The concern I see here is that restarts can be a pain for users and here they will only get feedback on the setting when they try to use a span query and then they can't use the query until they get the admin to restart the cluster
can we add a little note about avoiding race conditions between read and writes on a shared FS ? I think this will people we not see why we opted to EMPTY_COMMIT_ID
Pick node with THE primary shard
Elasticsearch guarantees that two nodes that have the same major version can talk to each other, so I'm wondering if HDRHistogram has a similar warranty so that upgrading HDRHistogram in a minor Elasticsearch release would not break Elasticsearch's wire protocol.
we might use `ExceptionsHelper.reThrowIfNotNull(exception);` here instead
make this a hard check please
looking at usage of this Text index, I think it can be removed and replaced by sharId.getIndexName()
I think that we need to be able to deal with higher node ordinals somehow. To be discussed, as it's not immediately clear how to do so.
I think this should be `Strings.collectionToCommaDelimitedString` and then you can use our Strings.java instead of JOpt's version
Same feeling here about how I'd much prefer to have this extracted to a class, where you pass in the parts that are needed, if possible.
nit: space after `[{}]` plus typo on temporay -> temporary
number of retries should be removed as a constructor arg
Looks like `FieldSortBuilder` is the only impl of SortBuilder that actually supports `missing`, so I'd try to delete this from the interface and move it there.
I guess this could still throw on us? How about we catch the channel exception here and re-throw it as an I/O exception? Then I think we are covered on all bases.
not really scope of this PR, but otherwise I will do it.. if we use `String.format()` for those URLs, they will be more readable
maybe call this `onFailure`
Sorry for all the trouble with this! It was a mess before and you are only making it better and this is really just another thing to do to make it better but hashcode and equals being consistent is one of those cardinal rules of java....
Since `IfNull` always expects 2 arguments, force this into the constructor: ```java public IfNull(Location location, Expression left, Expression right) { super(location, asList(left, right)); } ```
And the array allocation!
you should pass ctx.reader().maxDoc() instead of 0 for things to work properly
I think you should pass in the request here instead of empty params
It might be a good idea to store a version of elasticsearch that generated the task somewhere on the top level. So, we could filter out incompatible versions in the future and don't have to support old persistence formats forever.
Why did you choose to make `#randomRepoPath()` static? As you pass in the test case instance to `SnapshotSharedTest`anyway? I assume you decided that because the implementation only relies on class state, not instance state.
Ok - I reverted the 4.8 change locally but kept the other changes and everything *looks* to work. I don't think we can upgrade to 4.8 until we get to the bottom of this.
If users start using eg. "content" because it works and if we want to use the "content" parameter in the future for another use, it will feel like a backward compatibility break to those users. So I would rather throw an exception.
This isn't needed client-side.
oh boy I was hoping we would not need this sort of stuff, but I guess we do? I mean the instanceof as well as the cast to double array
Beware that strings need to be compared with .equals, `!=` might return false even if both strings contain the same bytes
That's right - you need to call them out explicitly.
given that this is a private class we can just make all the members package private to prevent syntetic access and remove the getters? Prevents unnecessary code IMO - I hate that java has no structs yet :)
while we're looking at this: Does it make sense to put this into a conditional along the lines of ``` if (indexShard.getTranslog().getLastSyncedGlobalCheckpoint() < globalCheckPoint) { indexShard.getTranslog().sync(); }
Can you at least change it to: ``` @SuppressWarnings("unchecked") private static <T> T get(String key, Map<String, Object> map, T defaultValue) { return (T) map.getOrDefault(key, defaultValue); } ``` I don't want us to reimplement core stuff just to avoid an explicit cast
maybe put these checks into validate() method? The checks are then all in one place (the disadvantage is that exception happens later).
Error if a mix of old style and new style params used alongside each other
I think a better name would be `acknowledgeResponseReceipt` or something similar
I'd vote for removing this constructor and change the caller to provide explicit arguments since it is not obvious what the defaulh parameter values should be
Also, I would make the method not abstract and have the default impl throw exception.
++ on hasNormalizationFactor . I would probably associate the flag to the parsing of normalized_value only. the other field is only optionally printed out.
I think we can put both leaderGroup and followerGroup into a single try-clause.
a nice side effect :)
I wonder if you want a CyclicBarrier here.
nit - an extra d? release**d**Delayed..
I wonder if this method should return NO instead of null. This also makes the line ``` UnassignedInfo.AllocationStatus allocationStatus = decision == null ? UnassignedInfo.AllocationStatus.DECIDERS_NO : UnassignedInfo.AllocationStatus.fromDecision(decision); ``` obsolete in another place.
don't think we should do this for abort, i think this should stay like it is for abort and only work as described for READ ONLY operations. For abort I think the current behavior makes perfect sense.
The first line of the method can be removed now - the endTime variable is not used. ``` long endTime = System.currentTimeMillis() + request.timeout().millis(); ```
you should assign a new list instance (or clear the `abortBenchmarkNodeStatuses` list) to make sure we are not reading an instance that already has some status in the list.
For the default value, you can more safely use `TimeUnit.DAYS.convert(14, TimeUnit.MILLISECONDS)`.
nit: extra line
if we'd make the `2` a double I would sleep much better at night ;) same below :)
I think there is something wrong with GCE http client code and we will need this around it, we grant the permission as a workaround. It would be really good if we could get this fixed in their code though. It makes it difficult for apps to protect credentials etc to their services!
Nit: Typo in validateValue()
all of these methods should create an instance of termsLookup if null I think , and we shouldn't initialize termsLookupBuilder at line 70.
I think we can simplify this a bit and maybe have a class that does that ie this: ``` Java static class IndexShardReference { private final AtomicReference<IndexShard> ref = new AtomicReference(); void setReference(IndexShard shard) { indexShard.incrementOperationCounter(); assert ref.get() == null; ref.set(indexShard); } void removeReference() { IndexShard shard = ref.get(); try { shard. decrementOperationCounter(); } finally { ref.set(null); } } } ``` this seems cleaner? or do I miss something
maybe rename this to assertMaster (as you supply the masterNode that we should match)
Fine with me, just a thought :)
I think I'd prefer if it were just a string/enum/whatever that made the logs and api spit out "true"/"false"/"unknown".
do we wanna call it `regex` or `regexp` I don't care too much...
I thought that you wanted to set the id in both cases and that the else block should become `new GetStoredScriptResponse(id, null)`
Ok I missed the recovery-private thing. Thanks
This can be only `Files.isDirectory(hunspellDir)` since `Files.isDirectory` returns false if the file doesn't exist.
you can not override them when you subclass which is a pita
space after comma
can we do `if (closed == false)` or use an AtomicBoolean and use `if (closed.compareAndSet(false, true)) {`
creating two ArrayLists may not be the best thing to do. Lets do this instead: ``` List<String> splitList = new ArrayList<>(); Collections.addAll(splitList, oldVal.split(separator)); ```
space between `try` and `(`
no need to shuffle here, since it is always a single element list
We can push this down to `IndexShard.onSettingsChanged()`. No need to touch `IndexService`.
maybe make this a `private final AtomicBoolean closed` and in close you can then protect double closing by ``` Java public void close() { if (closed.compareAndSet(false, true)) { //do the things } } ```
We'll keep this format around not only for backward compatibility, the array form is just another format.
you can replace both lines (check for failed shards and total hits) with: `assertHitCount(response, 2l);`. I would it everywhere in new tests as it makes them less verbose.
I would just access the recoverySettings directly - test changes will have effect faster.
Throwable's toString eats stack traces. I'd just `throw new RuntimeException("unexpected failure", e);`
I don't think we should delete the index at the beginning of the request. Instead, we should throw an error if the special index name exists. That way, if it is somehow an index that was created by the user, we would let them know, and not silently delete their data.
I wonder if we want to rename this one to avoid confusion.
good point, I think I went for pretty as default there because it's called by `toString`, and that made more sense in most of the cases, at least for queries and java api builders. Those methods are there solely for logging and debugging at this point. It does make sense to pass in false then in this specific case.
can we please use abstract runnable and override onReject() to ensure we don't barf if that threadpool shuts down.
> I do think that these things actually add value when the field is used more than once in the class Having a `static final String` constant is fine (if you refer to the constant, or refer to a literal string, it doesn't matter they will both end up in the constant pool for the class), it's adding an _extra_ class to hold it that is unnecessary and just adds extra classes to be loaded.
hmm can't we use `State.values()` and if this is only used for `fromId` I think we can just do this: ``` Java switch(id) { case RUNNING.id: return RUNNING; //... } ```
`throw new AssertionError(e);` to get full stacktraces etc
I wonder if it now makes more sense to have this setting on a shard level (since shard owns the inactivity). We can fall back to the old, node level settings (or just remove it if this is 3.0 change only and deprecate on 2.x)
no, the existing TermsLookup shall remain, but we have to add serialization etc. to it.
If we assume that all surrogate pairs need encoding, I think we can make this simpler? ``` int startIndex = i; for (i++;i< s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false; i++) { assert Character.isSurrogate(s.charAt(i)) == false || doesNotNeedEncoding.get(s.charAt(i)) == false; } final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8); ```
I understand why you did that but I find that the two storageAccess() just adds extra unnecessary noise. I think we could instead have a simple private `safeClient()` method that returns the `Storage` client to use, and later do things like: ` SocketAccess.doPrivilegedIOException(() -> safeClient().get(bucketName));` I find this easier to read and to understand where the stack is cut for access control.
nit: can we use the suffix "source" instead of "string" for these scripts? That matches what we call it now in scripting code.
just noticed this uses `metadata.settings()` (= correct) whereas `updateDelay` in `AllocationService` uses node Settings (which are not updated).
I think we should be very conservative here by default
I think we can afford to make this `HashMap` eagerly and avoid the noise in the loop.
Actually, I think we can do this without a `TemporaryFolder`. We can just write a new file within the `globalTempDir()` that is already available, no need to create a new folder. Also, this should make it possible to merge this new class with the existing `LogginConfigurationTests`.
I don't think we should special-case this. Depending on underlying blobcontainer, a different exception might be thrown.
this should throw `UnsupportedOperationException`
I wonder if we should use something like `"_na_"` similar to the `INDEX_UUID_NA_VALUE`. That is more an explicit value.
Sadly yes... We need to use `BaseCompositeReader` in the method signatures of our field data code instead of `DirectoryReader`.
Can we remove the "ingest_" prefix here? To me this structure should be similar to what we have for: ``` GET /_nodes/stats/indices?filter_path=nodes.**.indices.suggest { "nodes" : { "1S6tILi0QtKdOBVBMXml4Q" : { "indices" : { "suggest" : { "total" : 0, "time" : "0s", "time_in_millis" : 0, "current" : 0 } } } } } ```
This changes the empty options.. no good..
It might be worth adding a default implementation of it to whatever interface declares it. The vast majority of the time its a noop.
Feel like this kind of thing should be logged for debug purposes (realizing it was not done previously).
just do `registry.getIndexSettings().getIndexVersionCreated().onOrAfter(Version.V_5_0_0)`
And the first one feels fairly special around copy and ngram together? But I it can be a yaml one too without too much trouble.
what is unused is unused :) I have no idea how it became unused though.
you could extract this in a private method to share some code with the scritp execution below.
minor nitpick - use the `Deque` instead of `LinkedList`.
can you rename `k` to something a bit more meaningful? :)
to the same node
Maybe for now we should move things into one package. When we want to make ingest a separate jar then this will be a separate project. There are other things that we will have to address once we move to a dedicated ingest jar.
maybe we should change this and move the check to the data node already? not sure //norelease is good here, or maybe I am missing something
How does the volume of data relate to the slowness of the search api in the remote cluster? We are using scan search which is pretty fast and doesn't do deep pagination, and e.g. socket timeout set to 10 seconds doesn't mean that the whole response has to come back in 10 seconds, the request only times out if no data comes back for 10 seconds at any point of the request execution.
can we put it in their own catch clause similar in how it's done in refresh: ``` } catch (AlreadyClosedException e) { ensureOpen(); maybeFailEngine("refresh", e); } catch (EngineClosedException e) { throw e; } catch (Throwable t) { failEngine("refresh failed", t); throw new RefreshFailedEngineException(shardId, t); } ```
:heart:, this is one that I've wanted to do for a long time.
"have to eagerly evict or ..." -> "have to eagerly evict expired values or ..."
I don't think we should have this constructor on the client side, as there's no way to sensibly add the missing values (and no sensible reason why the user would need to).
Nit: Should still work as protected as far as I can see.
It might make sense to replace this class entirely with ParseFieldRegistry. I'm not sure.
`+ query` should do it.
if you get merge conflicts on these MetaData calls that should have been static, don't worry, I think I recently merged a PR from a contributor that fixed just that.
If `recoverySourceToKeep` was a bitset, we could do a leap frog, which would be faster if `recoverySourceToKeep` is sparse. ```java final ConjunctionDISI intersection = ConjunctionDISI.intersectIterators(Arrays.asList(numeric, new BitSetIterator(recoverySourceToKeep))); return new FilterNumericDocValues(numeric) { @Override public int nextDoc() throws IOException { return intersection.nextDoc(); } }; ```
Changes in this file make the assumption that the only thing that a Engine.GetResult.close release are the underlying searcher, I think it's too fragile
hmm, is there a typo somewhere in the end (s/shared/shards maybe?), I don't understand it. But otherwise, I would have been happy with just "Apply secondaryComparator last as it is more expensive than other comparators"
I would give this method the same name as the method above: `enoughShardsActive`. One operates at index, the other at the shard level. To make things even more explicit, the above method could have parameters (IndexRoutingTable, IndexMetaData) and this one (IndexShardRoutingTable, IndexMetaData). This would also leave it up to the caller to deal with `indexMetaData == null`.
can this be a norelease
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
+1 for doing it this way. I think that this'll make extracting this class from core into an xcontent jar more difficult but I think we should cross that bridge in another PR.
I had not though about option 2 but I really like the fact that it does not require to add a new API. But if this argument does not resonate to you, feel free to push the change as-in, I don't have too strong feelings about it.
We can drop everything after and including the period.
this looks awesome!
should this check be in the same place where we make the actual transition? then it doesn't look a `LIFECYCLE_FORCED_PHASE` would have to be set as a signal back to this execution.
It *looks* to me like this will hit a `NullPointerException`.
Actually, I think this logger can be removed now (thankfully).
that `!` fucked me up can we have `== false`? ð
I think it's good to reuse this threadpool, but it implies that the analytics process is a "job" from the point of view of deciding how many jobs can run on each node. We definitely need to hook these processes into a unified allocation framework. Also, maybe rename the threadpool to `JOB_PROCESS_THREAD_POOL_NAME` or similar.
I also think we should default initialize the `mapingsToUpdate` and trash all the `null` checks just make if final and done...
nit: space between `if` and `(`
It would also allow us not to have to make `parse` throw a checked `IOException`
@colings86 Is it correct to use the printer to define how dates should be parsed, I would rather expect it to be the role of parsers? I think we need in this iteration to collect _parsers_ for all inputs formats as well as the _printer_ of the first one? (while master currently uses the first parser as a printer, and your patch collect all printers to know how to parse)
(this refers to the access controller block)
We lost some info here - the original error was also including the request and timeout settings (and some more stuff, but I think that's minor)
good call on the typo. I did see the issue that originated this change, thanks for the heads up ;) Just trying to understand if yours is a special case that needs a custom timeout (which could be set), or whether the default timeout really has to be increased that much.
Oh good point, I missed the call to getAddress
Word wrap again.
trace logging here as well
Oh, and _nit_ on the unnecessary brackets :)
It doesn't _need to_ be a functional interface. It makes it easier to work with, I think.
`== false` here, as we do this in most other code as well
this needs to be version 6.3 now
This isn't a hot code path so I'm quite willing to try and write the most readable code possible and let the optimizer try and optimize out the extra OR operation if it is capable of it.
We could also use `FileSystemUtils.isAccessibleDirectory(Path, ESLogger)` to make sure this dir is readable.
yea thats fine, this whole class is marked //norelease , that makes sense
Two concerns here: If we convert Strings to BytesRef here, shouldn't we also do so in the (..., String... values) constructor? Also, since this seems a convenience method, I'd prefer converting the content of the Iterable to be converted to some array and then use the (..., Object...) constructor, as there are already too many ways of constructing this query builder.
Let's add a `"text-align:right;"` to these last three numeric fields.
Minor nit ```suggestion throw new IllegalStateException("index shard " + shardId + " is not blocking all operations during read-only marking"); ```
oh right sorry I keep missing that.
The path is a required option and this is unreleased code so :+1: to make field and write mandatory.
Yeah. I'm not sure either. I like that concrete classes are nice and quick. Lets drop this point for this PR at least.
`isCustomDatePath` -> `isCustomDataPath`
Suggest `Strings.isNullOrEmpty(username) || password == null`, but I'm not certain that a username _cannot_ be empty.
Painless is neither Groovy nor Java. We maintain similarity for convenience of new users being able to jump right in. The only reason the boxed types are even whitelisted is so that other whitelisted methods that require the boxed types can be used. One bonus is that we allow unboxed types to call boxed type methods. But otherwise, there is no reason I can think of to use a boxed type. Eliminating boxing support for these types other than that situations I listed above has removed immense amounts of complexity from both casting and promotion. I strongly stand by this decision and will continue to do so. On the boxing situation for the elvis operator I would make it work exactly as the regular conditional does right now. If a regular conditional had `Integer a = Integer.valueOf(0); int b = a != null ? a : 1;` I would expect it to throw a CCE. Divergent behavior between the two operators will be even more confusing, not to mention the odds of someone actually hitting this is pretty low considering the def type should still work. `def a = Integer.valueOf(0); int b = a ?: 1;` should work without any issues. Another option would be to disallow primitive types from working with the elvis operator at all.
You are right, I messed up :) I was pretty sure we had dedicated apis for search templates, but I confused the REST layer with the Java api. Leave it as-is, sorry for the confusion!
This is covered by assertAcked? (same for other occurrences in this class)
We should be returning `null` in this case. If nothing matches the bounding box, nothing can match the polygon.
I wonder if this really belongs in the request converter. It is the request logic that requires this bit of processing so we could simply call this utility method in the request conversion.
I am starting to wonder if this additional code belongs to PipelineStore. seems like it's become much more than just a store. (referring to InternalTemplateService and the doStart above)
this is a joda time class
One nit: `TimeoutHandler` -> `timeout handler` so that we're speaking plain English instead of code in these messages
maybe - failed to find primary but cluster state version [{}] is stale (expected at least [{}]).
maybe `clauses` can directly store Integers.
does using object parser cause us to be strict with potentially newly added fields to the response? Maybe it is time to investigate what we can do to make our response parsers more understanding (still having a setting that allows to enable a strict mode). I am asking because I remember I added `cluster_uuid` to this response with 5.0. In general shall we start not expecting fields that may not be there, and being more flexible with fields that are there although unexpected.
or rather the `Settings#getAsMemory` you added...
I think it must be abstract if it's named `*TestCase`
Can you just break these all onto one line per? This was also changed last week and if that was done then, the change set would just be the additional line.
If you always want to use the lowercased version of the constant maybe just implement `toString` to return lowercased? I'm not sure what the right thing is here but it isn't a big deal either way.
I think this should be moved to QueryCreationContext and exposed here through it temporarily
the changes should not be here, these tests have been moved to IngestClientIT upstream
Does this really need to be generic? We certainly don't care about any of that on the consumption side.
`){` -> `) {`
Else right after a return makes me sad. I'm not sure I have a good reason to think that way, but I do.
maybe only catch `IllegalStateException` to avoid hiding bugs? It seems to be the exception that the text field throws when fielddata is disabled and numeric fields when doc values are disabled
This can be `final` too
When trying to figure out what exactly goes wrong when the above query is executed\* I noticed that the template string above doesn't look quite right. When changing it to ``` String templateString = "{" + " \"template\" : {" + " \"query\":{\"match_{{#use_it}}{{template}}{{/use_it}}\":{} }," + " \"params\":{" + " \"template\":\"all\"," + " \"use_it\": true" + " }" + "}"; ``` your test is green on my master - am I missing something here or was that just a misunderstanding on how to formulate the template? Caveat: I didn't check re-formulating the other two tests yet. - And finally printing the non-quoted version after staring at the quoted one.
another option here is to remove the `success` and just call `translogs.clear()` once you are done and simply close the lists elements all the time
No need for the newline here
This will also accept something like "BBOX (-10) 10) -10) 10)", I think this should throw an error. Its a bit constructed but I think the parser shouldn't be that lenient.
That's just a minor thing but I think the recommended order in the Java styleguide is `static final`.
ok fair enough. I think for this delicate issue we should force the right setting IMO
it still bugs me slightly that we end up exposing this. Thinking of alternatives, we could move a portion of ParseContext#executeIndexTimeScripts to MappingLookup and rather expose a method that returns a Map<String, Consumer<LeafReaderContext>> but I am not convinced this is a good idea either ;) maybe you have other ideas
I'd appreciate if we can do `== false` it's just so much easier to read
I believe we don't need this now.
I wonder if the entire function could be simplified to the form: ``` current = min while (current <= max && iter.hasNext()) { // get next bucket // loop current up to nextBucket // set current to nextBucket rounded } while (current <= max) { // handles both empty case and trailing case } ```
this is the joda time class, which means this needs to remain original upper cased
can this api be package private
Nit: I think you can leave out ESTestCase here.
can you give an example of the output here? I wonder if we have duplicate information between the shard info and the failures bellow.. also, I'm not sure it should be a top level item here, but rather inline with each op.
Ah, this is a backport PR -- nevermind me!
The "liveness" request sets the type to "state" but I imagine that doesn't matter here because there is only a single channel open anyway. Actually it looks like the default is `REG` which I guess is more accurate for this. Speaking of the liveness request, why do we need it if we have this? I guess the liveness request can use the version but it feels like this request has all the information that the liveness request has.
Can you put the read/write logic for the enums into the respective class? That way it's easier to see how these enums are sent over the wire.
maybe also assert that the index that is supposed to be removed really is removed? I think we now just check that all other indices but the removed index exists. I think that for that, just checking that the number of backing indices is decremented by 1 should suffice.
I think that we need to do a hard exception indeed, we won't be able to read the rest of the message at this point because we can't read the customs (no `IndexMetaData#lookupPrototypeSafe anymore`) when there are unexpected ones. That is, `customSize > 0` is fatal for us.
It's unfortunate java doesn't have something like this :/
"err" doesn't sound like "error"? Have you though of using a diff name here and in code? It is fine to keep this name as well if you think so.
Also, I think that the exception message should include the offending cluster the name. The pattern that we usually use is ``` [cluster.name] must not contain ':' but was [<offending cluster name>] ``` This is another argument against introducing indirection here.
this is an inner class anyway, why pass these along? If you want to make it a static inner class, I'm good with it, although I'm not sure if it's worth the extra clutter.
I think this should be an `AbstractRunnable`, so it can either set `isForcedExecution` to true, or handle rejections gracefully, in the event the executor is ever set to a threadpool other than the generic one, or if we limit the queue_size for the generic threadpool (which we have discussed doing)
@jdconrad sure. The place where the expression script will be used is here[1]. Is this enough for what you need? If not, please let me know. [1] https://github.com/elastic/elasticsearch/blob/a216062d88205c0d109ac00a432b45bc90a14fe8/core/src/main/java/org/elasticsearch/search/aggregations/pipeline/seriesarithmetic/SeriesArithmeticPipelineAggregator.java#L109-123
same as I mentioned in the prefix query PR, wa may want to backport this fix for the java api to master.
The `Math.max` calls here and throughout are unnecessary; `System#nanoTime` is relative and will not go backwards.
Let us leave adding 6.1.5 out of this PR, that should be picked up separately. The strategy would be: - add 6.1.5 to 6.1 (plus a version bump to 6.1.5), 6.2, 6.x, master - add 6.2.4 to 6.2 (plus a version bump to 6.2.4), 6.x, master
IllegalArgumentException is unchecked no need to put on the interface you can just throw it
Why do we need this? The TokenizerFactory.name() was never used here before.
should be removed, `PluginInfo#DEFAULT_VERSION` should be made public and used here instead
can we change the method name to `valueForKey(long key)` (better indicates that the passed in value is the key... and differentiates it form `round(long value)`
It feels weird to have a call to `.value` at the same level as all the calls to `.field`. I presume this works because UnassignedInfo writes its field name. Maybe call `unassignedInfo.toXContent` then? You are more of an expert on this stuff than I am though.
If you prefer, in the indexing method we can do tryAcquire first out of lock and go under lock and try again, if failed.
Ditto on the use of ParseField
this is very confusing.. please use INLINE though
if think you can throw a hard exception here ie. `ElasticsearchIllegalArgumentException`
don't set tests.seed, it is already set.
I mean that if a term is in the accurate response but not in the accurate one, we should assert that the count in the accurate response is less than the agg-level error margin on the inaccurate one
nit: this is normally called the "short hash" so reversing it sounds very odd. :)
not true anymore
I wonder if it makes more sense to push the default into the engine rather than a fixed switch statement. Like, plugins could declare that they should be on by default or off by default.
give it the tests name that might make it easier to figure out where it leaked if it leaked
I think this one needs to be `true`
Bleh. Not worth it then. Sorry for the bother.
Instead of using `IndexWriter` here, you could use `DirectoryReader.listCommits` (there should be at most `IndexCommit` returned) and then call `IndexCommit.getUserData()` instead. Seems safer since `DirectoryReader` cannot do any writing on the index, doesn't acquire the write lock, etc.
wouldn't it be simpler if you remove the `viewGenToClean` and just do this `return new View(deletionPolicy.acquireTranslogGenForView());`
Oh nevermind, I see why not now :)
I'm still unhappy about this: if for some reason you need to add another wrapper, it could hide the FilteringGeneratorDelegate and JsonXContentGenerator wouldn't know anymore that the content is filtered. I'd rather like something that does not depend on "instanceof".
oh I see thanks for explaining. leave it as-is then, thanks! I will merge this in the coming days.
Is it possible to not implement BytesReference just to throw the exception but to actually use a "source" that will trigger some JsonParseException when creating the parser from source? I think that would be more realistic and a better test.
space after Ì<`
OK I see the point. Thinking about this some more though, I think the following variation of the condition will make it clearer what we try to prevent: ``` if (shardRouting.primary() && shardRouting.active() && state != IndexShardState.RELOCATED) { // must use exception that is not ignored by replication logic. See TransportActions.isShardNotAvailableException throw new UnsupportedOperationException("active primary shard cannot be a replication target before relocation handoff " + shardRouting + ", state is [" + state + "]"); } ``` It precisely states that we cannot replicate into an active primary as long as it hasn't been relocated.
I'd probably keep the old signature of this method and do the set construction above.
Nice, I like it to have some more controlled, non randomized tests here for basic behaviour.
Not sure if we need to do that it's just one entry per field though.
This will need to change to read a boolean to tell it whether it needs to read a doc or Id so it can use the right constructor and doesn't trip up passing nulls into it
I haven't thought much about it but this is not an easy problem indeed...
see above we have a `writeStringArray` as well
at first I thought this format would make it difficult to know how many policies didn't use a certain field, but after a few test queries, it looks like this is sufficient
see above about abstract runnable
I'd write this `ImmutableMap.of("term_vectors_fetch", new TermVectorsFetchParseElement());`. Not that it matters either way.
do we want to cache when we are using delegated realms for resolving user? because we are doing lookups in any case
> while in this case we only make a copy if maxBatchSizeInBytes limit has been reached. he - I'm pretty I saw we did in some previous iterations. And yes - it must allow reads because we block reads when we don't consume the write buffer. In a sense the right moment is when you coordinate writes and you consumed some buffer elements. Both are fine with me
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
nit: naming this "template" instead of script (although the argument is technically a Script) could communicate the usage of this setting better
This is no longer used, could be removed
It's really minor, I mean `decimalPrecision` could be before `radix` which is list.get(9).
Rather than `- 5` I'd do `- ":desc".length()` just to make it super clear what is up.
And this is required so the tasks request has something to target.
I think that instead of looping here just checking that the index that is supposed to be removed is removed and checking that the number of indices is decremented by one is sufficient.
I know what you mean about creating the json, plain strings would work I guess... we have this same problem in other queries (e.g. term query)...something we have to keep in mind for later.
I guess something went wrong.. no biggy.
The name of the method confuses me a bit because it's not an "update" method but rather a "remove specific blocks" + "add" method. This seems to be specific to some index blocks in a given context (restoring an index) and this method is located in `ClusterBlocks.Builder` class... I think the removals should be explicitly located in the `RestoreService` instead.
we shouldn't be lenient in case `lowerTerm` doesnt't implement BytesRef
I added a `randomNumericDocValueFormat()` method in core which seems appropriate for this.
but `electMasterService` is passed to the ZenDiscovery constructor? I don't follow, sorry.
This is great! No more @Inject!
I would think that it is better to sort this once once all the tasks are added instead of for every `task : tasks`.
this could be replaced with Objects.requireNotNull
I tried to think this through and we might be subject to concurrent deletes if we do it this way. Can't we instead do something like this: ```Java DocIdSetIterator soft_deletes = DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator("soft_deletes", sr); Bits liveDocs = sr.getLiveDocs(); FixedBitSet hardLiveDocs = new FixedBitSet(numDeletes); hardLiveDocs.set(0, numDeletes); for (int i = 0; i < liveDocs.length(); i++) { if (liveDocs.get(i) == false) { if (soft_deletes.docID() < i) { int doc = soft_deletes.docID() == DocIdSetIterator.NO_MORE_DOCS ? DocIdSetIterator.NO_MORE_DOCS : soft_deletes.advance(i); if (doc != i) { hardLiveDocs.clear(i); } } } } ``` note I didn't try this out.. just to provide an idea
`Matchers` is the more idiomatic way to do this.
One more thing, looking at the implementation of `failShard`, we don't need to append `e.getMessage()` here.
`if (value == FALSE) value = FALSE;` doesn't change anything so it can be removed.
I think it'd be useful to see the path in the exception message.
Duh sorry you're right ... don't change it!
It looks ok to me
I think we should delay these disconnections. Maybe we should rarely delay them by a lot.
cache flag might come after / before execution, so you might be setting the flag when it has been set by the user..., I would check it after the parsing
BigByteArray materializes as soon as you ask for something that goes across several pages. So I think this should return`offset + length <= PAGE_SIZE` instead.
ah! you do manual assertions instead. ok.
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
Instead of this being a generic class with a generic name can we call this `OutOfRangeSpec`, remove the generic arguments and instead use `K -> String`, `V -> Number`, `M -> String`. Also I think it would be ok for you to declare this class here and then reuse it in the `NumberFieldTypeTests` below instead of re-defining it
What does that check actually help us verify? I don't think smoke testing should care about what particular hash was used to build, it should care about whether the artifacts it is told to download work? I view the release as a blob. That particular check requires us to know the "release hash" as you called it here (other unified release stuff calls the version+hash the build id, note that it is not a git hash of any repo), _and_ the ES commit hash, but I think it should be easier to run smoke tests. We can do that check (did we put the hash in the jar we built correctly) in tests in ES directly.
There is a type called `DeprecationRestHandler`. That's what handlers passed to this method get wrapped into. But you don't and can't pass one of those to this method yet that's what the name `registerDeprecatedHandler` suggests you can and maybe should do. The method does not register deprecated handlers, it registers plain handlers as deprecated handlers. I think `registerAsDeprecatedHandler` is fine though. :smile:
I think it might be a useful to repeat the same message you added to `_all` field here. Something like `"As a replacement, you can use an [copy_to] on mapping fields to create your own catch all field."`
oh I see ok - I think we should remove that at least in master since I think it's still there but shouldn't
Not sure if this already includes the shard context, but if it doesn't can you change it to: ``` logger.debug("{} found local translog with id [{}]", this.shardId, id); ```
Why this change? It seems unrelated to the feature being implemented.
This is where I was a bit uncomfortable with requiring the underlying stream to have an unbound support for mark. If I read things correctly we end up with a stream that just wraps a byte reference and we therefore don't care. If you're comfortable relying on that behavior, then I'm good but then I also think we don't need to allocate a growing size of `firstBytes` but rather read byte by byte until we find the first non-white space.
I don't think we need a ref here? This field type is always associated directly with this mapper.
nit: empty line, ocd kicks in :-)
sorry, I missed the ping here. I think that 1 is ok too, but then we should in general change the terminology in `IndexShardOperationPermits` to move from the notion of blocking operations to running exclusive operations (similar to a read/write lock).
do we also want to have the publish address just to be sure? that's what nodes typically use to communicate with each other.
yea thanks for the link, correct order is public abstract, which I think we've been using in the rest of the codebase.
the "efficient" way to consume binary doc values would be to do ``` java BytesRef queryBuilder = binaryDocValues.get(docId); if (queryBuilder.length > 0 || bits.get(docId)) { queries[docId] = parseQueryBuilder(docId, queryBuilder); numQueries++; } ``` This works because binary doc values guarantee that docs without a value would return an empty BytesRef.
we can one more legal state here - old index with allocation ids.
maybe you should pick a node that has actually a shard of the index assigned to it. This allows to check that the node actually had in-memory structure of the index before it was removed. ``` DiscoveryNode nodeWithShard = state.nodes().get(randomFrom(state.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId()); ```
these do not seem to be used. I don't thing we need them? I rather make sure there is always a set for each shard.
the semantics of this method are weird. I pass in an operation and it returns OLDER if the given operation has a higher version? I would have expected the opposite. This semantics also make the rest of this method hard to read since it has to negate the return values in 2/3 of the cases. I think you should flip it.
Lets rename this to filter, and in all other places as well.
> But maybe we should do this in a different place then here? yes in the impl... :) sorry but I find this confusing.
Lets please not do that. The thing is it would break: the codebase of the utility class itself would screw everything up. To me, the right answer is not to make these acc blocks easier: its to have less of them, by fixing the actual problems so the blocks are not needed :)
I don't think we need the filtering on the node. How about using: ``` shardRoutingTable.assignedShards().stream().filter(as -> as.isSameAllocation(failedShard)).findFirst().isPresent() ``` If true, we keep the shard failure, o.w. we clear the iterator...
index -> delete
I'm not convinced in th soundness of the bookkeeping here. I think that `totalNanos` can include the total task time for more than `tasksPerWindow` tasks.
I think we can remove getClass() from here and make this class final to prevent any problem around that
While you're here, would you make these lowercase please: `ILM` -> `ilm`
I wonder if we should just fold this into a single iteration: ``` for (final DiscoveryNode node : currentNodes) { if (discoveryNodes.contains(node) == false) { <-- probably should rename discoveryNodes to nodesToKeep or something like it) // remove logic } } ```
` // <1>` is unnecessary.
missing whitespace after the parentheses :)
well it isn't very nice... but I think better than throwing an excepting and then one method higher up in the stack catching that exception and re-throwing it.
assuming fullFieldName is going to be used when topHitFieldRef impl is complete
the stats request should execute only on data nodes? in that case, we can pass in the list of nodes ids: `data:true` and it will only execute on data nodes.
should the countDown be called anyway? this logic seems odd
For the record, my other pull request #15123 is changing this logic to add all types anyway when creating such temporary indices since this is needed for cross-type validation that we need eg. for parent/child (today we are missing some validation checks when the master node does not have the mappers locally).
At this point I wonder if the order should still matter as it used to. Maybe negations should just subtract from the rest of the indices mentioned in the expression, with the requirement that an expression cannot be a negation only, otherwise we interpret it as an explicit index name that contains `-`. Should `-test1,test*` resolve to the same indices as `test*,-test1`? What other edge cases am I missing here? I also wonder why we support `+` as it is implicit anyway when missing.
In general chaining listeners is fine. I don't tend to use the `return` early style in listeners because I feel like they should *look* symmetric. They just *feel* better to me when they do. I use the early `return` style everywhere else though. The only concern with chaining listeners like this is that some APIs are synchronous *sometimes* and *if* you chain on a synchronous API you'll get a stack overflow. The initial phase of search has this problem. I don't know if you have that problem here but I'd dig through the code to make super sure you don't.
it is a bit disappointing we have to add new methods here, are they all necessary? (might be yes, just checking)
Generally we don't output empty brackets `<field>=[]`, eg. `indices`, so `opaque_id=[]` is better to not being displayed at all.
Okay, glad to hear that; thanks for the clarification!
nit: I'd remove `currently` here since we don't yet know for sure if we are going to be able to implement `copy_to` or if we'll have to have a different mechanism.
The proposed fix is ok, but I wonder if the following wouldn't be better: ``` @Before public void beforeTest() throws Exception { if (serviceHolder == null) { assert serviceHolderWithNoType == null; long masterSeed = SeedUtils.parseSeed(RandomizedTest.getContext().getRunnerSeedAsString()); RandomizedTest.getContext().runWithPrivateRandomness(masterSeed, (Callable<Void>) () -> { serviceHolder = new ServiceHolder(nodeSettings, indexSettings(), getPlugins(), AbstractBuilderTestCase.this, true); serviceHolderWithNoType = new ServiceHolder(nodeSettings, indexSettings(), getPlugins(), AbstractBuilderTestCase.this, false); return null; }); } serviceHolder.clientInvocationHandler.delegate = this; serviceHolderWithNoType.clientInvocationHandler.delegate = this; } ``` The idea is to execute this conditional initialization step under the suite randomness rather than the method randomness. If we don't want to parse the suite seed back from a string we could also generate our own suite seed, the important bit is that we generate it in the beforeClass which is executed under the suite randomness (master seed). I find that this way what we are doing is clearer. The proposed fix is good but can easily be reverted by mistake by just moving lines around.
No, I don't think we do
Note for anyone else: this is just copied from SuggestSearchTests which was removed below. It looks right to me.
Ok, I hope we get to see a follow-up :-)
I think it would be clearer to have the negation with each check directly (then parenthesis don't matter)? ``` if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) ```
Error if old style and new style params alongside each other
I think this shouldn't be removed, although the `autoMinMasterNodes = false` can go.
removeIndex might be good enough here.
IMO this is useless since it will throw an NPE anyway the check is obsolet
can be specified as `catch (SnapshotCreationException | RepositoryException ex)` in Java ;-)
can you just call spliStringToSet with true? why do we need another variant when the method this calls is public
nit picking - I would call specificMinimumMasterNodes just minimumMasterNode and update it before the settings (makes the setting code more readable) ``` minimumMasterNode = minimumMasterNode < 0 ? numberOfNodes / 2 + 1 : minimumMasterNode ```
I think `InternalDateHistogram.NAME` would be a bit better. Now that type isn't used for serialization I'd like to remove it entirely one day.
as an alternative to my suggestion above, `registerAllocationCommand` can already now be moved to `AllocationCommandRegistry` as we expose the registry here.
Typo here, "Trasnlog" -> "Translog"
can we fix this into a boolean before we start? will be easier to reproduce / know what happened.
this is typically called `prepareX`
`success` just made me think "the whole operation is successful" not "successfully started operation".
It was not really updated. That's just set here so that endSnapshot is called below. Maybe instead of updatedSnapshot and accepted variables we should have an endSnapshot variable that captures the snapshot to end.
It would be good to have direct unit tests for these utility functions, especially checking the boundary cases with the passed in offset and length.
I think they can stay here, until we start using them in other places.. but I'm good with moving if people want to
Rather than a spin I think you can say: ```diff diff --git a/core/src/test/java/org/elasticsearch/cluster/SnapshotsInProgressTests.java b/core/src/test/java/org/elasticsearch/cluster/SnapshotsInProgressTests.java index 75ac8993fd..4d1a1a6e58 100644 --- a/core/src/test/java/org/elasticsearch/cluster/SnapshotsInProgressTests.java +++ b/core/src/test/java/org/elasticsearch/cluster/SnapshotsInProgressTests.java @@ -31,6 +31,7 @@ import org.elasticsearch.test.ESTestCase; import java.util.Arrays; import java.util.List; +import java.util.stream.Collectors; /** * Unit tests for the {@link SnapshotsInProgress} class and its inner classes. @@ -72,10 +73,6 @@ public class SnapshotsInProgressTests extends ESTestCase { } private State randomNonWaitingState() { - State state; - do { - state = randomFrom(State.values()); - } while (state == State.WAITING); - return state; + return randomFrom(Arrays.stream(State.values()).filter(s -> s != State.WAITING).collect(Collectors.toSet())); } } ```
With all these nested `null` checks it makes me with we used `Optional` more places in our code :-/
nit: Extra whitespace here
If I understand the logic correctly, we get here if lucene **didn't** qualified this as a file corruption exception. It could be OOM or NPE, for example. So, something generic like `failure in [{}]` might be a better message here.
in generation, this should be a variable that's resolved and cached. We shouldn't do settings lookups with each op.
Yeah, I guess I'm thinking of people deploying without static IPs (certainly not recommended). These most likely won't suffer the same problems that this solution helps though, so it may be a moot point altogether.
but doesn't AliasesRequest extend IndicesRequest.Replaceable ? I think I don't follow. Not a big deal though :)
I wonder what difference there is here between empty params and null params... I thought there wasn't any and we should stay away from the null invariant to prevent any NPEs and such, as we do as much as we can. Sorry for the ping pong @jdconrad I know I made you reduce the number of constructors, I just thought that 2 is better than 4/5 :) Anyways if you guys think that null has some special meaning we can keep it...
If the error message is different, maybe you can differentiate between the case where we detect a missing START_OBJECT and the case where the underlying Jackson parser throws.
In all other methods in this class we don't call containsKey. I would stay aligned with those here.
same here ``` Java if (value instanceof Number) { return Float.toString(((Number)value).floatValue()); } ```
There's a typo here, it's `IOException`. This typo would fail the build. Please run compilation before submitting.
you mean removing the ensure open? +1 on that. Sadly I see the same out of lock pattern in the Translog class as well: ``` ensureOpen(); ImmutableTranslogReader toClose = null; try (ReleasableLock lock = writeLock.acquire()) { ```
nit: spaces around `else`
Same concern regarding the leniency.
same here: I'd like to keep the version using `generateParser` since its the same as in master.
where is this method called? Looking into why we have so many different concreteIndices methods here :)
can we add an assertion that we actually removed something? I think this will also mean that we need a tighter control over what we remove. For example, if the primary is relocating, but we did not move to "relocated" mode, the currentNodeId should not be in the list (and shouldn't be removed).
This happens regardless in the next `if`-statement since `address` remains `null`.
I think we should backport this fix to master, similar to what we did with fuzzy and regexp query
I don't think it will be resolved (rejecting camelCase) as its a huge change across 100s of files (because most parser use this style and not ParseField) and I don't see us doing that change quickly
`file reopened` -> `file is reopened`
this looks good. i forgot how crazy URL was here with null versus empty strings for different pieces...
Additionally, that's a calculation done under a lock, a lock that synchronizes a lot of other methods in this class.
Nit: `currentParallelSearches` -> `currentConcurrentSearches`
Would it make sense to change the signature of `ExternalNode` too, so it takes a `Version` parameter instead of a `String`? This would ensure at compile time that we pass really just a version instead of an arbitrary string.
I think at this level `NESTED` is definitely overkill and should be `OBJECT`.
It feels weird that this is empty.
we could test here the case where we have multiple errors as we do in other tests.
Can we not make the AbstractHighlighterBuilder define a fromXContent() method so it has the code for parsing the common attributes and then defer to a doFromXContent() to read the implementation specific attributes in HighlighterBuilder and Field? I am worried that if we duplicate this code in each implementation we will end up with parsing inconsistencies over time
I am not sure we should do that, can we restrict the geo context to `geo` fields and validate this assumption from the mapping (`context.mapperService`) directly ? If the field has the correct type in the mapping we don't have to check why it's missing.
I see. Maybe we should move the test? I am fine wither way though, up to you.
can we change this log to indicated why we ended up here? (now it says only translog ID)
nice - I like those removals
Oh boy, I hope nothing is broken here.
should we rather throw ElasticsearchException also, and why doesn't the context expose a check method instead that accepts for instance a message? :)
I think it's only usabe in assertions :) can you give a usage example? . Maybe call it reThrowIfNotNull and allow passing null values into it? might make it more usefull .
I think "Have you added" or "Did you add" might sound a bit better here... We could also change it to something less accusative :smile: like "If this is a newly added aggregation, please open..."
Weird. When in Rome, I guess.
ok, I don't ahve a strong opinion on this and don't mean to be blocking your PR, as I said it LGTM anyway
nit: writeOptionalWriteable() would be a bit shorter
I see, so we wither use the PercolatorQueryRegistry straight-away, real-time, or we go to lucene and do additional things that make the whole thing near real-time. Clear, thanks!
nit: can be package private (maybe I didn't see that in the master PR)
This is what I meant: ``` Index: core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java IDEA additional info: Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP <+>UTF-8 =================================================================== --- core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java (date 1459873883000) +++ core/src/main/java/org/elasticsearch/cluster/metadata/IndexGraveyard.java (revision ) @@ -37,6 +37,7 @@ import java.util.EnumSet; import java.util.List; import java.util.Objects; +import java.util.concurrent.TimeUnit; import java.util.function.BiFunction; /** @@ -290,12 +291,14 @@ final public static class Tombstone implements ToXContent, Writeable<Tombstone> { private static final String INDEX_KEY = "index"; - private static final String DELETE_DATE_KEY = "delete_date_in_millis"; + private static final String DELETE_DATE_IN_MILLIS_KEY = "delete_date_in_millis"; + private static final String DELETE_DATE_IN_KEY = "delete_date"; private static final ObjectParser<Tombstone.Builder, Void> TOMBSTONE_PARSER = new ObjectParser<>("tombstoneEntry", Tombstone.Builder::new); static { TOMBSTONE_PARSER.declareObject(Tombstone.Builder::index, Index.INDEX_PARSER, new ParseField(INDEX_KEY)); - TOMBSTONE_PARSER.declareLong(Tombstone.Builder::deleteDateInMillis, new ParseField(DELETE_DATE_KEY)); + TOMBSTONE_PARSER.declareLong(Tombstone.Builder::deleteDateInMillis, new ParseField(DELETE_DATE_IN_MILLIS_KEY)); + TOMBSTONE_PARSER.declareString((b,s) -> {}, new ParseField(DELETE_DATE_IN_KEY)); } static BiFunction<XContentParser, Void, Tombstone> getParser() { @@ -381,7 +384,7 @@ builder.startObject(); builder.field(INDEX_KEY); index.toXContent(builder, params); - builder.field(DELETE_DATE_KEY, deleteDateInMillis); + builder.timeValueField(DELETE_DATE_IN_MILLIS_KEY, DELETE_DATE_IN_KEY, deleteDateInMillis, TimeUnit.MILLISECONDS); return builder.endObject(); } ```
you can do `indexWriter.getReader().close()`, which will create a segment too but not do a fsync
Checkstyle is unhappy with this.
update: We spoke offline and decided it is better to tackle this in a separate discussion/PR
and here too ;)
extra space here in the log message
remove line wrap
yea I know we already do that, and I don't like it very much... I would try not to have the utility class calling test classes if possible.
The call to release should be indented
When you use it with an instance of `PreBuiltAnalyzers`.
we can still verify that that node has the primary and fail if that's not the case.
I meant empty as in the settings are empty.
This can just be `throw throwable` since we check if it's not null immediately above? Or else we can remove the check and make it just an `else`
We wouldn't have the confusing Double (it immediately makes me think, how/why can this be null). I expect we'd use -1 for the back compat case anyway? (e.g. just read a single double, and return { x, -1, -1 }).
nit: `>=` -> `>` (equality is not an option :))
```suggestion throw new IllegalStateException("index shard " + shardId + " must be blocked by " + request.clusterBlock() + ```
maybe add this to the `Strings` class like: ``` Java public boolean hasEmptyString(String[] array) { //... } ```
Unneeded import and extra line addition to this file
We should do this
I can try and play with it afterwards, no big deal
ok I do not like the way we use null here but I see the complication of changing this now. Let's leave it as is then and move on ;)
can we maybe use `persistenOnly == false`
The way I see it we call `concreteIndices` as soon as we found `indices` (or `index`), and at the same time we could verify if those indices match the current one and store the result, no need to call `matchesIndices` in multiple places.
do I get it correctly that you had a byte[8] with longs and a byte[4] with ints? If yes, then you would need to add padding bytes in the beginning in order to always have a byte[16]
Rename `calendar` -> `filter`
I wish there was a less impl dependent way of checking that named queries/filters get parsed (without instanceof etc.). Looks good though I don't see many other ways to do this. Btw this is code that every single query should support I believe (apart from match_all?), maybe we should try and make it more generic if possible (not only test wise).
I'm not sure about this, it is a usage error.
also use `indexRandom`
created version should not be able to be null. We have numerous checks that depend on it in the base FieldMapper.
Should we just do `String text = mapper.fieldType().valueForDisplay(textToHighlight).toString();` all the time? This looks correct to me and is more future-proof? If that does not work, feel free to merge the PR as-is.
maybe use `coordinates.children.isEmpty()` instead
However I think it is important that the default configuration emits an empty json
Remove comma to start line, place at end of previous line.
I don't think this should be warn, its ok not to allow, but is it really a warning? I think debug should be good? Otherwise, our logs will be filled with it with each reroute and each check for shard on that node per reroute. That warn note also applies to ones below.
this constructor is unused, both in our branch and in master. We can remove it I think
nit: s/final ArrayList<ParentIDFieldMapper>/final List<ParentIDFieldMapper>
Should we test script usage here, or does the IP agg not support scripts? (I didn't see anything to validate that scripts are not being used in the code)
Nit: typo in originalRetRepositoriesResponse
I see. +1 on removing.
can we name this `subtractShardsMovingAway` ? it's clear what it means
if we do that, lets do the 'looking' and set a static final boolean so it does not impact real code.
Update the delay _left_ ..
I'd feel better if we would do it this way ` IOUtils.closeWhileHandlingException(resources, () -> wrappedListener.onFailure(e));`
s/enable user/clear cache
These messages seem wrong. There are no top or left parameters
ok, while using cluster state output elements are ordered in a non deterministic way? I did not know what.
The formatting of thise code (spaces around brackets etc) is different to the way the rest of this source code is formatted. By the time we get to the end of this review process, we'll want to have it formatted in the same style as the surrounding code.
please make sure you remove the conditional on master
We use `== False` throughout the codebase instead of `!` because the former is easier to spot visually.
do we want to open an issue around this bug that we are solving here around the java api? We could probably backport the fix upstream too, should be easy.
Great. I now wonder if this whole block can move into the `JoinHelper`. If the code above returned its `mode` and called `becomeLeader()` then the `JoinHelper` should be able to work out the right things to do with the join.
I forgot about that test. I think it's good for now.
sorry, forgot to add here that we could randomize between atomic and non-atomic move.
Please use a space between the `if` and `(`. Also, I think it would be good to use `XContentParserUtils#ensureExpectedToken` or `XContentParserUtils#ensureFieldName`
I think part of the bug is also that we don't have an `else` statement here where we throw an exception. Which means that if you provide a parameter with eg. a boolean value (for which we don't check above), it will be silently ignored. Can you add such an `else` statement (you can look eg. at MissingParser for an example).
Apparently @s1monw prefered the reverse. I'm fine with leaving as is.
After seeing the mess that these kinds of "constants your children set" have caused in aggregations I'd prefer to have `shouldCancelChildrenOnCancellation` be abstract.
I think we can get rid of the ResolvedHostname abstraction - what am I missing? ``` diff --git a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java index 61bf1cc..3d3495e 100644 --- a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java @@ -242,40 +242,36 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]"); } // create tasks to submit to the executor service; we will wait up to resolveTimeout for these tasks to complete - final List<Callable<ResolvedHostname>> callables = + final List<Callable<TransportAddress[]>> callables = hosts.stream().map(hn -> lookup(hn, transportService, limitPortCounts)).collect(Collectors.toList()); - final List<Future<ResolvedHostname>> futures = + final List<Future<TransportAddress[]>> futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS); final List<DiscoveryNode> discoveryNodes = new ArrayList<>(); // ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the // hostname with the corresponding task by iterating together final Iterator<String> it = hosts.iterator(); - for (final Future<ResolvedHostname> future : futures) { + for (final Future<TransportAddress[]> future : futures) { final String hostname = it.next(); - if (!future.isCancelled()) { + if (future.isCancelled()) { + logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); + } else { + assert future.isDone(); // guaranteed by the invokeAll try { - final ResolvedHostname resolvedHostname = future.get(); - if (resolvedHostname.isSuccess()) { - logger.trace("resolved host [{}] to {}", hostname, resolvedHostname.addresses()); - for (final TransportAddress address : resolvedHostname.addresses()) { - discoveryNodes.add( - new DiscoveryNode( - idGenerator.get(), - address, - emptyMap(), - emptySet(), - Version.CURRENT.minimumCompatibilityVersion())); - } - } else { - final String message = "failed to resolve host [" + hostname + "]"; - logger.warn(message, resolvedHostname.failure()); + final TransportAddress[] addresses = future.get(); + logger.trace("resolved host [{}] to {}", hostname, addresses); + for (final TransportAddress address : addresses) { + discoveryNodes.add( + new DiscoveryNode( + idGenerator.get(), + address, + emptyMap(), + emptySet(), + Version.CURRENT.minimumCompatibilityVersion())); } } catch (final ExecutionException e) { final String message = "failed to resolve host [" + hostname + "]"; logger.warn(message, e); } - } else { - logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); } } return discoveryNodes; @@ -289,17 +285,11 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { * @param limitPortCounts the port count limit * @return a callable that can be used to submit to an executor service */ - private static Callable<ResolvedHostname> lookup( + private static Callable<TransportAddress[]> lookup( final String host, final TransportService transportService, final int limitPortCounts) { - return () -> { - try { - return ResolvedHostname.success(transportService.addressesFromString(host, limitPortCounts)); - } catch (final UnknownHostException e) { - return ResolvedHostname.failure(e); - } - }; + return () -> transportService.addressesFromString(host, limitPortCounts); } @Override ```
Nit: `[] {` -> `[]{`.
I know you've only moved this message between files but it might be worth making the format more consistent with others, i.e. `[job_id] message`.
Perhaps open a separate pr for the change to this method? This adds additional validation outside concrete index to data stream lookup.
Let's maybe reorganize this code a bit for clarity? Something like below: ```java if (fieldType.tokenized()) { ... } else if (is keyword) { ... } else { throw IllegalArgumentException } ```
Imho this is a confusing description. Maybe "Deletes all shards directories of an index for which a lock can be acquired. If all shards dirs are removed, the top level index directory is removed as well."
can we just pre-compute the hashCode in the ctor instead? I can already see this going bad with concurrency and we might be just lucky we didn't hit that yet? Either we do in the ctor and make it final or we need a volatile read here
I think the `"translog-"` string should be a public global static var named `TRANSLOG_FILENAME_PREFIX`, and should be used as the glob pattern for the directory stream. Then all the hardcoded "translog-" strings in here can use the PREFIX var (I did this the hard way in my version of the branch where I typo'd the prefix and it took forever to debug, so having a static prefix to use would be nice). This PREFIX can also be used in `LocalIndexShardGateway.recover` since it's hardcoded to `"translog-" + id` there too.
I do think it'd be nice if we could accumulate errors and print them at the end, rather than bailing on the first error, forcing the user to rewrite/rerun, then bailing on the next error, over and over for each error.
`String.toString` just returns `this`, so you could remove the `instanceof` check and cast after you ensure it's non-`null`.
I think we need to keep these methods at least in 6.1
an alternative would be parsing the proper version of the query, calling toQuery against both and checking out that they are the same via equals checks. Also we could add here a quick serialization check using assertSerialization
We could add a default value (.i.e. `< 6.1 `) in the parameterized message because > Automatically enabling security for older trial license (null) might be slightly obscure.
Yeah, less classes is much better
would be great to assert on the number of docs recovered. It's hard but I think it's good to keep a tight control of this one - it's complicated code and we need to know it keeps on doing what we expect it to.
Is the fetch servie smart enough to do a single request if two docs are on the same shard? If yes, I think it's worth it.
can we assert that ignoreReplicaException is false? it will be weird to have something fail a shard but not reported.
Same as above, reference equality shortcut would probably fit here as well.
let's just skip the iterator and use IndexShardRoutingTable.shards() (put it in a variable and use it in do run as well)
`initialRecoveryFilters.match(node.node()) == false`
I was thinking something like: ```diff diff --git a/server/src/main/java/org/elasticsearch/Version.java b/server/src/main/java/org/elasticsearch/Version.java index 1e1993e6d6..c0181d4f1e 100644 --- a/server/src/main/java/org/elasticsearch/Version.java +++ b/server/src/main/java/org/elasticsearch/Version.java @@ -372,7 +372,9 @@ public class Version implements Comparable<Version> { public final byte build; public final org.apache.lucene.util.Version luceneVersion; - private List<Version> declaredVersionsCache; + private static final class DeclaredVersionsHolder { + static final List<Version> declaredVersions = Collections.unmodifiableList(getDeclaredVersions(Version.class)); + } Version(int id, org.apache.lucene.util.Version luceneVersion) { this.id = id; @@ -414,17 +416,10 @@ public class Version implements Comparable<Version> { public Version minimumCompatibilityVersion() { if (major >= 6) { // all major versions from 6 onwards are compatible with last minor series of the previous major - List<Version> declaredVersions = declaredVersionsCache; - - if (declaredVersions == null) { - declaredVersions = Collections.unmodifiableList(getDeclaredVersions(getClass())); - declaredVersionsCache = declaredVersions; - } - Version bwcVersion = null; - for (int i = declaredVersions.size() - 1; i >= 0; i--) { - final Version candidateVersion = declaredVersions.get(i); + for (int i = DeclaredVersionsHolder.declaredVersions.size() - 1; i >= 0; i--) { + final Version candidateVersion = DeclaredVersionsHolder.declaredVersions.get(i); if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) { if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) { break; ```
mental note to remove this outdated TODO in lucene
I think this should be moved to QueryCreationContext and exposed here through it temporarily
maybe here and below you can move the `+` to the end of the prev line.
that is a good point Christoph! if we really want to keep varargs otherwise we could validate that the array has length >=1 , I have no strong preference on how we solve it though
> Making type @Nullable will solve this as we will know the difference between an inline script entered as an object and one entered as a simple string that's exactly my point... I believe the `Script` construct should reflect exactly what the user inputs.. hence the `@Nullable` type approach
The `version` field from this change and the `customs` field from a previous change are not incorporated into `IndexMetaData#hashCode`.
we don't need the thread pool anymore
this should be an immutable set...
wonder if we can move this check to validate, I don't like the fact that it happens only when you call toQuery
We looked at the usage places. Currently only used for specifying thread pool sizes. If a user specified that he wants queues of "5b", then it SHOULD break :-)
this should be done by just reading username password from the Credentials
If it can be done as part of another PR I would like it better :)
I think we want it to read "received state _with_ a local node that doesn't match the current one"
spaces missing after `if` and before `{` ð¡
I feel like it'd be cleaner to have this be the result of falling off the end of an if statement chain.
can we add a shortcut for `all`? we lost it...
I think this map should also be unmodifiable like the outer one. It is not so important, because the whole thing is private, but for consistency. Alternatively remove the unmodifiable from outer map, too.
Adding this mutable field (and thus making `RestRequest` not immutable) is not attractive.
"Directory" is misspelled as "Direcotry" here
Actually we probably don't need a method to add the reader for the pipeline aggregator as there should be just one reader for each pipeline aggregation type so we could just pass it into the PipelineAggregationSpec constructor
Please could you assert that the content of the message is correct? (`expectThrows` returns the exception thrown, so you just need to assign it to a variable and check its message.)
One day `getMessage` will be added to the forbidden apis. May as well not make it worse.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Same here, can you add the punctuation mark
Is it worth optimizing the case where `fetchSource` is true and `includes` and `excludes` are empty and the xcontents line up? Then you can just return the bytes you have like we do for search lookups.
typo: no -> not
we should use CompositeChannelBuffer, but then extra care need to be taken when writing to netty, and if it should be a gathering one or not. It might make sense for it to be gathering if under ~512k, and not if above.
great to see this behaviour move to UnassignedShards!
I have the feeling this should not be handled in parse phase but only in toQuery....
I think we might miss some responses in case of onFailure() because it will be using responses created [here](https://github.com/s1monw/elasticsearch/blob/issues/5766/src/main/java/org/elasticsearch/action/bulk/TransportBulkAction.java#L94)
no need for this `alt` variable
why don't you use `finally` instead of `catch`? I guess that is legacy or copy/paste
On second though, I think `null` is difficult here because we dereference the script all over the place. I plan to rework a lot of those dereferences eventually anyway so maybe we can just swear that we'll remove this "very soon" and be ok with it.
I also wonder if we should only have `Task.java` and have different ctors and if you don't pass a parentID you are not a child task? and default parent id is 0 just like in linux etc.
I wonder if we should throw an `IndexNotFoundException` here or just log the occurence and move on, because the intended result would be the same - the index is no longer in the cluster state. For example, it could be possible that just before someone executed an alias action with remove index, they executed a delete on the index. If we just log the fact that the index doesn't exist and move on, we would have achieved the same objective. I may be missing something though.
I'd prefer ``` else { return false; } ``` Just a bit more balanced looking. No big deal either way I guess.
can this be `debug`? it will get very noisy....
yeah I'd leave everything to the stream just like java seriazliation works
Sound good then, no idea about the compiler optimizations tbh, I was just curious.
we can open a new issue to add debug logging to SelectedType but this is really arbitrary here. I don't think this should be info - we have enough info going on and if we reset it we see it in the settings, no need to X different ways to get some information
Remove it if not used
can we make `"security.manager.enabled"` a constant please
you can remove a switch in this class (fromXContent method) and use Operator.fromString
I would rather not have the uncheckedGetLastModifiedTime method. Instead just do old school iteration on the reader list, keeping the min of the last modified time. Then do a one off extra min with the writer's value. Re the test - I would prefer if you make an array of random positive long values, map readers to them and make sure the method returns the right value when compared to a calculation that is made directly on the array.
maybe, but I am also asking questions, answers and opinions are welcome :) what I suggest doesn't always make sense
Nice to have an example of how to implement fetch phases as a plugin!
the only case that we don't cover here is the classes that by mistake don't extend `ElasticsearchTestCase` (plain junit tests) whose name doesn't end with `Test` or `Tests` either..... pretty sure this never happened before. not sure we want to do anything about this. Maybe we could just separately check that there are no plain junit tests in the codebase.
can we call this `index.shared_filesystem.recover_on_any_node` (and rename the constant) and move it to IndexMetaData? I am concerned that people will think its a flag that supports non shared file system cases
Please revert the name change. It's fine as is, and the name change here isn't thorough enough (there are methods invoked here that still have the parameter named `pluginId`).
Because not all of the inheriting classes implement `ToXContent`.
Thank you for using the `getX` naming style!!
Could we handle the `authorisation == null` case first to avoid these null checks proliferating? It's also helpful to distinguish no authorisation header vs a bad one, which this would achieve.
To be clear, I don't think we need anything extra here.
I wonder if we should return all indices of the remote cluster here. That would more naturally map to the notion of the state of the remote cluster representing a snapshot.
Further down in the function it looks for the file and appropriately errors out if they were to be missing, I don't think this will be an issue.
feels like it would be more correct to set termsLookup only here in the `else`, it should always be null otherwise.
we can remove the 1 + , now that 0 is not reserved for the global scope. This should be `portCounter.incrementAndGet() % 10;`
I think we should have a consistent message regardless of the number of aliases, I know it's bad form for people to write tests against error messages, but that doesn't mean people don't. So, I think we should stick with just `aliases [foo] missing`. What do you think? (I'm only +0 on the change)
The entire slow search can be removed, because we break BW there is no need to keep this code around any more.
yes and make it recursive I guess, that sounds good.
`SearchResponse` implements `StatusToXContent`so you can use its `status()` method instead of forcing `OK`. Something like: ``` java SearchResponse response = item.getResponse(); builder.field(Fields.STATUS, response.status()); response.toXContent(builder, params); ```
Does this still support numbers? Having a test for numbers would be good here too.
How is verifying that the hash of the IDs the same as verifying that data was not mutated? It seems to me that all this is verifying is that the doc Ids are unchanged.
I think I would revert this change, no need to call the other constructor here, so the precondition can happen first, which makes more sense. Same in other constructors
take out boost and queryname once you rebased
Oh I thought it aleardy did! Then maybe a better way would be to make this method pkg-private? (I'm just trying to keep the API to a bare minimum)
Thanks for removing this. I had hesitated to do it when importing the fixed CSQ.
here too, as well as the following error messages, they all need to be adjusted
Also, will this stay around or go away at some point? If it's supposed to be gone we should mark as //norelease
Oh right... Good point. Yea, I think it makes sense that a ctx should only be registered once
here too, maybe go straight to what was expected and what was found. I don't understand which of the two is what in this error message, and the last part confuses me. Maybe it's me.
I'd try to keep what gets returned from there from the request inline with what is actually used in the transport action. That's why I suggested to move the logic to the request.
I don't have a complete design here but I feel like phase should be called something more generic (like stage for example), moved all the way up to the task level and have a common expandable dictionary. The stage description is a bit tricky, but it looks like we have several stages like INITIALIZING, SENDING_CHILDREN_REQUESTS, WAITING_FOR_CHILDREN, CANCELLING, DONE, FAILED, etc that will be shared among many tasks. But then we will have some stages that will be important but very task specific. So, a few designs with pros and cons comes to mind. It can be an enum (to describe common stage) + string (to optionally describe a specific phase), or a class extending some common Stage class, or some ever-extending enum where tasks will add their specific stages (the simplest but not going to work for plugins), or maybe just a string and an utility class with a bunch of constants defining common phases.
maybe it's nicer to just capture the `DiscoveryNode` object here and use `equals` on that (internally it will use the ephemeral id for comparison anyhow).
I think the old indentation was a bit better than this.
I think this isn't just about alias, it can shadow existing class names right? Maybe tweak the wording to make clear it's either an existing alias or classname
Yes! Please test this and maybe a couple others like x[-1] += 1 with numbers or something with Strings.
Should assert that `e` is an instance of `TypeMissingException`.
Can you name this something more descriptive? maybe `shardIdToRouting` instead of just `map`
we never use xcontent for cross node communication. I think we can use state and be tolerant of reading status when parsing? (until 7.0)
I see. Not sure if its worth it, if doRewrite makes things complicated in its own way, given that createWeight is final and it will catch the issue.
They shouldn't diverge as these will never change other than eventually being removed when we no longer have to be backwards compatible with 5.6.0 (say, 7.0.0). This pattern occurs often enough that the field is not needed to clarify that this was added in 5.6.0 instead the code already speaks for itself in that regard. Finally, the git blame will tell us the commit that added this which will have linkage back to this PR if someone *really* needs to go on a cave expedition through that. ð
can we please use ActionListener here instead and use a struct that holds the arrays? I really don't think we need these listeners
Instead of using params maybe the caller can do this? Like, the REST endpoint knows about it. And it isn't a big deal to have the extra field in the task status.
this looks awesome! exactly what I expected can you also try to add prebuild TokenFitler and Tokenizer? just for kicks
no need for the annotation if the test method name starts with "test" :)
would be nice to have an assert after this line that we consumed all bytes
This condition is equivalent to simply `seenMount`. Effectively, `seenDevice` is unused. I think this means something is missing/wrong in the test cases.
this can go back to boolean if we move back Settings to boolean too
I think the filter flag needs to be checked earlier, already in the parser. `isFilter` is a statefull flag in the QueryParseContext that gets set/unset when parsing one of the (former) filters. ParseContext.isFilter at this point doesn't reflect the state it was in during traversing the query tree. Check QueryParseContext.parseInnerFilterToQueryBuilder() to see where state changes can occur.
Can we remove this boolean? There is only one constructor for this class, so if it succeeds, then we loaded. otherwise we have no object to call addConsoleCtrlHandler() on, so we can remove the check for it there, too.
I wonder if it's worth having this in RandomObjects instead. But given that it is only used here I don't have a strong opinion on that.
can we check part of the message so we know we got the right exception? ditto for the other cases like this in this file
test for >= just to be safe? (and we can assert in `deleteShard` it is identical to expectedResponses
cool, we just had to do it twice while queries were going to be moved over, now we do it in a single place. Thanks for clarifying.
it's a matter of taste so I will leave it to you my suggestion is to call it `blocking` instead. but again up to you!
`noAllocationDeciders` and `throttleAllocationDeciders` can be used instead here
Small optimization: Use `UidFieldMapper.TERM_FACTORY.createTerm`
I think we should return a readable / understandable msg here something like: ``` Java QueryPhaseExecutionException("Result window is too large, from+size must be less than or equal to: [" + Integer.MAX_VALUE + "] but was [" + (((long)from()) + ((long)size()))) + "]"; ```
the enum values make no sense in the context of the name. I wonder if we should call it `OperationAge` or something like this.
May be randomize the container name as we do in `AzureSnapshotRestoreTests`? ```java private static String getContainerName() { String testName = "snapshot-itest-".concat(RandomizedTest.getContext().getRunnerSeedAsString().toLowerCase(Locale.ROOT)); return testName.contains(" ") ? Strings.split(testName, " ")[0] : testName; } ```
Also the iterator.
Works for me. Maybe just have an interface called Cancellable - it seems CancellableTask is taken.
this is what you get from the crazy syntax ð
I would add an `assert this.context != null` here just to make sure
I'm not entirely sure it is required to have the FIPS checks implement an interface, but if we go down this path ,I think that conceptually it would make more sense to have a `FIPScheck` interface that all the relevant checks ( settings, password hash etc. ) would then implement.
For now, let's move the construction of Definition out of the loop, so we still only create one, until we can figure out if we need an internal cache to ensure too many copies aren't loaded of common classes.
Same here, with `CLUSTER_ROUTING_REBALANCE_ENABLE`
Scratch that, I see this is private and only used internally, and the request only has one of each parameters, so duplicate calls are unlikely. Just me being paranoid.
cool ok that's fine.
`numberOfFiles++` can be moved out? minor nit pick but it reads easier IMO
The listeners in SnapshotService and RestoreService could just themselves implement this matching logic. The API would then be ``` snapshotsService.addListener(repository, snapshotName, new SnapshotsService.SnapshotCompletionListener() { ... }); ```
can this be trace? we already have a info log message before.
this is the reason; https://github.com/elasticsearch/elasticsearch/blob/master/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java#L127 I guess that's fine here we don't support DFS for rescores
I think we should remove this exists check? createDirectories will ignore, if the path already exists _and is a directory_ but will do the right thing if its something else like a regular file
you should use the `awaitBusy` method here which doesn't have a fixed sleep but increase the sleep interval in quadratic steps...
Sorry I got confused about what keys were about.
We should still throw an exception here though.
I could be wrong but it looks like the argument to withAllDeprecated indicates the new setting which has replaced the deprecated options and is only used in the error message to point the user to the new option. so for `pre_zone` we would use `new ParseField("pre_zone").withAllDeprecated("time_zone")`. It might be worth checking with @s1monw that this is indeed how it should work
was puzzled about the naming of `release` here for a second for adding a filter context. Also, the below code, just means, this context can never be reused by not being added to the queue, right? (Just want to make sure I get this right)
Because `deleteOnClose()` is an immediate verb, I would be fine with renaming it `setDeleteOnClose()` if that sounds any better
Can you change this assertion to match the whole error string? It might be a bit fragile to future changes in tests, but since we don't randomize anything here the error should stay stable for a bit and this makes it easiert to understand the whole error structure from reading the test.
no need to implement/override this method if no validation is required
I do wonder if this class should be in a separate utility file somewhere? It's a third of the entire file length. On the other hand, this is all going away in master, so maybe it doesn't matter.
Idea: ``` if (toResolve.remove(snapshotInfo.snapshotId())) { snapshotInfos.add(snapshotInfo.basic()); } ```
again, this should be resolved outside of the loop. Also we have to be careful about when we are resolving the names (here we are using generic thread pool).
Sorry I am late, but I think this should go under debug logging, as by default, this will be logged each time a node starts, and I don't think it is important enough to log each time a node starts...
I don't think this is worth the inconsistency. Please remove that and make it camel cased
If I see this correctly, you're doing `recoverFromTranslog` under the mutex here? This can potentially block the cluster state update thread for minutes.
I don't think that we need to mark a private method as deprecated. The advantage of leaving this annotation off is that then you can move the two `IndexModule.Type.DEFAULT.match(storeType)` checks in `FsDirectoryService#newFSDirectory` to a separate private `isDefault` method (the JVM will inline it anyway) and thus move the suppression on `FsDirectoryService#newFSDirectory` to just that method which reduces the scope of the suppression.
It would be better to change this to: ``` java logger.debug("creating shard_id {}", shardId); ``` To log both the index and shard ID, since `ShardId` has a nice `.toString()` method
the exception is completely swallowed... we should at least log something
ditto on wording
I believe it is fine to just remove this class and use the strings. That is what we've been doing with new code. If we want field constants the Fields class is really nice. But I don't think the constants buy us much.
You are right on this, good point. using equals to do the assume was kind of a silly idea :)
I think this has to happen before you start the cluster, or else the cluster will start with full knowledge.
can we move the translog related code out of createSearchManager and move it here (or have a dedicated method for just that). I think it's good to have it all together.
fix please for max time in queue
can we add logging to what transport is active.. We used to have : ``` logger.info("Using [{}] as http transport, overridden by [{}]", httpServerTransportClass.getName(), source) ``` The source will be hard to do, so I'm fine with dropping it.
yea I missed that, I think it makes sense to do it there too.
I see it now. Sorry!
Okay, we might have to revisit some other queries we refactored then.
For posterity: this is handled by the gradle logic that scrapes the version file and a test in `VersionUtilsTests` that verifies that the gradle logic and VersionUtils line up.
cool, so we can remove it from the ignores list
I wonder if we should just let the default be 1 instead of confusing the user with some sort of QUORUM semantics that does not exist in our replication model.
this should not be public, private is fine
make that dude final for now
These methods should be gone now, they have been moved to IngestClient upstream
to clarify , the retryPrimaryException is only relevant for the handler of the primary action, not the reroute one. If it comes back from a reroute it means the target node already retried it and we can just fail.
It's a non-static inner class, that's the syntax for constructing an instance of an inner class that is tied to an instance of the outer class.
boost will be gone once you rebase, same for queryName
I think with this removal the `requestId` is now no longer used and can be removed.
code style nitpicking here: do we usually do a space after the if? if so, there have to be several corrections in the next lines..
instead of having this setter I think we should do this in `ClusterService` and `TransportService` ``` Java @Override public void start() { throw new UnsupportedOpertationException("use start(DiscoveryNode) instead"); } public void start(DiscoveryNode node) { this.setLocalNode(node); // private call super.start(); } ``` WDYT
To be clear, one thing is testing the toString output, and another thing is to make sure that the class implements the right interface, so that its output can be generated and is valid. I would do both from separate methods.
sure, nothing bad happens, but it might still be a user configuration error (user configured initalTimeout, but forgot to set maxTimeout). I think it's nicer to just throw an exception and report it.
looks like trolling :)) what's wrong with `&&`
But I think this is confusing. If I have a format specified as `yearMonthDay` that works then I would expect to be able to change it to `epochSecond` and it would work. Supporting some values in camelCase for date formats and not other values is very confusing to a user. I'm all for removing camelCase but we should be consistent with it, especially when its different values for the same setting (in the case different values of `format` for date fields).
nit: wrong doc
I don't like adding a context to StreamInput since the context makes little sense for the stream itself but is rather useful to the parser of this stream? I like the first idea better.
Super tiny nit: could we wrap the `SUPPORTED_DATE_METRICS` with brackets (`[...]`)? Makes it easier for the user to see the difference in message and dynamic values. Ditto to below with `unsupportedMetrics`
oh no! I thought we broke rescorers extension point, not this one too!
Not sure if this would work, but could you keep this override but make it relative to the number of nodes on latest version, essentially removing the need for hte new "num lucene latest version" method? That is a very awkward parameter for a general integ test that is really specific to backcompat tests...
the unconventional newline between a parameter's type and name makes this pretty hard to read.
you should protect from double closing here.
nit: put the second in a new line (it'll make it more readable)
I think I already explained that even that PR has access to mappedFieldNames, that is something static, and all of the random queries can depend on it, I don't see the problem
I think this results in double logging, we will log this here too, no? https://github.com/elastic/elasticsearch/pull/11545/files#diff-9a7b643d56430763f42de913657ca798R125
Personally I don't think that is an issue. Removing the extra transport header is the cleanest.
can we also assert so the failure message will include the offending file? I think it will be easier to trace that the alternative of looking for it in the logs..
can we mock TP here? This should make this test easier. Something like this: ``` ThreadPool threadPool = mock(ThreadPool.class); when(threadPool.executor(anyString())).thenReturn(Runnable::run); ```
ah I see it has problems with `null` got it
nit: can you use `this.` consistently when setting members in ctors here? It is difficult to tell what might be locals declared earlier in the method and what are members.
s/No/no we tend to have all lowercases logs/exceptions. Not that we are always consistent with this, but that is the preference.
maybe just simplify these by setting it to the value of the `randomBoolean()` and using `Boolean.valueOf`? Not super necessary, just a nit.
This should call `setObject` directly not `setDate` (with 2 params) which effectively is `setDate(paramIndex,x,NULL)`. The 2 arg method should invoke the 3 arg one not vice-versa since the former is a subset of the latter.
> The boolean query throws an IllegalArgumentException when min should match is a negative value but only on some cases, for instance if you don't have should clauses then the query works. OK, I didn't know that, it's more complex than I thought. Let's merge this PR as-in then and work on another PR to make minimum_should_match validation more consistent.
I think it will be cleaner? not a biggy though
lol. over fanaticism. can we just have -1, 100ns and 60m? (ie., none , very likely to happen and never)
if you catch IR you have to reset the interrupt status otherwise we keep on blocking
Lucene has a FilterFileSystemProvider which allows mocking of various file system calls (for example the VirusCheckingFS class in the lucene test-framework which throws AccessDeniedExceptions on delete)
I'm not a fan of this. we effectively always wait. Can we just rely on the `assertNull(throwableRef.get())` at the end of the test? it may have some false positives but if we get something wrong, we'll know soon enough
can we maybe name this with something that indicates its the version of the after ClusterState? `afterVersion` sounds bad. If we use `to` and `from` in the ctor we can have toVersion, fromUuid, toUuid etc :)
I think it should be: TransportAddress address = discoveryNode.getAddress(); TransportAddress expected = poorMansDNS.get(discoveryNode.getHostName()); assertEquals(address, expected);
It's good like it is , it's more civilized, otherwise it would indeed indeed violate the scope of this PR. I think I see the privilege code as new code where creative destruction is more loosely permitted. But I still think it would be nice to do this change in a follow-up. I am happy to pick it up if you wish.
same suggestion as for master operation use java8 default impl in _TransportRequestHandler_: ``` Java default void messageReceived(final Request request, final TransportChannel channel, Task task) { messageReceived(request, channel); // override if you need the task } ```
Maybe just throw Exception? (the error variable generic type should then get changed as well)
here is a better suggestion: ``` static Random random; static { if (System.getProperty("tests.seed") != null) { random = new Random() { // ensure no bits are consumed by e.g. a test class's clinit, since that will never reproduce. // randomized runner has a similar check against its random() @Override protected int next(int bits) { throw new IllegalStateException("consuming random bits at illegal time, this will not reproduce!"); } } } else { random = new Random(); } } /** this is set by ESTestCase.beforeClass, to a new Random instance based on runner seed, so each test class is "reset", since tests are run in groups on the same jvm. in ESTestCase.afterClass, set set it back to an exception-throwing one again, to fail tests instead of making them non-reproducible */ static void setRandom(Random r) { random = r; } ``` I don't know how many classes you have under this category, but each one would need to be handled in this fashion if you want to repro a single test case that failed in jenkins.
Yes, it can throw rejected execution exception if the thread poolâs queue is full or it is shutting down.
having thought about this, I think that unifying the two paths is not possible at the moment, but I would consider making AbstractFieldScript typed , and add a method to it e.g. consumeValuesForDoc(int docId, Consumer<T>) so that we standardize on the API used to retrieve values for index time scripts, given that we can do so.
also we usually lowercase all the log messages and exception messages too (minor nit)
I think two separate PRs would make sense - one for Azure and another for S3.
That while loop is too complicated (any `while(true)` should be avoided whenever is possible). Can we put all of these conditions under a `hasReadBudget` and have the while be something like ``` while(hasReadBudget() && lastRequestedSeqNo < leaderGlobalCheckpoint) { numCurrentReads++; long from = lastRequestSeqNo + 1; lastRequestSetNo = Math.min(from + size, leaderGlobalCheckpoint) sendShardChangesRequest(from, size) } ```
Oh, you're right. Then it makes sense as is.
I'm wondering whether the fact that this would still return `false` after `close` has been called could be confusing.
Main thing here is that the test fails rather than errors on this line
this shouldn't be public, potentially private, otherwise package private if we call it from tests.
just make it a norelease
this seems to be called when `upgrader.needsUpgrading(shardId)` indicates true, so this is not needed. Do we want an assert `needsUgrading(shardId)` instead? if we want the log (which should be debug imho) it should be moved to the calling function. It's not visible now.
I'm not a fan of `_` in any java method names. I don't that much though.
this class should not be part of Guice it should really take the ClusterService whereever it's needed or the actual class it needs and make sure it's a final class with a private Ctor and if applicable make it package private
why `if (shardRouting.primary()) {` ? Directly put the assert there.
I think you forgot to add the name of the script here to the failure log
this should be `public static final Setting<TimeValue> INDICES_CACHE_REQUEST_CLEAN_INTERVAL = Setting.positiveTimeSetting("indices.requests.cache.clean_interval", TimeValue.timeValueSeconds(60), false, Setting.Scope.CLUSTER);`
I see why we have maps of maps, but if we have to do it this way, maybe we could have a PipelineConfiguration class that holds the configuration as a map and is Writeable and ToXContent etc. ? similar to the previous PipelineDefinition but this one would hold the configuration.
Nitpick: I wonder if it would be better delegating this assignment to the constructor above.
Is it necessary? the aggregator factory should create it with the right size directly? (if it does not I think this is a bug)
I think the message here should be different? Otherwise it is confusing to see the same message, with different endings (one being xcontent, and the other being a java stack trace).
I think this is tricky to do here without any backwards compatibility. Users were able to do that in the past so on upgrade they will get an exception and they will not be able to fix it. I think we have to move this into where we validate our settings such that it only applied to new indices and old indices should still have this ability? I think we need to add something to the settings infrastructure to prevent this from being added but we should fail here too if the index is onOrAfter 5.0 so this means we should make this: ``` Java if(BUILT_IN.containsKey(name) && indexSettings.getIndexVersionCreated().onOrAfter(Version.V_3_0_0)) { throw new IllegalArgumentException("Cannot redefine built-in Similarity [" + name + "]"); } ```
There are other methods in InstallPluginCommandTests that could potentially be useful if we wanted to share them.
Ah! I see now. You don't do mean to fail. You aren't deleting the destPluginBinDirectory, you are deleting the extractLocation to clean up. Got it! +1
This is much cleaner and nicer to read!
can we make this an enumSet called writeAllowedStateForReplica (and the same for primary). It's getting out of hand :) also please right them in order recovering, post_recovery, started, relocated
don't we need to read the original indices anymore here? not sure, but if that's the case we may be able to remove that specific PercolateShardRequest constructor.
The idea is to replace calling readFrom against the prototype with calling a new constructor for each query that takes a StreamInput as argument. Depending on where those common fields are read/written they may have to be moved, which is the part that breaks serialization as a constructor can only call super from its first line.
you can do that please
can we use failShard(reason, true, e) here? will be clear what it does. Also change the java docs please.
It would be great, if we move to a DiffableStringSet, to make this version return a Set<String> and bellow the hood return an immutable set. This will prevents people from messing with the internal state from the out side.
I don't think we are perf critical here of any sort, can you just use the constants where they are used? I think they are only used in one place and these Field classes are really unnecessary
should be `'norms': False`
Just FYI this is a bit out of date with respect to FSDirectory.open. Actually we default to mmap on all 64-bit systems now, as its faster on the macos X too.
make `SendPingHandler implement Closeable` and then use `IOUtils.close(receivedResponses.values())`
seems like we use field or fieldName throughout the different processors. Can we settle on the same name for all processors? I think field is enough.
just a nit: maybe pass forceExecution before actualHandler so that the order is similar to the `registerRequestHandler` method
I think the first check should be: ``` Java if (parser.currentName() != null && parser.currentName().equals(Defaults.NAME)) { if (parser.currentToken().isValue() == false) { throw new MapperParsingException("Expected a value as Content id but got " + parser.currentToken()); } /.... } ``` that way we also fail for arrays etc.
Yea, I can see that... . The problem though is that it might create a lot of warn messages... . People can always decide to dynamically enable debug logging here to see whats going on. We do not allocate shards on other deciders, and never warn because of it... One of the things we were thinking about is that potentially part of the reroute call, we will give back a full explanation on what was allocated and what was not, so people can see it as part of an API call about why things were rejected.
make this final
this way you don't really test the toString :) I think it's good to leave testQuery.toString(). We will later change the toString to not depend on ToXContentToBytes.
I wondered in the past whether we should add something to the transport registration logic indicating which action were added on what version, so we can automatically disable (new) actions if any of the nodes in the cluster is too old. Feels like this kind of things belong in a generic infra so action implementers won't need to worry about them...
can we give that a better name that describes what the function does? something like `checkCommittedAndSendCommitIfSo()`.
I think this should have `delay` somewhere in the name, it's kind of confusing to have two `getTimestamp*` methods
OK sorry, I had missed the dependency resolution issue. Then I suggest to keep your current solution for potentially revisit when all aggs are refactored and we have a better picture.
OK, did not know this :-)
time for a base class for all these recovery requests? we can remove a lot of boilerplate in RecoveryTargetService by have the recovery resolving shared. As a different PR , of course.
I guess I get that its our way of saying `!isUpdate` since the `!` operator is frowned upon for readability, but I would just be fine seeing `docAsUpsert(false)`
Ahh okay, I missed that usage then, thanks!
To me I think the rule should be: we override this method if you have a specific rest http status code that's associated with the exception. I this case we just use a generic code that's not really indicative of the error. However, looking at alternative, I suggest we use 503 Service Unavailable
I suggest we trace log the failure as well, the stack trace might prove important if we are debugging more complex script failures
Why not use `DEFAULT_SYNONYM_QUERY_STYLE` as a value ? This way if the default is ever changed then one has to change it at just one place.
Yeah, don't feel bad, that's what reviews are for. :smile:
In case of LOCAL_SHARDS/RESTORE, we could again call activatePrimary here.
we can use `// norelease` here to ensure we never release with this in it
these are eclipse specific tags right? I don't think we'd want them in our code.
this header is wrong
not really it was without type before...
Nit: "have change it's" -> "has changed its"
maybe remove `settings` fields? because it is unused.
@dadoonet "iff" is a synonym for "if and only if"
;) I was struggling with the same thing!
Oh I see. I think this doesn't really need to be there - the threaded action listener is already setup by the client if needed. See `AbstractClient#execute(action.Action<Request,Response,RequestBuilder>, Request, action.ActionListener<Response>)` : ``` public final <Request extends ActionRequest, Response extends ActionResponse, RequestBuilder extends ActionRequestBuilder<Request, Response, RequestBuilder>> void execute(Action<Request, Response, RequestBuilder> action, Request request, ActionListener<Response> listener) { headers.applyTo(request); listener = threadedWrapper.wrap(listener); doExecute(action, request, listener); } ``` We can remove this in a follow up change (when we plan to clean up TrasnportMasterNodeAction), but simplify the test complexity and remove unneeded threading, let's wrap the listener in the test ourselves with a SAME execution: ``` .execute(request, new ThreadedActionListener<>(logger, threadPool, ThreadPool.Names.SAME,listener)) ```
cool. good to know. thanks
we miss a log line here.
can we move this validation up to the start of the method, next to the validation of the fromNode? then all of this is together and we can fail early.
can we have only one return statement in this method and make this if a `if (changed == false) {`
Is this really needed ? Why not keeping the original `build(QueryShardContext context)` ? Custom QueryBuilder have the same signature for the build function and the `QueryShardContext` does not expose too many things like the `SearchContext` so it should not be a problem to expose this in a plugin.
It is more common to just call `.get()` now. This is a pretty old test!
this new file is missing some kind of explanation about what it does...
I think the existing version is more readable and I doubt that the performance difference matters at all.
I see why this happens, will fix s we can remove this hack
Remove this empty line.
`BrowserCompatHostnameVerifier` is deprecated in later Apache HTTP client releases. Additionally, it does the **wrong thing** for wildcard certs. I think we should use the non-deprecated strict hostname verifier
can we use 0 based indexing? :)
`. Delete it if there` -> `so we delete it if they exist`
This enforce that the exception is thrown, but the current code doesn't *always* throw one.
no test annotation (not needed, but for consistency)
Does this mean the module version is only the "major" version within a semver denoted jar filename? It might be useful to note that, or even link to any Java spec docs that describe this version extraction for automatic modules.
Snapshot could not be read
(we just load all files in the `ES_HOME/config/ingest/grok` directory)
same here - we can drop the termsSet.clear(); later on.
Yeah. I was more thinking with my fingers.
I think we need to check the incoming version and have back-compat here, i.e. if the version is < X (X = first version when we add this feature), we read the old (only memory) stats.
@uboness that's what I see doing with new classes in other PRs, I am just adapting to that tendency here. I don't know if any formal decision has been made. No strong opinion on my end, but I tend to consider this user facing through java api at the end of the day, although we dont' get there yet with this PR but we should at this point.
I think `"Failed to parse value [" + value + "] as only [true] or [false] are allowed."` is a easier to read.
Indent these a bit more please!
maybe overkill, but is it worth keeping a list of highlighters ordered by precedence instead? it could even allow plugins to provide their own precedence, but that's maybe too much? I am not sure, just asking
ok, didn't know that guice would complain about that. Indeed mocking can be useful.
Maybe make this two declarations? It is really funky to read like this.
just an idea: we could skip the creation of the `ReplicationPhase` entirely if shadow replicas are being used.
can we use AbstractRunnable ? this will give us handy onAfter and onFailure methods.
Returns the primary term **THE** index shard is on
I wonder if a wikipedia link or something would be useful.
I understand the difference between the two...just saying that we are adding an extension point that is currently not used. But if we plan on using it in the future, thats' great. Just reluctant to add complexity when we don't need it.
thanks a lot, looks great!
please add `{}` even if it is only one line
+1. I passed an engine searcher directly.
I recently used the Script.parse methof in the same way when refactoring the ScriptSortParser, Nik encouraged be to add a static 'parse' method to the Script class that does the wrapping of the potential IOException. This can most likely also be used here.
nasty... we have to backport this to 2.x and 2.0, and master if not filter is still there.
`try / finally`
make this final
no objections :)
No need for an else, it can just be outside the if
why is this needed? `publishNode(buildNode);` should be synced!
We should check all levels in the path, for instance in `foo.bar.baz`, `foo` can be a simple object field and `foo.bar` a nested field.
Yes! Thank you.
go for it, you don't break anything, it's a new method added in master only anyways
I wasn't sure about that. If it is temporary we can leave it, let's just make sure we don't forget if we need to take any action in the future
This isn't really necessary, there are later assertions that will fail if this would have.
Nothing to do with this PR, but I don't like that we have this `NumberFieldTypeTests` which randomly chooses a type to test. We should be testing the mapper/fieldtype for every numeric type on every test run...
We should not make these changes until we remove site plugin support. This part right here, does not play well with this change at all.
do we want to use `Xmx` here? `getHeapInit` is `Xms`, I mean, typically, this will be the same, but by default, they are different in our config
nit: can you use assertEquals rather than `assertThat(..., equalTo())` ? I know we do that in quite some places in our codebase but we seem to be preferring the former over the latter nowadays.
"current shard has to be started inorder to relocated " -> "current shard has to be started in order to be relocated "
Can we unit test this instead of creating a integ test? (by extending from `AggregatorTestCase`) ~~We can have a simple rest test (eiher yaml test or simply extending directly from `ESRestTestCase`) that verifies the aggregation has been integrate properly, but it feels like most of these tests can also be tested with unit tests.~~
I think we want shardInfo.toXContent(builder, request); here? like this we loose the request as params
this should be out of the try finally. and then we can avoid the counterInc boolean.
It would be good to have some context as to where the filter appeared. I would at least word it a little differently: `"Missing [type] setting for anonymous char filter: " + charFilterName`
I don't understand why the new method would ever need to be used in tests. random() can safely be used and is always more clear. We should only use the Randomness method for non-test code, and keep it contained. Collections.shuffle(List, Random) is always ok.
this only verifies the repo on the master, not the other nodes...
Or just make it `abstract`
That is just what PayloadTermQuery does, too. So again how is this different from PayloadTermScorer? Even the variable/method names are similar.
There is currently a PR for adding `Optional<Response>` performRequest methods, so you can, instead of having a `isFound` boolean inside your `Response`, return an `Optional.empty()`. I am not sure it would work for these APIs tho, as the docs did not specify them throwing a 404 if the user is not found. The code reads like the 404 would be thrown if the user is not found, but the API docs specifies it returns found=false. Can you verify which one is correct, and if return=false is correct we should probably remove the `singleton(404)` in the ignores parameter. Ill leave this here to look at, for returning Optional.empty() on a 404 not found, in case you find it useful. #35166
It's super minor, but I think we usually don't include punctuation at the end of exception messages (the `.`)
I think we should also get rid of `setNextDocId()` since it's part of the scorer by definition? if you wanna make this work in a second PR that's fine too
no need for `? true : false`
I wonder if it would be better to move towards supporting only `_key` for the time/term ordering since to the use this is actually what its doing, sorting by the key of the bucket? We could do this in a backward compatible way by using the`ParseField` and having `_time` and `_key` as deprecated values for the order. We could also solve the mismatch in `byte id` values by checking the version in the writeTo/readFrom methods and if the version is <6.0 making the code read/write the old id values and otherwise read/write a consistent response. This should mean that we can move towards only having BucketOrder and not the individual implementations.
`newMasterId` (= `getEphemeralId()`) cannot be null, `getMasterNode()` can be, however.
Same here for the line splitting
A better wording for the error is: `[size] can't be negative` Changing that will require updating tests
Minor nit, this can be `new HashSet<>(indices.size())`
Personally I'd write this as `assertEquals(singletonMap("field", "value"), hitContext.hit().sourceAsMap());`. If you like it better the way you have it that is fine too.
We don't assume that all actions have the constants, only the ones that we register. This is something that makes me think using mock requests, actions and response would simplify things, as I wrote above. Yet, if this is a good test for consistency we should have it as a separate test and test all the registered actions, not only a few of them.
same concern about SearchPhaseExecutionException
you can ignore acceptedDocs here I think.
oh I see yeah fine :)
Could you add a short description here? Something like `Add a byte to the sequence.` would make it so you could skip the `@param` bit and still keep the `@return` which is so nicely descriptive.
neat picky - formatting. (add {} )
oh please give us a message here what field it is... it will save some CPU cycles if shit hits the fan
I think its too much trouble: you could also do this: ``` private static final Random RANDOM = new Random(StringHelper.GOOD_FAST_HASH_SEED); ``` that one is already setup to respect `tests.seed`, otherwise its set to `System.currentTimeMillis`.
sorry! totally missed that.
good catch :)
nit: can be package private (maybe I didn't see that in the master PR)
we might make this pkg private once we moved all logic into IndicesService
I am not exactly sure what you are doing here. The `toString()` will always give you a String... and `get(proc)` can throw an `IllegalAccessException` if the field is inaccessible (static, since `proc.getField` will check the `public` part). So why the "does not provide a String NAME field"? Sorry if I missed something.
I think `Store` and `Started` should not be internal classes, it makes the `AsyncShardFetch` file smaller and easier to digest if they are moved to their own files.
Can you explain this case to me? I am just curious, because all commits we need to read (4.0+) have a CRC32 checksum as the last 8 bytes. Its just that since lucene 4.8 we also added the rest of the footer (FOOTER_MAGIC) to be consistent with all other lucene files in structure. So if we want, we can always at least just check that the last 8 bytes are the CRC32 checksum for any segments_N (just don't look for a footer or call checkFooter).
I don't know that `== false` is worth it here.
+1 to randomize on 1 node cluster as well - wasn't aware of this to be honest...
this reorders the output. I think that the StreamOutput/StreamInput can call super() but that the toXContent should be completely done by the subclass so that we can render output in the optimal way. I would for example prefer to see the can_remain_decision **before** the node decisions where to allocate.
We can restore those assertions about the state of the join helper here - i.e. no accumulated joins when leader or follower.
let's split on both chars at once? `split("[>\\.]")`
shall we rather use assertToXContentEquivalent ? I am always cautious on comparing json strings (keys ordering etc.) but maybe in this case it's ok
I'm generally on the fence about adding getters for stuff that *might* be used but isn't at the moment. It looks like this wasn't needed so far (at least there is nothing using it in this PR, might be the clients need it), so I'm +0 on adding stuff we don't really need, but maybe I'm missing the reason. Same for the other method here and the "getFilter()".
oooh awesome! :)
So that seems to confirm that they are interchangeable.
/me is wondering why this one didn't get an @Override annotation while other methods did, is it Intellij's fault? :)
I think this would be nicer as `recoverStateFromStore`
This would read cleaner as: ``` if (shouldHaveScriptStack && hasEmptyScripStack) { ... } else if (shouldHaveScriptStack == false && hasEmptyScriptStack == false) { ... }
this should not be needed anymore
Wonderful these can now be final!
+1 on registration directly via the `RestActionModule` I don't think multiple multibindings is supported, but tbh I wouldn't do that if it is/was. By exposing the extension points as registration methods on the Module you communicate what can be extended and what not, what accepts multiple implementation of X and what just replaces a singleton of X, etc...
ok that should repro the previous behaviour without assertions enabled you mean? I dunno, given that we are touching how we read and write stuff, I would be happy to have proper bw comp unit tests, especially around negative numbers that we don't cover anywhere in our test infra I guess.
from skips the specified number of **buckets** This class will be reused won't it so not necessarily buckets
.jva -> .java
Oops must have accidentally pull this code over from 6.x. Thanks for removing
nit: you could use writeOptionalWriteable() here
no those have to stay as they are as it's already existing classes that people have been using with the transport client.
Can we please avoid Paths.get here? We should always minimize its usage since it makes things hard to test, etc. I would do something like: ``` translogName.resolveSibling(translogName.getFileName + ".recovering"); ```
this is interesting - we explicitly check it's not there? https://github.com/elastic/elasticsearch/blob/master/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java#L586
Ok, just checking.
Why do we need this leniency? The semantics should be either no qualifier is null, or empty string, but not either.
Can you change this to assert `e.getMessage(), contains(the text)` while you are here? That'd make the error message so much more useful.
If we are deprecating now, we either need to upgrade the mappings in master, or throw an error? The current code would allow still specifying the setting? I think we should error on new indexes (at minimum 3.0, although if we should error for 2.2+ or something, I dunno). But the deprecation warning should be for all indexes that still "support" this setting.
I think it is more idiomatic to statically import the `instanceOf`.
can we mark nodeId as nullable? (or find a way to always have a value)
why do we need to read the checkpoint again? I think we need to be consistent here - either with throw the underlying exception (and thus not protect about FileNotFoundException) or catch everything and rethrow a corruption exception. I tend toward the later..
Nit: The default constructor `AtomicBoolean#<init>()` can be used.
nit: `missing` value -> `missing` weight
please wrap in {} and use `== false`
let's add an assertion that this method is only called from the snapshot thread.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
doesn't this need to be set somewhere? i.e. back to the to the geohash. Also, I think that the GeoPoint itself needs to be used as a varialbe and not the geohash, since generating the geohash will be based on the precision specified? For example, someone might define a very high precision, and then the geohash method here uses the default precision which might not be good enough... I think that we can simply call GeoPoint.parse(parsers) without the check on VALUE_STRING, and then use the GeoPoint to generate the has based on the precision later outside of the parsing loop.
do we really need to extend this class? I wanna get rid of it? We should set things up in a ctor and impl. Closeable IMO
on the move now, so can't really check, but I'm confused. timeValueField always output the raw value and that should be used for parsing. the human version can be ignore. Not sure follow how this influences the Index.Builder class.
I'm unsure if this setting should be dynamic.
Thinking about it twice, I don't think that this is necessary. I think you can remove it, run the test multiple times andsee if it fails or not.
> In that case we always make a copy of the underlying array in ArrayList, Not if you change the request and such to use lists. > while in this case we only make a copy if maxBatchSizeInBytes limit has been reached. which may be frequent (i.e., every request), which is why I was considering making a change.
If this stays an Object we have a problem with builder equality when we do the roundtrip doXContent->fromXContent that we currently do in the tests. I had similar problems in TermQueryBuilder already. Imagine an Integer (126) that is rendered to JSON (or other XContent) via `writeValue(Object value)` which inspects the class of the Object and then chooses a type-specific method to write it. On the parser side, this is always read back as a String ("126") with `parser.text()`. So if we check those builders for equality we will fail with `126 != "126"`. For the lucene query produced in the end this difference won't matter (we convert all values to String there), but I think it would be great to keep that property that when we have builder A, generate XContent for that and parse it to Builder B, they should be the same. One option would be to push up the String-conversion we later do in `toQuery()` anyway to the constructor. I'm not sure if the java API currently is to lenient here by allowing any `Object` as argument, since parsing only works for object types that correctly parse back as String. Another option might be to allow parsing to numeric values using `objectText()` like in CommonTermsQueryParser. Not sure about which way is better to be honest.
you could also use `ElasticsearchAssertions.assertHitCount` here
this means the mutable ShardRouting will have their hashes re-calculated every time . Can you double check the impact this have on a huge routing nodes and the balancer (your favorite code :)).
it doesn't break anything given that this class was only used internally, it was not part of the java api. Only this change makes it part of the java api.
Needs a guard.
Does this work? Above PROTOTYPE is initialized with null which will result in an exception being thrown here.
+1 this also looks useful for objects
Fyi, you could use ESTestCase#randomValueOtherThan() for this I think.
on second thought, this might be easier after adding proper settings (with defaults).
I think while we're changing this, it would be nice to change this from "removing" to "removing from dangling index set", otherwise it is kind of confusing about whether data is actually being deleted (which it's not)
I don't think we should allow null's to be passed into Builders as this can easily lead to NPEs. If this settings are not required then the user should not set them rather than setting them to null.
I think we should we add this as part of stabilisation (as an initial step).
Personally I don't like mixing `this.stream` with `stream`. It makes me think you are shadowing and need `this.` sometimes. No big deal, but it slows down reading to have to follow that little mental dead end.
affect -> effect. as far as all the delete methods, i am again curious if this is the right approach. deleting a Collection of files or prefixes won't be atomic anyway, so maybe the impl should only have to delete a single file at a time? This would prevent them from having complex or buggy exception handling. the caller could just use e.g. listBlobs/listBlobsByPrefix and call delete on each one. Separately: does delete really need to be lenient if the file does not exist? Otherwise it leads too easily to `delete + write` which is the same as truncating data :)
Fair enough. We can also maybe just have a something we can drain and let it be a final field.
We use `assumeFalse(Constants.JRE_IS_MINIMUM_JAVA9);` elsewhere, I don't think this is right since the version string no longer has the leading `1.`.
half the shards? please update
Yeah. It can and should wait.
@jasontedor Would using `ExceptionsHelper#convertToElastic(...)` helper method in `ConfigurationUtils#newConfigurationException(...)` or similar here be sufficient? I think the excepting being thrown if the mustache template couldn't be compiled is a `MustacheException`, which gets wrapped by `GeneralScriptException` in `ScriptService#compileInternal(...)`, which is what also should be fixed. Instead the lang-mustache should catch `MustacheException` exceptions with `ScriptException`.
I'm not sure we should be adding more references to the injector. Either we should make the `NamedWriteableRegistry` a package private member of the client or we should just serialize the thing somehow.
Nice! Fine by me leaving the test as is.
I think the test framework might complain about this if it's not properly unset. Yet, I we can mute that by extending `private static final String[] IGNORED_INVARIANT_PROPERTIES = { ...` in `AbstractRandomizedTest#186`
and so the registry returns to the scope of the factory! I am a fan of the `ProcessorRegistry` cleanup
I would also test the direct retrieval of a file (not relevant to this change but we miss that one now and it will be good to have)
Thanks for getting this case too!
This should say `higher cluster state version` instead of `higher id`.
Nit picky - Can we capture the initial `long oldestCreationDateInNanos = System.nanoTime();` and use this as the "now"? Just worried that the queue can be empty (after the initial check) and we will still get a non 0 value ..
I don't have a better idea, but this makes me slightly nervous since nothing in the API prevents you from doing ``` java Analyzer a1 = new NamedAnalyzer("foo", someAnalyzer); Analyzer a2 = new NamedAnalyzer("foo", otherAnalyzer); ```
new ByteSizeValue("512kb").bytes() :trollface:
at this point you don't need the restClient variable anymore
I've never really liked references to github issues. I'm of the mind that if the test is well enough named there isn't really a point and if you really need to trace it back to an issue you can `git blame` the file.
I don't think we should save the state at the end of the job. In fact the indexer should never save any state, this should be done outside of the task. I have a branch that does that but it's not ready yet. In the mean time I think it's fine to just ignore the exceptions thrown by `doSaveState` and just call `onFailure` with the real one (the one thrown by the search/bulk).
maybe the name should contain `doc_count` to make clear what it applies to
Typo for `expect`, should have been `except`.
good point, I found this naming here tricky, includeFields is better, it just described what it does.
Ah, I misinterpreted that line because I never use that syntax. :)
Maybe implement Writeable and a reading constructor? That seems to be the way we're doing things more and more.
I also like "ExternalAggregation" but I'm OK with ParsedAggregation too.
I think this could be final, as I can't find any setter for it
Or maybe alternatively use a CopyOnWriteArraySet instead of a list
Remove these empty lines pls
I guess that is ok! I think you can also add SnapshotInfo.readSnapshotInfoOptional(in) ? I really don't care if it's public to be honest!
don't hardcode script :) we are going to rename it and if you use the existing constant renaming will be easier
Since this is more likely to be read by external developers I don't think it should mention "Autodetect", as that's an internal details. Maybe something like this: > Analysis configuration options that describe which fields and analyzed and which functions are used to detect anomalies.
shall timedOut also be a Boolean? maybe not because it's always returned while terminatedEarly is not? trying to understand the difference between the two
This looks like it is caused by gradle not passing *any* system properties to the test sometimes. We use the absence of a system property set by gradle to engage "IDE mode" when running tests which mucks with the security features a bit. If you run tests from gradle in IDE mode they won't work right. Security, at least, won't work right. If these were to happen for other tests then it'd explode in other ways.
I wonder if we should either check for `Function.identity()` or allow the function to return `null` for "no change needed".
Ok. Changing messages like this can cause a hassle when trying to diagnose issues, because it breaks the "grep the code for the error message in approximately the right version of the code" workflow, but in this case I think the new message is a sufficiently large improvement.
those license headers are old afaik
I would prefer at least one good and one malformed case per test run. Otherwise we only catch bigger errors on multiple repetions and not e.g. on PR tests.
EPERM static constant can be removed if it is not use here anymore
I think we should use this notation `[0..1]`
remove this line and use `updateRequest.index()` instead below.
My bad, looking again at it, I think it is not needed due to the way the method is called, always submitting a state update task, which makes sure there are no concurrent calls.
same here as suggestion above
shall we check what the current token is? if it is a field_name we could use a while instead of a do while? that would be a bit more readable I think.
If you take a look at line 245 of your modified file: `actual = read ? last.after : definition.voidType;` I think this needs to be separated out for the two cases: for the ADefLink case -- actual = read ? expression.actual : definition.voidType; for the regular case it should be the same, but moved into the else block actual = read ? last.after : definition.voidType; This way the actual type for the EChain in the def case will be the expression.actual value that ends up duped onto the stack.
I think this public constant is a bit scary, as it's an object and can be modified (think queryName or boost). I think in this case I would not add a constant for the default value, create a new query all the time.
This will fail if `(int)((end - start)/bucketSpan)` is greater than 10000. A check should be added elsewhere to ensure that the window is small enough that this won't happen.
can we add java docs? this starts to be confusing...
Same deal here as on Delete. I think you should pass the `result` into the ctor and `assert` that it is sane.
Yes, that was actually what I meant (add ParseField to this class and leave HighlightParseElement as is)
sneaky :D, throwing from the `finally` block to supercede the possibly thrown exception from `grok.captures`
Ah nevermind, I see where we use it :-/
Count _as_ delays I mean.
No need for these version checks, a full cluster restart will be required for 2.0 anyway
I think it might be worth asserting that `Result` is one of `DELETED or NOT_FOUND`.
This try-catch throws an exception while the one modified below calls `listener.onFailure(ex)`. Should they match? I suspect this should call `listener.onFailure(ex)`.
After going throught the whole PR I'd probably not suggest this anymore, unless you have some nifty awk / ide search&replace magic at hand. Sorry for the noise.
this does not need to be volatile anymore.
I think we could also have tests for (unless I missed it): 1. master changes while task executing (but before trying to send notification) 2. master changes while sending the response on the response node 3. master changes when task is marked as completed in cluster state but before the response is sent on the PublishingFailureListener
"close or delete the index" I would also lowercase the "reroute API"
nit: remove `this` as its not needed and will be consistent with the below lines
Actually, even better, we can have a single constructor that takes `(String... jobIds)`.
When I see this, I am now happy that wait is a forbidden API. :-)
to -> so
This can be `true` since the check is itself guarded by `isInFipsMode`.
I opened #28603.
we can remove it - mockFS takes care of all of this
I wouldn't. if you pre-generate values would stay the same throughout that same run.
can we have unittests for this stuff I think it's pretty much only tested in integration tests. We should abstract stuff away to make it unittestable!
Since this code is repeated in the `visitIntegerLiteral`, maybe it can be encapsulated in the `minusAwareSource` or in a new method that wraps it.
I can't unsee this, it is like ð¥ in my ð.
Why not just make `SeqNoStats` implement `Streamable` and just use the existing `readOptionalStreamable` and `writeOptionalStreamable`? That's consistent with most (all?) the existing stats objects.
This should not be overridden to true, since in a rolling environment a 7.11 node could start logging deprecation messages that are indexed prior to the master node being upgraded (meaning that the templates would not be in place), so the messages could end up not being indexed correctly
I think I recall cases that work perfectly without the leading "/". e.g. https://github.com/elastic/elasticsearch/issues/19314
I guess the first thing to figure out, is if we can avoid relativize() call at all. Basically its a complicated method, the two paths have to both share the same root (so e.g. one cannot be absolute and the other relative) or you get IllegalArgumentException, if they are equal it returns empty, symbolic link behavior, etc. I just want to know why we this isAbsolute -> relativize check and if we can avoid it for those reasons. The only time i used it in the lucene tests was for presentation purposes in the verbose-wrapper, to create the smallest possible filename to keep infostream small.
Is this new or code that was moved? I was looking for where this came from but couldn't find anything.
I'm not sure this does what you want? it blocks the thread handling the request. Maybe use latches here to signal events and control the disruption from the test? I think it will also be clearer to read.
Maybe it would be simpler by iterating forward as this would remove the need for a null check: ``` for (int i = 0; i < sortedShardList.length; ++i) { ScoreDoc scoreDoc = sortedShardList[i]; lastEmittedDocPerShard[scoreDoc.shardIndex] = scoreDoc; } ```
import appears unrelated to the whitespace-only changes in this file
This can not possibly compile. There's no way the JVM can infer that the lambda here is intended override `BootstrapChecks.OsXFileDescriptorCheck`. Even if there were a way to infer it, I would prefer this as-is because as-is it's clear what method is being overridden, losing that behind lambda makes it less clear.
oh boy I didn't spot this :) we should definitely backport this to master
Shield uses it as a first pass. The actual security is rechecked on the search and sub-bulk requests so this is just more of a pre-flight thing. It makes sense to return both requests, yeah.
can we invert this logic and do `if (recoveryStatus.tryIncRef()) {` or use `== false`
Not sure we need this. For instance we don't allow to remove sorts on a SearchRequestBuilder.
the version here matters. As an initial approximation, we can take the maximum version of data nodes in the leader cluster.
same here - throw IAE
After giving this some thought, what if instead of making a new node, the pieces were built up in the Walker? I think this might end up being easier to maintain since the nodes have already had some testing. Something like the following: ``` AExpression condition = AExpression expression = (AExpression)visit(ctx.expression(0)); AExpression value = AExpression expression = (AExpression)visit(ctx.expression(1)); AExpression comp = new EComp(location(ctx.expression(0)), Operation.EQ, lhs, new ENull())); return new EConditional(location(ctx), compare, new ENull(), value); ``` This should take care of all casting issues since null will naturally become object for the promotions. Let me know if I'm missing something here, which I very well could be.
I think it will be simpler to just capture the local and global checkpoints before we start and build one map here. This way we don't need two maps.
another case for pickier decoding via a helper or similar
I know it's not needed now but it's a bug waiting to happen when someone adds a line below.
nit pick why not: ``` Java } catch (ScriptException e) { throw e;// its already good! } catch (Exception e) { ... ```
Same here, we can change to primitive `int` and use default values for this and some more of the fuzzy options. This will also simplify doXContent, can also be used in parser then.
Could this remain as `<working directory>`? Trailing `>` was lost too.
You can set it to 5.6.0.
can we separate the flush and make this a `SnapshotIndexCommit snapshotIndex()`
my personal option is that we should deprecate staring multiple nodes on the same datadir altogether. that will let us drop this and it will be much simpler? That is the future PR that I am seeing here. if somebody wants to start another node they need to give it a dedicated data directory. I know we will have all the crazyness about out of the box experience... we will deal with it.
The existing `Automatons` code throws an exception if a pattern starts with `/` but doesn't end with `/`. So we could simplify all this checking down to a single if/else and still be compatible with existing behaviour. ``` if (indexPattern.startsWith("/") || indexPattern.contains("*") || indexPattern.contains("?")) { nonExactMatch.add(indexPattern); } else { exactMatch.add(indexPattern); } ``` I don't care strongly, but shorter and simpler seems nicer.
it's different because applyStartedShards and applyFailedShard are doing something that isn't done in the reroute. Also this method is called when we are 99% sure that something is going to happen. I don't think it's worth the extra code path.
Shouldn't this only be consuming the `help` key? Any random other params should still cause an error.
I'm wondering that maybe we should directly use TermListBackedStringFilter in that case: I wouldn't expect automatons to speed things up a lot and having TermListBackedStringFilter only in this catch block makes it hard to test.
space missing between closing and opening bracket: `false){`
do we want Vints here? (plus assertion about non-negative values in constructors)
`newMaxWarningHeaderSize` -> `maxWarningHeaderSize`, and reference the member field by dereferencing `this`.
Also, no need for the field, you can inline it in the places it is used.
`addPathPartAsIs("_xpack", "security", "user")`
makes sense, probably also the `QueryShardContext.setTypes(types);` should be postponed.
Indeed redundant but clear (I had to double check because I wasn't aware of the convention, as most people reading this will be). I suggested the `to` & `from` to make it shorter so less of an overheard. as said, just a suggestion.
no need to pass ThreadContext here. Just do `threadPool.getThreadContext()` when you create the observer.
Can we keep the refs to these internal clients
I think this should go before the previous check because otherwise a trace log will read that the script file is being loaded, and then that it is being skipped.
IMO this should just hold username / password and the authentication should be done in a sep class.
didn't see the `isHeldByCurrentThread` ++ thanks
I don't think "abstracts away" is quite right here.
start the data node first? There's no need to wait on yellow then (index creation waits for primaries to be allocated by default).
there is a bunch of duplication here so I guess we could at least put the `recycler != null` case in a a single method like ``` Java private <T> T registerNewPage(Recycler.V<T> v, int expectedSize) { cache = grow(cache, page + 1); assert cache[page] == null; cache[page] = v; assert v.v().length == expectedSize return v.v(); } ```
there is a word missing in the sentence above. also triple stars.
@rjernst Ping on that cosmetic thing. Not sure it is worth changing though. Up to you :)
It is also fine to use this 1024 constant, even if overestimated. Aggregations that hurt us most are those that create many aggregator objects so it sends the right incentive.
this one is not used - can we remove it until we cat over to the paths API
I think we could pass the requested size as a `ByteSizeValue` and only convert at the lower level. This will make the API less error prone.
a single, explicit empty ctor should not be necessary (that is what the default ctor is)
this method should just return the `Set<String>` or better `Set< IndexMetaData>` and `processDanglingIndices` should assign it. That way this method is `idempotent` and easier to test. We also don't need to load the `IndexMetaData` again
`info *is* unavailable` I think.
@jkakavas - thanks for the thoughtful reply. I don't want to derail this PR and will open an issue for further discussion. EDIT: Issue logged: https://github.com/elastic/elasticsearch/issues/31692
same here with removing retry logic
`randomValueOtherThanMany` might make this easier to read.
I think the following would read better to me: ``` java if (nodeShard.index().equals(shardRouting.index())) { nodeCount++; } ```
I double checked, injection is good as-is, thanks.
ah, I didn't realize that. Maybe we should do this to make optimal use of the `slot`? ```java final int slot = processedSeqNo.indexOf(bitArrayKey); if (processedSeqNo.indexExists(slot) == false) { FixedBitSet bitSet = new FixedBitSet(bitArraysSize)); processedSeqNo.indexInsert(slot, bitArrayKey, bitSet); return bitSet; } else { return processedSeqNo.indexGet(slot); } ```
isn't this the default? just omit in that case.
This string could be a `static final String` also I think
do we want to add another one of these alpha(N) onOrAfter alpha(N-1) checks? not sure if that is necessary
no I would do it later, definitely
Not a critical part of the test but presumably this should be named "product2" for clarity
Yes, I think the builder should operate on the field type.
I don't think this needs to be an AtomicBoolean? Its no longer a member variable so it should already be thread safe.
nit: "Set up" -> "Create"
Nit: could this by simplified even more by randomizing the xContentType, humanReadable and shuffle flag inside of `parsedAggregation`? Not sure about other callers of this method...
This multi-line `||` is super ugly to read without syntax highlighting (on github, for instance). How about: ``` java boolean same = local.isSame(remote); boolean hashAndLengthEqual = (local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length()); boolean consistent = same || hashAndLengthEqual; ```
I'd rename this method to `writeRandomBlob()` since this is generating random data and writes it to the container
oops right, createTempFile not only creates a file object but also on the filesystem
nit: it looks like we can just capture the version here and forget about the entire cluster state
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
nit: we prefer to use `fieldType().hasDocValues() == false` for clarity.
space missing before `"max_input_len"`
Question - why not just get the connection from the transport service right here? does the supplier buy as something? maybe we can even try to get it first and create a new temporary only if it fails ``` Transport.Connection existingConnection = null; if (transportService.nodeConnected(nodeToSend)) { try { existingConnection = transportService.getConnection(nodeToSend); } catch (NodeNotConnectedException e) { // it's ok we'll create a temp connection } } if (existingConnection != null) { sendPingRequestToNode(existingConnection, sendPingsHandler.id(), timeout, pingRequest, latch, node, nodeToSend); } else { ```
Minor, but missing a " " between `..._PREFIX,shards...`
I'm not sure the length comparison buys you much. I'm fairly sure `String#endsWith` already checks that super duper early.
I prefer when the `readFrom`/`writeTo` are symmetrical. Specifically, since we can't use `readOptionalStreamable` in `readFrom` due to `ShardId` only having a private constructor, I think that we should have a symmetrical `if` here in the `writeTo` rather than using `writeOptionalStreamable`. The symmetry makes it easier to check that the `readTo/writeFrom` are in sync.
I think you can remove the whole override.
not related to your patch but I think `autoBoost` and `similarity` are missing here
if this is done only in tests then the test should advance instead this makes 0 sense to me
This doesn't look right.
I wonder if this new method/accessing the char[] is something we should just deprecate immediately? Long term I don't think eg we should not be using the keystore to store a password for another keystore; the contents of the other keystore should be moved into the elasticsearch keystore.
I think this can be trace. maybe the message can be "ignoring node failure (reason [{}]). local node is shutting down"
nitpick: can you change these constants to static final rather than final static (just a common convention on order of modifiers)
oh come on don't feel bad Tanguy :)
I don't understand the use of this helper method, it only seems to be used internally and by introducing it I think the code gets harder to read. Might just be me though.
a constant could cause problems though if the constant gets misused (e.g. changing its boost etc.), method is ok sorry
I think the sub-type (e.g. TermSuggestionBuilder) should read the name and use the constructor).
please get this from the current commit. I don't think it makes sense for the engine to get this from the translog. I can know on it's own!
ok let me know if I have to look into that or you can manage.
`bytes and` -> `bytes, and`
The assertions here need to stronger than this.
can we check that the distribution is balanced in a multi index / multi shard case? like that thing differ at most with 1.
It seems to me that this belongs to BenchmarkExecutorService. The rest of the methods can be moved into an utility class and then we can get rid of AbstractBenchmarkService.
For the record, I was a bit confused at that method, which I first read as if it was Comparable.compareTo while it's not
Same [thing](https://github.com/elastic/elasticsearch/pull/14852/files#r47091246) as in `ShardFlushRequest`; I think the underlying request should be concatenated here.
the test makes sense indeed. +1 to ban Query.setBoost in src/main but not src/test like @nik9000 suggests. I think this should work if you only touch dev-tools/src/main/resources/forbidden/core-signatures.txt instead of all-signatures.txt.
can you use //norelease instead of TODO? then we are sure we don't release if this method is there cause the build script stops the build in that case
At this point we really should just be passing the string to the method. I expect this change is purely mechanical so that isn't something you want to do here.
not sure about this default impl. Seems like the runtime has to plug in its own template service and template impls. but in the interface we assume that we always have mustache. I don't mean to make the engine pluggable, but I think we have to better figure out who needs to do what and how when the ingest library is used outside of the context of es core. I think for now this assumption would be better placed as part of the implementation.
You can just make this an anonymous ActionListener as you had before, capturing an AtomicBoolean to flag whether or not `onFailure` was actually invoked. I think that it will clearer if it's inline with the test, and there will be a little less boilerplate because you can drop the field and the setter.
I see, bummer, I guess we can't do much about it ;)
Don't want to digress, but this would be a perfect usecase for Mockito. Just saying, as long as this works. Might be something to look into later.
maybe we should throw illegal argument rather than illegal state.
I think all of these can be made final.
implements BoostableQueryBuilder should be gone once you rebase
remove this part which doesn't apply anymore
this is a nit and was there before this change, but maybe we should call this `securityIndexManager` everywhere instead of `securityIndex`
> It sounds like I'm going to shift to List from arrays anyway, and thereby drop these methods altogether. +1, that should shrink the added code in this PR by a lot.
`escapeCtx == null ? null : string(escapeCtx.escape);` feels a little cleaner to me. No need to pitch `null` through `string` and make the reader wonder what `string` does with null.
I think I'd just let deleted and updated come out in the toString rather than worry about that. I think it was a mistake that I did it. I don't think it is worth the complexity of the map. It is just a couple of fields that we can ignore.
Yet it's reverted now. ð
yeah, this is tricky. I instead I think we can run a test that cancels from the running task and makes sure it is never run again? we can then decide whether to cancel immediately or after a few iterations
no there was no misunderstanding, I just didn't realize the implications of this check
This can be private to the Try context and final - no need to declare it outside
I think the length of individual byte[] values should also be encoded using vInt.
Same question here about closing.
this is very hard to review, can we maybe do each of these steps as a separate PR? I would appreciate this.
Are we sure we wanna rename `allowNoIndices` to `failNoIndices`? Wondering if t becomes more error-prone than before :)
Good for me, I didn't have a strong feeling about it.
Given what we are doing below I think we should declare the `ValueType` as `ValueType.VALUE` here because otherwise its confusing when reading the code to see INT here and then the fact that we might expect a String that isn't just an int value below. We should then add an else to the below method to throw an exception if anything other than int or String is supplied.
I think this integration test is better ð .
This is unused.
I didn't think about this, maybe we should do the same with IndicesQueriesRegistry and get rid of the buildParserQueryRegistry method.
Good points. For consistency, I think it should indeed remove duplicates.
I'd really like to see this to be positive logic. ie. x || y || ... this is much easier to read and explicit since in the current case I don't the the invalid states
Could you explain why this needs to be public now? I think we should try to keep this package private if possible
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
I am very convinced it should go into the engine ;)
typo: two "if"s
cool lets move on with this.
nit: the more I see of this, the more I think that it's worth extending the `onDPKG` type of API to be able to produce values so reading trough the code is more consistent.
please add one space after `,`
remove extra newline
don't be sorry, I can explain! at REST, we also accept the `context` query_string parameter. It is a string and PutStoredScriptRequest already supports it, you just have to read it from the request and set the corresponding parameter so that we pass it through to the REST layer.
This breaks the stream backward compatibility. The default timestamp should only be written if the output version is >= 1.4.0
I'd just make one CancelTests or something and have it check all three actions.
Yeah, this is really tricky, but I think you did the right thing here, I don't see a better way.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The server-side request (and REST endpoint) converts null, empty or `*` into `_all`. So we should probably do the same here, or remove that from the server-side request and add the logic to the transport action. Otherwise an asterisk from the HLRC will go unconverted and the server will try to look for a job literally named `*` :)
this whole updater should be based on scheduled executor, where every second you'll run "update" task and when you're done you'll schedule another update task for a second later
do we need so many? (up to 10)
the bytes are not the same right because we shuffle the keys? I guess it depends on how we compare bytes references.... would be nice to get around it so we don't need this odd method at all :)
use the real ctor :) - applied to all the ctors below!
oh yeah oh well :) fair enough...
if `addToRoot` is true then maybe fail if target field is specified? Not a big a fan of silently ignoring this.
Consider making this an `||` and having it lazily fail on use (or moving the on-use exception to the constructor and fail fast) due to a misconfiguration.
This is causing a compile error for me, pls use `assertNull(object)` so it compiles clean
I know "vars" is the terminology used in the code originally, but irrc this is actually `params`? I think that naming would be better.
I think this is a tricky place to put this - it doesn't really know what the retry semantics are (that we always retry a full batch). This is why we had the BatchOperationException. If we want to remove it from the "official exception list" (+1 on that), we can still make BatchOperationException dedicated non ElasticsearchException by always rethrowing it's cause.
what I mean is just do it at the end of the method so waiting for refresh will be concurrent to the fsync (just a minor optimization - not really something worth complicating flow paths)
This can have a better name.
I think we should also name it `get` or `getOrDefault`
can also expose the index level ack, or neither? this is confusing imo.
this will need to become protected doToQuery as soon as you rebase
nit: extra lines.
i mean, maybe we can fix their code to not need setAccessible at all? I can't imagine why it would need that.
ah here it is... I guess it's just a matter of picking positive or negative and getting over the fact that we can't have both. null would be better here but we can't have it.
Instead of creating a new BytesRef on every call to `nextValue`, it should modify in-place the `scratch` member that it inherits from `BytesValues` (potentially resizing the array if it is too small).
IMO key should be `null` and you should reset to null as well. Then when we do `vars.put(..` throw an exception if we see key to be null. I also think we should just to `vars.put(key, parser.text());` there
I know we already checked it but I think it's important to make sure all data deletion goes through the same place where we do (and will extend) all the required safety checks. We might even want to restrict access to the delete methods in NodeEnv via forbidden API.
This one should extend `ElasticsearchTestCase`, otherwise it will use the junit runner instead of the randomized one.
just use the public one with one less parameter...
Request vs Reuqest Funny. The typo comes from the old IT test :)
I like the level of detail in these tests, the degree of splitting them in into so many test methods and helpers is maybe a little bit hard to read. The following are just some suggestions of how to maybe group some of the tests. e.g the null, true and false test could be grouped into one case that checks allowed fields fort the allowMalformed field.
what happens when indexing completes, relocation happens and then (and only then) the global updater kicks in. I _think_ we still have an issue, if true, let's just relax global checkpoint for now. I'm good with doing all of that as a separate fix in the interest of getting this in.
Cancel that. This is an internal class.
nit: add the current open mode to the message please
I really think the root cause of the problem here is that we accept this on the server maybe we can require all settings to start with `index.` on the server side? (different issue if you want)
Did you mean to push some commit? I don't see any change here
Does the ordering of this new test rule matter? Should it really be "innermost"? (I don't understand the implications of this TestRule ordering...)
yeah, my guess is (long ago :)) that the idea was to reduce unneeded noise - this whole node leave business is to prevent ugly messages like "pinging failed to this node" and have a cleaner shutdown experience. So if a node sent the leave request to a master but got it wrong, it's not a big deal. I'm fine with going either way, error or debug but I tend towards the later (debug)
Same "now" -> "not" typo here
good catch!!!! not sure why our tests didn't uncover this, will dig.
You can still override only one method when you extend a class. Anyways, keep the service, it's fine
I am ok with what you propose Nik!
I think it still causes NPE, IIRC it's because a search context is not set... so `SearchContext.current().indexShard()` still blows up. The TODO is still valid as a whole... and is the reason why we don't test this function as part of our function score tests
yeah, I meant the `failures.addAll(Arrays.asList(this.failures)); - this is a constructor, so we know this.failures is empty.
Okay, I am going to commit #4613 for now and I will update it to use this with #4616 once this has been merged.
Another option, if we make the recoveryState available on the performer (as suggested for the translog op counting), we can put it in start here and add an onStart method to the performer which changes the state to TRANSLOG.
By design, t-digest is supposed to return accurate values for minimum and maximum values (when quantile is 0 or 1) so it shouldn't be needed to track them separately.
Ah, you have enough in CustomUnifiedHighlighterTests, I think.
can this executor? name is what we often give the tasks..
Nit: space after `))` so `)) }`
does it really make sense to accept null here as a value? I think I would remove the if
We could totally do a default constructor that sets it to `_all` and ensure this one does not do that behavior w the null check
you don't need to rethrow, I'd just make the method throw it as is
oh right we do have the mismatch here, like we expect a start_object that is never printed. It's the expected state of the parser when passed in, as highlight field is not a valid object per se. Odd. Not sure what we can do about it.
expectThrows works nicely here.
The list reference is already final in the class so this isnât really needed
can we check the commit id in the stats and make sure it's the same? alternatively, can we maybe find the segments info for the right commit and create a stats object there? You're right about the synced flush not caring, but I'm worried that we get false scary warn message. I want to avoid that.
I think we can work around it on the node side of things - it should expect to find an existing copy.
nit: `if maxTermFreq is greater than 1, it must not be a fraction`
Need a `return` after this, or we'll respond twice (`failure` and then `success`)
thank you :)
Why not just use System.getProperty("tests.seed") ? is this an intellij auto-complete thing? I see this anti-pattern quite often and i wonder why its done.
Let's type the left-hand side as `Set<String>`.
Can you add a TODO/followup here to just make SortedDocValues "view" that exposes 'missing' as arbitrary value? I can work on it, just so its always fast...
I wonder why we're mocking this simple class. Maybe we can fix the tests? :-)
oh seems like you also removed some ParseFieldMatcher usages, nice :)
minWordLength must be greater or equal to 1
worrying *about* the ...
I will take care of the simulate changes too.
Should probably be `final` (hands wrote `null`, but the brain meant `final`).
I'd never really thought of this but it makes sense.
nit: I have nothing against being defensive here with `pendingShards.decrementAndGet() <= 0` but I would like the assertion to capture `== 0` check. Preferably on the same variable as pendingShards is modified concurrently. This means: ``` int pendingShardsCount = pendingShards.decrementAndGet() if (pendingShardsCount <= 0) { assert pendingShardsCount == 0; ... } ```
same here with removing retry logic
I will provide you with a PR showing what I mean!
guys take this offline if you want - let move here.
note how the Throwable may be null. Also, it would be great if we can capture the reason. So I would suggest we make an IOException here with a message that has the reason in it and capture the failure as a cause.
I think it would be valid to fallback to a generated salt if none is set (for other use cases), but it doesn't necessarily need to be part of this PR.
Also, do we use the `minStringLength` and `maxStringLength`? Just wondering if instead we could do `Arrays.asList(generateRandomStringArray(...))`, unless we need the unicode-ness and the min/max string size
I think it would be good to use `XContentParserUtils#ensureExpectedToken` or `XContentParserUtils#ensureFieldName`
can we factor this out of this class and remove the useless `@Inject` from the `AsyncShardFetch.Started` & `AsyncShardFetch.Store`, make the `GatewayAllocator` instantiate these classes directly. We can then have a simple `OnShardFetched` callback that we can pass as a ctor argument that does the reroute for us. Similarly, the `GatewayAllocator` should also register the cluster change listener and if you ask me I'd drop all this generation thing and replace the entire cache if we are getting a new master in the `GatewayAllocator`.
minor nit: for readability, I would rather do ``` if (leader.skipDuplicates == false || seenSurfaceForms.add(current.getText().toString())) { options.add(current); if (options.size() >= size) { break; } } ``` That makes the if with continue not needed as we are at the end of the while block.
Can we fold shard info the constructors of responses? This way it's easy to forget.
And here just call `readOptionalWriteable` at the call site. You might could also do `in.readOptionalWriteable(SnapshotInfo::new);` which is a bit more concise if it works.
Nit: it does not really matter here but this boxes and this should instead be `Long.parseLong`.
this is not needed anymore now (i.e. the `resyncListener` does not need to exist outside the try-catch block
can you push a commit to 2.x that marks score_type as deprecated? ideally using ParseField
I think this missed a misses a maybeFailEngine as well
nit: I think that we can drop this loop here and in other tests, and instead just rely on multiple runs of the same tests in our CI.
Yes, I saw the explicit test and I was hoping for a randomized polygon/hole thing, but I just realized that also GeoJsonShapeParserTests doesn't do this fully randomized. So if it is difficult I'm also fine if there is only the explicit test.
I used to use file:/path/to/file.zip instead of file:// Not sure if it respects standards but it works.
Let's replace the `assertTrue` and `assertFalse` by more effective matchers.
@mike can we just do this as follows: ``` Java List<Throwable> exceptions = new ArrayList<>(); try { for (Closeable c : Arrays.asList(unreferencedReader, () -> Files.delete(translogPath), () -> Files.delete(translogCheckpointPath))) { try { IOUtils.close(c); } catch (Throwable t) { exceptions.add(t) } } //... ExceptionHelpder.rethrowAndSuppress(exceptions); ```
We normally name these `in`, it leaves for shorter code and it would be consistent with other places in the codebase.
I would have something in the name here about this being for aggs (and for the other agg related methods).
``` java assertThat(provider.fetchCount, is(3)); ```
sorry, I can't help it... typo s/exected/expected
Maybe call it `topLevel` or something.
I was confused with the StringBuilder here, as you later on `insert(0` for the prefix of the message. You could use an ArrayList for the `type.getKey()` and a StringJoiner to append them to the StringBuilder. Really minor, just a suggestion.
does it ever kick in? I would assume you get a `FixedBits` instance for live docs instead of a mutable FixedBitSet.
If it is not possible, I think there is a [better pattern for this](https://github.com/elastic/elasticsearch/blob/76de93c25808b51b27f5d3cedaee159cf3d74fea/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/execution/search/extractor/FieldHitExtractorTests.java#L588) base on `randomFrom(...)` and `Supplier<...>`
also we need those _PER_ shard.. so the allocation ids for shard 0, alloc ids for shard 1 etc.
shard_s_Stores -> shardStores
Arbitrary null values don't really make sense for this mapper so I think it makes sense to remove support for it.
I would consider reducing the visibility of all these details and methods. I think most of them only need package visibility. Some of them might be needed only in tests, which most likely means that the tests are in the wrong package :)
If we call `start()` and `stop()` in a time frame that is below the resolution of `System.nanoTime()` (at best ~ 30 ns) then we will have also significant skew here (assuming 1 ns between consecutive calls).
Yeah! Good point. Maybe applySlop is called after applyBoost? That isn't a good reason, but it might be the reason.
you can use expectThrows
> @bleskes When parsing the system property "tests.seed" we look for a hexadecimal number (because this is the format that randomizedtesting provides seeds in). When parsing a setting (e.g., DiscoveryService#SETTING_DISCOVERY_SEED", we look for a decimal number. Argh. You are right. Sorry for the noise.
`"auto_expand_replicas": 2` instead? That way you don't end up with a yellow cluster on one node and you end up with a fairly large amount of paranoia if you have three nodes? I'm ambivalent for the 2 vs 1 replica thing but I like `auto_expand_replicas` here.
This test checks essentially the same thing as the previous unit tests? To check more in this test, we could as well verify that indexShard has the right term (i.e. that the cluster state update was properly applied to IndexShard).
weird, I thought this was very similar to query_string where we do have AUTO as default, but eventually it isn't, sorry.
maybe just default it to `true` then you don't need to override it in the existing ones
I see, ok
I think that this too can be private.
I do like this change, it simplifies things a lot. What I am wondering though is if it was simply wrapping a search source, or also hiding that inner_hits don't support everything that can be put within a search source. For instance, the `query` element doesn't seem to be supported, as well as other parse elements I'm afraid. This becomes a problem in the java api only I think, cause you can potentially set things that aren't supported. Maybe it is ok for now....
+1, now I see what you're saying (I read that section of the spec. the same way).
can we call it `isLive` we usually mark docs as live not deleted
This could be deleteIfExists
Same here, we should check the index version created.
Log the **node** versions? Can also be done directly in the loop where you are adding the nodes :-)
I'd really like us to start using `EnumSets` for this kind of stuff and then do ``` Java private static final EnumSet<IndexShardState> CAN_UPDATE_INDEX_BUFFER_STATES = EnumSet.of(....); if (CAN_UPDATE_INDEX_BUFFER_STATES.contains(state) == false) { continue; } ```
While you are here it is probably worth mentioning that this will print the the command's usage info. The other might not, I didn't scroll down and check because I'm on mobile.
Should protect this with `logger.isTraceEnabled()` to avoid the extra locking if logging is disabled.
The interface design is odd at first but makes much more sense with the explanation.
rename to `percentileRanks` (should be aligned with the rest api
same here, this might be called by a user-invoked force-merge
This is why it had the generics. OTOH I'll bet if we always return the subclass of QueryBuilder anyplace interesting and have each of them implement this method by returning their own type then no client code will have to change. We should probably add something to the docs on this method telling implementers to return their own type, not QueryBuilder.
Going with the approach of not printing "unknown", this can be: ``` if (nodeCount >= 0) { builder.field(NODE_COUNT, nodeCount); } ```
You can use `assertAcked` here and just wrap the above line... one line saved ;)
we need to change these docs. The lock is not held while the method is called.
maybe use `coordinates.children.isEmpty()` instead
yeah that is odd - I will try to investigate!
its not clear to me when `listener` could ever be null here (and also below in `clusterStateProcessed`)? if it is possible, then the method should have @Nullable annotation for listener
In the case the cluster layout is the same then the sequence of nodes that will be picked during the first requests will be the same. I think this randomisation is good? Another benefit is that if we run in tests the test seed influences the sequence of nodes. This is good for test reproducibility.
I think it might be cleaner to separate this to one elseif handling the string, and have an additional elsif after handling a direct value? This would eliminate the need for the if/else below for value/string, and would clearly separate what happens in each case (and then you don't need the string checking in the other conditionals as well).
IgnoreMeQueryBuilder ? :D
I *think* `0xFF & b` would amount to the same thing and is a bit easier to read, at least it is for me.
Since we use `Type.fromString` only here maybe should change `Type.fromString()` so that it throws the right exception? We would have to change the signature to accept a tag.
(in case that wasn't clear) "bass" -> "pass"
clause.isScoring is also true for MUST clauses, so I think the naming is confusing
Or I can just merge as-is, don't worry about it :)
why catching throwable here? seems a bit too much
nit: Collections.emptyList() to avoid unchecked assignment warnings.
Similar concerns as ValueCountAggregator.
I call those "leftovers".
mind fuck :)
How do you feel about reversing the negative? I feel like `environment.defaultPathData() == null ? 0 : 1;` is easier to read since it's less like a double-negative
We check that the indexMetaData is not null, but it looks like we do nothing if it is null, do we need to warn or throw an exception when the state is null? Right now it looks like it will be silently ignored if the state is null
the reason we don't use timeouts is that if they happen you don't get any info other than the time out. This way, the suite times out and you get a thread dump which helps (sometimes) to see deadlocks and where things are stuck.
haven -> have
I think we can use the `relativeTimeSupplier` and merely report the time (elapsed) since the last fetch.
I think this tryIncRef is only there to make sure shouldCancel can called without things changing on it. I think we can just call cancelRecovery and see whether it returns true.
shall we move to using `@ConditionalIgnore` here. If I understood correctly in that case before and after wouldn't be executed for ignored methods, hence you wouldn't have to keep track of whether the test ran yourself
Maybe a TreeMap if you are just going to build it an then iterate over it. Probably doesn't matter.
not sure it makes sense to talk about `applying` the state here
I wonder if we should resolve things again here. I think we should make it as simple as possible here. Maybe have a Primary request (or use internal request) which has the shardid already built into it. All we need to do in the action is lookup the index shard, see that we have it and do our thing.
We need to close this thread pool at the end of the test
I was planning to do that as soon as we merge the standing PRs. We'll have to hold on more PRs for a bit, but I think it's worth it :-)
these should be : ``` .putArray("path.data", tmpPaths()) ```
Since `shard_store` isn't a reserved keyword maybe this can be "starting recovery from store ..."
``` Java if (value instanceof Number) { return Double.toString(((Number)value).doubleValue()); } ```
imho if we don't check on connected we can make this method static which will simplify testing quite a bit.
I am ok with it. stuff like this is always tricky
I just saw @s1monw replacing `Lists.newArrayList` with `new ArrayList<>()` a few days ago. Maybe that way is out preferred way now? +1 on removing the warning though.
Can you use `expectThrows` instead? I think we should use it rather than this try:fail/catch:check_msg pattern for new code.
I think the confusion came from the case when someone using `position_offset_gap` (in a pre 2.0 index) also specifies `position_increment_gap`. This should be an error, not just making one "win".
Randomized runner should not need these @Test annotations.
sorry I was almost sure I saw a change in GetAliasesRequest too :) I was wrong.
I tried to suffix all settings with `_SETTING` to make it's type clear
Origin should REPLICA
same here regarding the versions
Those arguments confued me at first because a constant named `DEFAULT_...` is being used to set the minimum (3rd arg), and the numeric literal is used for the `defaultValue` (2nd arg). It's not a big deal, but I suspec it will confuse others down the track.
The purpose of createComponents is to create services. This creates an unenforcible ordering dependency between creating these services and calling `getActionFilters()`. `getActionFilters` should take whatever is necessary to creation action filters.
Can you update the logging in `SharedFSRecoverySourceHandler`? The `phaseN` logging messages are now incorrect with the phase changes.
thanks, if there is a reason thats fine ;-)
I don't think we need to use Nullable. In production this should not be null, we just have tests that abuse this contract, knowing how it is used.
Ignore that. Got my listeners confused.
Strictly speaking this is different than the previous code - if none of index analyzer , search analyzer and theAnalyzer is set, we reset the indexAnalyzer and searchAnalyzer on the builder to null. We didn't use to do it...
It would make sense to refactor this into `private Settings newNodeEnvSettings()` since every test requires it, in case it ever has to be changed in the future.
I'd set refresh to true on the index request instead of using a separate refresh.
+1 on adding UUID
exception is in the wrong location :( (was already the case)
this is a very cool first step. I think once we have this one in we should add support for NodeClients / MasterOnlyNodes etc!
nit: extra plus in `+ 5 * + 3600000L`
Hmm can't do `ok and ...` because Python will short-circuit and won't print the failures... Maybe just: ``` if check_env_var(...): ok = False ``` for each check? Or leave it as a list :)
I think "median" is a better function name here? Limiting to 3 letters doesn't seem to buy us anything.
It might be worth eventually making some method that takes an `ObjectParser` with the appropriate signature and returns a `QueryParser`. Eventually....
this one is sneaky :)
can be `protected` and would call it `printStackTrace`
with changes above, this can become tribeService.start()
how come this is set to false? Id prefer if we allowed unknowns since the server side API can change and we want to be as compat as possible w/ server on multiple versions
Only `_field_names` actually builds the content type and I wonder if it would not be better to remove the `"type"` parameter in `_field_names` parser instead of doing it here for all root mappers. Else it might look like you can define a type for different root mappers: ``` PUT testidx { "mappings": { "doc": { "_analyzer": { "type": "geo_point", "path": "custom_path" } } } } ```
Let's replace the `assertTrue` by more effective matchers, and replace the `assertEquals` by `assertThat(..., equalTo(...))`.
I just fiddled around with it some more and see what you mean about periodically checking. Your arguments sounds good to me.
lets also rename snapshot() these names are not good
You don't need to store this in a field, it's available as `super.serviceProvider.getReqAuthnCtxClassRef()`
Right, then parsedFilter is also Nullable :), also, for completeness, you can mark the filter() and parsedFilter() methods as Nullable
8096? Maybe 8192? ð¤£
It seems `optimizeMutex` is there to avoid doing multiple optimizes but also not accumulate pending ones. Lock.tryLock could also work, I guess. Back to the merge policy. It is acquired from the indexWriter so is it OK to change it while not have a read lock? the indexWriter may have been changed/closed. I'm not sure just want to make sure it's considered.
nit: maybe use VandomUtils#randomVersionBetween()
do we also support `copyTo` I guess not
can we add async variants to do this? startMasterNodesAsync, startDataNodesAsync..
Looks like the '--' is not necessary since the variable is not used anymore later on.
I had not looked closely now I see why you were using mockito before :) I don't mind if you prefer to go back to it, I am happy either way
And when we go to actually solve the problem is gives us a potential way forward.
Nit: space after `,`.
Or even something like `containsString("unknown field [bogusField]")`!
do we do this in other places? I mean using read/WriteByte for enum ordinals? I think there's many many places where we have VInt instead
Ok, I'm fine with that..
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
hooray for try-with-resources!
yes I know, I value consistency here, let's not support things only in specific cases. we will parse those back when/if we will support proper numbers.
Now that we have `ESRestTestCase` you can write the test in java if you like. It is up to you if you want to do so, but I like having stuff like loops available. Yaml is nice if you want to make sure the language clients can run the tests but that really only applies to the tests in `rest-api-spec`.
We no longer support `aggregations_binary` (already listed as removed in the release notes for 5.0) so we can just remove the `aggregation_binary` code below which should solve this issue? (it looks like I missed this bit whilst doing the aggregation refactoring before.
Definitely for a different PR, but I think we can fix this by making the String constant in ALink an Object constant instead.
shouldn't we check that the returned mapper is not null and is od nested type? we have this in NestedInnerQueryParseSupport: ``` if (nestedObjectMapper == null) { throw new QueryParsingException(parseContext, "[nested] failed to find nested object under path [" + path + "]"); } if (!nestedObjectMapper.nested().isNested()) { throw new QueryParsingException(parseContext, "[nested] nested object under path [" + path + "] is not of nested type"); } ```
lower cased exception name
`Weight weight = searcher.createNormalizedWeight(filtersFunctionScoreQuery, true)` would be better I think as it will include weight normalization
To me this is the part of the PR that needs attention. The way it is implemented here means that the same partition could match different terms across refreshes. I am unclear whether it would be an issue. Maybe it would not, like pagination of the search hits.
we usually prefer underscore case
fine, it's a small detail anyway
Same thought as @tvernum here.
I am glad we simplified things by just renaming id to tag, that's a good choice
I wondering if we should do it on validate? feels more natural there, as we won't need to wonder if there if we got all the paths to set version types
We discussed this via another channel, @bleskes will work on removing this guard and obviating the need for even considering adding a 6.0.0 version constant.
don't worry too much about this method, we wil get rid of it soon. I am preparing the field for this change :)
This also needs a test for the exceptional case (exception during reading).
Do you think you can make something like: ``` protected static <T> ConstructingObjectParser<T, Void> setupParser(String name, TriFunction<List<TaskInfo>, List<TaskOperationFailure>, List<ElasticsearchException>> ctor) ``` in ListTasksResponse? That way you wouldn't need to copy this stuff.
QueryBuilders should always set the defaults since they can be constructed without ever passing through the parser (Java API)
that' shouldn't be possible. A live doc is always the one with the highest seq# (if exists).
I don't think this is the best place to apply minShouldMatch. The difference between this and say match query is that it supports multiple fields (i realize the default is _all and this patch will work with that). So in this case, this query will return a boolean query across say title, body, author fields. the current application of minShouldMatch will be unintuitive there.
right I missed that good catch
do we need to handle NONE? I'm wondering this could happen if there is a segment that does not have any values for that field
sorry for the confusion!
`Objects.requireNonNull()` either returns the first argument or throws an exception so you could simplify this to: ``` java this.lifecycle = Objects.requireNonNull(lifecycle, "lifecycle must not be null"); this.logger = Objects.requireNonNull(logger, "logger must not be null"); ```
Please complete the sentence ;-)
maybe say something along the lines of "cluster bootstrapping can only be done against a master-eligible node"
I think it'd be a bit cleaner not to do this for Byte, Short, Integer, and Long.
I think I'd prefer `"failed to remove index " + index` here and get the toString for `Index`.
I think the message is a little deceptive, because it is not account, but the client name? And in the backcompat case, I think it may be confusing, because the client name is fake (ie primary or secondary, but a client configuration by that name does not actually exist).
What do you think of: ``` private void handleReadResponse(long from, int maxOperationCount, long maxRequiredSeqNo, ShardChangesAction.Response response) { maybeUpdateMapping(response.getIndexMetadataVersion(), () -> { synchronized (ShardFollowNodeTask.this) { globalCheckpoint = Math.max(globalCheckpoint, response.getGlobalCheckpoint()); final long newMinRequiredSeqNo; if (response.getOperations().length == 0) { newMinRequiredSeqNo = from; } else { assert response.getOperations()[0].seqNo() == from : "first operation is not what we asked for. From is [" + from + "], got " + response.getOperations()[0]; buffer.addAll(Arrays.asList(response.getOperations())); final long maxSeqNo = response.getOperations()[response.getOperations().length - 1].seqNo(); assert maxSeqNo== Arrays.stream(response.getOperations()).mapToLong(Translog.Operation::seqNo).max().getAsLong(); newMinRequiredSeqNo = maxSeqNo + 1; // update last requested seq no as we may have gotten more than we asked for and we don't want to ask it again. lastRequestedSeqno = Math.max(lastRequestedSeqno, maxSeqNo); assert lastRequestedSeqno <= globalCheckpoint: "lastRequestedSeqno [" + lastRequestedSeqno + "] is larger than the global checkpoint [" + globalCheckpoint + "]"; coordinateWrites(); } if (newMinRequiredSeqNo < maxRequiredSeqNo) { int newSize = (int) (maxRequiredSeqNo - newMinRequiredSeqNo) + 1; LOGGER.trace("{} received [{}] ops, still missing [{}/{}], continuing to read...", params.getFollowShardId(), response.getOperations().length, newMinRequiredSeqNo, maxRequiredSeqNo); sendShardChangesRequest(newMinRequiredSeqNo, newSize, maxRequiredSeqNo); } else { // read is completed, decrement numConcurrentReads--; if (response.getOperations().length == 0 && globalCheckpoint == lastRequestedSeqno) { // we got nothing and we have no reason to believe asking again well get us more, treat shard as idle and delay // future requests LOGGER.trace("{} received no ops and no known ops to fetch, scheduling to coordinate reads", params.getFollowShardId()); scheduler.accept(idleShardChangesRequestDelay, this::coordinateReads); } else { coordinateReads(); } } } }); } ``` PS - note the difference in handling of `lastRequestedSeqno` - I think the way you had it had a bug.
I think you need to return the BufferedHttpEntity in the response for this to work. Building it here will consume the underlying entity, but you still return that entity. So it'll be empty. I'm honestly not sure why the tests pass.
Why do we need this? The public ctor is used for new types, when intializing all the metadata fields. But in that case, there is nothing shared so no need to initialize the join fieldtype (it should not be used unless/until _parent is set on the new type, in which case it will be parsed and the protected ctor will be used).
maybe this can be static too, and I would rename to assertDeprecationWarnings or expectDeprecationWarnings
This should be: ``` ^(?:[-\\w]+[.])+$ ``` This assumes that (a) at least one level is required and (b) there is nothing after the group key (so it is anchored to the end of the string)
mmm I think I don't see why we need a functional interface here. Seems like having a registry class makes it more clear and is more consistent with what we do with queries. But it's my personal opinion, not sure what others think.
No, that allows `0`, `off`, and `no` for `false`, and `1`, `on`, and `yes` for `true`.
actually we could even skip the unmodifiableList wrapper since the wrapped list is already unmodifiable
These make sense. I haven't checked the system call numbers but I trust that they are right. I will double check before final review.
Maybe this can just be "terms_set" too
oh boy... would be great to have them then
XContentParser.Token.VALUE_STRING.isValue() always returns true
I don't see why we need to restrict types here. This should work fine for stored scripts as well, and they should be validated too.
++ for doing it this way for now.
you can use `exception = ExceptionsHelper#useOrSuppress(exception, e)` here instead
`ThrottlingAllocationDecider` is not imported, so this is a compile error.
Same here - I think we should move the log before the close command.
we can maybe have an assertPathHasBeenCleared variant? then people will hopefully see both and choose :)
There should be extra spaces here, between the `if` and the `(`, and the `))` and the `{`.
This should probably be private.
maybe use `indexOf(...)` and then `indexInsert(...)` and `indexGet(...)` respectively to avoid determining what the slot is for a key several times? ```java final int slot = processedSeqNo.indexOf(bitArrayKey); if (processedSeqNo.indexExists(slot) == false) { processedSeqNo.indexInsert(slot, bitArrayKey, new FixedBitSet(bitArraysSize)); } return processedSeqNo.indexGet(slot); ```
I had something similar before, maybe revert back to using ALink.after for that - I was not sure if the operand should always have the same type like the after value. In any case I would keep the superclass ADefLink to make them easier to "detect" in those if statemments, although the ADefLink class is empty afterwards.
ignoring the status here makes sense to me, but I wonder if we are 100% sure that the status returned by `ElasticsearchException#status` (which looks at cause etc.) will always be the same as what we got back (either as status code or within response body).
Maybe include the exception in `UnassignedInfo` instead of a detailed message? So that the entire exception is included once the cluster state is serialized, like we do on other places to now and it is useful too.
yeah use READONCE
ok lets open an issue for it and get this one in...
This is again one of those tricky points. I think it might now be possible to get 2 datafeeds referencing the same job as it's possible 2 concurrent PUTs end up passing the validation. We need to think this through.
Could we reuse the constants used in InternalSignificantTerms by making them public? I think we did that elsewhere and also do this with the CommonFields.
Wonder if it makes sense to rename the inner `Type` here to something more specific to not get it confused with the three `MatchQuery.Type`s that it's using internally.
I think this is dangerous at the moment - versions can go down if a master goes down halfway during the publication of a cluster state - the new master may have not yet received the new version. I have plans to make this better, for what it's worth.
I'd probably do something like "testreason" so no one gets confused.
`doSaveState` is async so there is no need to try/catch this call. We ignore exceptions in `doSaveState`, this is ok IMO since saving the state here is just to ensure that we'll start from the last commit point.
Based on the discussion above (whether we need to account for the "has no results" case at all after "reduce", I would opt for at least testing it less frequent, and thest the "result" case mostly.
You have an extra `,` before the URL
Oh I see it called above, nevermind, instead, this should be: ``` public String getTestConfig(Settings settings) { return TEST_SETTING.get(settings); } ```
My (hopefully) last corrections here (in this case I'm correcting my earlier self ð): - We should also add allocatedPostIndexCreate() to be more in line with PrimaryShardAllocator. This means that this condition and the subsequent two become `shard.primary() && shard.unassigned() && shard.allocatedPostIndexCreate(indexMetaData) && storeCopy == ClusterAllocationExplanation.StoreCopy.STALE` - We should also handle `StoreCopy.NONE` in the same way. In case of assigning an unassigned primary, having no shard data is also a NO.
Nit: I think that name of the request parameter should reflect concurrency rather than parallelism.
I think here the `i` logic can be replaced by a `boolean`? Seems to be a `true/false` scenario.
Out of curiosity, we cannot do a check with the similar intention in the policy file itself, no? To me it looks like this part of the code is only used for testing.
These are all so nice!
Hmm, this is so we can call `runUntil(getCurrentTimeMillis() + ...)` but that's always how we call `runUntil`. Maybe move the addition inside, call it `runFor(...)`, and adjust the logging suitably (cos searching for absolute times is a useful debugging tool).
yeah I used `...` so explicitly `source[n/a actual source size: [12345b], max source length: 2048b]`
can't this just be `if (IndexMetaData.isOnSharedFilesystem(indexSettings) == false || closed)`
it can't happen in practice, but I would like better something that would do if (tdigest) {} else if (hdr) {} else { throw new AssertionError(); }
I don't think so, that's relying too much on an internal implementation detail (that there is a cache, that file scripts are compiled and put into the static cache, that the key is the prefix of the filename, etc.). The purpose behind the PR is to get the script service to ignore hidden files, and that is what needs to be tested. I haven't looked too closely, but I suspect that you're going to have to hook into the script service or maybe the resource watcher and possibly refactor a little bit to expose the pieces needed to in fact make this assertion. Let me know if that's enough to get you started, I'm happy to take a closer look if needed. :)
I usually find it cleaner to make a variable of type Runnable in cases like this. Doesn't matter though.
this else clause is unnecessary or infact wrong :) no? we should not write `UNBOUNDED`
we also need to close the connection in `public void onFailure(Exception e) {` since we might get rejected or something like this.
Oh no! The build failed because of tabs! You can catch these sorts of things with `gradle core:precommit` which is much faster than `gradle core:check` because it doesn't run all the tests. I'll run the tests before pushing but for something like this it ought to be safe for you not to run them.
you can create these files using `temporaryFolder.newFile(filename)`
There's a bit of a problem here. A builder as it is presented here, is a stateful construct, meaning, you use a builder to build a "configured" instance of a processor. But the passed in registry should not be stateful... effectively, the builders in the passed in registry should act as "factories". either separate the two notions (builder & factory) or have the registry hold "prototype" builders and then change the `void fromMap(Map)` to `Processor build(Map)`. Personally I like the separation of the constructs - builds clear API with clear roles and responsibility for each class. But core moved more towards the "prototype" direction, so perhaps a prototype here will be more aligned with core.
nit: move this to the line above.
here is a space missing before `Explicit`
same here - can we move the `_shards` to be the last of the `_` fields? Now it's mixed: ``` { "index": { "_index": "index", "_type": "type", "_id": "3", "_version": 1, "status": 201, "_shards": { "total": 2, "successful": 1, "failed": 0 } } }, ```
nit: might throw in a DEFAULT case instead.
For this simple test, maybe you can inline the builder creation.
There is a single field here, `tombstones`. If the `IndexGraveyard` instances are reference-equals, then the `tombstones` fields will be reference equals. But `Object.equals` method already does a reference check before deferring to a logical-equals. Thus, just deferring to `Object.equals` on the `tombstones` field does not save anything. Hence, I _do_ think that only the equality check on the `tombstones` field is needed (after, of course, checking that `obj` can be cast to an instance of `IndexGraveyard`).
I think it's too lenient, we should fail if the type is unknown.
That's true, the Hamcrest matcher doesn't handle recursive matching, so it won't really simplify this class. A very general question - why didn't you use Jackson to do the equality check directly on the actual and expected JSON? Because the assertion errors would be frustratingly non-specific? Or because you are only testing certain elements of the JSON response for equality? Thank you, this is a very neat enhancement!
nite: can we add some java docs about the life cycle of this reference (closed when operation is done and replication have completed).
I think this line fits in the previous one
The reason we delete the temp files is that when a new recovery starts, it will create a new folder and copy files over again and we could (were) filling up disks that way. This is not an issue here. I think we should be consistent in our policies. We chose to leave complete corrupted shards around in other places, so I think we should do the same here? I don't feel strongly about this, though. This was the gist of my question.
see above & there are some extra lines here
lets call `stdinReferences.clear()` after we closed all of them. I also think you should use `IOUtils.close(stdinReferences)` instead, it will close all references even if one close call throws an exception.
You could also (if you don't want to use the `useOrSuppress` above, just collect the exceptions into a list and use `ExceptionsHelper.maybeThrowRuntimeAndSuppress(listOfExceptions);` without the `if` statement
Missing space. Should be: `String publicKeyBase64 = getValue`
I think if you add this below then that will work too and it is shorter: ``` (actual instanceof NodeNotConnectedException && actual.getMessage().contains("TransportService is closed")) ```
We could use `BytesStreamOutput`
nit: I find equals impls easier to read when they are symetric, eg. something like this should be correct? ``` Objects.equals( timeZone == null ? null : timeZone.getID(), other.timeZone == null ? null : otherTimeZone.getID())`
and setting it here is too late anyway, for example StringHelper in lucene is already initialized. changing tests.seed is simply a non-option. If you want things to reproduce in your IDE, you need to pass tests.seed to tests: its just that simple.
Ignoring that we need it for `network_types`, I kind of like that settings are now on by default.
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
active shards cannot be started. They are started by definition of being active ;-)
I was curious about how new ingest processors are implemented, so looked into this PR. Regarding requiring "sort": what if lastType is "sort" but it was sorting another field? Something that might be caught by pipeline validation perhaps.
one too many line break
testing will be tricky but doable. I have some ideas here similar to what I did on `RemoteClusterConnectionTests` where we basically mock the calls to clusterstate and return a pre-build state but we can also put some sleeps into it.
This is not longer correct - more like "Creates a new QueryBuilder from the query represented by the xcontent in the parser." or something.
imports not needed.
no I like creating a new instance, seems to reflect what we do everywhere at this point. But we should clean things up a little bit more, to make sure that the set search context is consistent at least.
I'm concerned that in this case, the per-key list of headers will not be cloned. Maybe this optimization should be removed and just be: ``` java if (customHeaders == null) { customHeaders = Maps.newHashMap(headers.size()); } ```
Do you want to remove the stuff in the TODO below like the note asks? I don't think we're likely remember to remove it unless you do it now or open an issue to do it as a followup to this PR.
Just curious about what this does.
I think we should have just one pool for all job types, and the maximum number of open jobs per node should also relate to _all_ job types. Since the number of threads in the pool is governed by the number of named pipes we create per job we shouldn't need to adjust the thread pool size. However, since people might now want more jobs this might be a good opportunity to implement #29809.
we could as well make this public, I don't see harm in that. After all it's what the user set.
I wonder if we want to add and an else clause with a debug log here to make sure we see duplicate failures? might be helpful in debugging.
Why not `copyBinDirectory(sourcePluginBinDirectory, destPluginBinDirectory, terminal);` instead? As far as I can see you pass `pluginHandle` just for logging reason here. You could pass the plugin name instead: ``` java copyBinDirectory(sourcePluginBinDirectory, destPluginBinDirectory, pluginHandle.name, terminal); ```
or maybe give the return value a variable and name it accordingly
We can use `Randomness#get` here.
oh nevermind I thought it was a parsing method, but this is the simple Enum.valueOf
extra newline here please remove
we try to be practical when it comes to code style... some things we're strict about, other less. I think with today's idea's the import styles are quite meaningless (I personally have time folded all the time and never find the need to look at them), so whether one uses \* or use explicit imports... I think it's really not a big deal (I think I personally left the default intellij behaviour where imports are collapsed above a certain threshold)
I wonder if we should wire this to `org.elasticsearch.index.translog.TranslogWriter#getHeaderLength(int)` with a static constant somewhere.
I don't think you need to fail always but rather fail randomly. This is important to test failures that can come in any step, not just the first.
This will be logged for every single shard. So, I think it might be better to make it `TRACE`.
Do we need the `.score(..)` here? For the user all they need to know is the score function that failed. The method is probably not relevant to the user in the message and will be in the stack trace for a dev investigating anyway
NO unfortunately there is no `Property.ClusterScope` so I think it makes it more important to have the setting resolved on the coordinating node so that all shards use the same value.
This was a bug previously? Seems so, just trying to understand.
can you add a space between the `if` and `(`
It seems that the normalizer can be changed when the field is updated ? It should be prohibited because we apply the normalizer at index and search time. Though the check is done on the index analyzer only and here we set the search analyzer so it won't prevent the normalizer to be changed at runtime.
I have a small preference over public abstract rather than abstract public
`originalTimestamp` can be null here, causing an NPE
You can save a line and go `Object value = valueTypes[level].get();` directly
you should count down the latch in a try / finally not in the exception block. Another thing which is nice about java 7 is that you can just rethrow even if you do catch throwable like in your case this would look like this: ``` } catch (Throwable t) { logger.warn("Failed to update master on updated mapping for {}", e, mappingRequest); throw t; } finally { latch.countDown(); } ``` since java 7 realizes that this must be an unchecked exception!
also, please make a note to make this configurable.
Really like the unification of the `getRandomValueForFieldName()` helper method above. Here I think it would really improve readability if the method wouldn't take `exclude` arguments but rather all the fieldnames to include in the random choice. More like `randomFrom()` really. I had trouble understanding the tests below, if they read `getRandomFieldNameAndValue(OBJECT_FIELD_NAME)` I first thought I get an Object value back. So even if this makes the list of arguments in the tests longe, I think this should be the other way round.
++ the the plan to move it here.
sorry, missed the loop
I think it's in the right place here.
while I understand that we already have `aliasFilter`... I really think it's a bad name... the alias functionality leaks into the search context (which has nothing to do with aliases). I'd rather call it something like "includeFields"... or something generic like that (the fact that these are coming from an alias is just a use case IMO)
The PKI realm should clear its own cache for both of the role mapping changes as of #31510. For the explicit LDAP clear cache, it is the cache clearing of a different realm and this user is technically coming from the PKI realm and the cache should be cleared for that user in the PKI realm; now if the PKI realm has authorizing realms that are caching realms, then it should delegate the call to clear the cache for the user to those other realms as well.
maybe make this method static, give it a list/stream of readers and the current time as parameters? this would allow for proper testing with mocks and fixed time.
Can we keep the order of arguments for this and super ctor consistent? So all the args that will go to the super class should come first, in the same order to the super ctor? It is confusing to see args moved around (here the order is consistent but in others it seems not)
I think this is missing from hashCode/Equals as well
little typo - shareds
Not very expert on this aspect but I wonder if and how rewriting affects other queries explain output? Also, tests would help here just to validate what we print out.
This method can be package-private.
nit - updateMaxUnsafeAutoIdTimestamp
as far as I can tell this check previously could never be triggered as we used to hold a reader lock which means no one was allowed to change indexWriter. Now we do it out of the lock which means it can happen? I think we should remove it.
URL should never used IMO you should always use URI. Generally, if the URL describes both the location and name of a resource, the term to use is URI. URI also doesn't take care of encoding of the characters which might come in handy if there are spaces in the path etc. Yet unless you need to have a URL I'd always use URI (ie. if you need to have support for credentials which I'd discourage anyways here)
nit: it's just other nodes - we are pinged by any node in the previous cluster.
Can probably be `writeOptionalWriteable` or something like that.
NIT: noisy reformat :)
This also seems like the kind of leniency that we'd want to remove in the future.
maybe extract `settings.fieldsAndWeights()` to a variable to avoid this weird indentation
indeed I suggest to move away from `Preconditions`, for now using ActionRequestValidationException sounds good, maybe a specific query exception would be better but we can figure it out later on I guess
I think we should just rethrow `t` and remove that exception. We can't handle this just like refresh since a failing refresh means dataloss while this one might just be a configuration issue or so. We should just pass t to `maybeFailEngine` and rethrow IMO
I don't mind either way
Just dug into it and found we use `TestRuleAssertionsRequired` from the lucene-test-framework jar to do this check
maybe also here `"foo"` -> `{@code foo}`
Can we move this and the `if (shard != null) {` outside of the `try`? I.e. shrink wrap the `try` around only the code we expect those scary exceptions below to be thrown from (the `shard.updateBufferSize` call).
This is close, but I think this needs to, unfortunately, be placed in an overridden cast method. this.expected isn't guaranteed to be set until after the analyze phase because of possible promotion. Something like the following: ``` @Override AExpression cast(final CompilerSettings settings, final Definition definition, final Variables variables) { final ALink last = links.get(links.size() - 1); // If the load node is a DEF node, we adapt its after type to use _this_ expected output type. // Note we avoid doing this if the cast is explicit because we want to ensure that the cast // will do primitive narrowing operations and upcasts at runtime without throwing an // exception. We also avoid doing this if a store is being done since the value from // the store is what will be on the stack. if (!explicit && expression == null && last instanceof ADefLink) { last.after = this.expected; this.actual = this.expected; return this; } else { return super.cast(settings, definition, variables); } } ```
spaces after if and around '='
Is it good enough to put this at the end here? Like, if a pugin wanted to add a root mapper.
this should be alpha6 now that alpha5 is out
It seems the general problem with the existing setters is that they can lead to partially constructed lookup objects. I'm leaning towards disallowing setting null in all the lookup setters here alltogether. The user currently using the java api can avoid the setters by simply not calling them. In the parser we can avoid doing this for the optional index / routing by first constructing the TemsLookup (Builder whatever) and then setting this via `termsLookup(...)` setter.
its not clear to me we aren't double-wrapping here if leafreaders were shared from the previous.
This is a breaking change now so this PR needs to be marked as "breaking" and a note added to the migration guide
This will throw an EngineClosedException which is a different type and we do check for RecoveryEngineExceptions in some other place of the code. I'm not sure this matters, I think it's safer to keep as is? Also we loose the information about the recovery phase (1)
Is this still fast, when we have a packaged application? Does `getResourceAsStream()` need to read all classpath jars, until it finds a corresponding file? We should make sure here that response times for command line tools are crazy fast.
Just so you don't have to build the object with so many nulls and throw it away again. Its no big deal.
Hmm I just realized we are doing too much work here? We should only be visiting the files belonging to this segment, but we are instead visiting all files in the directory (at least, in the non-compound-file case)? I think instead of `directory.listAll()`, you could use `segmentReader.getSegmentInfo().files()`? This should return all file names that this segment uses ...
It only checks those persisted in the repository...
This should probably be `< 0` in case someone passes -2 as the requests per second
oh one thing s/optinoal/optional :P
Maybe add an explicit `continue;` here to indicate that it is being skipped
I think that license header is broken - check the other for details... if you have java 7 running you can run `mvn license:check` it will tell you were you have problems
+1 but I would check with @clintongormley whether we are happy making this breaking change in 5.0. However, we haven't actually formally removed camelCase in ParseField IIRC so adding this extra name here might be unnecessary anyway
we shouldn't make this change here in the branch, but rather in master. Let's get that one in first in master and then this one in our branch.
Actually this line is not the actual problem, but this one is: ``` java final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT]; ``` together with ``` java breakers[code] = parseRules(resourcePath, env); ``` If `code` is greater than `UScript.CODE_LIMIT` then this will result in an `ArrayIndexOutOfBoundsException`. But I do not know whether it is possible that this condition occurs in practice.
I really don't think we should add more of those double negations is should `CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED`
maybe we can try to log the stacktrace in a try-finally block in hopes that we can get the full stacktrace? In the finally we can throw the Error
I think this is fine for now, but note this stuff got excessive in all the spans and still would not find bugs. In order to make things debuggable i had to solve it another way: https://issues.apache.org/jira/browse/LUCENE-6411 So I am not sure about all the asserts, to me I just get lost in the code.
Let's use `assertThat(..., equalTo(...))`.
We already do not support camelCase for all settings, and I don't think there is any consistency even within the same query/field type/whatever.
should we allow null here? I think it must not return null but the raw handler instead? maybe I am missing something
just a reminder: version might need to be updated here too depending on which branch we backport the PR to. You might have thought about it already, but these are the things that I usually forget about when I push :)
I like the implementation of the algorithm! Consider using CompletableFuture instead of AtomicBoolean+CountDownLatch though because it's only one concurrent primitive instead of 2.
can you add `for FIPS 140-2 compliance`
this `readStringProperty`? it is not parsing script code, it is an ingest-node config reader
Maybe rename to something like noopAfterRuleTask? To make it clear by default we do nothing here, it's just a placeholder in case a subclass wants to set its own AfterTestRule.Task.
I don't think we need an implementation for this method however I think this could be `RamUsageEstimator.shallowSizeOfInstance(CountedBitSet.class) + (bitset == null ? 0 : bitset.ramBytesUsed());`. You could even fold `RamUsageEstimator.shallowSizeOfInstance(CountedBitSet.class)` into a static final constant.
This is needed until we have a better understanding of the implications on nodes with small amounts of native memory.
Would it be useful to have 0 have the special "I've not even tried yet" meaning? I think setting it to now is kind-of funky because you aren't actually doing an allocation when you build the object.
nit exta space between `TRIAL` and `)`
Alternatively, you could also change all the uses of `context.settings` to `context.environment.settings()`
It should say greater than zero, 0 is not permitted.
maybe just `return totalSize == fileInfo.length();`
`pluginName` should still be wrapped in a code block (`{@code}`).
Can't find `validate()` here. I think we went for always having empty implementation in builder class, even if there's nothing to validate.
I believe we can safely expand the semantics of `isRelocationTargetOf` to also incorporate this case. This means changing `isRelocationTarget`, `isRelocationTargetOf` and `isRelocationSourceOf` such that it not only accounts for `INITIALIZING` state. (It is a safe change as a STARTED shard can never be a relocation source and RELOCATING shard can never be a relocation target). For example, replacing ``` public boolean isRelocationTargetOf(ShardRouting other) { return this.allocationId != null && other.allocationId != null && this.state == ShardRoutingState.INITIALIZING && this.allocationId.getId().equals(other.allocationId.getRelocationId()); ``` by ``` public boolean isRelocationTargetOf(ShardRouting other) { return this.allocationId != null && other.allocationId != null && other.state == ShardRoutingState.RELOCATING && this.allocationId.getId().equals(other.allocationId.getRelocationId()); ``` Can be a follow-up, just something to think about.
can we do ``` if (currentState.nodes().masterNodeId() == null) { // we welcome our new overlords return false; } ``` One less nesting to put on the mental stack
please don't use String concatenation in logger calls, but positional parameters, for example `logger.warn("failed to get snapshot [{}]", ex, snapshotId);`
I think we should leave this method for java api bw comp
Oh nevermind I see it will happen below.
Thank you for this test, much appreciated.
If we separate `updateNodes(state, clusterStateServiceMap);` out of `randomInitialClusterState`, there is no need to have a `clusterStateServiceMap` in this test.
;) do we have unit tests ? (I didn't check if so ignore me!)
I think the test should fail. We don't know what else have happened due to this interrupt nor whether the node is ready.
It seems like it would make more sense if the setting being `false` meant that term queries were not cached. Right now just looking at the name, it seems like setting it to `true` would mean that term queries **are** cached.
Yes I think so.
can we just make it an overload of failShard with a boolean, like in the engine? . I don't know what soft means :) Also if we do that, let's change failShard(string reason, throwable e) to just call failShard(reason, true, e) ...
I don't see the benefit to making the `MonitoringService` mutable in this way. Disabling the scheduler in the same way that `setElasticsearchCollectionEnabled` seems like it's enough and then the `Collectors` can be immutable and never shuffled around. I would change `scheduleExecution` and `doRun` to ```diff + /** + * Determine if the Monitoring Service should schedule the collection of Elasticsearch stats. + */ + public boolean shouldScheduleExecution() { + return isElasticsearchCollectionEnabled() && isMonitoringActive(); + } void scheduleExecution() { if (scheduler != null) { cancelExecution(); } + if (shouldScheduleExecution()) { - if (isMonitoringActive()) { scheduler = threadPool.scheduleWithFixedDelay(monitor, interval, threadPoolName()); } } // ... // ... @Override public void doRun() { + if (shouldScheduleExecution() == false) { - if (isMonitoringActive() == false) { // ... + if (shouldScheduleExecution()) { - if (isMonitoringActive()) { exporters.export(results, ActionListener.wrap(r -> semaphore.release(), this::onFailure)); } else { semaphore.release(); } ``` and then drop all of the other changes from this PR not related to setting / getting `elasticsearchCollectionEnabled`. This also keeps the collectors a little simpler by allowing them to run even if this is set (as it currently behaves).
can we pass empty string and empty bytes ref to this so it's a valid ctor? we should fail if these args are null
happens in other tests too.
there is a `request.hasParam()` shortcut...
> why would the user not be able to correct these exceptions? Because I'm specifically referring to exceptions being thrown because of bugs in the compilation explicitly not due to the user's template.
nit: space after if
Here's Python: ``` >>> ', '.join('(byte) 0x%x' % x for x in cbor.dumps({'foo': 5})) '(byte) 0xa1, (byte) 0x63, (byte) 0x66, (byte) 0x6f, (byte) 0x6f, (byte) 0x5' ```
I wonder if we should use an ArrayList with initial capacity. We can then change the request etc to use List<> instead of array
I would prefer this instead: ``` java if (currentIndexMetaData != null && currentIndexMetaData.isSameUUID(indexMetaData.uuid()) && currentIndexMetaData.version() == indexMetaData.version()) { metaDataBuilder.put(currentIndexMetaData, false); else { metaDataBuilder.put(indexMetaData, false); } ``` Less code blocks at the price if a longer condition, but this is just my personal style.
I think that it's worth logging the index metadata version here too (and the mapping metadata version in the future).
would use currenTimeInMillis here as well, also, shouldn't the order be reversed? (currentTime - startOf)
Take care, the warning headers are de-duplicated below. The accounting should happen after de-duplication, otherwise we truncate when a warning header would not have been added because it is a duplicate of an existing warning header.
There should be an `else` clause to set `shardId` to `null` if the stream indicates there is no `ShardId` in the stream.
If the search request is impacted too I'd rather have it in a different PR
I would say that we should have `-v` as verbose as it stands now and just support `--version` for the version parameter and not have a short form for it (if thats possible). If not, I think this is a good solution. `-v` is fairly universal as a flag for verbose.
that's just a suggestion, I tend to do thsi this way: ```Java Runnable toRelease = () -> {}; //... semaphore.acquire(); toRelease = semaphore:release ``` that way you don't need to check any boolean logic and can just call the runnable
General thought for these various `Double.NaN`'s .. should we be returning `null` instead (and subsequently returning a `Double` instead of `double`)? E.g. because some fields may actually have `NaN`'s as real values, and lacking a field isn't quite the same as not-a-number? Not sure, probably needs several more opinions :)
Nit: `seqnum` -> `seq_no`
I see ok that sounds good to me then
I think we'd do better logging the first 10 levels or something. It'd be fairly painful not to have any stack trace.
typo: dictionnaries -> dictionaries
nit: can we move this next to the other predicate? I think it's good to have them together.
I didn't know you could mutate it!
can you add an assertion on the origin here? i.e. PEER_RECOVERY or REPLICA
Can we test more than one version at a time ? At least one of v2 and one of v5.
In some previous discussion for other builders we tried to set default values for non primitive types that have a default, setting to null effectively means use the default, same as specifying `field: null` in the json query. Maybe we can keep this here (and in the following setters that have default values)
if we change this to never be null, I think we can share the logic here and make it simpler. Something like: 1) Add everything we get to the buffer 2) coordinatewrites (always) 3) If max retrieved seq!= requiredMaxSeq, send another request 4) else if ops.length == 0 schedule a future coordinate read 5) else if coordinate read now.
how about introducing a writeable object that holds the lookup info? then to determine if it's a lookup or not would be checking if that object is null or not. we could have a new setter for that new object, and also keep the existing setters that create a new instance if null (for bw comp).
imho, we should just always persist the newRouting. The oldShardStateMetadata just complicates things and as far as I can tell doesn't add much value - we call this function very rarely.
doesn't matter that much, I thought -1 didn't make sense :)
you can delete this test. It doesn't do anything meaningful.
Drop the string constant. :)
Hmm I don't like that we do not get the metadata from the pki realm when we use a delegating realm and we do not even attempt to map roles. There may be cases where a PKI cert doesn't map to an AD/LDAP user but role mapping is desired, so we now need two realms.
name is `getPerNodeTasks`
The theoretical idea here is to try to move away from overriding methods like crazy at the transport level. So if refactorings need to happen, we can (hopefully) just move the stubs to different locations, opposed to dealing with a billion different tightly couple to the `Transport` interface tests.
Note that in case of peer recovery with a retry, we could end up with a higher gcp in the globalcheckpointtracker than what we're setting here.
I would reword this to "script_score returned NaN"
ok @jpountz then we will also have to set it to the final lucene query, cause at the moment we I think don't do anything with what we parse or allow to set... this whole parse business is misleading unless we do something with it. Having setters is a different story as they are in the base class, which we did to avoid handling boost and _name separately on each query.
Can all the classes here be in the same package too? I don't really see why these handful of classes need a package hierarchy.
It does seem a bit cleaner to use a list. For what its worth my highlighter would just `return true` from canHighlight because its defaults let it pick its hit detection strategy based on what is in the mapping.
Nit: `"call back"` -> `"callback"`
It looks like with the latest changes serializedStates can no longer be null, so we should probably remove `Nullable` here.
`of the it's last` -> `of its last`
yea I think so too
btw the build fails because of the removal of String.EMPTY_ARRAY its import is now unused.
yes, we can improve this in a follow up issue. I do think we should change metadata to be a map of maps and then get the entire exception into it (including all cause exceptions).
this makes the executable script not that simple anymore ;)
> Also getting the raw byte[] which is what gets used, requires extra steps (BytesReference -> BytesRef -> copy BytesRef's byte buffer) Good point
I think we should return `null` if the key is not an instance of `String` rather than converting it
I think that we can unconditionally assign indexBoosts.
I see, thanks for the explanation!
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
No tests will ever be executed concurrently. Removing the thread context is enough, I suspect that this is how we will test deprecation warnings once we remove strict parsing, which we currently use only for testing.
Fine by me.
I think `value.length() == 0` here should be `String.hasText(value)`, so it checks for `" "` and uses the default value for it.
That is much easier to read!
extra space between 'for' and 'index'. Also, we typically log the index name first under []: `[{}] failed to ack index store deleted' . If I read things correctly, this also logged when something went wrong in innerNodeIndexDeleted so maybe change to "fail to ack index & store deletion"
space before curly bracket
this test is about timeouts, right? feels unnatural to throw a normal exception here. You can also rename to the test to say "handle exceptions" and check all exception are handled correctly (timeout or thrown) - imho a deidcate non-timed out error is better (i.e., it tests it returns immediately and not after a short timeout).
Exactly, or in that particular case, from their child since constant-score queries can only have one child.
These might be better if they just fail rather than go to the DepercationLogger. This is fine though.
can we call this initializePrimaryTerms ? I find allocate confusing here
This reads a bit funny: "If any .. are not found"...
`s/Class<C>/Class<? extends C>/`
I also wonder if we should move this part in a different method such that this method doesn't get too big to be inlined if needed but I guess it's not hot enough anyhow.
makes sense - treat whatever I wrote as a draft that can be adjusted as more metrics are added
same question here if Strings.toString(XContentBuilder, true) could be used, and also for https://github.com/elastic/elasticsearch/pull/20011/files#diff-4dad2c5391932f86a402ee44b5160218R57
This one also has the same problem with java 8.
I suspect you can build the arraylist here with the expected size being the count.
cool then we can take those out so it is clearer what we have and don't have to do :)
What about using a ConstructingObjectParser? You get the arguments and then can just return an ExpressionRoleMapping instead of the builder.
right, I see. It is just that the caller will never see this exception, the node processing this exception just won't ack the cluster state update. Also the if there is an issue during pipeline creation the failure is likely to be caused in the put() method as we construct the pipeline to see if something is wrong before submitting a cluster state update. The only time I think we end up throwing an exception here if when an ingest plugin isn't installed on all nodes. Some nodes will fail the processor factory for a specific type. If this would happen then it isn't a good situation to be in, so we should think about how to best tackle this problem and I think we should open an issue for this.
yeah, I'm on the fence my self. It's just one (cached) thread we spawn per cluster task (which then executes all of the call backs). Not sure wether you saw this in the profiling as a potential time consumer when it was doing it before. I don't feel too strong about it though.
maybe replace `shardRouting.isRelocationTarget() == false` by `shardRouting.relocating()` (simpler)
nice, effectively this change will be backwards compatible for users using this method. Not for users calling the public Builder constructor, but I think that is a good reason to make them switch to this static method.
super pedantic but the second param should be deleteRoot_s_
not sure whether we should call them `concreteIndices` here. Seems to me that we usually call them `indices` and they are implicitly concrete in the responses...
Oh thats cool then. Icky but cool.
yeah I think this one is ok!
Maybe ``` Builds a "pyramid" out of all clauses by combining them pairwise. So {@code combine(List(a, b, c, d, e), AND)` becomes <pre><code> AND |---/ \---| AND AND / \ / \ e AND b c / \ a b </pre></code> ``` The picture would make me feel better.
maybe add `directory` or `dir` at the end of the string
ok lets go with null then
same here re iterator.remove()
I think this should be moved to QueryCreationContext and exposed here through it temporarily
I see, ok!
> I would also be fine with removing all the camelCase options for all formats in this PR to make it consistent. This is the kind of statement that stalls progress. Requiring huge changes just to make a small improvement should not be necessary.
good, can you set that flag and test that it does the job? We could work as a followup on making this behaviour configurable. What happens with fields that we expect but are not found (Imagining using a client in 5.4 and e.g. es in 5.1 that may have less fields in its response).
One too many `*`s here I think.
can we rename internalShardId to resolvedShardId ? also add some java docs on how it should be used. I think that , as a separate change we can move the index field to another class DocReplicationRequest that is a subclass of this and a parent of IndexRequest and friends. It will be cleaner. No need to do it now.
Not sure which junit version we are on. Came across the ExpectedException rule here https://github.com/junit-team/junit/wiki/Exception-testing recently. Just mentioning, no need to change this code right now as the above is the pattern we use all over the place.
OK. I wonder if it's needed as they can be assigned everywhere. But this is definitely a different change (if at all)
strike that, it looks good, confused by the changes view on github...
I don't know that we care about closing the handler. It probably does not matter too much, but there should not be any resources hanging around if we properly consume all the requests.
I think this is a mistake here you didn't want to pull in some guice class here right? `+import org.elasticsearch.common.inject.Provider;` Can't we just make the privder be a string instead? and if necessary it should be a `Supplier`
I see. I missed it. I think it's surprising to put it in `readDocAsOp` and shortcut. I'd prefer to do it in `next` where do all our state updates and then everything together. it's rare anyway and doesn't require optimization imo. That said, it's all nits. If you prefer it otherwise I'm good. Thanks for clarifying.
I was just wondering if there could be bad side-effects such as causing some operations to take longer.
I'm a bit concerned that we have different code paths depending on the value of `offset` since this means that changing the code for `BigArrays.hashCode` might break this hashCode implementation.
It'd be useful to describe the how here I think. I guess this works like a bucket of water slowly filling up. You get to compile a script if there is enough water in the bucket, otherwise you don't. If the bucket overflows then you don't get more water.
Looking what this does, an interruption is ignored and will only used to cause an extra TTL check or shutdown. I think doing nothing is the right move here.
Can this be a `IndexingOperationListener... listeners` that way we don't introduce a hard dependency on IMC
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
This way the fields will not be checked when type is "multi_fields": ``` PUT testidx { "mappings": { "doc": { "properties": { "title": { "type": "multi_field", "fields": { "lala": { "type": "string", "foo": "bar" } } } } } } } ```
I believe we can get away without doing anything for BWC for the buckets because they are not being transferred between nodes. But I would like @droberts195 to confirm as well.
makes sense, lets leave list for now
I don't think we should force `https` if a password is used. It's unfortunate but someone might want to use auth without encryption
java docs on obtainLock please.
You'll also need to change this in [the associated test](https://github.com/elastic/elasticsearch/blob/216c761a5dd81e65ca9826fb0793ddc53cd2ff27/client/rest-high-level/src/test/java/org/elasticsearch/client/IndexLifecycleRequestConvertersTests.java#L102). CI should catch this, but in the interest of not waiting 3 hours to find out...
I'm good with that, and a strict YAML parser doesn't barf with this syntax, which is a bonus :)
Why not create one temp dir, and then a subdir off of that? There is nothing that guarantees tempdirs are all created side by side.
Nit: I think we need to renamed the method + docs - it now also rejects mandatory and invalid settings.
This should be done in reset()
Let's change the conditional so we can avoid the negative: ```java if (readers.isEmpty()) { return current.getGeneration() } else { return readers.get(0).getGeneration(); } ```
I think we are missing includeHidden here
To be coherent with the `preVisitDirectory()` method I think we should use the `FileSystemUtils.move()` method instead of Files.move() that doesn't support moving non-empty directories between different filesystems.
Please revert this change.
Nice, I like it.
can we open an issue for this so we don't forget and link it here? I know that we will remember to get back to these queries but I also want to remember to re-enable this test ;) also the norelease look weird within the bugUrl, I would take it out
the deleted flag is only set when an index is deleted. The PR description says we don't want to flush upon relocation. I'm a bit on the fence w.r.t flush on relocation. On one hand it would be good to leave things consistent. On the other hand it may delay things needlessly (this runs on the cluster state thread). In anyway we should change the description of the PR we keep this way..
we throw `IndexMissingException` all the time when `allowNoIndices` is set to true. I don't think we should act differently here.
Nit: `automattic` -> `automatic`
I'd move the extractions all to the top.
do we need a dedicated test for this? can't we randomize the number of nodes in the normal deletion tests? O.w. we will need to test this situation with both closed indices and open. It's a shame IMO
can we make this a `if (!closed) {}`
I think this should be a trace log with "[{}] trying to delete store (reason: [{}})" (note the index name as well) and log the info after successful deletion. We already log a debug message (or higher) in all callers of this method and it will not result in an info message saying "deleting" when we actually failed. ``` logger.trace("{} trying to deleting store (reason [{}]}", index, reason); nodeEnv.deleteIndexDirectorySafe(index, 0, indexSettings); logger.info("{} store deleted (reason [{}]}", index, reason); } catch (LockObtainFailedException ex) { logger.debug("{} failed to delete index store - at least one shards is still locked", ex, index); ```
we plan to use this for background operations like the global check point sync, where it's not a big deal if this happen. I don't want the logs to have warning in them. Instead, implementations (i.e., TransportWriteAction) of `failShardIfNeeded` can log a warning if they are going to fail the shard
Its cool. I don't think it is required for the PR. It would cut 50 lines or so - you implement NativeScriptFactory instead of ScriptEngineService and you implement AbstractSearchScript instead of LeafSearchLookup - just less code I guess.
Ah sorry, I could not see all the setters in the review without expanding.
Background tasks run in background periodically, but they shouldn't run for very long time. I guess what I am trying to say is if for some reason a fault detection ping or a stats operation started by a ClusterInfoService runs for 5 minutes it's probably also a leaks, even though it doesn't have corresponding REST request that started it.
getLastComputedDelayInNanos -> getLastComputedLeftDelayNanos
There is a superclass ReplicationRequest where we should put these methods (as they apply to all the replication requests).
Where have you seen this convention? I use uppercase almost always, and that is mostly what I have seen...
Another reason why I think we should remove the Void context argument if we can, passing this null value is confusing
I think we should keep this second test though and use ParseFieldMatcher.EMPTY, then test that it indeed breaks with the STRICT one.
we probably want to rest here as well: `registeredNextDelaySetting = Long.MAX_VALUE;`
can we add some assertion here that ensures we copied everything? I think we should have a method that does the clone that we can use to assert that we didn't loose anything something like this: ``` Java assert serialize(this.shallowCopy(queryBuilder, postQueryBuilder)).equals(serialize(this)); ```
Personally I think we should return `RestStatus.PARTIAL_CONTENT` (206) in the event that requested aliases were requested and *some* were found while some were not, but it sounds like this ship has already sailed as far as what to return.
I think we can skip the unwrapCorruption and always use the IOException which captures the reason as well.
You can push a fix for this oversight directly, dismiss my disapproving review, and merge. ð
I think we want this test to be more evil. Right now itâs inserting the sequence numbers into the translog in order. This is divorced from reality; letâs shuffle the sequence numbers. This means youâll have to change the assertions that you make below.
you can use the util method printBoostAndQueryName here now (once you rebased)
This logic should be optimizer (changing the tree) instead of the parser which should be pretty accurate to the actual query (helps with reporting errors). Further more it would make this apply if one of the expressions becomes `NULL` in folding and such.
The matrixStats PR is here - https://github.com/elastic/elasticsearch/pull/18300 - with code from @nknize et al.
yes that is true for primaries not necessarily for replicas. The replicas might not be a light recovery
Maybe `files_total`? We already break things, so...
can the methods like getFileStore() be package private? I don't see anything outside of this file using them.
Note that we also use this pattern for shard responses which are in the same situation.
this one sounds familiar :)
I am sorry but this name is completely off :) I don't get what it means :) Can we find a really good name here? here are some suggestions: - `updateRequired` - `canHaveDuplicates` - `requiresUpdate` - `resolveDuplicates`
100kb also seems arbitrary, I know it was here before maybe @costin knows
can this just take a string? no need to pass the service here
I think this should be `Object[] propertiesCounts = (Object[]) histo.getProperty("sum.value");` else the tests don't pass.
I don't think `4xx -> 400` and `5xx -> 500` is good enough. Sure we are against building new exceptions but then we are ok with losing info about errors here? I personally think we should make this work properly, not sure what others think.
As @s1monw would say, "you have 140 characters, use them". ð
no worries I was just curious.
Its true but its kind of confusing to understand i think, its like an unnecessary optimization where I think clarity is more important. but really its not a big deal to me, I hope ultimately these go away anyway.
I think that would be better. IMO new code shouldn't be bogged down with backcompat behavior. It would only send the wrong message (eg seeing a deprecation warning when using norms.enabled on a text field, when it should be an error so the user looks at docs and sees "ah, it's just norms now").
nit: formatting, add some whitespaces
I'd move the writeTo implementation under this constructor so that they can be on the same page. It helps so much with eyeballing them for errors!
I have seen this comparison in several places. Maybe, it makes sense to move inside Snapshot and have something like `boolean hasName(String repository, String name)` method where it will take place? Not sure if `hasName` is a good name for this method though.
s/even make/eventually make,
is this correct? don't we want the maxrequired to be global checkpoint (i.e., from - 1 )? now it seem you have to bring at least on seq# back.
And again, looking at the code, they _do_ use the field name in equality, but for the query, you can't have multiple _different_ queries even with the same name (which is why the hashset doesn't work), I'll stop confusing myself now.
You can use a for-each syntax here: `for (ObjectCursor<byte[]> cursor : bytesList)`
now that we use a semaphore, we don't need to put it back - we can remove the synchronised as well
nit: read lock -> just lock.
A++ new constructor code
> still think it's safer/better to remove this feature and fail if more than one config file is found. It reduces the complexity for reasoning where a setting came from. +1
Why the prefix `[types removal]`? I dont' think we have any prefixes like that in other deprecation messages.
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
same question as above re no active allocation ids.
can we check that intValue is non-negative? (we use it in vint)
please make either this class or `resetFromString` final otherwise this might have odd side-effects if somebody subclasses this.
does it make sense to use the `GeoUtils` constants here? might help people to understand why they are here
`S3SignerType should not be available for Frankfurt region`
> On the other side if the rejections occur because somebody misconfigured the generic thread pool or something like this the shutdown message will be very confusing. Fair enough re not saying shutdown. Note that @jasontedor is working on making it impossible to configure the generic pool in a way that violates what we expect of it - never reject unless we're shutting down. > trace level though. I think this will cause unneeded noise because when we stop the transport the node is shutting down and any outbound concurrent request may hit this..
ensure green has the nice reporting if we fail to get to green. Can we have an equivalent utility method that takes a create index response and check for shard acked, and log things? maybe a variant of `assertAcked`
I'm fine with removing it - it's useless . I'm ok with just checking it further after the PR is done.
It is in.
We prefer using `== false` instead of `!` as it the first is more obvious when scanning code.
This should be `default` now.
Okay, that's probably not a bad test to have; I think it'd be better to make `BootstrapCheck#checks(Settings)` package visible (and final) and check that `checks(Settings.EMPTY)` contains an instance of `MinMasterNodesCheck` (it's a more direct test of what you're trying to test).
I know Simon preferes if (Strings.isEmpty(field) == false) , shall we change it then? ;)
`.get()` is more idiomatic now.
should we say something about upgrades in the message? I suspect people with "uninstall" in their head will have a WTF moment. Probably good to say "delete manually if not needed".
this is a different issue, but while we change this line, I think we should also set the `previousTypes` variable :)
nit: doesn't really matter but mostly I see this as // TODO. Might be better to keep it similar to be able to grep similar things or for other tooling.
Can you add the `<String, Object>` (@nik9000 style) or `<?, ?>` (@jpountz style) to the map? Again, I don't know if you should have a default here.
ok, we can always port it back later on.
You don't even really need to say "a TimeValue" here because its in the return type. Its only important when its a long because you don't know if its millis or nanos.
Note: I was wrongly assuming that DocIdSet.EMPTY returns a null iterator, which is not the case.
lets just use IOException that's much better for this purpose and it's checked
you can use the `randomFrom` method
fyi I think you can IOUtils.closeWhileHandlingException(files) since its Iterable...
ok fair enough!
maybe we can avoid exposing the Client and instead expose only one new method with the needed functionality in INdexQueryParseService and simply proxy it in the context? That would prevent us from spreading around the big client dependency
FYI - for future work - they should be mergeable (i.e. leader into follower) not necessarily identical.
since we use this for logging now - I think we should change the node Id to DiscoveryNode - ids are hard to trace.
++ on adding this.
grrr...you are right @bleskes sorry for the confusion. It would be a breaking change for the java API. I don't like it when internal requests get exposed as they are to the outside world :)
+1 to do that and then fix `BigArrays.hashCode` to accept offsets in a separate change.
I think it'd be clearer if s/throw/check/.
I know it was already the case, but can we make this allocationFound parmater actually count the number of allocation found (i.e. all shards with an allocation id, matching or not) Later we can refactor this maybe and remove it completely but for now let's keep it consistent.
can we replace these test with a simpler to understand test, paying the price of things being less targeted? experience have shown that this type of tests are very hard to maintain and often don't reproduce exactly what was intended anyway (because it's so hard)..
do we have a todo to extend this to the new setup (in a follow up)? There's much more that should go here.
I think that we need a different mechanism here. Either we need to invent the notion of a private setting, or as I prefer, these should be considered custom index metadata. While we have partially deprecated and neutered custom index metadata, I think that we should bring it back. We also have a similar need in index lifecycle management. As @colings86, @talevy, and me are all out next week, I will pick up a thread when I return from vacation to resuscitate custom index metadata and then we can use it here and in index lifecycle management.
This was not a typo
This will need updating once the setting is moved.
I'd move this to the end of InternalIndexShard constructor. This would help keep the calls next to the places where the state variable is actually change.
can you update the `shouldAutoCreate` method so that it getl a local reference to the AutoCreate object as a first step and then uses this reference for checks? The motivation is to make sure all checks are done against the same instance in case there are concurrent updates of the auto_create setting
I see!, in that case, I would stay with what you suggested in the first part, and just rely on the first byte, it will work well in our context.
The name of the method seems to explain where it's expected to be called from. I wonder if that is necessary.
Not sure this should be "Query" ð
Randomness is awesome when it's needed, but also adds complexity. Also, we need to let the OS free the old ports before reusing them. I think having some gaps is good? I'm hoping a cycle of 9 is good enough, but we'll see...
Can you please put these constants into something like `GeoUtils` so `DataTypes`? I went with a similar approach in #30418 for readability and maintenance.
If you pass the plugins in instead of `emptyList()` then I think `SearchModule` will do this stuff for you.
I am okay with you pushing this directly.
I know it was like that before, but we are here now. ð
I mentioned the NamedWritable#getWriteableName() above, I think "term" here should be a constant that identifies the type of SuggestionBuilder this is. Then we don't need it as an argument in the super constructor anymore.
IMO we should allow the interface to throw IOException that just makes sense here
minor nit: s/currently in a/in/
is it fixing another issue? If yes, I think we should have a separate PR
Is this method not deprecated? I think it should be `XContentParser parser = XContentFactory.xContent(XContentType.JSON) .createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream))`
Even it we remove that logic, it would be good though to keep the explanation that we don't use an automaton for the term list case in order not to blow up the maximum number of states.
wouldn't it be better if the exception uses `synonym_query_style` instead of `synQueryStyle`. It would be more clear, I think.
very minor and I know this wasn't your code anyway but we could move writing the size out of the if block since it's the same on both branches
wouldn't be better to output `null` instead of a string? will be easier to handle on the client side
That seems redundant since we only call this from snapshot initialization.
OK :) thanks for checking.
I'd consider this optimization optional for now.
I don't think these should be `IOException`.
I have just pushed the class ScriptParameterParser to master and 1.x which standardises parameter parsing for all scripts across the codebase. It would be good to use that for parsing the script parameters here too. It accepts four parameters: - lang - for specifying the script language - script - for inline scripts - script_file - for file scripts - script_id - for indexed scripts
This probably isn't required - other highlighters can just be called out in the request if you want them.
I think this one is fairly lite - typically there only a few and very specific rules
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
Any interest in implementing `Accountable`? Accounting for caches is a thing we like.
can we just do it even for `size == 0`
Some of these checks can potentially be removed after changing internal field to primitve types / using defaults.
Same thing, I don't think this variable is necessary.
that that :)
I think it's a simple enough change to make as part of this PR.
Yes sorry you are right, I didn't see that the params variable was a parameter passed in and therefore need to be updated and was just thinking about the params map in the node that would be returned.
we should probably expose snapshot directly as I see that usage points create a new Snapshot(..) again based on the data here...
minor formatting issue
ok. Considering `Setting` as a simple value class, it should probably have no logger at all (but that's a whole different story).
also use the constant here
secure iff not reproducible (sentence is a bit mixed up)
@dimitris-athanasiou may have a different opinion around this ^, So I will defer to him.
The recovery state reporting is not clean now, as we start the engine and replay translog under `TRANSLOG`. I wonder if it's worth while capturing the START phase at all (i.e. how it takes to open the lucene index). Maybe we should just rename that phase to CHECK_INDEX and only apply it if it's needed ? (i.e., `checkIndexOnStartup == true`)
Instead of using an expected exception here, can you use a try/catch in the test and verify the exception messaging? Not exact messaging, just something verifying this is indeed working (since the error before your change was already throwing a SearchPhaseExecutionException).
Should be annotated with `@Nullable`
shall we stop it first? we might get false positive as the node threads move an acquire shared resource and trigger the block detection.
I think you can answer for yourself at least for this one: would you be comfortable with 2.0 released with still this bug in it? Mayeb this fix should even be backported to 1.x, it's a bug and should be treated as such
QueryBuilders should always set the defaults since they can be constructed without ever passing through the parser (Java API)
Or maybe you meant to add the simulate check here? Otherwise this members would be modified when simulating (simulation is like the "validation" pass in mappings merging)
can we please keep the ordering as its and maybe add it at the end. I don't think we should change the byte value its' just a code. We can also use a negative value btw.
Typo here, "pathf" instead of "path"
I don't think this catch logic is needed here? We can just let any exception bubble up here, because this logic is executed when each node receives a new cluster state and is processing the pipeline config.
no, the catch there should be removed as well....that is what my IDE tells me :)
I don't think the test name needs the issue number. The rest of the name explains what the test is checking.
indeed it is not happy about it
I'm just used to `ClassCastException`s in tests being test failures. The cast is implicitly part of the test. I'm fine with keeping the explicit assertion but I'd prefer the other style so you get nicer error messages.
can we make the units clear in the name? (it's also not used now) getDeleteTimeInMillis (we typically use time)
gotcha, I didn't realize that we were creating a new query not going through the mapper, which accepts a Term. This is correct as-is, sorry.
But `value` is coming from the system property and `setting` is come the settings object? He's ensuring that he takes it from one of the two, but not both.
I'd just annotate it with `@Nullable`
I don't think you have to add here `TermsLookupQueryBuilder.NAME` to the array
not if we test less. Right now we try to test more but most of the test is not meaningful, cause we call the same methods in both sides.
I think it's ok to leave those settings unchecked for now.
> the code in ObjectParser looks scary at first glance! That's no good. Can you please keep notes as to what made you feel that way? it should be the go to place of "no problem, I can parse json settings in a breeze and with confidence"
I think it should be `greaterThanOrEqualTo(0)`... According to https://docs.oracle.com/javase/8/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getTotalPhysicalMemorySize-- both `getTotalPhysicalMemorySize` and `getFreePhysicalMemorySize` should return a value.
alread -> already
Can you remove the extra block? I don't think it buys anything.
I don't think this boolean does what you want? if start commit is null it will always pass.
when we have `field: null` containsKey will return true, but the method will return null as remove returns null, which was the actual value. I think that null shouldn't be returned and we should throw an exception instead, like we do in other methods. Just call remove and check the returned value, without containsKey.
yeah, it might trip every once in a while (if we do a good job testing), but I'm OK with leaving it as is for now..
Thanks for this and sorry for the delayed response. Holidays kicked in :-) Happy new year! Elasticsearch is handling `null` in ordinary search/sort by putting those values at the end (or the beginning when the order is descending). It also lets the user change that behaviour via the `missing` parameter. Having said that, I would argue it is overkill to support this in the context of the `bucket_sort` aggregation. Looking more into the code, it actually looks like `ComparableBucket` could never really get any `null` values. There are 3 scenarios: - the sort field is `_key`; keys will be non-null I believe - `gap_policy` is `skip`; the bucket won't exist at all - `gap_policy` is `insert_zeros`; the value of the bucket will be `0.0` and will be sorted accordingly. So, it most probably is dead code.
++ thanks a lot
style-wise we generally strive to make the scope of if/else blocks explicit (brackets)
This is the actual cause of the issue. +1
rename to `getQueryCreationContext()`
while you are at it can you remove the randomization on script engine service given that we have only one now? seems like this test is a bit outdated after recent changes.
This has the same issue where multiple threads could wind up âfinishingâ this since done is not rechecked within the synchronized block.
I actually don't think we should persist this one. Putting a template in place with `is_write_index: true` will be confusing because only a single index can be marked as the write index. I think we should instead throw an exception if `alias.writeIndex()` is set to `true` here (fail early rather than fail late)
Nit: Can we rename `shardReference` to `ignored`? I don't know about Eclipse, but this will at least prevent IntelliJ from issuing unused variable warnings.
++ on this. The ReroutePhase owns retrying across the board.
Oh, wait, I just got it! Neat.
I double checked and this has changed with this PR, we used to return 404 before.
what about `"Source is too big, max length [2048b] but was [XXX]"`
I don't think this should be here as future scheduling is a special case of a read response that comes back empty. I thinks this method should always send at least one request (even if locally we think there is nothing to do). The flow goes: 1) If we can, always fetch something or at least send a peek request (as you call it though there isn't anything special about it) 2) When a request comes back empty we don't call this method immediately but rather schedule a future call.
hehe :) nice one
I know this is existing, but I think we can lift this up to a singleton so that we do not create a new instance on every publish to every node.
But that day can wait.
I think the exception should still be QueryParsingException here
also here add the op type in the message
missing Test annotation, just for consistency with other test methods
here you can use a `scaledRandomIntBetween` something like ``` Java int length = randomIntBetween(1, scaledRandomIntBetween(PAGE_SIZE * 2, PAGE_SIZE * 20)); ``` this will use the upper bound rather than the lower bound when we run with nightly=true.
That's a good point @tbrooks8, we should not do this.
I don't like this - can we just name is `hasJoinedCluster()`
watch out with the back port! needs to be wire compatible with 2.0 ..
Same question as for the adjacency matrix one.
Is this clearer? ```diff diff --git a/core/src/main/java/org/elasticsearch/node/AdaptiveSelectionStats.java b/core/src/main/java/org/elasticsearch/node/AdaptiveSelectionStats.java index bed282b899..787fa1e9d1 100644 --- a/core/src/main/java/org/elasticsearch/node/AdaptiveSelectionStats.java +++ b/core/src/main/java/org/elasticsearch/node/AdaptiveSelectionStats.java @@ -33,6 +33,7 @@ import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; +import java.util.stream.Collectors; /** * Class representing statistics about adaptive replica selection. This includes @@ -102,10 +103,12 @@ public class AdaptiveSelectionStats implements Writeable, ToXContentFragment { * Returns a map of node id to the ranking of the nodes based on the adaptive replica formula */ public Map<String, Double> getRanks() { - Map<String, Double> ranks = new HashMap<>(nodeComputedStats.size()); - nodeComputedStats.forEach((k, v) -> { - ranks.put(k, v.rank(clientOutgoingConnections.getOrDefault(k, 0L))); - }); - return ranks; + return + nodeComputedStats + .entrySet() + .stream() + .collect(Collectors.toMap( + Map.Entry::getKey, + e -> e.getValue().rank(clientOutgoingConnections.getOrDefault(e.getKey(), 0L)))); } } ```
Yes, I meant that we should add this method which does not exist. It could be done in another PR.
Right. I mean the timeout waiting for the cluster to form on the test execution side. I think by pulling out all the waiting we do for the port, and that "started" message you're returning faster to the client (the actual backwards compatibility test process). Which is fine, but that means it'll have to wait longer for the node to join the cluster.
why did this become public? Did you remove the support package in the test directory structure
we decided to live on the edge and have fun. The concern was around non ascii codes breaking tooling but CI seems happy. Let's see how far we get.
I find it really confusing to have `footerChecksum` at the top-level that is a byte array and `footerChecksum` here that is a string, with only `this.` to indicate which one is being used.
same thing in the second arg check above
I'd replace this with `get()`.
If you change the previous method, you can make this return `void` because it doesn't need to return the string
I think in the next iteration I am going to move this into `AbstractGeometryIndexer` and make it obtainable from `QueryShardContext`.
I think we should explicitly set this to `false` so if Jackson's defaults ever change, we won't be bitten by it.
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
I believe you could replace this function body with: ``` java for (String iOrT : array) { checkIndexOrType(name, iOrT); } path.append(Strings.arrayToCommaDelimitedString(array)).append("/"); ``` Which also then doesn't leave the `path` stringbuilder in a bad state when an exception is thrown
Correct, we have removed support for parent in master. I will have to remember this when backporting to 6.x where we still support parent.
Can we deprecate and remove this one too? I don't think we should have global settings like this.
makes sense to me as well now, sorry for the noise.
Okay, I think I understand why it is this way. What I am concerned about is the different ways that a `TermQuery` is constructed here, there's: ``` java new TermQuery(actualField, actualValue) (new TermQuery()).fromXContent(context) (new TermQuery()).parse(context) // <-- weird that this is not static ``` What I think would be better is maybe static methods that generate new versions for all except the plain construction version: ``` java new TermQuery(actualField, actualValue) TermQuery.fromXContent(context) // <-- static, returns new TermQuery TermQuery.parse(context) // <-- static, returns new TermQuery ``` I dunno, maybe it's a gut feeling :), but the current implementation feels very "loose" and _too_ flexible in what the "correct" way to create a new TermQuery, making the methods static instead of mutating the current object feels more functional (in both senses of the word!) to me. I _personally_ would rather have `TermQuery()` constructor be private, but I guess that's an entirely different discussion about builders versus non-builders...
> disruption tests do not use mock discovery They don't use it because of the MockZenPings - if we make that an optional feature of MockZenDiscovery (via a setting or whatever), the disruption tests could use MockZenDiscovery, turning mock zen pings off.
I think the it's also important to explain here is why we don't allow writes on RELOCATED
I didn't mean that the static parser name will go away, I only mean the parserName method in the builders... sorry for the confusion
I think we should place it after the other _meta fields - it's less important and shouldn't be first.
I think that this change that introduces boxing should be reverted. This means that we need a value to represent unset, and -1 is the idiom within Elasticsearch for that.
Can we compare messages from a normal ElasticsearchException with and without cause, with ones obtained from a parsed one? I wonder specifically if the `Elasticsearch exception [` prefix is needed etc.
It's unusual to override the base class `@Before` method and then call the base class version first. JUnit will by default call all the base class `@Before` methods before the derived class `@Before` methods, so it would be more usual to just give the derived class `@Before` method a different name and let JUnit call the two methods in the standard order, avoiding the need to call `super.setUp()` here.
Probably makes more sense given where we are going. Sorry for making more work for you!
we usually call the getter also `terminateAfter`
I think that rather than copying this code from FixedExecutorBuilder, this logic should be pushed up to a package-private static method in the super class.
you could just use a `EsExecutors.newDirectExecutorService()`
wonder if this is the best way to get a client, can't come up with better ones though at the moment....
one assert per member is better then you see what's not null :0
Hmm if info is null (`fieldName` is unknown) should we throw an exception here? `DocValues.getSortedNumeric` will just return an empty doc values.
can we add some out of order insertions here? just to be a little more evil
I'm sorry for flip-flopping on this, but thinking about this again (with the new model we introduced), I think it's simpler to call this just shardId , which must be set either at construction time (for things like refresh/bulk/flush actions) or when the request is resolved. Feels unnatural to call this resolvedShardId when it can be part of the constructor.
wish a boolean could just be `true` of `false` :) but we have this logic somewhere else in `Booleans#parseBoolean(...)`
This isn't needed client-side.
I suggested a slightly different split in https://github.com/elastic/elasticsearch/pull/33013#discussion_r211957615
Hmm, I don't know anything about ElasticSearch, don't even use it â I just stumbled over this pull request as a showcase of error-prone. I don't think I have the time to set up my environment to do any proper PR or to test a change like this, sorry.
Can we call these `from` and `to` and the non Diff fields `toVersion` `fromUuid` and `toUuid` ? sorry to be a pain but I think it will be clearer.
I don't think we should add new settings like this which are unsecured. This and `account` above should be secure settings.
I believe there's a difference between `null` params and an empty params. specially when it comes to parsing.. `null` basically says "used whatever default is defined in the server"... with empty, it's not possible to conclude that. +1 on keeping it null
I think we should increment the term, and log that we've done so.
This should also require that `this.matchFieldPredicate` is not already set. For now, let's limit ourselves to only supporting one of these on each parser.
redundant `public` as mentioned by the gradle checkStyle task
I wonder if this should be `Queue<Expression> work = new ArrayDeque<>(exps);` and then you do `work.addLast(combiner.apply(work.removeFirst(), work.removeFirst()));` The `for` loop and `remove` together scare me.
`If we are retrieving all the s`
readFromStream? :) not that important...
I like keeping changes like this purely mechanical though. If we should remove the setting we can remove it after I think.
This is fine as-is.
You should use `expectThrows(...)` instead of try/catch.
Was this test not useful anymore? Maybe just test the builder here.
Can you use `Strings.splitStringByCommaToArray`, it should be equivalent but that's the function used by the other action when they parse the `index` param.
Well, obviously this is not about the line of codes. It better integrates with the internal cluster + the NodeEnvironment choice's of data paths. No hard coded reference to it or the node ordinal. It creates node data where it is supposed to be, as opposed to a random place somewhere etc (I can come up with more if need be :) ) . If in the future we want to introduce any randomness (which imho is a good thing here because you want to see that bwc works under different node environments, but that's another discussion), we practically get it for free.
I think it's always a single node cluster, but I'm good to keep it like this.
I meant something like this: ``` long pause = rateLimiter.pause(1); if (pause > 0) { listerner.onPause(pause); } ```
Actually I was not thinking of always applying deleted docs but rather to leave this responsibility to consumers of this class: if they just want to apply their filter, they pass it as-is and if they want to apply deleted docs, they can just wrap it with `ApplyAcceptedDocsFilter`.
Sorry, I wasn't refering to the fieldname but to an additional validation that that not both variants specifying the terms (of termsLookup / values) are used at the same time.
This leads to resolving the snapshot name on the repository for each entry in the list, which is very wasteful (We query the list of snapshots n times and thus have n separate network requests on S3/GCE etc.). This method should be rewritten so that we query the snapshot names on the repository once and then get all the snapshotInfo elements for the entries that we requested in a subsequent step.
Should we just use `parser.isValue()` here instead? I think we do this in other places that we are coercing the value into a number
We should also have a different `valueForSearch` only for this case, so we won't need to create a Field just to get the value... .
Should it keep using `exclude` when serializing the request? Otherwise a 1.3 node couldn't talk to older nodes? Specifically, what I'm thinking about is doing: ``` java if (include != null) { builder.field("exclude", !include); } ```
Sure. Created #6090
+1 for tests, I am slightly worried that we will forget about this location parameter in some places in the future, was wondering if there's way to enforce it, so that we print out the location whenever possible.
please remove the additional `getNodes()` here :-)
Shouldn't this test still be calling getSelectedClient (which in turn calls generateOperationContext)? Otherwise the name should be updated.
it doesn't make sense to allow that, so I would just make the change here and consider it an improvement. We are more fixing a bug than breaking things I think.
can we just do it even for `size == 0`
sneaky, I missed that :)
coerce -> ignore_malformed
> I'm not sure that negative numbers actually break vint. Yeah, they don't break it, they are just more inefficient, using `writeVInt` to me is kind of an indication that you never expect a value to be negative (from the code-side), so it's nice to encapsulate what you expect for the intended values. Could always change this to `writeInt` instead
why prevent it on primary? Sure it makes not much sense but it does not hurt
I believe for chained assignment like int x; int y; x = y = 1, expression.actual needs to be set to be the storeValueType since that's what will be duped onto the stack. expression.actual is set a few lines down from here, but it's set to last.after which is no longer correct in this case.
What do you mean "inner fields"? Passing a string "foo.bar" is not the same as creating an object field foo with a property bar.
I really think this should not be part of this query class. The fact that it's only used here doesn't mean that some other components will not be able to use score functions one day, which are also pluggable. The idea is: 1) plug custom function through SearchModyle 2) if you need to lookup a function, inject the registry. This last thing I think shouldn't have a dependency on the query. Sorry for making your life hard here, I hope you see what I mean.
This can't happen, and if for some reason after the switch fielname/value are unassigned the returned query will throw exceptions at some point (validation, doXContent, toQuery), so given this is a test method I'd remove it.
I've been wanting a portfile for a few weeks now for other testing things. It'll really make BWC tests more clean to have this, I think.
I'm bad at naming things but I'd call this `fallbackFieldParser`
can we get away with passing `null` instead of `TrustSelfSignedStrategy`? I'd prefer to have the certificates we trust only stored in the truststore
can we use an iterator here instead? it would be more clear to me if we'd do that..
the constantScoreQuery wrapper is not necessary
nit: space `primaryTerm >=1` => `primaryTerm >= 1`.
There's utility method that could replace all of this in `org.elasticsearch.common.String`. I think `toString(ToXContent toXContent, boolean pretty, boolean human)` can replace all of this methods code.
I like that... we should probably move that to: ``` public interface Versioned { Version getVersion(); public static class Predicates { public static Predicate<Versioned> onOrAfter(final Version version) { return new Predicate<Versioned>() { @Override public boolean apply(Versioned versioned) { return versioned.getVersion().onOrAfter(version); } }; } ... } } ``` then have StreamOutput/Input implement `Versioned` and then: ``` public void writeTo(StreamOutput out) throws IOException { ... out. writeOptionalStreamable(streamable, onOrAfter(Version.V_1_2_0)); // static import for Versioned.Predicates } ``` clean & simple (the only downside, is that we're creating a bunch of temp objects... where we don't really need to, but there shouldn't be that many of those anyway)
I think you should fsync after writing these bytes, e.g. `out.getChannel().force(true)`, like the translog code does? Would be horribly unlucky if the user ran this tool then their box crashed and it left the translog corrupt.
not sure this suppress warnings is needed
you have a logger in the AbstractComponent, can you use that and not create a new one? It automatically makes sure to log the node name in top level component, and if its an index / shard service, log the index/shard as well
These are so common in elasticsearch its not worth mentioning.
can we add a word about the implications of using SAME? i.e. this will run on the schedule thread, of which there is only one and should only do super light weight things.
update version to beta1
ah nevermind I see you do the `hasScoreDocs` thing
I did some research and I think I get why this assertion was put in there. This assertion should check for V_6_0_0. That said, I'm not even sure we should have it and the accompanying TODO. I suggest changing the assertion to V_6_0_0 in this PR and I will work with @dakrone to clarify this in a follow up.
This method can be package-private.
maybe verify that adding a fields under an existing field works? (for example under `fizz`) and also verify that getting an object field returns the entire map? (for example fetching `fizz` should return a map with 2 entries (the existing one and the newly added) )
I have a feeling that this might cause some issues. We don't control the underlying storage, which might change on us without our knowledge. I would like to run a couple of scenarios by you when you have a chance to see if we should/can make it more robust.
Indeed we might restore persistent settings and templates. We need both.
It'd be nice to be able to change this to only take `ToXContentObject` one day....
(I'm all for it, but would just like to make sure we have a changes entry for it)
There is an open PR #17811 that will kill `DummyTransportAddress` anyway.
I know the result is the same, but we are not adding to something existing, we are creating a new object. The addition is not needed and I think it would make the code cleaner if we called the other constructor.
Since this isn't a blocker we'll cleanup these defaults in a separate 2.x issue. Opened #11682 to track.
I vaguely remember some differences around the indices options used depending on what we retrieve. Are those still 100% bw compatible when downgrading the request? I guess so since if I remember correctly the get index behaviour is already bw compatible but wanted to double check ;)
Oh, I'm sorry I mixed VInt with optional, my fault. Must be the heat. Please ignore.
Same here about `Exception` catching
`newMean` & `newVariance` (we don't do underscores in var names)
I'm with fine with doing that after the review is done. The advantage for rearranging the methods is that in future PRs it is easier to see how changes to two or more of these methods affect the overall behavior as the changes are then displayed in Github UI in the order in which the code is executed.
It looks like you have a typo here. It's very helpful it you can get gradle to pass before raising a PR, so that these sorts of things get picked up by tooling rather than people needing to look at them.
I think we should also check the taskId here
also disabling put delete and get actions on the rest layer doesn't disable them on the transport layer, I think we should remove that part.
this should indeed be extremely unlikely to cause a user-visible issue (as at least the new primary should not run into this). Still, it's not great if an active shard cannot serve searches at all times. Let's take this out of this PR for now and rethink this later.
but it wasn't replaced by any other similar line somewhere else? I think this line is quite important, as gets printed out at startup in the console by default like the following: ``` [2015-01-06 10:18:01,288][INFO ][transport ] [Gertrude Yorkes] bound_address {inet[/0.0.0.0:9300]}, publish_address {inet[/192.168.0.27:9300]} ``` I don't think we should remove it.
can we use a limit variable that looks like `int limit = indexMetaData.numberOfReplicas() + 1; // one for the primary` and then bound the loop with `<` instead of `<=` it took me a while :)
maybe you can create a `Client` manually instead and make this extend `ElasticsearchTestCase`? at the end of the day you don't really issue the request...
also you probably want to check that `info.getPointDimensionCount() == 1` instead in order to skip range fields.
You see InvokerHelper at the very top, that is the bad guy that throws it.
> the original query weight is greater than 1 and that the rescore weight is greater than 0 `query_weight >= 1` is not even necessary anymore now that you changed rescoring to multiply the score of all hits with the query weight
The assert message should be `https` not `http`!
@jpountz @nknize Wouldn't it be better to be more lenient and accept the first 3 (or 2) dimensions, rather than completely fail? Adding failure now might break compatibility with previous behavior.
I've noticed these flip flopping some. I think someone had "use star if >3 imports per package" and I ended up setting that. I see you do the more normal "never use star". This isn't a big deal and I dunno if it is worth having a standard. The only real way to enforce these standards is with something like checkstyle because reviewers forget.
I would keep a `Map<String, Classs<? extends Processor.Builder.Factory>>` as a variable on the module... add a `public void registerProcessor(String, Classs<? extends Processor.Builder.Factory>)` method to the module and change this multibinder to a map binder that will just map all the registered processors.
or more simply: ``` java .addMapping("type", "location", "type=geo_point") ```
that should not be `doesNotRunTemplateUpgrade` I assume
I wonder if we should default it to the number of shards :)
I don't think we need this any more on master, since we can break backwards compatibility. In that case we can throw the UOE
I realize the example already here used this form, but I think it is clearer to use `== false` for inverted conditions.
This is a big antipattern: here we have two methods, both named interval(), just with different signatures. One is actually a getter, whereas the other changes state! But you have no idea reading source code, what is going on, e.g. its just a method and you have to follow the source code to figure out what is happening. Please change to getInterval() and setInterval() [there are other instances of these in these files, obviously those should be fixed, too]
why? `""` is not a sensible default. I think `null` is better here
@jaymode what do you think? I brought it up but I don't have a good answer for this.
This looks like the exact same implementation...can `BaseGeoPointFieldType` just be renamed and used in both classes? There isn't a reason the field type needs to be a static inner class of the mapper, they are just there for convenience since they are so small and tightly coupled with the mapper parsing code.
This goes away in favour of the version in #18042 I guess.
This exception will be treated as ignore replica exception. :wink:
you can get rid of the builder and just return an expressionrolemapping by changing the `Void` to a `String` and when you call this use: ``` String name = parser.currentName(); ExpressionRoleMapping mapping = ExpressionRoleMapping.PARSER.parse(parser, name); ``` then the function to build would be: ``` (args, name) -> new ExpressionRoleMapping(name, (List<String>) args[0], (RoleMapperExpression) args[1], (Map<String, Object>) args[2], (boolean) args[3]); ``` Obviously that is missing the checks for values, but those should be in the constructor of ExpressionRoleMapping anyway
Could you extract this "type" string to a constant? (and replace other references to this string to a reference to the constant)
Can FieldOptions be really immutable? (final fields)
The case statement is `keytabPathWithNoReadPermissions` but read-only false is not no-read, it's can-write. So the setup for DOS isn't consistent with the test scenario.
Maybe simpler just to do it the oldschool way. ``` final Map<String, SnapshotId> allSnapshotIds = new HashMap<>(); for (SnapshotInfo snapshotInfo : snapshotsService.currentSnapshots(repository)) { SnapshotId snapshotId = snapshotInfo.snapshotId(); allSnapshotIds.put(snapshotId.getName(), snapshotId); } for (SnapshotId snapshotId : snapshotsService.snapshotIds(repository)) { allSnapshotIds.put(snapshotId.getName(), snapshotId); } ```
nit: we should rename `tempDir` to `translogPath`
we should also fix the naming for `DynamicScriptDisabling` to `DynamicScriptExecution`
same request for assertion.
Yes, I changed it in #22675
It is no concern at all, it only prevents deadlocks and performance issues :) Don't use parallel streams with the default pool, specify a pool instead (in the same or child thread group): http://blog.krecan.net/2014/03/18/how-to-specify-thread-pool-for-java-8-parallel-streams/
If I'm reading this correctly, the `context` variable is never used so can we just assign to `leaf` directly (one less thing to think about).
Holy cow, this thing reads like House of Leaves, can we change it to something like: ``` java if (ParseFields.SNAPSHOTS.match(currentFieldName) == false) { throw new WhateverException(...); } while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) { if (token != XContentParser.Token.FIELD_NAME) { throw new WhateverException(...); } if (parser.nextToken != XContentParser.Token.START_OBJECT) { throw new WhateverException(...); } while ((token = parser.nextToken() != XContentToken.END_OBJECT) { ... etc ... } } ```
This is a code smell, setting static fields from an instance constructor. I think that we want to do something different here, so that these fields are instance fields. I can offer a suggestion on how to do this, but I prefer to let you spend some time coming up with a solution on your own (I don't want to take the joy of problem solving away from you).
There is little value in reusing the histogram if you still create new inputs here. You might want to have a look at `ByteArrayDataInput#reset`.
Yeah, let's do that (expand the range to the entire valid port range, and add assertions etc.). Thanks @jaymode.
Change we change the parsing to use ParseField? we have moved over the queries and are moving the aggs over to ParseField whilst refactorign so it would be good to include this in the rest of the search request refactoring too
Yeah, I was saying we can remove it now, since I was the one that originally added it
isn't this exposed in the status object? can't we use that maybe? just an idea
Got it...sounds weird though that you use your own `FetchSubPhase` which depends on a custom `HighlighterContext`, as the context is pretty much bound to our `HighlightPhase`. I wonder now if its constructor should have been package private from the beginning too :) Anyways, I think a `protected` constructor would do the trick for you instead of `public`, I'd prefer that so it's clear that people are not supposed to instantiate a `HighlightQuery` in the ordinary usecase.
can this case have a default case that throws `ISE`
oh so this is not new stuff? If it was already there this way leave it, please!
I wonder if we should void this check if indexUUID or that.indexUUID is IndexMetaData#INDEX_UUID_NA_VALUE . We can still run into this value when reading existing state files.
space missing before `Explicit<Boolean> coerce`
isn't enough to have another waitForEvents to make sure that the previous event was successfully published? I really think we shouldn't have this time based solution. 10s makes me shudder :)
Yup. I just don't know it well enough. Disregard.
there is a license header missing
The method name seems incorrect since it's not a check but a set. Something like `setIfNull` or `handleNull` is more appropriate.
I think its worth it? most of the time the response handle is SAME, so its not a big problem, but it allows to not overflow the same thread pool if it happens
Should we actually control this? I know, I wrote that code as well at the begining but the more I think about it, the more I think it's not that useful to block... May be only log.warn with "[{}] signer might not be supported"...
what's the difference between TermsLookup and TermsLookupBuilder? I am thinking if we can just make TermsLookup Writeable etc. and avoid adding a new class that holds the same info.
`addPathPartAsIs("_xpack", "ml", "filters")`
By that I mean a switch or something similar to what SuggestUtils#resolveDistance() does.
This adds an extra `2 * DEFAULT_DELAY_VARIABILITY` to the maximum time it might take to complete a publication - one delay on a follower and another on the leader, so we need to update `DEFAULT_CLUSTER_STATE_UPDATE_DELAY` accordingly.
can you use `null` instead of POSITIVE/NEGATIVE_INFINITY? this is the way the rangeQuery method expects to be notified about open bounds
This will silently ignore octets that are captured by the regular expression, but are in fact not valid octets.
> there is no way to distinguish between file doesn't exist and file exists but you don't have permissions to read it on this level Argh, that's bad... Thanks for improving it Igor!
This seems to be used more as a flag indicating whether or not to bootstrap the cluster, and a default of `do bootstrap the cluster` makes more sense to me.
this is NPE when termsLookup is null. I am tempted to just expose a termsLookup() getter rather than all the specific getters. Remember that the specific setters are there only for bw comp, but the getters were not there before, so we don't necessarily have to add them.
Can this be final? If a subclass overrides this but does not call super, its caching will break.
Why have this check? I know I keep this variable around, as well as one for java 8, and set JAVA_HOME based on it when I want to switch.
I would prefer that we don't use a threadpool in this class, it's supposed to be side-effect free. I prefer to set request.waitForActiveShards() to NONE and make a shortcut in MetaDataCreateIndexService for NONE.
formatting, 1 line instead of 2
maybe `Objects.equal` could make it easier to read
Not sure, but maybe we can add null-check for innerQuery here like in other nested query builders (e.g. BoostingQueryBuilder)? That would avoid potential NPEs or null checks in doXContent later.
can we please move this into the engine and don't add another service to our already overdesigned system. I try to hard to fold them into other classes and the 10 SLoC are not worth it really.
public class FuzzyQueryBuilder extends AbstractQueryBuilder<FuzzyQueryBuilder> implements MultiTermQueryBuilder<FuzzyQueryBuilder> {
Perhaps it should just be `script.groovy.sandbox`? It would then serve as the root property of all the child properties of it in a readable way: ``` script.groovy.sandbox = true script.groovy.sandbox.class_whitelist = ... script.groovy.sandbox.package_whitelist = ... ``` Versus: ``` script.groovy.sandboxed = true script.groovy.sandbox.class_whitelist = ... script.groovy.sandbox.package_whitelist = ... ``` Or, to go back to enabled, even `script.groovy.sandbox.enabled`. Longer, but I think it makes it better because it lives in the same hierarchy as the other sandbox properties.
+1 thanks Adrien, I was about to complain that we don't test search_type count anymore :)
Could possibly use `assertThat(e, org.hamcrest.Matchers.isA(ElasticsearchParseException));` here instead but I don't have a strong opinion about this either way.
cool this is not a response any more...
Can we support milliseconds through an explicit format parameter? We just got rid of this fallback mechanism in date fields for 2.0. It can be trappy when a user has no way to disable this builtin format.
Yes, pass the value as a json string.
`IOUtils` can handle null
well we don't loop at all we return the first one no? you can also do `if (numValues>0)` though.. same thing :)
you can use `IOUtils.close(processor)` it deals with `null` values...
here is a space missing before `new NamedAnalyzert`
ok lets leave it, it doesn't seem like a problem for now
I don't like Files.exists in general but personally I think this is the right decision for a good surgical fix!
`status` must be declared in the static inner `Fields` class like `Fields.RESPONSES`
This can be just `new Tuple<>(`
@dakrone Ha thanks! :D
This check is not necessary, Gradle doesn't allow for it unless the task is marked `@Optional`
I see. Could we just open all the directories up-front and then clean them all up at the end? If possible I think it's clearer that there are no leaks if you can see acquisition and release of resources to be paired up in a single method. It's not always possible, but here I think it is.
I think there is `LuceneTests.randomSortValue()` that generates random sort values. I wonder if we could use it here.
This other approach looks fine to me as well. Thanks for the clarification!
Can limiting this to only one snapshot cause some race conditions on repo? The only scenario I can think of is if restore lists index files and just before reading the file it needs delete creates a new generation index file.
+1, we could multiply `nodeCount` with a small constant to favor latency over throughput but the reasoning for the default value is to make sure that we hit all shards in a default index even when there is a single node so this change is consistent with the new default number of shards.
I think it's a problem to call fail engine here as we're holding the write lock. failEngine has a code block that acquires the read lock: ``` } finally { closedOrFailed = true; try (InternalLock _ = readLock.acquire()) { // we take the readlock here to ensure nobody replaces this IW concurrently. if (indexWriter != null) { indexWriter.rollback(); } } catch (Throwable t) { logger.warn("Rolling back indexwriter on engine failure failed", t); // to be on the safe side we just rollback the IW } } ``` Maybe we should reset indexWriter to null and then skip the read lock in failEngine if that's the case. Not sure.
instead of making this method protected I think we should use `MockDirectoryWrapper#failOn(Failure)` and pass some failure to it that fails if we commit the indexwriter like this: ```Java Failure fail = new Failure() { @Override public void eval(MockDirectoryWrapper dir) throws IOException { for (StackTraceElement e : Thread.currentThread().getStackTrace()) { if (doFail && "commit".equals(e.getMethodName())) { throw new FakeIOException(); } } } }; ```
let's just rename originalContext to context in the argument list
it seems that the latch is useless? or maybe you wanted to enable the recovery half way through the "indexing operations"? Also, this suffers from the same racing condition - if the ops that are now in flight when the relocation comes in are not first in the onLockAcquiredActions list, we will have a deadlock.
nevermind. Misread the test. It actually writes a shard copy to all paths.
I think this is not needed. It should use the default account available.
Forbidden API: ``` Forbidden method invocation: java.lang.String#format(java.lang.String,java.lang.Object[]) [Uses default locale] in org.elasticsearch.cloud.aws.blobstore.S3BlobStore (S3BlobStore.java:211) ```
I wonder how long this would work ;)
space missing before `Explicit`
Why not have the canonicalClassNamesToClasses above be a TreeMap? Then their iteration order is sorted by the keys. But since this seems to only be used by the doc generator, I would keep the sorting to only occur in the doc generator, rather than making PainlessLookup always incur that cost.
I know there's a lot of renaming still outstanding, but it might be best to use `data_frame` instead of `feature_index_builder` here from the start.
I am not sure what we have yet to decide here. What Christoph is suggesting makes sense, let's update the PR accordingly
But you can replace wherever the boolean is used with equality to the enum value: `orientation.getValue()` -> `orientation == Orientation.RIGHT`
can we have a better failure message - "file ["+tmpFileName + "] was renamed but still exists"
I usually try to write a test that fails if the version is 6.0 to ensure we don't miss this, like a simple unittest
I think you should protect this against double counting down the `closeLatch` by wrapping this entire try block in ```Java if (isClosed.compareAndSet(false, true)) { } ```
extra new line
You can use CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey() to get the above string constant already today.
No more wildcard imports right :)
If they are essentially the same thing then I wonder whether we should eliminate one of them completely? Anyway, I am fine with the current state.
Can we make MultiMatchQuery.Type a Writable similar to Operator etc...? Relying on serializing an ordinal feels safer to me than using the names.
Same as the double note above, just for long.
since this is a `FixedBitSet` I wonder why renamed everything to use bitArray? I don't mind. Just curious.
this needs a message
These look like leftovers.
I think you might be able to pull this out into a helper method.
I still feel like there ought to be a way to make these methods look less copy-and-paste-ish. They just set off my copy-and-paste blindness even though they aren't copied and pasted.
I think the message needs to be changed here..
oh..ok... so make `Operation` implement `Callback`, it'll still clean things up
can we make these final fields on the parent class? they don't have any state.
I think it would be simpler to have the node remove its threadcontext from here on close
we can remove the bound (AllocationCommand) and make this a top-level class `FromXContent` (dual to `ToXContent`). There are also other places that could implement this new interface (e.g. ContextMapping, MetaData.Custom, ...).
how will you be able to detect duplicates? hmm... maybe I'm missing something here... the way I saw it, each plugin will effectively define a static its contexts (probably static constants of `SearchContext.Plugin`) and then pass it to executable/compile on demand
not 100% sure bad request is still good here, have yet to find a better status code though....
is `timestamp` the partner of `end_timestamp`? Should it be `start_timestamp`
Nit: space after `))` so `)) }`
To keep things simple, I would not support null values for now.
too many shards [%d] already allocated to this node, [%s=%d]
`performPreSyncedFlush` might call this. Let's make this noop
I'm OK with this, but it could have been fully randomized using XContentBuilder/XContentType I think
I wouldn't rely on the order the replicas exist in for this behavior, note it works in the primary case cause there can be only one :)
This change is a little out of the scope of this PR, you did discover that we're missing a method below this one that has ```java public void testForceMergeActionWithCompressionCodec() throws Exception { forceMergeActionWithCodec("best_compression"); } ``` So I think we should not apply this change in this PR
You could use `map.computeIfAbsent()`
It may return no types if no mapping has been put, but indeed never more than 1 type. FYI the right way to check is `context.getIndexSettings().isSingleType()` rather than `indexCreatedVersion >= 6.0`
This was added as a protection against a failure during the rename, leaving the shard in a corrupted state (#10053) . We later added better checks in another place ( #11269 ) . I think it's OK to remove.
FYI if you want (not that it is a problem as it works now) you can leave the randomized number of shards when creating the index and retrieve it through `getNumShards("test").numShards` which you can use for the comparison.
Probably should remove the leading space here.
I think you still need to use the low level client for that, using `client().performRequest()`. That said, why not change the order of the test blocks around and move the `// Testing deletion` block to be first. It will create the index.
can you please add the `clusterStateVersion` to the assert message
I'd switch the order of these so it matches the declaration order.
all sounds good to me. innerQuery is fine.
> However I can't think of a good way to reliably assert that we don't do this I don't have any good idea here. I'll keep thinking about this. Should not block this PR though.
Shoot. Sorry for the confusion... I meant this.actual (the EChain's actual value). I believe if you have something like double x; int y; x = y = 1; will blow up? (Or at least do bad things.) The duped value on the stack ends up being viewed by painless as a def type rather than an int.
I don't think we need to copy headers here, we do it in `RestController#dispatchRequest` in a controlled way after we stash the context so I think this is obsolete
We have code in `ExceptionsHelper` for this (`unwrapCause` I believe)
Although I liked it at first, I'm starting to doubt the usefulness of these tests. And formatting makes it unreadable. If we keep it, can you change this to something like: ``` StringBuilder expectedString = new StringBuilder(); expectedString.append("{"); { expectedString.append("\"took\":0,"); expectedString.append("\"timed_out\":false,"); expectedString.append("\"_shards\":"); { expectedString.append("{\"total\":0,"); expectedString.append("\"successful\":0,"); expectedString.append("\"failed\":0},"); } expectedString.append("\"hits\":"); { expectedString.append("{\"total\":100,"); expectedString.append("\"max_score\":1.5,"); expectedString.append("\"hits\":[{\"_type\":\"type\",\"_id\":\"id1\",\"_score\":2.0}]}"); } } expectedString.append("}"); assertEquals(expectedString.toString(), Strings.toString(response)); ``` That should be more robust against auto-formatting.
I wonder if we should set this to true only if options.expandWildcardsOpen || options.expandWildcardsClosed . Otherwise wildcard expressions don't get expanded...
InputStream or OutputStream? This is confusing because the method is `InputStream readBlob(String blobName)`
`} catch(IllegalArgumentException e) {`
oh nevermind I just saw that this is the object path
Yeah - it'd be super nice to be able to set the time unit on the URL and get it back - I'm quite happy at the idea. I'm just worried about the times when we persist stuff in XContent form and it lives for a while. We'd have to expand the places where we parse quite a bit. I think we could to it fairly easily for ObjectParser and friends but all the old places where we parse by hand are going to be a pain. They'll work now just because nothing ever changes this from millis. That is why I propose moving it out of this - if you just did the names cleanup that'd be a good thing but supporting more units is going to be a bigger change.
`coerce` and `ignoreMalformed` seems to be related maybe we can enforce that both are updated together? or at least add a TODO
Personally in code like this I would just throw AssertionError. it make code uglier in many cases to do this, but there are times where its better to be paranoid...
This parser used to ignore arrays of stuff with any name. Now it ignores them. Awesome.
metas-tate -> meta-state
do you think it makes sense to support the other options as URI parameters as well? will simplify curl executions.
I think this should be a ParseException instead of an IllegalArgumentException. This would be in line with what we do elsewhere in the codebase (such as in the mapper parsers where any left over parameters after parsing is done are throw in a MapperParsingException).
good move, folding this into the base class..
So +1 on renaming and pushing like this
Another personal preference, but we should be able to avoid empty opening `(` here
Can you only do toxcontent for ScriptException, but still log the entire stack trace for other exceptions? eg, if we have an NPE because of a bug in painless, I think we should still see the full stack trace.
No need for this ctor.
yay for stack traces
maybe some docs would help on the two above methods, for instance to say that new aliases have not been added yet when validateField is called and that new fields have already been added when validateAlias is called
I'm OK with floats here, eg the jump from 1 to 2 is quite big, I can imagine people wanting to use `1.5` here
This will break all plugins and will force all authors to update their plugins. Not sure if there are any other option but if not we should mark it as a breaking change. Can we add it only to `AbstractPlugin`? I mean add it as a new function but not replacing the existing signature.
nit: too many newlines
are we saving some newlines here? ð
but it feels like we are back with our own ordinal then, more LOC too with two switches compared to the previous `Operator` impl :) can't we just handle bw comp once we actually change the enum? of course the main issue is remembering about this, and tests are a good way to remember...
What do you think of this? ``` public <K1 extends K, V1 extends V> CopyOnWriteHashMap<K, V> copyAndPutAll(Iterable<Entry<K1, V1>> entries) { CopyOnWriteHashMap<K, V> result = this; for (Entry<K1, V1> entry : entries) { result = result.copyAndPut(entry.getKey(), entry.getValue()); } return result; } public <K1 extends K, V1 extends V> CopyOnWriteHashMap<K, V> copyAndPutAll(Stream<Entry<K1, V1>> entries) { return copyAndPutAll(entries::iterator); } ``` It's not necessary but the call site on line [519](https://github.com/elastic/elasticsearch/pull/13533/files#diff-80e3b9bf08264f2b719b2f8ce044ae80R519) can then change to not call `Collection#stream` but the rest of the call sites can remain as is.
nit: maybe the field name could be a constant under `Names`, the same as in e.g. GeoPointFieldMapper (or reuse that one)
It would be nice if we could somehow get the parseField from each parser, but I guess the problem is that QueryParser needs to be a functional interface? Maybe this can be added later.
Can this just go into `createNewEngine`? It's the only caller of this method.
I am fine with the new way, but then let's fix all other setters and getters to match this one.
Maybe also check the explicit flag.
why is this log uppercase? :)
+1 to _not_ build in another hard coded fall back (we don't know what a number means - might be seconds). I do wonder what goes wrong here. The default date field formatter should fall back to mills: `strict_date_optional_time||epoch_millis` .
uhm, this line does not belong here. I wonder why this did not break any tests....
I like the type safety!
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
yep. it's just before the shuffle. got confused. all good.
IMO consistency is important... if we state that all queries accept a boost and a name, we should be consistent here as well. This is important specially from the client/user perspective where often they have defaults for commonly supported features...
Now that we use a simpler shard iterator, this is no longer up to date.
I think it's not needed
I see! I think your change makes it clearer actually, looks good
> I say we refactor TermsLookup into TermsLookupBuilder when we refactor TermsLookupQueryBuilder. not sure what this means. when is the queryParseContext used in TermsLookup? I wouldn't be surprised if it's never used....
hmm i see what you mean. If the formal term for it its `differencing` then maybe the current name is ok. I haven't really thought about what we'll call the `arithmetic` agg since, as you say, the plan is that it will support more than just subtracting series. Its basically a 'parallel time series scripting agg' which is a bit long for a name ;)
It gives clients an upgrade window where they can safely continue to use their old mappings for a while. Its normal not to push a new version of your application in the same release window as you push Elasticsearch. In fact I'd wag my finger accusatorially at anyone that did. So you want the old code to work with the new Elasticsearch. And the only way to rig that is to support both names for a while. Either we add support for the new name in 1.7.X and re-release or we support the old name for a couple of releases.
Given that signaling this failure up the stack would be a mess, I wonder if partial results really bring us any advantage. I suggest we fail (call the listener's failure handle). When we'll move the security searches over a different threadpool, partial results would be even scarier.
scratch that I see how you use it now ;)
might be something that was previously supported in and query and or query which are now gone. not is the only survivor. That said I am leaning towards leaving that logic in the context anyway? It feels weird to be looking queries up from the parser here and throwing generic exceptions like "no query registered". And maybe open an issue for discussion about deprecating this syntax. maybe we should have a single way to specify things here.
I was just wondering if it's IDE configuration. does everything compile and build without the suppression? Asking because I am not sure we generally add those type of suppressions, but I may be wrong.
ObjectParser has another constructor version where it takes a provider that can be used to build the request. You could save a whole line if you used it!
I'm not sure about this test. I think it's confusing if ``` { "obj" : { "f": 1 } } ``` returns `{}` but ``` { "obj" : { } } ``` returns `{ "obj": {}}`
If this stays an error or maybe gets converted to a log message, the line number would be a helpful debugging information for the user the file.
nit: the word "event" is no longer relevant
You probably meant geoData.isEmpty() == false
These cause compilation errors for me...
I wouldn't move everything within the catch, just the part that you moved out as part of this PR. We use the same cluster state throughout the execution of the whole multi get transport action, so deleted indices once the cluster state has been retrieved won't be seen by it. What will happen is that the shard action will fail as the shard is not there anymore, hence that specific get item will fail.
This whole method is now only useful for backwards compatibility. I don't really think this is needed any more.
Wildcard imports will break the check-style build (ask me how I know :D)
this feels weird. We have a parameter and not use it. Can we add java docs and throw and operation not supported if someone used it? (this goes for all of those)
I think we cannot (yet) do this with auth tokens received externally because they need to be passed to the test suite as well as this fixture, so we've had to settle on just using the same (long) string in both places. It would indeed be nicer if there were no magic strings in the fixture at all. For deterministic testing, maybe you can pass a seed in from Gradle somehow? Or just hard-code them, it's not that important. I'd rather they weren't synthesised as they are now.
same here, "Missing types in exists", maybe beter sth. like "Missing types in 'exists' query" or something like that.
I think `analyzingSuggestHolder` should have a getter for `preserveSep`
please remove this or use the logger instead.
We should fail if the put replaced an existing entry? Or rather, not replace if the mapping already exists (ie where a 2 different whiteslists are whitelisting methods on the same class). But surely they can't be allowed to have different names in painless for the same java class (one would overwrite the other here).
waitForCompletion returns SnapshotInfo
I still dont' think it is necessary. The mock FS needs to be installed before creating the Environemnt, and any calls to PathUtils.get will work correctly, including the one done for tmpDir.
I wonder if the input parameter should just be typed as an `IdentityHashMap` then? Note that currently this will silently ignore duplicates in the input `tasks`.
the transport client exposes this api via the `execute` method
Sorry, i don't think i was very clear. I meant the hashing algorithm here is an HMAC (a keyed hash). For the anonymization use case we could use a non keyed Hash to the same effect. The key doesn't provide much value unless you are verifying the hash's integrity. To avoid swapping implementations based on a key's existence, a hard coded key can be used, which effectively (but not technically) changes from a keyed hash to non keyed hash.
Its clearer to you because you are used to it. For me, every time I see a `visit` call I have to think "why does this one get an increment/decrement and not that one?" and "do all calls to `visit` with this parameter type increment scope?" and things like that. That second question is why I asked if you could push the increment/decrement to the implementation. Making a method call for it probably wouldn't make it clearer though.
Are we sure we can use lessThanOrEqualTo here? we can also just assert that time() > 0 imho.
+1 let's have AbstractProcessor instead
We could inline `releaseAndNullLocks` here, and moreover we don't need to set each lock to `null` since we don't reuse the `locks` array.
lets skip the guard - not perf critical and gets called more often then
Could you explain why this still needs to throw an exception rather than just returning an unmodified cluster state? Also I know we threw an IllegalArgumentException before but it feels wrong to me since the user won't have supplied anything invalid
I'm suggesting to just round it to the nearest `long` with `Math.round`, the output will always be between 0 and 100, and thus can be indexed as an integer.
Nit: `No` -> `no`.
ok, fair enough
I'm curious why we have getValues if all of these classes already extend list? Nothing to do with this PR, just something I noticed: since we are looking at breaking changes in the future, maybe this could be cleaned up too (either extend list, or have getValues())
Or "no longer than 512 bytes"
can we maybe un-chain this line it's very hard to read... like ``` Java CreateIndexRequest indexReq = new CreateIndexRequest(request); indexReq.mapping(request.type()); //... ```
Same here, I think we should go back to the `ImmutableSet`, the types should keep people from thinking they can change things with these collections
A value if 0 seems to be okay here. At least there are some tests in SuggestSearchTests (unfortunately in the lang-mustache module) that use that and now fail with an exception.
just pass `DiscoveryNodes` as an arg
Can we avoid using camel_case here? I think `testMaxConcurrentReads` should be good.
Err, the next one a TimeValue, this one a DateTime or something? Its not required, at all and I just thought of it but a TimeValue would make runningTimeNanos easier to read I think.
this is a leftover I think
I think I prefer the current logic of this method to relying on the return value of get().
Should be `for (JvmPlugin plugin : jvmPlugins)`
What do you think of simplifying the last few lines with the following? ``` int checksumIndex = Math.toIntExact(writtenBytes - checksumPosition); System.arraycopy(b, offset, footerChecksum, checksumIndex, length); ```
can we do this `for (IndexShard shard : this) {...` not a big deal though
get shards here is an overkill. Let's add a operationRouting().resolveShard() method that returns a shardId.
right! oh the confusion :D
I see. Maybe we should consider adding a wrapper similar to `TimeValue` to avoid string manipulation. But this is no new issue, let's defer...
And I was wrong again! It looks like if your NativeScriptFactory returns something that extends AbstractSearchScript then you can indeed use native search scripts....
You don't need this anymore, this method always run with a single registered type.
We have other analysis components that also use Java regexps, I don't think we need to block this one.
there is a whitespace too much here ;)
never mind, I saw them later on
Can you remove the leading underscore? Variables should start with a lowercase letter according to http://www.oracle.com/technetwork/java/codeconventions-135099.html
Typo: `thoulands` -> `thousands`. Same typo [here](https://github.com/elastic/elasticsearch/pull/15998/files#diff-091a93c5c6d4170159d3170b6c085be2R95).
spaces around '='
Then could you do something like: ``` @ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.SUITE) // Changes settings ``` That'd make it clear why it is needed so folks don't go copying it into their tests without knowing why... ð¼
I think it should be a separate if statement, not an `else if`
I think that for consistency with `jobExists` the listener should get `Boolean.FALSE` if the group does not exist and it is up to the caller to know if they want to error on `false` or not. Giving the listener an error here does not seem right as no error actually occurred.
I think that we have a problem with backwards compatibility here. Most likely our bw comp tests are going to fail (would be nice to verify that actually). I think indices_boost would get ignored in a mixed version cluster (e.g. 5.x and 5.1): - 5.x coord node does the resolution on the coord node, serializes search source builder to 5.1 node (nothing changed there) which doesn't know how to resolve indices names yet, hence it reads indices boost from the original source, it works as it used to. That's ok. We can't do better than this. - 5.1 coord node doesn't resolve indices boost on the coord node, serializes source builder to 5.x node (nothing changed there) which knows how to resolve indice names, but it doesn't get them through shard search request as 5.1 node didn't send the info. Hence the indices boost are always going to be 1, ignored. We should fix this. I think the way to fix it would be to detect based on the version whether we have to read the index boost from the source builder of from the shard search request.
also use new `writeDoubleArray` here
yeah so I'd initialize the `String[]` with `Strings.EMPTY_ARRAY` and then make sure that it is never `null` but maybe that is an overkill. I just don't like that we use the `null` invariant use all over the place. Rather check for `null` and throw an `ElasticsearchIllegalArgument` on the setters. What do you think @brusic
can you undo this change given that we will soon ban wildcard imports? #15395
nit: drop this extra line
Double checking, there might be something I missed here...not sure we really need to use this variation of `prepareCreate`, that makes sure the index is going to be allocated on as many nodes as `nodeCount`. If we only start a single node, looks like we are going to use needless allocation exclusions.
rather than introducing a generic setting for this (that people can abuse independently), I would prefer we explicitly check for tribe settings. `TribeService` checks this by using `settings.getGroups("tribe", true))`. We could make `tribe` be a static string and use it here or have a static method on the `TribeService` called `isTribeNode`.
Now that we have immutable mappings in master, I think that is a worthwhile goal. I believe it would be different from this PR though, not a quick change.
Can you call this something other than `total`? It's really hard to read things like `total.total, total.total, total.total + total.total`.
+1 to that as a first step
if it gets too low level the instanceOf that you have is enough here, we don't have to go that deep I think
I know some methods add the `@throws` and others don't. I think we should still add the `@throws` entry even if it is a checked exception. I have not been consistent about this myself either :(.
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
I also don't think a copy should be made for this example. The secure string should be closed after using it to decrypt the keystore.
This sucks.. I want to see how big of a deal it is to keep things as they were. Indeed snapshotting a commit will keep it's translog around but I'm not sure anymore it's worth this kind of wrapping layers. Maybe we should invest in faster clean up on those snapshotted commits. I'll reach out to discuss.
sounds good, this one will require the version as argument though
scratch that... after looking closer, copyBytes cannot be used, which means the other alternative would be to copy the array and assign it explicitly and indeed `deepCopy` is cleaner (creates a new instance, but we only do that for those buckets we return anyway)
oh no it now throws `ElasticsearchException` which I think is weird it should throw IOException
It is so greaaaatttt to find such test bugs!
add a newline here
can you assign `event.state().nodes().masterNodeId()`
maybe return to the two allowed values here to give the user a hint
any change we can use `URI` here instead? `URL` is pretty tricky though has odd equals impls etc.
++. "Concurrency level" is always 255 now. Kinda.
Maybe `Set<String>` instead? The list should be short so it likely doesn't matter but it feels better to me if it is a set.
yields always true
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
can we invert this and move the `meat` into the if statement? /me doens't like returns and continues ;) it's easier to read IMO that we skipping the entire body if it's in the if block
Could you assert the entire text of the message as you had done previously? It helps to clarify what this bit of code is testing.
can we just call this `getEngine` the `safe` part is unnecessary
Awesome :) On 18 April 2014 21:36, Lee Hinman notifications@github.com wrote: > In > src/main/java/org/elasticsearch/index/query/support/XContentStructure.java: > > > +import org.elasticsearch.common.xcontent.XContentFactory; > > +import org.elasticsearch.common.xcontent.XContentHelper; > > +import org.elasticsearch.common.xcontent.XContentParser; > > +import org.elasticsearch.index.query.QueryParseContext; > > + > > +import java.io.IOException; > > + > > +/** > > - \* XContentStructure is a class used to capture a subset of query, to be parsed > > - \* at a later time when more information (in this case, types) is available. > > - \* Note that using this class requires copying the parser's data, which will > > - \* result in additional overhead versus parsing the inner query/filter > > - \* immediately, however, the extra overhead means that the type not be > > - \* extracted prior to query parsing (in the case of unordered JSON). > > - */ > > +public class XContentStructure { > > I think this is possible with some refactoring, I will work on adding it. > > â > Reply to this email directly or view it on GitHubhttps://github.com/elasticsearch/elasticsearch/pull/5838/files?utm_campaign=website&utm_source=sendgrid.com&utm_medium=email#r11773450 > . ## Met vriendelijke groet, Martijn van Groningen
oh boy this PROTOTYPE was totally useless :)
Maybe do sth. similar as this: https://github.com/elastic/elasticsearch/blob/master/core/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java#L962
OK, thanks for the clarification
Wonder if we need this flexibility. Do we ever provide multiple fields to exclude? Also do we ever exclude any field other than OBJECT_FIELD_NAME ? Also do we ever call this method without excluding OBJECT_FIELD_NAME? I think we can simplify this quite a bit.
the name is not too descriptive but I dont have a good alternative at the moment either
@gfyoung @rmuir's suggestion here is correct. If you can fix that, I'll merge the PR; sorry I was a bit delayed today in responding.
++ on making this explicit
Pass SnapshotInfo directly to this method? See `TransportSnapshotsStatusAction`. No need to revalidate...
will need to add `std_upper`, `std_lower`, `confidence_upper`, `confidence_lower` here otherwise they won't be able to be used in sorting or `getProperty()`
I think it'd be better to check before and decrement the counter after. We're in a synchronized block.
I think that node provider interface can go away (now that's were on java8 - function refs FTW)
This can probably be on one line
this method can be private now
Yes, I think we should make `Job.Builder::setJobType` `public`. The user could change it if they used the low level REST client.
Yay, you can remove this TODO!
Helper method is no longer needed now that `Logger.log` exists.
I don't think this needs "WithAlphas", because the unstable branch always has alphas (when we switch to beta, we cut a new stable branch).
I wonder if we need to go to `generic` here. Direct executor / same executor should also do.
Can you add more randomization here. You can build a random list of field names for the includes and the excludes for instance.
`rm` takes multiple paths, why not use that? It handles exceptions from any of them.
if (this.totalSizeInBytes == -1) { this.totalSizeInBytes = other.totalSizeInBytes; } else if (other.totalSizeInBytes != -1) { this.totalSizeInBytes += other.totalSizeInBytes; }
use a different variable
I'm doubting if we should introduce generics for the BatchingTask and batchingKey. I'm fine with keeping as is if you don't like the generic version.
I'm ok either way, just proposed this one because it looks simpler to me
Looks like the wrong copyright header...
nit: reactivate randomization
I think it's simpler to just keep equality, but I'm good with you prefer it this way.
I also think we could now make this static and unit test _just_ this method, which would be really helpful
Hang on: this is index throttling, which still exists and is different from store throttling? Index throttling is when ES forces incoming indexing to be single threaded because merges have fallen too far behind ...
Oops, sorry @imotov
Duplicate from the `discovery-ec2` module. Do we have any chance of sharing this code across modules without too much hassle? Otherwise we might forget to update the settings here in case we change them in the other module.
Please put it into an assert if you keep it. Iâd remove it.
Great test! Maybe one more that tests total compiles 2 or 3 or something - just more than one. So we can see how the number doesn't increment in weird ways.
can this be `requestHeaders`? I find it a bit confusing as response headers should also be persistent
I added an alternative pattern above how to pass on the ref..
Since it is defined on the superclass it'll still be there, just not a delegates-to-superclass override.
Creating an `InputStreamReader` without specifying a charsets isn't allowed. Instead use this: ``` java new InputStreamReader(UserAgentProcessor.class.getResourceAsStream("/regexes.yaml"), StandardCharsets.UTF_8) ```
> the behaviour there kind of sucks in that we're just quietly returning null for fieldnames that can't even work to begin This definitely sounds like something that should be fixed in a followup.
I presume, by the way, that passing `null` for the region here is ok. I haven't tried it.
I was confused by this name for quite a bit, but I cannot come up with something that would be concise and at the same time describe this class better, which made me think that maybe we actually need two maps - one from name to IndexId and another from name to List of snapshots. I think we should brainstorm on this when you have time.
It would be nice to explicitly test on which platform getSystemCpuLoad returns -1, if any, like it is for the load average
super minor nit: I wonder if we even need the string constants at this point :)
I think you mean `fromOperation`? I think it'd be slightly better to have `Operation` implement `Writeable` and call this method `readFrom` and have it take the `StreamInput` instead. At least, that is how we've been doing these enums in the past few months.
lots of unused imports can be removed here.
this key is different from the one specified above in https://github.com/elastic/elasticsearch/pull/20310/files#diff-9a1a4781a78e7e7a89657e8717f88997R61
Probably worth noting this exception to the rule in the PR description (since the description suggests that `es.*` causes a failure when this clearly shows that it won't).
+1 on adding the shardId. I believe the exception needs to be first in the parameter list.
in all the builders, you can remove the class name, just `return NAME` is enough.
Typo above (`GeometryCollection`) and copy/paste error with the return.
Not a big deal. I was just thinking of community plugin developers but it's not hard for them to fix. We should may be add this in BWC doc.
We're doing one extra execution here... I think we should have `while (retry < maxRetries)` and `if (shouldRetry(e) && retry < (maxRetries - 1))`.
should we warn on this failure now? because of we have a bug and we can't obtain the lock, we won't delete anything, which is a different semantics than deleting the files and letting the OS handle dangling open file handles? This in theory should not happen because a lock is there
this is tricky - it leaves us in a potentially scenario where there are two active primaries - the target and the source. I don't have a clean solution for this. My suggestion is to fail the shard and let the master promote another replica.
`o.e.i.Streams.copy` will close both `in` and `out` after the copy is complete, but `ByteStreams.toByteArray` did not do this. This could potentially be problematic in the case of `in` here; we will need to think through this carefully.
I don't think you should catch this here! this must not be null at all just let it run into NPE
I see, that is hideous. ð¦
we can remove this stuff: https://github.com/elastic/elasticsearch/pull/12966 it's deprecated since 2.0, no reason to keep the deprecated version of it.
I don't think you need to keep the `found` part of the `toString`. I'd just nuke this line.
That won't loop forever, as far as I can see this will run into a JsonEOFException because if the unmatched brackets eventually.
Wouldn't it be good enough to write: ``` List<DiscoveryNode> nodes = this.nodes; if (closed) { throw new IllegalStateException("transport client is closed"); } ensureNodesAreAvailable(nodes); ``` as we know that the close() method first sets `close` to true and then empties the nodes list.
Maybe use a simple for loop here like: ``` Java if (!contextMapping.isEmpty()) { builder.startArray(Fields.CONTEXT); for (ContextMapping c : contextMapping) { builder.value(c); } builder.endArray(); } ```
@bleskes was talking below about using only the index, source, and id for the task description. The toString change would still be nice, but less important then. That seems like a good choice to me.
I know you've just copied but is it worth even asserting this? Also, if you do assert this maybe use `assertThat(o, instanceOf(Text.class))`;
Thanks for this - it'll be a lot easier to debug failures than to look at two differing byte arrays and back into the difference.
still don't like the "final" ;-)
can we tunnel through the cluster state used in the action? that way we don't need to worry about consistency between the two (concurrent index deletion etc.)
can we use the index name first in the log, like `[{}] locking all shards, num_shards [{}], index, numShards`
This is an excess to the indexWriter without a lock. I think this can lead to an NPE if the shard is closed. I realize it's not part of the change, but I think we should deal with it.
we need a consolidation of all the score mode / type we have at some point, not here though
I think we have to add a null check for `Script` too
We prefer adding the `set` prefix. ```suggestion public void setContents(Object contents) { ``` Also in this particular case I think we should also make a semantic change and type `contents` with `String`. This does mean that groovy will resolve GStrings sooner, but looking at the uses of this task that is ok and I would prefer the stronger typing, it's one of the reasons we convert in the first place. We can always _lather_ add a version that takes `Supplier<String>` if we need it to be more dynamic.
I think it'd be nice to do: ``` java Exception e = expectThrows(UnsupportedOperationException.class, () -> { RestTable.getRowOrder(table, restRequest); }); assertEquals("blah blah blah", e.getMessage()); ``` It is just nice to assert something about the message so you know _which_ `UnsupportedOperationException` you get.
We have the pluginInfo here as well, in bundle, so we can create a LoadedPlugin
not used (I was so much looking forward to more usages of this)
Our build does not allow the use of the `@Test` annotation and instead we have the convention naming test methods starting with `test`. Could you change this test method to have a name beginning with test? Also it might be a good idea to run `gradle precommit` after making the change to find out if there are any other issues.
`crush` -> `crash`
I think the same reasoning can apply for `wildcard`, `prefix` and `regex` queries so the default impl should throw a `QueryShardException` ? Only `StringFieldType` fields should be able to build a `wildcard` query.
this file can go back to 140 chars as well...
(and also the fact that it will be lost on serialization, etc.)
And I think that's bad because with `"tru"` the user meant `"true"` and the system silently swallowed their error. I want `"true"` -> `true`, `"false"` -> `false` and `null` -> `false` and all other values are rejected.
Can be removed here, queryName and boost are all handled already in AbstractQueryBuilder#toQuery().
nit: I think this should be worded differently given its public: ``` Marker interface for index lifecycle management actions ``` Reasons: * This is a marker interface not a parent class * The fact that its a client side copy is an implementation detail that client users should not need to know about * The fact that we use it to have a common category class for the NamedXContentRegistry is an implementation detail I don't think clients should need to consider
I'm tempted to remove `isCreated` and just use `getOperation` everywhere. Might make more sense to do in a followup PR because it is a lot of small mechanical changes.
We don't explicitly support upgrading between alphas. Can you test this with a 2.x version instead? I would use `VersionUtils.getPreviousVersion(Version.V_5_0_0_alpha1)`
Oh, sorry, I meant mixed in the sense of one with `@Test` and one without. I am all for separate tests because it gives a lot more granularity. Honestly think the above test could be at least two.
do we need busy waiting here? and we should probably wait on the node to join the cluster and have no relocation pending.
Not sure why the order matters. Since we know this is a string -> string map, let's write it for that: `out.writeMap(grokPatters, StreamOutput::writeString, StreamOutput::writeString)`
Probably worth asserting that they return success. I've never seen them not do so but if they ever start then this test won't have many segments and will fail in strange ways to anyone trying to debug it.
Thanks, that makes sense. I didn't think about the reducing tests.
LoggerMessageFormat handles the toString on the array. It'd be `throw new IllegalArgumentException(LoggerMessageFormat.format("Merge failed with failures {}", result.buildConflicts());`. I you don't think it improves readability then I'm happy for you to merge as is.
I think you should not ignore it completely? The contract is that is `simulate` is true then conflicts are reported but changes are not performed.
I don't like the locking semantics - read/ write for stats updates and fully synced for class execution. I think we should stick with one. I understand you did it to make sure stats reading is consistent. My vote goes to the simplicity of synchronized access and making the status creation method synchronized as well. It's super light.
Right. I figure we should have a test for it or explicitly make the min for that parameter `1`. We have other ways to turn off dynamic scripts if we want so maybe it'd be better not to have two ways to do it.
Doh! the recommendation is forbidden API ..never mind.
Maybe call this `delayTimestampNanos`
maybe implement `Releasable`
To be clear, I was referring to both `globalCheckpoint` and `docId`.
I think after closing #19917 we can remove this todo
this can be replaced by just `ActionListener.wrap(runnable)`
if it is unused remove it!
if we need to have this discussion I'd suggest to have it on a separate issue and not hold this PR because of this.
put [ and ] surrounding the blobPath, so `"File [" + blobPath.toString() + "] ...`
See RandomScoreFunction (it does not depend on the order of visiting docs, and just substitute using the uid field with either docid or a user supplied field).
if all sub queries are term queries with the same boost, it would be nice to build a SynonymQuery instead
@HarishAtGitHub sometimes less is more. Too long an exception just means that the user doesn't read it all.
Nit: maybe if..else would be more readable
I guess we should be consistent and use top/bottom across the board for now!!
You can use the same for the rescore with another field for instance
with vint we save a cast to byte I guess, that's it :)
++ to that
if you want to save some characters you can replace all these `execute().actionGet()` with just `get()`
This method can be public, static, and take a String instead of a Path, which would allow us to unit test it. It will require moving the logging up one level higher though, but still nice to be able to unit test.
nit: please keep the formatting
make it an IllegalStateException please
Nit: `numConnection` -> `numConnections`.
By moving this inside the `for` loop it throws after the first IOException, so it would be better to throw inside the `catch` block (unless moving it inside was not intended)
What I am missing here is a real unittest for this class. Something on the lucene level that does som indexing with random refreshes etc. and that make sure it holds multiple readers etc.
alright - lets get this in
can we inline this - it is ionly used once
I was referring to the fact that the setting netty uses are the result of a merge of multiple things: ``` // merge fallback settings with default settings with profile settings so we have complete settings with default values Settings mergedSettings = settingsBuilder() .put(fallbackSettings) .put(defaultSettings) .put(profileSettings) .build(); ``` If we can make that static and available we can now for sure they use the same thing, even if people change stuff.
"marker" interface is also fine. I made it as a class for the special cases we might introduce when we have more "def" types propagation. For now interface is also fine. It would spare to repeat the ctor!
I wonder if we should move it up above the IllegalIndexShardStateException, as we don't want to retry in this case (although it's not that bad).
`current_node` might suffice (see reroute API)
Interesting syntax, any reason not to cast using "(MultiLineStringBuilder)" here? I'm just curious ;-)
maybe it would be useful to log the exception message with this warning, just to know what could be the reason for the failure
yes and that should be enough. and that is also why we keep Object in the builder. but we can simply pass the Object that we have over to the fuzzyQuery method, with no conversion
the @Test annotation is unnecessary
Same here with regards to the test.
There's a stray semicolon here.
yea I figured why MapperScript is there, and maybe that should be the only abstraction of a script for this functionality. I don't see the value of the indirection that IndexTimeScript causes now, as it could be just a method exposed directly by the mapper. Maybe you can give that a try and see what happens.
Can you add output_unigrams in the formula: maxGram - minGram + (outputUnigram ? 1 : 0) ? This way the default diff is 1 since output_unigrams defaults to true.
The purpose of this thing was to do circuit breaking, I think we can remove it now
It might be nice to name the two `bucket_sort` aggs differently for readability.
nit: could we use `index` rather than `indices`? That is what we have in our docs, indices is just a synonym but I don't think that other clients use it either.
canceled -> cancelled
I think it's good though. less likely to misuse.
fare enough. It would be a settings per index, but I get your point.
`listener` should be marked `@Nullable` here
or maybe we have other tests in this class that already use other formats, in which case it's ok as is
@sabi0 I was thinking that if you override writeBytes instead of writeByte and ignore entire content of the method it should work, but it's a moot point now because I think @bleskes's idea of not including source at all is much better.
I was not talking about moving the registration of the defaults but the `registerAllocationCommand` method.
if we reduce the publish timeout to 0 (which will make the test faster), we need to use the same assertBusy technique on masterNode2 to make sure it has process the change as well.
Since setup is only used during writing and writing is illegal, this can also be the same create error as store.
but this can also be done in another pr.
#19359 will take more time to discuss (so far no reaction at all) and it makes no sense to stall this pr on it. We can remove the examples for now and if we find we keep `IndexLookup` anyway add them again.
please wrap {}
These non-immutable classes :(
Given that only GeoDataGenerator uses this, can we move the method to that class. It seems weird that GeoDataGenerator references ESTestCase
another option is have this ``` Java public interface StreamInput { public <T extends NamedType> T readType(); } ``` and ``` Java public interface StreamOutput { public void write(NamedType type); } ``` and this can resolve all the stuff internallly and if it doesn't know how to resolve it barfs? ``` Java public interface NamedType extends Writeable { public String getName(); } ```
I can confirm that changing the name of the template (but not the index pattern it matches) will not break the Logstash Management UI in Kibana. As long as the logstash management index name remains `.logstash`, everything in the Kibana Logstash Management UI should continue to work.
can we make sure not to delete a file that wasn't created and hide the original exception? we typically do this: ``` bool success = false; try { do something success = true; } finally { if (success) { clean up } } ```
Nit: this could just be `logger.debug("using endpoint [{}]", endpoint);`.
++. PS - We shouldn't optimize for refresh mapping as it's going away.
At minimum this should be typed (we should have separate script classes for each underlying doc values type), but I would much rather this be built into the script itself, so instead of setting the value, an iterate type call is made, similar to the doc values api.
Sorry for the back and forth, I had to do some more digging. CompositeIndicesRequest is not really about the type of operation (read or write etc.) but more about each set of indices and their corresponding indices options that are used to resolve them. Think of _msearch for instance, each inner search has its own indices, which get resolved based on each individual indices options. That said, I am not sure that delete by query should be seen as a composite request, as the indices get resolved once when doing the search. Then it should simply implement IndicesRequest and return the set of indices that the inner search request points to.
Actually, is that true about the non-200s? It is with the low level client.
does not seem harmless, but not sure we should sneak this in here. Also it may be worth discussing what we do when things break here and what we should do instead.
I think this is dangerous - it's correct now since the way we stream guarantee that the bytes ref is offseted with 0 and has a length equal to the bytes array but this isn't guaranteed by the API. I think we should honor the API or, if this turns out difficult assert at the very least.
this is wrong we don't support `topleft` we support `topLeft`
FYI I opened https://issues.apache.org/jira/browse/LUCENE-6148 so that we don't have to use Iterators.size
this getClass() test is not necessary, super.equals already takes care of it
same 1+ randomInt
it seems like `MetaData.Custom` should be and abstract class
What about something like ``` p = nextBufferPos(p); int sequence = 0xFF & sequenceBuffer[p]; p = nextBufferPos(p); sequence = sequence << 8 | (0xFF & sequenceBuffer[p]); p = nextBufferPos(p); sequence = sequence << 8 | (0xFF & sequenceBuffer[p]); node.add(sequence << 8); ``` No byte array required.
If it's not used afterwards, maybe we don't need a ref to the location. We could simply use `.put("location", randomRepoPath())`
I understand the problem, and we will encounter this in many more places. The question is whether this is going to cause problems down the road, which I guess we will find out shortly.
I usually just do ``` /** * Read from a stream. */ ``` The input and output are relatively obvious. Same for the IOException. The IllegalArgumentException isn't, but honestly it isn't a big deal I think. Also not a big deal, more a matter of my personal style preference which I don't want to force on anyone.
we should generate some 0.90 indices here too just to be sure :) they are all Lucene 4.x
> I didn't go further and disallow wildcard queries for all non-keyword or text fields, as some other field types like _index explicitly support wildcard queries. I missed this part sorry. I think we should explicitly add the support in the `_index` field type rather than supporting this query on all fields. Currently the support for `prefix` queries is also broken so we don't really use this ability.
You should be able to collapse this to `IOUtils.close(this.current, uncomittedTranslogs)`
Please revert to `== false`. This is used throughout the Elasticsearch codebase as a more visually abrupt form of negation to not be easily overlooked.
Hrm, why this switch of java imports to the bottom? I had just changed by import logic to match eclipse which puts them at the top...
now that this method does not just select any active replica, maybe we should rename it to something that better reflects its purpose
This file needs a license header.
can this just be an `Iterable<ScoreDoc>` I think it's only used as a such so we don't need to make a copy of it.
I'm a little concerned about all of these "choose a random version" because it will severely reduce the test coverage for the new code? If we are concerned about backcompat, lets have dedicated backcompat tests for pre 2.2 behavior being maintained...
Can we remove this line if it is not needed? At a glance it just looks like a broken test that was "simplified".
Do we need the generic type here? The interface just defines `Object getKey()` but I guess it safes us some casting somewhere else. Just asking.
maybe add some java doc? (emphasising that includingDefaultMapping should be false must of the time)
I think we need check whether pipeline has be specified on the bulk request or on any sub requests here. Right now we always delegate to the pipeline execution service that will execute on the ingest thread pool, which we should prevent if no pipeline has been specified.
I wonder if we should barf already if the field is not mapped or automatically create it in the mapping? I don't think we should throw and exception at this point to be honest!
can we also log the action name and the fact that we're shutting down? Also, I think this can be trace? (it will flood the logs ...)
Similar to above, `[job_id] message`.
No need to be fancy here, just: `logger.debug("got exception", throwable);`.
I usually have one assert statement per comparison in here and just return `true` on the bottom. Easier to figure out what's going on. ;)
we can use assertThat(translog.currentId(), isGreaterThan(currentTranslogId) and get nice messages automatically.
I think this is only called in INITIAL state, so let's `assert currentItemState == INITIAL`
We didn't serialize or use the defaultType of ToXContentToBytes so far, neither in the QueryBuilders nor in any other elements of the SearchSourceBuilder. I think it is safe to ignore this, because the only thing it does is to determine which type of xContent the object is written to when `buildAsBytes()` is called without an argument. It doesn't really change anything about how the object behaves on the shard.
Finally getting back to this! On this look I noticed that this would make hashcode and equals inconsistent which is yet another thing to fix. I haven't really thought through the right way to make them consistent, but there ought to be a way!
Answering here - I would prefer keeping the logic the same for all nodes i.e., any custom change is processed based on the latest cluster state of those nodes. No need to special case the current node as I don't see what it buys us but complexity? without it it can be a simple stream
is this still a bind exception all the time? If not we should update the error message
I also think we should re-throw the exception here and not silently fail
`updated` and `updatedRepositoryType` can be final too
is there any difference? I personally never know which one to pick :)
yea this sounds good to me.
is it true that it's not needed or is it more that we don't want to change refresh semantics in an assert method.
You know, we can add a checkstyle check for those....
I wonder if we can also use `abortIfNotCompleted` here. Finally, looking at `BlobStoreRepository.snapshot`, we should also do the `store.decRef()` before we move to finalization. The store is unnecessarily kept open (possibly causing ShardLockObtainFailedException) and the snapshot process does not check abortion while it is doing its finalization.
ok. I see the parsing code now reuses those object instances in it's parsing logic. I personally think this is overly engineered but not enough to ask you to change it if you prefer it this way. Up to you and @ywelsch then.
Maybe catch `Exception` instead. If there is a jvm error (out of memory and such) then we should just bail and not try to execute the onfailure processors.
we can use constants here from QueryParsers
Sneaky tests, testing all the things!
Shall we add a constructor that takes a `List<String>` and make `jobIds` final? As the job IDs is the required part of the request, I think replacing the setter with a constructor guides the user better towards making a valid request.
Bleh. These are problematic because `CreateIndexRequest` really feels like it shouldn't need stuff "from the server". At some point we'd like to extract it for the high level rest client. Can you make a `source(Map<String, ?> source, DeprecationHandler deprecationHandler)` version of this method and make this one delegate to it? That doesn't solve the problem but I think it makes it more obvious.
s/does you background/does your background
no worries, thanks for catching this @ePaul !
If we went for one suggestion that I left above, on filtering the list rather than the current per host predicate, the selector could decide what to do directly. Either go for another node, or return an empty list, and we would always throw whenever we get an empty list (after also trying to resurrect nodes). The current extension point seems a bit limited in that it doesn't give context on the set of nodes that are to be tried.
Not related to your commit but I think we should return false immediately in case of an InterruptedException.
We have two modes - filtered and unfiltered. DocsEnum is only relevant in the less-common filtered mode and it looks like we already pass that choice of FLAG_FREQS/FLAG_NONE so this would just save the if statement around the call to docsEnum.freq(). > I wonder if we should get rid of all the if's and cache both by default. I'm not sure about the trade-off between removing ifs and caching counts unnecessarily? Signif-terms does a lot of DF lookups and I wouldn't want to add a cache of TTF count for each unique term when it is of no interest to me.
can we make this a regular "readInt" call, and use `-1` to denote that we couldn't compute it? otherwise, 0 can be very misleading
actually I think would simplify things as we don't even have to wonder whether we need to retry or throw exception. If the selector doesn't return any host we just throw, it is responsibility of the selector to return at least one host given one or more hosts. Knowing that, a selector can fall back to some backup plan in case e.g. it doesn't find any non master only node.
this is tricky TTF will not respect deletes, I think you need to fetch the doc though. It's not much overhead compared to this.
I think it would be good to be consistent and always throw
You could use ``` java index("my-index", "my-type1", "1", "some_field", "some text"); ```
You can do IOUtils.closeWhileHandlingException to close these streams only if they are not null and silently
These tests will now, right? Because of the empty on_failure processors? I think we should expect an exception here instead.
strictly speaking, we can log the reason here as we don't know why people called us. We need to either pass a parameter (reason) or remove the last part.
I think that the method signature should change to not throw a generic checked exception, but instead be explicit about the only two that are present here.
you don't need to expose the client to everybody. You can contain which objects depend on the client simply having a handleTermsLookup method or something along those lines in IndexQueryParseService. That one will use the client but that way the client will not be exposed through public getter.
possibly use a `SimpleFileVisitor` here to not override all methods
Same here - more randomization would be nice
as far as I can see in the term query the parser doesn't check if the value is there or not, hence we check it in validate for both java api and rest layer. You are free to test it and verify that what I'm saying is correct. These things are subtle and we are changing them a bit as we go and we learn new queries, so it is always possible that we used a slightly different approach in queries that we refactored a month ago....
(others tend to have a preference for `== false` so I'd recommend using that)
nit: `"it's"` -> `"its"` (or maybe even `"a"`)
Remove if/else by `in.readOptionalWriteable(Snapshot::new)`
I think it's okay to make these lowercase now that they aren't enums
sourceIndexService could be null? (you're doing the null check in the next line)
this one can be private
`o1 +=8;` <== format this file again :)
just keep the change simple that extra allocation
weird to declare vars after the constructor
Here we should be able to get correct flags? Maybe not always, but at least in the context of aggs, I think the search context is available
Suggest: > You should run this tool only if you have permanently lost half or more of the master-eligible nodes, and you cannot restore the cluster from a snapshot. This tool can result in arbitrary data loss and should be the last resort. I'm suggesting to avoid saying "lost a majority" because you also need this tool if you have an even number of nodes and you've lost half of them, which isn't strictly a majority. Also could you explain how it can render the cluster "completely non-functional"? I mean I see how it can break indices, but it should allow a cluster to form and any broken indices can be deleted.
add space after `=`
Can we avoid DEFAULT here? This code assumes that every Path in `roots` uses that filesystem. Technically, they could be different. I would prefer if we avoid get()-like methods for cases like this, and just resolved simply it, like this: ``` for (Path root : roots) { Path normalizedPath = root.resolve(path).normalize(); if (normalizedPath.startsWith(root)) { ... ```
add a a `logger.isTraceEnabled()` check
I see your point, on the other hand I think we can have options that are part of `IndicesOptions` although not exposed to users, even if they change only depending on the api. That was the direction in #6169. It would be great if we can keep a single `concreteIndices` method that knows what to do based on the `IndicesOptions` provided as argument and move this `canFailClosed` flag to `IndicesOptions` without exposing it to users.
I wonder (though not sure) if we can check for the existence of a seqNo and that's it.
since finalizePingCycle will call listener.onPing, I think we shouldn't re-throw the exception but rather let finalizePingCycle do it's thing here: ``` logger.warn("[{}] failed to send pings", t, id); finalizePingCycle(id, listener); ``` at a future change we will do the same with UnicastZenPing
can we add [{}] to the filename
We tend to use `expectThrows` for this when we write new tests. It isn't required but it is a bit cleaner to read.
Is there a need to substract the identical ones? The filesToRecover, which we iterate over, won't contain those anyhow.
we can just call `terminate(threadPool)` here
Maybe we could avoid generating intermediate garbage because of boxed objects by directly creating the primitive array, eg. something like: ```java int[] v = new int[values.size()]; int upTo = 0; for (Object value : values) { if (hasDecimalPart(value) == false) { v[upTo++] = parse(value, true); } } if (upTo != v.length) { v = Arrays.copyOf(v, upTo); } ```
:+1: I like how this method abstracts the way sub aggregators should be collected and how you can mix deferred aggregation with sorting.
I didn't mean to revert the changes made after SImon's review, I meant to revert the variable rename from key to header.
If you think lots of places will use the empty definition then I don't think it should be abstract. I thought only a few script would use the empty definition though.
We should also have tests for testing the ordinal value of each enum value (`Enum.ordinal`) and for checking that reading a random invalid ordinal throws an exception. See ShapeRelationTests for examples of what I mean
It's too bad our settings don't mimic the `Map` `getOrDefault` to make this one operation
can you format this, there is a space missing after `=`
then I guess the equals method is wrong too cause auto != AUTO . I think I would try to uppercase (or lowercase) when parsing and make this case insensitive that way.
@jasontedor Very minor typo, but should be `/proc/self/cgroup`
I think the version should be 5_1_0
Although this change is correct it is not necessary. An inline script with no parameters can have two forms: ``` "script": "scirpt contents" ``` or: ``` "script": { "inline": "script contents" } ```
> This is not correct? Each node created by the cluster uses a random data dir. All the cluster nodes put their data next to each other, under the current working dir. After you run the tests, check for example: `target/J0/data/` . As I said, I really don't think you should remap data paths here. Just use what the test cluster decided for you. Not starting an extra node is a bonus.
There are a few issues here. First I think we have a race condition here. Moving this check to the the repository level will not remove it right now, but will tighten the loop. Hopefully, we will solve it there at some point of time with tightening the blob store api and adding locks. The second issue is that it can be done more effectively on the repository level.
can we change this to await busy? then we don't need sleep ...
We may also potentially want a way to have ILM delete the source index automatically after the rollup has been successfully completed, in case the user wants to do a destructive rollup
This is logic that I think should go into ReplicatedOperation.
Yes, that is what I meant.
We should be using a new script context here. Then this can be SimilarityScript.Factory. The new context can return `float` directly, and take Stats as an arg.
this method became useless I think? the whole try catch can be removed as it's handled by the caller in the `ClusterService`. I think we should break applyUpdate into several methods each updating a different parts. i.e., updateNodes, updateIndices and now the now updateCustoms
`String description = request.getDescription() == null ? filter.getDescription() : request.getDescription()` for readability
You could use SetOnce if you want protection from overwriting.
Everything else is `Deprecation` so I think this should be too. Also, I think that `registerHandlerAsDeprecationHandler` might be a clearer name since we are really wrapping a handler.
similarly to the read, you need to protect the write with a version check. Additionally since you changed the parent setter to not set the routing, I think you would need to do the following: ``` java if (out.getVersion().onOrAfter(Version.V_2_2_0)) { out.writeOptionalString(routing()); out.writeOptionalString(parent()); } else { String routing = routing(); if (routing == null) { routing = parent(); } out.writeOptionalString(routing); } ```
hmm we do this twice? this looks odd
nit: no need for extra parens
we can just use the enumSet.toString here (assuming it gives nice output). This will make sure we are never out of sync and I think it's OK to have a technical message here.
I'm not sure if it's worth the complexity of this code here just to provide a better message as to why an index service got removed. If you think it's useful, maybe factor the logic of determining the `AllocatedIndices.IndexRemovalReason` based on currentState and newState into a helper method so it can be reused by removeIndices
These are cosmetic changes, let's revert them here.
Nah, if it hasn't hit yet we'll handle it if it does in the future, don't worry about it.
can we please only have one value for this. there is no need to have more than one IMO
Oops, sorry, brain fart. :)
I see your point, fair enough
a bootstrap API will use networking an have this thing arrive in different times on the node. Should we already simulate a short network delay here? (i.e. schedule as a task)
Shouldn't this be `return writable.readFrom(this);` ? Otherwise we return the ref retrieved from the supplier, which can be IngestStats.PROTO
wondering if each index in the list should be added separately... such that the header will hold a list of indices and not a list of a single comma-delimited string of a indices
Please use `org.elasticsearch.common.Base64` and not a sun API
why do we need assertBusy here? I rather use two signaling methods - the one you have now and the one signaling the some/all the threads have acquired the ops lock. Note that now I think you have a race condition with the recovery thread can sneak in first.
> If set it to `MAX_VALUE` or something and it goes wrong the stats will be extremely off and hard to recover. Well, it would only be when assertions are enabled. > Felt like an overkill. Okay.
nit: one too many line break? :)
We render a subsetSize as the DOC_COUNT field in the surrounding aggregation, I'm not sure if this is equivalent with the bucket subset size but maybe it could be used here? Probably would need some checking with somebody who knows the aggregation better though.
and I think we should leave periods out of log messages too
Is it still used ? @elasticmachine test this please
I think it can fit on one line
Nevermind, I just got to the part where this is overwritten in CompletionSuggesterBuilderTests. Quiet tricky though, I wonder if this could be made somewhat easier to understand, haven't completely wrapped my head around it yet.
ah right, oops. anyways, a positive outcome!
if you change the `.toString()` method to not use fileswitch this will need to be changed also.
same as before: shall we check what the current token is? if it is a field_name we could use a while instead of a do while? that would be a bit more readable I think.
Yes it can @mayya-sharipova but if we restrict the counting to `scroll` queries let's use an AtomicInteger. The overhead should be limited since we create the search context for a scroll query only on the initial request.
maybe `collate_match` can be True, False, Null (omitted if Null in XContent)
if you put it like that, you can undo c08cd8b
hasArray API concept is that it is backed by a direct reference array, so calling `array()` is cheap (similar to netty `ChannelBuffer`. In this case its not, so this should return false, and `array()` should return null.
This triggers a checkstyle error regarding star imports. Reproduce with `gradle precommit`. Note that there will be a few other checkstyle errors too from other classes (line length > 140; star imports).
maybe just implement `Iterable<IndexShard>` here and inlcude the primary... would make the streams below simpler and we can simply write: ``` Java for (IndexShard s : this) { s.refresh() | s.flush(); } ```
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
this log message does not contain the right "before" local checkpoint as you moved it to after the local checkpoint reset
Sorry I wasn't explicit, I meant create a GH issue and link here.
If we already break the builder API by changing the value-getter, it would be great to somehow also restrict the constructor to not accept every value type anymore. Maybe deprecate this constructor and instroduce new ones for String and Number? Not sure if also Date type is handled correctly when parsed to String here. In general I'm unsure here to how far this PR should change the status quo. I think only selected Object types worked here in the past, it should be stated somehere (docs?) what actually works. In our own code we really only use the constructor with String argument, so at least internally we could easily change that, but not sure how many client code this would break.
maybe use `IOUtils.close()` handles `null` values
can we doc the new methods here too, since they are on an interface, they represent a contract.
Can you drop this method and just call the constructor instead? I don't think it buys anything.
why do we need two of these? can't we have just markShardCopyAsStaleIfNeeded? we can rename `markUnavailableShardsAsStale` to `markUnavailableShardsAsStaleIfNeeded`
ah ok I misunderstood what this was doing, I'm +1 on it working as you describe to match keyword fields
this should always be non null now
Could this make finer assertions about the state that the publication is in? More precise requests follow...
I think you should have all options listed here and don't use default. Be explicit here please
any time we measure deltas (how long something took) we should use nanoTime. currentTimeMillis can be reset by ntp ... if the bulk api uses it for this purpose, it should be fixed...
we should call onFailure here. I wonder if we should have a utility pass through TransportResponseHandler that takes a channel and passes the response to it.
how do you feel about renaming this "force merge" instead of "optimize"? (may be out of scope, just curious)
I actually meant an error (http 400)? Messages can be ignored. This is just an invalid configuration.
I think I need to reset the DV :)
I think the reason whi Jim did so is that this is the method that is implemented by all fielddata impls regardless of whether they use numerics, binary or sorted doc values under the hood.
Lifecycle component is not concurrency-aware, and not all methods that create the blobstore etc. are guarded by "if-not-closed" checks. We need to guard against creating a blobstore / container after the closing has started
this way we only test against non existing types, I think it would be worth to test against types that we have. Have a lok at what we do in IdsQueryBuilderTest#doCreateTestQueryBuilder for instance
Minor, but both places that use this could avoid assigning a value by always using the contents of `else` block if this were initialized to `0`. ``` Int cnt = termFreqMap.get(term); if (cnt == null) { cnt = new Int(); termFreqMap.put(term, cnt); } cnt.x += freq; ```
can we not read the indices from the cluster state response instead of resolving them manually again? I guess I don't get the order problem...
You can use assertAcked(client.admin().cluster().preparePutRepository(repositoryName) .setType(FsRepository.TYPE) .setSettings(repoSettings))
I don't think we need the unassignedDelayedShards anymore, right? now that findSmallestDelayedAllocationSetting only takes delayed shards into account.
Should probably make these `final` where possible.
wtf is this yield doing here? ;)
can u also add a set to the withWaitForCompletion
Somewhat related to this PR: should we just remove this code? this "save/restore" is quite complicated, and I know for a fact it never happens (we don't have any OS we have ever tested on where thread cpu time is _supported_ but not _enabled_, and if such a situation were to present itself, we'd surely want to know what the implications of switching it on temporarily are). I know this because this method requires permissions that we don't grant `ManagementPermission("control")`, so it does not ever succeed. We don't have to do this on this PR though, but it definitely makes the code here complex.
wondering if extracting this block to a new method would make it a bit more readable, I have no strong opinion though
so I think the issue here is that `\u001F` is a reserved char in the suggester (we move to it lately). What about `\u001D` instead? (http://www.fileformat.info/info/unicode/char/001d/index.htm) once you do this you need to add it to `CompletionFieldMapper#isReservedChar(char character)`
looks like a leftover
I wonder if these checks for the lucene query are necessary given that we already have createExpectedQuery and the comparison between that query and the result of toQuery
it's a delta, mandatory argument in comparisons between double values.
Nit - there is a stream::toArray(Directory[]::new))
let's see if we get objections on that PR or not
actuallt are we sure it's good to just ignore it if field is null? I would rather leave as it was (it throws NPE) and throw IAE ourselves, not much difference though
Some more candidates for `ESTestCase#randomValueOtherThan` here.
look into `StreamInput#readMap`
I think we need to support backcompat here. You can look at version.created in indexSettings, and then only accept the old setting name if before 2.0 final. It would be nicer if we forced the upgrade once, when loading the index, but I don't think that is currently possible without a bunch more work.
this is already logged in the shard state action
I think that we can do without this flag, it could be a util method that returns a boolean depending on whether values are set or lookup details are.
Thanks, it is probably also worth changing the other exceptions thrown in this method to ParsingException as it is a more appropriate exception to throw here compared with e.g. IllegalArguementException
Oh never mind. I misread the grammar. The elvis operator applies to the call, not the var. Sorry, trying to think about too many casts at once :)
Do we want to be exposing more java.util.regex stuff? We've been trying to be careful with that package. Is there a version of this that take Lucene's regexes? You can limit the time and space complexity of those....
construction contractor? :)
Any chance you could group this so `unit.isMillisBased` is called once? I think it might be a bit easier to read if you juggle the "arms" of the `if` statement.
maybe use `atLeast(250)`
I think it needs another `else` block with `throwUnknownField(currentFieldName, parser.getTokenLocation())` here
It's from a [suggestion I made in an earlier pull request](https://github.com/elastic/elasticsearch/pull/17804#discussion_r59959473). The codebase is not consistent but there is definitely a tendency towards having a blank line between the opening of a class and its body, and its body and the closing of a class. It's not a requirement, but I think that it looks nicer this way. ð
Had missed that `predictions[i]`. Think in that case it's better as is.
I would remove the word current here as its the strategy the user is trying to set that is the issue not the one already set
I just go with a TreeMap automatically if I know I'm going to iterate on it. Not required though.
does it make sense to check for null beforehand and throw exception? we don't want anybody to call this method and explicitly pass in `null` I guess.
Most of the imports here are not used
I think you still can add the named patterns, since the files are still on the class path? ``` java grok.loadFromStream(getClass().getResourceAsStream("/config/ingest/patterns/aws")); grok.loadFromStream(getClass().getResourceAsStream("/config/ingest/patterns/bacula")); // next file ```
is it necessary to parse everything into a map in the first place? At some point later on we do need a map, but I wonder if we can postpone calling parser.map till then.
not terribly sure about this. we could still recover the right status code although there was a problem reading the body... not sure which exception should win :)
Since lifecycle methods are not doing anything and are not invoked either, it might make sense to extend AbstractComponent instead of AbstractLifecycleComponent here.
Maybe we can make it slightly more efficient by storing eg. a "totalNumKeys" parameter on the aggregator which is equal to filters.length when showOtherBucket is false and filters.length+1 otherwise. Otherwise if you do not need the other bucket (default), you would waste 1/filters.length of the bucket ord space
I think when this is rewritten, I would prefer to have an `.isConcreteIndex()` method on `AliasOrIndex` to avoid the double negatives in comparisons, I had to stare at this for a while to validate it is working correctly.
I think this should also concatenate the underlying `FlushRequest` `request#toString`.
Since the purpose is to replace eg. range queries, I am wondering that we might want normalization to behave like range queries so that scoring is the same (that would come ootb if we extend ConstantScoreWeight and don't extend getValueForNormalization/normalize). I realize this is not really related to this PR since we already have the issue today in master since we use Lucene's MatchNoDocsQuery which also returns a norm of zero, so maybe it would best be addressed in a follow-up PR? (do as you prefer)
Do we gain anything by passing a reader into `parse`? It seems like it'd be easier for testing if you pre-read the file into a String or a list of lines and then passed it into parse. Are we concerned about the memory of reading `jvm.options` up front? (It would also let us separate errors reading the file from errors parsing the file from a feedback perspective)
ShardRouting#getIndexName() is good enough, the index uuid is just distracting here
I think we should just log the error. As @dimitris-athanasiou said, if it fails here the job will have a status of `open`. So anyone who reacted to the failure to open by trying again would be bemused to find out that they couldn't open the job the second time because it was already open.
This swallows the `numberFormatException` but it should instead be wrapped by the `ElasticsearchParseException`.
Calling this just `primaryTerm` is confusing (in light of a future PR that uses this code during resync). Here it means the term of the primary that was sending this operation, not necessarily the primary term of the log entry that is being replicated.
Can we add another TODO here? This seems massively inefficient: 1. expressions know if they refer to score, true or false. in lucene, Scorer.score() will only be called, if the expression actually needs it. 2. here it seems, something calls score() always, and passes it to the expression even if its maybe not needed? so it might be called uselessly on the scorer, even if the ranking function doesnt use it. 3. passing score in this hacky way im sure prevents inlining of actual scoring function into the expression and hurts performance.
Can we switch to using the method that returns `Index[]` and use the index uuid rather than the index name as key in the map? That will help with the upcoming cross cluster search feature ;)
should be ThreadedActionListener<>
Nit: Almost ;-) To be or not to be, and also where, that is the question.
nit: IMO `sort must not be null`
Actually the main confusion in the original issue was that the error that was thrown did not say which field in the request caused the error. However with this fix as it stands, if the user sends the wrong type of object for a field (say a String instead of an object) the error will not tell them what is wrong. I think we should add the token to the message, and possibly also the token we expected in this case too.
I prefer to use the word "force" somewhere in the message to make it clear that this is not rebalancing based on weights.
I think what gets returned by singletonList is already immutable, no need to wrap it with unmodifiableList too.
Those last checks are redundant. We should do only one of them.
afaics, all accesses to listeners are under lock, but I may miss something.
I think `query` can be null here in 1.x and before, we should double check before calling a method on it.
could be shorted using `com.google.common.io.Files.write`
could be made more concise/efficient by using Stream#anyMatch or Stream#allMatch
should rather -> must
I think you should port this to the new settings infrastructure.
I don't think this should be randomized. If we test toString, we ought to test that one all the time. If we also want to test something else, I think we should make that part a separate test method.
should we check that the query is not null too? seems like the parser does it.
I think assumeFalse would work better here showing us if the test actually ran or not.
One more thing, maybe you want to have a testEqualsAndHashcode like we recently introduced in the query-refactoring branch, just to make sure that equals and hashcode are properly implemented.
waitForMappingUpdatePostRecovery defaults to 30s, give that the timeout now results in a failed shard (good!) I think we should be more lenient. Especially given the fact that local gateway recovery runs on full cluster restart where the master might be overloaded by things to do. How about something very conservative like 15m (which is what we use for the same update mapping - see RecoverySourceHandler#updateMappingOnMaster)
no worries, this one seems indeed a good candidate to be tested via unit test :)
and maybe drop any improved description here too
I was wondering what the difference is between an exception that is created not going through parsing, and an exception that gets parsed. Wondering about the message specifically.
could be `status.getStatus()` in the event we change the local variable above.
oh, I missed this. thanks
do we need the Iterator/do-while? should this just be: ``` for (Accountable child : segment.ramTree.getChildResources()) { toXContent(builder, child); } ``` this would be better than the current assert + do-while code shape. I don't see what the current assert guards against either.
use `assertNoShardFailures` here please
Maybe this should even be ``` java if (Double.isNaN(v1)) { if (Double.isNaN(v2)) { return 0; } else { return 1; } } ```
can we add a failure message saying "inactive shard state shouldn't be persisted".
nice that this is removed.
use assertBusy instead.
this is now redundant. openTranslog commits when openMode == EngineConfig.OpenMode.OPEN_INDEX_CREATE_TRANSLOG
> it can be but not removing to have a easier time backporting this to 2.x ACK.
You can change the equals template in intellij to use Objects.equals
if we do so, I think this becomes a simple stream reduce
It was deprecated prematurely. It has functionality that is used in Kibana and which we need to replace before we can deprecate or change this.
> The allocation id has only been added to ShardStateMetaData in v3.0.0. Good point. I'm fine with leaving as is
s/toa /to a /
nit: extra line
This bikeshed is going to be very multi-colored by the time we are done with it. :smile: +1 for @ywelsch's proposal, but I do not like `UnsupportedOperationException` here but `IllegalStateException` would be fine. I think of `UnsupportedOperationException` as being reserved for cases where the receiving object does not support the invoked method, but `IllegalStateException` as the receiving object rejects the invoked method because of the current state. :angel:
I was hesitant in the beginning due to the need for the additional class, but this looks great, it simplifies also concurrency as we read only once per node from the blacklist, so from then on we don't even have to retry as we kind of act based on the previous view of the blacklist. Not only does it allow us to remove the max_attempt, but also to remove retries due to the concurrent changes as a whole!
And the compiler is right: Before the super constructor is called, this is not yet useable, not even defined according to JLS. And we create the inner class _before_ the super constructor is called (argument is evaluated first)!
I think it is ok to use the Version from Version.java.
Extra space is extra.
I think this method should throw IOException
That's java 1.8 construct
@martijnvg After the last write operation, we might need to sync the global checkpoint manually in the test `leaderGroup.syncGlobalCheckpoint();`. This is fired async in the production code.
does it make sense to replace `new TestAllocateDecision(Decision.NO)` by `new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO)`.
Maybe it should just be `long` instead of `long_sort`.
can we move the catching logic to `constructPipeline(...)`? then we can create unit tests for this and remove the java integ tests in `IngestClientIT`.
if you use vint you can't write negative values :)
should it not be required? If so I would move it to the constructor of the Builder and remove the setter for it.
I would replace ` - ` with `: `. s missing: di**s**covered
I think this needs to be `@param` in order to be picked up correctly.
I don't think you need to this, the internal cluster will call the node settings automatically.
I think we can just move this all out of the try block and then we don't need to assign this to any value since int he finally block we simply decrement the counter. this would simplify this a lot I think
Makes sense. Thanks for the explanation!
we should start thinking about testing the parsing phase for things that we never output from doXContent.... :)
(Not part of this, just asking hypothetically)
Thanks for writing this. Wonderful.
This is a great suggestion, I think it should be a warning in the server logs as opposed to an additional warning header that eats into our budgets.
I guess these two requests are really the only requests where you can't call `getVersion` on the stream.
then use `Collections.singletonList()`
this is great
A `Collections.newSetFromMap(new ConcurrentHashMap<>())` would be more efficient IMO.
sorry I re-read it, missing is appropriate, maybe we could rename the constant to MISSING_FLAGS then
I think we simplify this code by merging the two use cases. The only difference is the exception that goes into the BulkItemResponse.Failure object. Can we have that as a variable instead of isClosed , i.e., `Exception unavailableException = null` and later check: ``` if (unavailableException != null) { BulkItemResponse.Failure failure = new BulkItemResponse.Failure(request.index(), request.type(), request.id(), unavailableException); BulkItemResponse bulkItemResponse = new BulkItemResponse(idx, "index", failure); responses.set(idx, bulkItemResponse); // make sure the request gets never processed again bulkRequest.requests.set(idx, null); } ```
we can omit this set no? maybe do ``` if (randomBoolean()) { queryBuilder.clause(null); } ```
`Matchers.equalTo` or `equalTo` with a static import is more normal for this sort of thing I think.
remove the super call
can we remove this default ctor and pass the non-recycling closure in the test directly. I think it's just one place.
we discussed this and we decided to leave it for ease of use, just keeping only the most common (required) arguments, index, type, id and path
Do you think we would gain something by using directly the long bits to sort? (in the future, we need to switch to the lucene comparators first)
Maybe the post parse phase should become a class of its own: I am thinking this could help readability, clarify what it needs and what it outputs, and possibly even include some logic from IndexTimeScriptContext
We should debug log here the number of times that we have retried up to here.
I think I'd prefer to check `listedNodes()` instead of `filteredNodes()`, which wouldn't be empty if the transport client used the right cluster name (`foobar`). Otherwise it feels like we are testing two things at the same time (filtering out the nodes and updating the version)...
I think this needs to be `randomLongBetween(random, 1L, Long.MAX_VALUE);`, since the validation check makes sure the interval is a value greater than 0.
This can just be `System.getProperty`? I thought the point of `BootstrapInfo.getSystemProperties()` was when you wanted to call `System.getProperties()` (which we have in forbidden apis)
I think you can just go with `threshold + 1` on the write side and `threshold - 1` on the read side
e != t :) I think this will be simpler to read if it has a top level with TransportActions.isShardNotAvailableException(t) and then the right handling bellow it.
Should probably annotate this as `@Nullable` since it can return null, just to make it explicit
+1 for the 0-based partitions, this would be consistent with the `from` and the `slice`.
> In the latter case it would fail the query early because useAllFields freeze the fieldsAndWeights map. I think it's better than the current behavior which accepts this query but fails when the query is actually built (fields and useAllFields are mutually exclusive) ? Sure, that sounds fine, as long as we're okay with this failing (esoteric) use-case. > For the first example I don't know if it's really a problem. Maybe we should just disallow useAllFields(false) ? I don't see a good reason to unset it especially now that the index default field defaults to * ? Yeah, I don't either, the only argument I can think of keeping `useAllFields(boolean)` is that then it's apparent it's a "setter" and not a "getter"
Please add this to the package-info as well.
alread => already
shall we flip this outer if? `if (fieldNamesMapper != null && fieldNamesMapper.enabled()) {` looks a bit nicer to me
Extra ` `s
I see. We can't bail here because we won't do the disabling that we need. Got it!
Would be great if the decision on whether to include the items can be made earlier. Maybe in `TransportBulkAction` in the `finishHim()` method around line 541? This would then save creating bulk item response array. Would be great if we could make this decision even earlier, so that no shard level response items are collected. Then in the case that there are failures then we could serialize the successful items as null elements? But then I'm afraid that we break the bulk response format.
In order to care about the defaults in a single place, we usually prefer using `Boolean` in the builders, with `null` meaning unset. This way, if we want to change the default to true in the future, we only need to do it in the parser (not in the builder).
whitespace before and after `=`
to me we only have node and index settings, the settings that are dynamic are updated in the cluster state so we are already there
yes I would adapt the docs, let me know if you prefer me to take this over given that it's becoming a bigger task.
> Why do you think that? Does having a hard reference to an object guarantees all weak references to it are kept around? I was worried the GC might decide to remove a weak reference just because, in which case we will create another marker. Again - not saying this is wrong, but looking to learn.
annoying :) I'd be nice if we could share it somehow
I think we should be able to assert here that the `metaStateService` is in its "reset" state, with no pending writes (i.e. empty `cleanupActions` and `newIndices` and `globalGeneration` matching that in the `currentMetaState`.
ð much cleaner. There was no need to stop a node inside the callback.
thanks a lot for taking care of this, I couldn't figure out why this tests was so slow :)
ok sounds good. maybe add the `case 1:` then.
It looks like all of this section is whitespace changes (extra blank lines, additional indentation) that aren't needed.
s/it/in , also not sure what you mean with "the BytesReference will be removed in a future commit", maybe the sentence needs to be clarified.
This is outside the scope of the PR, but we should look into requiring vars to be non null in the future
maybe the reason can simply be "primary " + shardId + " is already assigned".
@javanna would it make sense here and for all JSON parameters below to use a `ParseField` object instead? For example, here you could define a `QUERY_FIELD` of type `ParseField` and make the conditional here `parseContext.parseFieldMatcher.match(currentFieldName, QUERY_FIELD)` This would also allow you to specify camel case variants like you are checking for some of the fields below.
Ignore the last bit about gap policies...I was confused about how this bit of code worked. Started playing with it and cleared up my confusion :)
This line is longer than 120 characters so CI will reject it.
you don't need to create a new array. the argument is a vararg
nit: assigne shell.size() to a local var? seems safer to me :)
I think for simplicity we can use the default float value here directly? just skips a condition down the road I guess.
It should now be possible to make up the `RoleArn` and `SecretAccessKey` using the seeded RNG rather than by concatenating strings like this. They can reasonably be different each call.
Can you use a word other than `clone`? It makes me think of the `clone` method which this isn't. I tend to use `roundTripped` or something.
I really wonder if we should have `Strings.toString(ToXcontent x)` I think we have this code in a lot of places
Ok sounds fine then.
buildInListeners -> buil_t_InListeners (and in other places..)
I think this doesn't work since rounding is not always idempotent: if this is used as a sub aggregation of a PER_BUCKET aggregation, an HistogramAggregator will be created several times and each instance might have different bounds.
A description here on why someone would want a custom name resolve would be nice.
should we use a long just to be on the paranoia side of things
This `,` is optional in English. I don't tend to include it most of the time so I wouldn't change this.
Just a question: this means we are failing the whole rank_eval request here, no? I think this is okay, as long as this is what you intended.
oh boy, so this test sets a field called "index" to value "index" which is contained in the "_index" field. I must admit I would try to make it a bit easier to read using different values if possible.
I'd remove the word `post` from the beginning of this method name. We don't usually specify the request type when it's POST.
thanks a lot for adding this!
imho having `hasUnassigned` and `hasUnassignedShards` methods is very confusing.
yes. I should have been more precise - the usage of SequenceNumbersService.UNASSIGNED_SEQ_NO is only relevant due to a BWC aspect.
@s1monw With that change, when running a suite which had a lot of tests, `ElasticsearchRestTests`, when you have a failure in one test, all other remaining tests will restart a full cluster. We should only restart the cluster once until we get another issue.
Can you regenerate the query in this case? Skipping tests based on something random can make refactoring like the `@Test` work that I just did difficult. Even though this is super rare.
This exception should probably be raised in the `PluginHandle.parse` method and/or constructor to avoid any issues. Otherwise, if `name` is `null`, then `PluginHandle.parse` will throw a `NullPointerException`.
Why do we need to convert to an array? In general I think we should try to use either lists or arrays everywhere instead of doing back-and-forth conversions? (not for the cost of the conversions, more for consistency) Maybe this should be a different PR though, it looks like an existing issue to me. It was just weird when looking at the diff
indicesClusterStateService should not have changed, so no need to refetch from the map.
remove the super call
you should change the writeTo method to take care of nodes on older versions like in DeleteRequest
I don't think we should initialise to empty string. Why not add an assert here to check for null? This should never be null here as that would mean we got a value before a field name.
one more line break? :)
can we just have this variant not the one that takes a String.
I wonder if we should make these Map<Index, IndexService> - it will remove all these index.getUUID() calls..
Unlikely to matter, but you should put this assignment above the handler registration since it hands out a reference to an incomplete object that _could_ cause trouble.
I wonder why we don't implement the `HashFunction` interface for `murmur3` and then simply use this here without all the other code chances? We can deprecate the version with the `type` too and force the new `Murmur3HashFunction` to just use the ID? for new indices we should just barf is somebody sets to use the type.
++ . I like this better then the listener.
oh right....that is what I was missing, inner queries may come with their boost as well, would work only for leaf queries :)
I think we have this code now in many places, we should factor it out into `ESTestCase` or a test helper or something.
The sizes are `long`s so I think `randomLongBetween()` would be better.
I didn't know that, thanks for checking!
maybe we should just build a map for this? I don't like the linear nature
I'd make the string here `"junk"` or `"not interpreted"` or something. If you don't read the file carefully it looks like the script is run because that is a valid looking script.
maybe a regex would be more readable here :)
could be `final`
I think that the idea behind that was not to log on error level when node was no longer master (as node leave don't matter in that case anymore).
maybe we should expand testing a bit, just to make sure? the byte representation is quite convenient as it doesn't require the usual base64 based testing for these bw comp scenario. I think that we should test more of the previous values, if not all.
Maybe a method on `StatementMetdata` to copy the appropriate metadata. It saves a few lines of code and forces you to name the operation.
Please can we create an audit message _as well_ as the annotation. One shows up in the config view and the other in the results view.
When I first started contributing that was something I thought about. I tried to puzzle out what setting would cause the least churn and still let Eclipse handle all the imports for me. I set the setting and then pretty much ignored it.
I think this is fine for now. While I do think expert users will want to tweak exactly which metric they use for evaluation, I guess it's ok to not make this plug-able right from the start.
there is a method called `anyMatch(...)`. This will also make it return true on the first occurrence found
so if the manager would be folded into this class we could make this just one call? I think we should do it and fold it all into this class
I'm doubtful. I wonder if we should do this or follow the proven path we have in the listener interface where we have a processed callback (changed or not). I'm leaning towards the later as it gives more options (with the burden of an extra equality check).
please add the discovery type to the exception message. You can access it with `DISCOVERY_TYPE_SETTING.get(settings)`
Rather, I only see you serialize it but I don't see it accessed.
Simpler: `snapshotIds = in.readList(SnapshotId::new);` No need to create lambda :-)
Or use [`Math.toIntExact`](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toIntExact-long-) on `writtenBytes - checksumPosition` and do away with the extra `if` and `else` (less lines of code)? ``` int index = Math.toIntExact(writtenBytes - checksumPosition); footerChecksum[index] = b; ```
oh boy I am sorry! I thought it was moved down in the same class, your initial change made sense, next time fight back :)
me neither, I did some googling :)
unkown -> uknown
After discussion in another channel - I understand the release method will be called from other places too.
+1 other than than LGTM
nice, I thought I checked out the test data and that field was keyword, but close enough. Ping me if you notice anything when playing with runtime fields ;)
executes already checks for cancel. No need.
I know this is out of the scope for this PR, so this can be ignored... should we just get `nowSupplier.getAsLong()` once in this method and reuse its value? I'd imagine seeing three separate values here for a single step change can be confusing
nice all the branches are gone!!
Nit: I think you can leave out ESTestCase here.
Yeah, I think this is a good idea.
This has to be ``` .addPathPartAsIs("Strings", "hard", "coded") .addPathPart(indexUpgradeRequest.index()) ``` for sanitization
hey can we rename this V1 to ChecksummedTranslogStream
`false == Strings` is our style and I've grown to rather like it! I find it a little more obvious.
This should use ephimeral ids, not object identity
haha! I was pretty sure you were going to answer that :)
I think this block would be simpler as: ```java if (accessKey.length() == 0) { throw new IllegalArgumentException("Missing access key for s3 client [" + clientName + "]"); } if (secretKey.length() == 0) { throw new IllegalArgumentException("Missing secret key for s3 client [" + clientName + "]"); } final BasicAWSCredentials credentials = new BasicAWSCredentials(accessKey.toString(), secretKey.toString()); return new S3ClientSettings(...); ``` Instead of the nested if statements and double-negative-ish `if` statements
This is weird as this value is not returned with the response. But we can hardcode the formatter because this agg doesn't support format? I am a bit confused. Ideally we wouldn't have to implement this at all.
nit: maybe the null check isn't necessary
I think it would be easier to read if we use the string representation to create these: http://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html#fromString(java.lang.String)
Thanks, these are easier to read.
I see one thing that looks weird in this class: ``` @Override protected void doXContent(XContentBuilder builder, Params params) throws IOException { if (positiveQuery == null) { throw new IllegalArgumentException("boosting query requires positive query to be set"); } if (negativeQuery == null) { throw new IllegalArgumentException("boosting query requires negative query to be set"); } .... ```
one `[` too much
I suggest we remove _source. handling as well..., including in get.
I wonder if it would be better to use `ClusterServiceUtils#createClusterService` and other utility methods here. It reduces the mocks that we use
maybe just extend the note to say: doesn't check docsWithField since we replace missing values in select() ? Took me a while to figure out why this was safe
I think you can initialize the capacity.
can we make a constant out of the -1L it's easier to see where it's used :)
must be param prefixes now
now that we have `GsubExpression` (hurray!). we should probably define an equals, where the `pattern` field is compared using the `.pattern()` command since that seems to be the proper way to check equivalence between `Pattern` objects. then these assertions would be simplified as well.
can we open an issue/track it somewhere that these should be evaluated
Something like `settingsModule.registerSetting(S3Repository.Repository.KEY_SETTING);` registers a global setting named `access_key`: once done, nothing else (core or another plugin) can register a setting with the same name. And it laos registers it as `Filtered` so I guess every setting with the same name is filtered out from every places? That seems wrong to me because the plugin only need to retrieve the `access_key` from repository settings and to filter out this setting from the repo settings. I think we should find another solution but not register this as a global setting like it is in the code.
QueryBuilders should always set the defaults since they can be constructed without ever passing through the parser (Java API)
oops. Missed it. You're right.
or maybe "shard cannot remain on this node and is force-moved to another node"
I think using `ConstructingObjectParser` would make all these parse methods much clearer
Similar to [`CopyOnWriteHashMap#copyAndPutAll`](https://github.com/elastic/elasticsearch/pull/13533/files#r39337198), what do you think of the following? ``` Stream<Closeable> closeables = pluginsService.indexServices().stream().map((p) -> indexInjector.getInstance(p)); IOUtils.close(closeables::iterator); ``` This saves an allocation of an `ArrayList`, and possibly multiple backing arrays as the elements are added to the `ArrayList`.
I was just trying to see how we could make some variables final so that the compiler ca help us. In addition this one variable looked to me like you would almost always want o use a custom weigher.
Same question about tracing the cleanupOldFiles method run.
can we assert that the first 2 bytes are actually `E` and `S`
we can use ElasticsearchAssertions.assertThrows. Slightly cleaner code.
Nit: `currentThreadNamme` -> `currentThreadName`
uh good! :)
Static is about whether there is state needed from the outer class. This is still package private, so I don't see it as a problem for someone trying to construct this (especially since it is all within the geoid plugin project anyways.
I think we may need to move Settings to the Builder. It makes more sense that the parser knows about the builder, cause it creates it, rather than the builder knowing about the parser.
Curious about what happend to this parameter.
doing this via reflection would be nice too :)
I do see the reason why we need to make the `HighlightQuery` public, but I'm not sure about the constructor. The object gets created by the HighlightPhase and ideally the highlighters would just rely in the instance created there.
please don't use two letter variables names for acronyms.
we may need to go over all the callers of the new NamedWriteableRegistry#register and see whether they are compliant to the decision that we have yet to make in #17458 :)
ok, then i am fine with it! Maybe we should followup and consider moving it to a base class and we do this stuff in a consistent way everywhere. I bet we will find test bugs.
nit: no need to go through the getters for these three fields
maybe this setting should have a more descriptive name too
Since Min and Max are the actual functions, `extremum` seems like a better name.
minor nitpick: there seems to be an indentation issue with the closing bracket
I'm wondering if we should just never remove if there are no active copies? it's a simpler edge case to understand and it covers this scenario. I think it's even equivalent (i.e., the last active shard must be a primary).
funny, we were testing the setting and the test succeeded although the setting was ignored? :/
IMO it is write because the cluster is changing (an action is happening in the background), and metadata because it is not changing data (it is changing the underlying storage, but from the user perspective the data is not changing).
`newMaxWrnHeaderCount` -> maxWarningHeaderCount` (and reference the member field by dereferencing `this` then).
can we detect this rather than catching this exception? I'd feel better about it if we could
That'd be a "no" then.
@uschindler -- Does your solution fail for `int x; def y = 2.0; x = (int)y` ? If it does I think this line `if (last instanceof ADefLink && this.expected != null) {` needs to be `if (last instanceof ADefLink && this.expected != null && !explicit) {` Otherwise, we will not properly cast in the case of explicit casts because the expression.actual will match the expression.expected already.
oups no, that just me not reading the change correctly
I have no idea too...
By the way should we throw an error if the loader generates a null value? I'm unsure if we need it and it makes the cache harder to manage (or just bad if we keep on regenerating null values)
so to me the biggest issue is that they tend to cause NPEs so I kind of like to have a sentinel rather than null where we check instance == SENTINEL instead of instance == null. Yet, this might come from my background and where safety was king :)
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
Nit: " . " -> ". "
this is not a warning level log, if we return the error over the API call, we debug log those

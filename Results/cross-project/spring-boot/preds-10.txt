Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Nit: reword to avoid "log" being ambiguous as verb or noun: "Writes errors and their context to application logs."
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Nit: reword to avoid "log" being ambiguous as verb or noun: "Writes errors and their context to application logs."
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
nit: one too many line break? :)
No tabs in python code.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
this four lines can just be one line: `Topics.validate(topicName)`
nit: move parameter to it's own line (same below)
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
this four lines can just be one line: `Topics.validate(topicName)`
nit: move parameter to it's own line (same below)
minor: unused import now that WINDOWS is a static import below
Nit: unnecessary new line.
This class is surprisingly similar to org.apache.zookeeper.Login, have we copied from the same source? ;-)
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We don't need this field, this could be a local in `startClusters()`
MILLIS => MS to be consistent with other places. Ditto in a few other places.
Fails checkstyle, needs to be final
While you are there, can we fix this one? it is " Running at : " + miniKdc.getHost() + ":" + - miniKdc.getPort()
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
public access? I can see this being accessed by another package too (such as `rest.resources`)
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
Hmm, that's annoying.
Question: Does `LogAppendTime` really provide processing-time semantics? My understanding is: - `CreateTime` = Kafka producer time = **event-time semantics** - `LogAppendTime` = broker time - System.currentTimeMillis() = WallclockTimestampExtractor = Kafka consumer time = **processing-time semantics**
The docstring could also have a cross-reference to `WallclockTimestampExtractor` that says "If you need processing-time semantics, use `WallclockTimestampExtractor`" or sth like that.
Also: missing full stop (`.`) at the end of this sentence.
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
typo `to to` (also missing `.` at the end of the sentence)
Hmm, that's annoying.
Also: missing full stop (`.`) at the end of this sentence.
The docstring could also have a cross-reference to `WallclockTimestampExtractor` that says "If you need processing-time semantics, use `WallclockTimestampExtractor`" or sth like that.
Question: Does `LogAppendTime` really provide processing-time semantics? My understanding is: - `CreateTime` = Kafka producer time = **event-time semantics** - `LogAppendTime` = broker time - System.currentTimeMillis() = WallclockTimestampExtractor = Kafka consumer time = **processing-time semantics**
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
public access? I can see this being accessed by another package too (such as `rest.resources`)
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
Hmm, that's annoying.
Question: Does `LogAppendTime` really provide processing-time semantics? My understanding is: - `CreateTime` = Kafka producer time = **event-time semantics** - `LogAppendTime` = broker time - System.currentTimeMillis() = WallclockTimestampExtractor = Kafka consumer time = **processing-time semantics**
The docstring could also have a cross-reference to `WallclockTimestampExtractor` that says "If you need processing-time semantics, use `WallclockTimestampExtractor`" or sth like that.
Also: missing full stop (`.`) at the end of this sentence.
Good idea to add this safety net.
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
Nit: unnecessary new line.
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: `{@code null}`
nit: no new paragraph required
explain why `Integer`, `Long` is used instead of `int`, `long`
Sounds good. Would be helpful for users to understand. The exception message should explain what they need to do to avoid the exception.
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
Nit: unnecessary new line.
nit: some extra newlines here.
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Maybe: Include in the log the Connect key, value, and other details of records that resulted in errors and failures.
Same question here about just using a static ConfigDef instead of a static method.
nit: remove `this` if not required (code style)
`assertX` has expected value as first parameter -- we should switch both to avoid confusing error messages. Applied to whole class.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
use `Objects.equals` for all once changed to potentially null references.
same for tests below as well
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
use `Objects.equals` for all once changed to potentially null references.
same for tests below as well
In my dreams, merging would either throw an exception or return a new independent mapping so that we wouldn't need this validation phase :)
Going through itertools here ends up creating both a list and a generator so it's likely slower than just returning a list. If the list is very large and your goal is to reduce memory consumption, you can use a generator expresssion instead of a list comprehension on line 322: ``` python expanded_excludes = (self._pattern_to_pkgname(self.base, p) for p in self.base.conf.exclude) ``` However, for iteration over most data, lists are faster than other iterables so it is a time-space tradeoff.
to me these should be sets and required to be non-null
this can be collapsed into `assertTrue(foundTerms.add(bucket.getKeyAsNumber()))`
Why do we need both? Is it because there are so many things going on in this file? I don't understand why we wouldnt just need the CompiledAutomaton for the terms.intersect operation, why do we need a ByteRunAutomaton too? Having both seems silly anyway, but if we must do it, try to assign the ByteRunAutomaton from the CompiledAutomaton. The majority of the time it will be non-null: ``` /** * Matcher for quickly determining if a byte[] is accepted. * only valid for {@link AUTOMATON_TYPE#NORMAL}. */ public final ByteRunAutomaton runAutomaton; ```
I have a similar concern here for when entry.getValue is not a Map
It looks to me like it duplicates the logic of creating a XContentBuilder in a given type and then write the filtered source as map. Could it be something like this? ``` ... Object value = source.filter(fetchSourceContext); try { if (nestedHit) { value = getNestedSource((Map<String, Object>) value, hitContext); } final int initialCapacity = Math.min(1024, source.internalSourceRef().length()); // deal with null here try (BytesStreamOutput streamOutput = new BytesStreamOutput(initialCapacity)) { XContentBuilder builder = new XContentBuilder(source.sourceContentType().xContent(), streamOutput); builder.value(value); hitContext.hit().sourceRef(builder.bytes()); } ... ```
so I think that is an ok test but what you really want is to: - create an item with random values - serialise it to json with the toXContent() - deserialise the json back to an item - compare the items - they should be the same - repeat a couple of times...
Scratch that, I see this is private and only used internally, and the request only has one of each parameters, so duplicate calls are unlikely. Just me being paranoid.
same for tests below as well
Can we also assert that the state gets to `RUNNING` after the new thread has joined
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: break line
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
nit: line too long
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: no new paragraph required
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
Sounds good. Would be helpful for users to understand. The exception message should explain what they need to do to avoid the exception.
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
Nit: unnecessary new line.
Fails checkstyle, needs to be final
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
Can remove if initialize above
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
Good point, but it could be clearer. This implementation can be used in production, but the `PropertyFileLoginModule` that also ships with this reference implementation should NOT be used in production.
extension name must not be empty
recommended; ditto below.
probably better to just create a method that returns the principal name and host. might be easier to extract all of it using a simple pattern matcher instead of going through bunch of indexofs and substrings.
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
nit. Add `{ }` to block (we always use them). Same below.
nit: line too long
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
This would wait forever. Maybe we should do: ```suggestion TestUtils.waitForCondition(() -> stateStore.get(high) != null, "The store never finished populating"); ```
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
For this specific API, I suspect it is ever commonly used in PAPI, so I'm fine with not supporting it right away, also as a way to encourage users to change code sooner than later, if there's anyone.
I'm +1 on supporting the timestamps, even if it's not commonly used now, users will often look to tests for example usage (at least I do). I'm also +1 on removing `childIndex` for the same reason, but I don't have too strong an opinion on that.
Child-Index was deprecated recently -- should we remove it? Also, with KIP-251, we should capture output timestamps, too.
nit: break line
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
nit: line too long
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: no new paragraph required
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
Sounds good. Would be helpful for users to understand. The exception message should explain what they need to do to avoid the exception.
Fails checkstyle, needs to be final
Nit: unnecessary new line.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
`assertX` has expected value as first parameter -- we should switch both to avoid confusing error messages. Applied to whole class.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
remove the super call
remove the super call
Seems to fit in one line
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
`Integer.toString` is a slightly more concise way of doing this.
I fixed this one to use the constant before merging.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
The test name is not self describing: what about `shouldAlllowToSpecifyRocksDBConfigSetterClassAsString`
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Existing issue, space should be after the colon.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Ditto on removing before/after
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Existing issue, space should be after the colon.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Ditto on removing before/after
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Hmm, why did we do this? I thought we'd have a try/catch block.
I don't think we should make the patterns dir configurable? Outside the ES_HOME directory ES has insufficient permissions to read files. I think the patterns dir should always be `$ES_HOME/config/ingest/grok/patterns`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
lets just use IOException that's much better for this purpose and it's checked
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
I think maybe just "return Math.log(doc.popularity) \* 100;", you don't need the "<idOrCode>" bit.
5.1+ I think, actually. Have a look at `VersionTests#testUnknownVersions` and the note right underneath `Version#CURRENT`.
Use `Collections.singletonMap` here and `Collections.singletonList`
This test is not really testing what we want to be testing here. The reason that it's not is because the cache key for a file named `".hidden_file"` is not `"hidden_file"`, but rather it is `""`. A file named `".hidden_file"` never would have been processed by the compilation engine because it doesn't have an extension. So this will ultimately throw, but not for the right reason.
same here as what i said below. You can use a `assertThat`
Include the exception in the log so there is an indication of what went wrong? Looks like it was previously included.
Note that this is different than setting a single property as it adds the inputs to the list.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
Can you include latin-1, non-ASCII characters? `café` is one of the few English words matching this requirement. `Just latin-1 :)` will encode identically in ASCII, latin-1 and utf-8, making the tests much less interesting.
This isn't Django's default charset (unless I'm mistaken).
This is the default charset in Django, I wouldn't call it unusual :)
nit: make the keys a `Set<String>` and then do `assertThat(keys, equalTo(Utils.mkSet("2","3")`
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
I was referring to the fact that the setting netty uses are the result of a merge of multiple things: ``` // merge fallback settings with default settings with profile settings so we have complete settings with default values Settings mergedSettings = settingsBuilder() .put(fallbackSettings) .put(defaultSettings) .put(profileSettings) .build(); ``` If we can make that static and available we can now for sure they use the same thing, even if people change stuff.
guys take this offline if you want - let move here.
I think we should separate the two and push this as is. Your code refactoring has more changes than this functional change and on the security end I think we should be careful. let get this in and cleanup the stuff afterwards
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
When you use it with an instance of `PreBuiltAnalyzers`.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
I don't think it's important for now
Good catch, thanks for cleaning this up!
I don't know that we care about closing the handler. It probably does not matter too much, but there should not be any resources hanging around if we properly consume all the requests.
I think we should fix our datastrucuture first and don't make Path trie super complicated and flexible. This should be fixed first before we make this change here.
No need for this as the listener does not release anything.
same as above for non exception case
nit: a space before `else`.
No, I still think that it should not be a method on the `Strings` class.
> Though I do prefer that it fails fast instead of lazily later. ++
Is this right? Shouldn't it be `validHeaderValue`? And I don't think this should be an assertion, but a hard failure (assertions are disabled in production and if we are sending bad headers something is seriously wrong and we need to die hard).
that `!` fucked me up can we have `== false`? ð
do we need this logic? we know what we will send it
I think it would be easier to read if we use the string representation to create these: http://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html#fromString(java.lang.String)
That is much easier to read!
I call those "leftovers".
But `value` is coming from the system property and `setting` is come the settings object? He's ensuring that he takes it from one of the two, but not both.
Right, what I meant was, that `containsKey` value is only used if `value != null`, so why not get it only if `value != null`
You don't need `containsKey` here, you can put this line of code below the check for `if (value != null)`
Ah, I misinterpreted that line because I never use that syntax. :)
Probably worth noting this exception to the rule in the PR description (since the description suggests that `es.*` causes a failure when this clearly shows that it won't).
Instead of using `IndexWriter` here, you could use `DirectoryReader.listCommits` (there should be at most `IndexCommit` returned) and then call `IndexCommit.getUserData()` instead. Seems safer since `DirectoryReader` cannot do any writing on the index, doesn't acquire the write lock, etc.
It won't always be the case that there will be one index commit, sequence numbers will change this assumption.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
getters should not use get. i.e. use `networkDevice` here, etc.
nit: use the `SecurityManager` interface
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
use `try-catch` instead of `expected` annotation -- not a single line test.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
I have a similar concern here for when entry.getValue is not a Map
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
I fixed this one to use the constant before merging.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
Why is serviceName a property inside JaaS config? Could this be made one of the Kafka Sasl configuration properties instead? Presumably it is used only by Kafka code and hence doesn't belong in jaas.conf? IBM JDK Kerberos module throws an exception because it doesn't recognize this property.
getters should not use get. i.e. use `networkDevice` here, etc.
nit: use the `SecurityManager` interface
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
use `try-catch` instead of `expected` annotation -- not a single line test.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Thanks for clarifying, @ijuma. Seems like we could verify the round-robin behavior without relying on specific number of IPs.
The test is verifying the round robin that _our_ code does, not the DNS server. We should ensure we still have that coverage in the meantime.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
I have a similar concern here for when entry.getValue is not a Map
same for tests below as well
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
a logger should always be private -- if classed extend `KTableSource` the should create their own logger with the corresponding "child" class name.
"This class is intended for a single thread use." - can we change this to a more aggressive "This class is NOT thread-safe"? I want to make sure there is no confusion in the future for any other devs using this class
nit: chain these c'tors to consolidate code. Makes it easy to do validation etc in case a need arise in future.
Is it necessary to call a public non-final method from a constructor? This can cause issues when somebody subclasses `IcuTokenizerFactory` as initialization order gets important. I'd opt for making `#getIcuConfig()` private which avoids the issue. Alternatives: Declare `#getIcuConfig()` or the class as `final`.
Nit: rename to `shouldThrowOnInvalidTopicNames`
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
s/support multiple command/supports multiple commands
ditto on the properties and the driver.
We should limit this suppression to the method for which we really need it instead of the whole class
I'm thinking whether it makes more sense to let `MockProcessor` encapsulate a delegate `MockApiProcessor` so that we could also use existing tests to verify the correctness of the migration.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
It's better to avoid "double-brace initialization", which is actually declaring a new anonymous subclass of HashMap just to add some stuff to it in one statement. A little while back, I added this method for accomplishing the same thing more safely: `org.apache.kafka.common.utils.Utils#mkMap`, and the accompanying `org.apache.kafka.common.utils.Utils#mkEntry`.
Fails checkstyle, needs to be final
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
This could be `ConfigException` instead. With the `ConnectException` hierarchy we get a little bit stuck because we can't have `ConnectException` be the base of all our exceptions and not redefine some. There are some from core Kafka that are fine if triggered from within the framework, and `ConfigException` falls under that category -- the biggest value aside from standardization that asking for `ConnectException`/`RetriableException` from connectors/tasks is that it is a signal for how to handle the exception, but the runtime code doesn't require that everything inherits from those (and in fact we handle other exceptions from connectors as well, we just would prefer that the connector think about how it wants the framework to handle possible errors).
It should now be possible to make up the `RoleArn` and `SecretAccessKey` using the seeded RNG rather than by concatenating strings like this. They can reasonably be different each call.
I really think this should a hard-coded value and not passed in from the environment. I don't think we gain much by accepting it from outside, and I envisage it being the sort of thing I have to look up each time I come across it. The `BUCKET_NAME`/`KEY`/`TOKEN` inputs are clearer (despite that the `KEY` and `TOKEN` used here could be generated internally if we could do so deterministically).
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
can we also step out if `matchedDocId < DocIdSetIterator.NO_MORE_DOC`
nit: add a space before the `:`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
assuming fullFieldName is going to be used when topHitFieldRef impl is complete
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
"with a read-only key"
with a read only key
two license headers? :)
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
The official name is "Docker SDK for Python" ([docs](https://docker-py.readthedocs.io/en/stable/)).
you should specify 'docker python library'
You might also want to say which versions you support.
```suggestion type: str required: true ```
Well, it's easily googlable :) I've shared links in some PR recently. Let me see whether I can find them
#45989 has a response on it. The preferred way is to *not* advance the date or add a range.
You could add that the "zone" must be activated for this domain (as far as I know it's only possible using ovh's manager).
Tests for `formset_factory()` and `formset_factory()` are missing.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
"with a read-only key"
with a read only key
two license headers? :)
nit: put `@Override` on its own line
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
This could be final.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
Passing through Jackson seems to be the real test we need here (though checking `toString()` itself is also useful for logging elsewhere if we want consistency).
There is a built-in for this `Function.identity()`
Nit: could just throw the exception directly here; doesn't appear to be much benefit to putting that in a separate `setup` method.
Cheating the compiler, woohoo!
Same question for ProcessorSupplier for using a delegate, but is minor to me.
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
I know this is only a test class, but returning `Collections.emptyMap()` would be the nicer thing to do here
nit: Capitalize `p`.
Update the above TODO with only admin client left.
Same for `addThroughputSensor`.
@rodesai I see your point here. However, the downside of not throwing is that we will also not notice the bad behavior in our tests like the soak tests. I personally prefer to improve tests instead of downgrading the reaction to bad behavior. Assume in future somebody makes a change that breaks the assumption of the non-shared metrics registry, we would find this bug immediately during development instead of during production. Another option that comes to my mind is to classify exceptions that originate from the metrics framework differently in the uncaught exception handler, but that would probably need some more work.
Not sure if it really matters, but this is not a uniform distribution (because MAX_VALUE and MIN_VALUE are not integer multiples of 1000 days. If you wanted a uniform distribution, it looks like you can use the bounded `nextInt` and cast to `long`. Also, FYI, `Math.abs(Long.MIN_VALUE) == Long.MIN_VALUE` (which is a negative number), due to overflow.
Could you test `maybeRecordE2ELatency()` through `process()` and `forward()`? Although you test `maybeRecordE2ELatency()`, you do not test if the recording is done during processing, but that is the crucial thing, IMO.
nit: move .collect to new line
I remember some of the metrics were lazily registered, i.e. they would only be registered if the corresponding action is called for the first time. Have we refactored it to always register all metrics up starting the task / process-node etc? Otherwise waiting for the stream state to transit to RUNNING may not guarantee all metrics should be already registered.
Thanks for double checking this! Then it lgtm.
Nit: let's avoid moving all of these imports around. Our convention is to place the `java` and static imports at the end, and moving them unnecessarily just complicates maintenance.
Could we use ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG etc instead of hand-coded strings? It is less error-prone for possible future changes.
Ah, my bad. I think the variable I had in mind is actually called `Double.BYTES`. Not 100% sure it's defined for all possible primitive types, but I would hope so
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
That sounds good to me ð
You are an exemplary boy scout!
nit: use `private static` ordering (for consistency with the rest of the code base)
ditto on the properties and the driver.
Why do you need to prepare `KafkaStreams` for testing? Only classes that are mocked and that are either `final` or have static methods need to be prepared.
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
I think we could leave this called `simpleString`. The convention seems to be not to call out the existence of the Validator explicitly in other calls. I see that this might cause some issues with overloading but I think they're surmountable.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
It should be robust in case of some missing fields.
base -> based progress -> progressed
You don't need to specify any symbolic name for a group since you have only one.
I have a similar concern here for when entry.getValue is not a Map
the reason why I suggested to make it configurable is that we could pass in our own values in tests that's all... not a big deal
Can change this to the new autoclose functionality in Java 7 now that the codebase is on it: ``` try (ZipFile zipFile = new ZipFile(pluginFile)) { // ... } catch (Exception e) { // ... } ``` Thereby dropping the entire `zipFile`-related code from within the `finally` block.
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
It *looks* to me like this will hit a `NullPointerException`.
When you use it with an instance of `PreBuiltAnalyzers`.
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
typo: optain -> obtain
I don't think it's important for now
Just to avoid allocating an empty list in the common case where we don't throw any exceptions.
Sounds good. I prefer it the way you suggest anyway. I'll change it.
Why not make it `final` and return an empty list? It seems better to avoid using `null` if possible
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`Integer.toString` is a slightly more concise way of doing this.
I fixed this one to use the constant before merging.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
nit: add `final` (same below)
Just to avoid allocating an empty list in the common case where we don't throw any exceptions.
Sounds good. I prefer it the way you suggest anyway. I'll change it.
Why not make it `final` and return an empty list? It seems better to avoid using `null` if possible
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`Integer.toString` is a slightly more concise way of doing this.
I fixed this one to use the constant before merging.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
nit: add `final` (same below)
looks like this is not passed to Metrics object. we can use reporter instance at below line.
nit: new Integer(1) => Interger.valueOf()
using `assertThat` is nicer as it gives better failure messages. `assertThat(sourceNode.getTimestampExtractor(), instanceOf(MockTimestaampExtractor))` in other places, too
nit: There is an extra space before `+`.
typo: kStreamhould... -> kStreamShould In fact i'd probably rename these methods to begin with should, i.e., `shouldAddTimestampExtractorToStreamWithOffsetResetPerSource` etc
This line is failing checkstyle.
could be named as `processingMode`
Nit: you can call `Thread.enumerate` directly. Also, it would be good to assert that `threadCount` is < than `threads.length`.
Should we close the task first before re-initialize it to another StreamTask? Ditto below.
Although the code is clear, the level of indirection here makes it hard for the reader to figure out that this (and similar other) test does. As a suggestion, what about combining test_object/test_object_IgnoreMalformed, then the code from `sourceWithObject` can be inlined in the test case. Also I would make the assertion on field1 and field2 explicit, even if that means a few more lines of code. In this case I would trade repetition for readability.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
Please break this down into a couple of lines to make it easier to read. Also, the `distinct` call should be unnecessary for this bug, and only introduces extra work that distracts from the main problem.
Should be changing double quotes to single, if at all. I wouldn't really worry about it though.
chop blank line
:thinking: ```suggestion defaults=defaults, ```
It would be fine to put these on a single line `{'publisher': 1, 'count': 1}`
A style that didn't require so many lines and use non-4-space indent would be more consistent with the rest of the code. Something like: ``` vals = list(Book.objects.annotate(xprice=F('price')).filter(xprice__lte=30) .values('publisher', 'contact').annotate(count=Count('pk')).values('publisher', 'count') .order_by('publisher')) ```
`test_mti_update_non_local_concrete_fields` works without the patch, so we should move it to a separate commit.
Looks good, my mistake.
I'm not sure the usage of `settings.FORMAT_MODULE_PATH` is correct here. Now the `format_module_path` keyword argument is no longer used (thus the failing test, I think).
don't need the trailing comma
"new" -> "now"
Rather than filtering ourself, we could alternatively pass prefix as glob to newDirectoryStream, and it would follow filesystem rules.
This method can be public, static, and take a String instead of a Path, which would allow us to unit test it. It will require moving the logging up one level higher though, but still nice to be able to unit test.
confuses the shit out of me everytime :)
Not sure if this already includes the shard context, but if it doesn't can you change it to: ``` logger.debug("{} found local translog with id [{}]", this.shardId, id); ```
You should be able to collapse this to `IOUtils.close(this.current, uncomittedTranslogs)`
Again, need to figure out what to do if ATOMIC_MOVE is not supported
Import them from compat module: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/common/_collections_compat.py#L37 ```python from ansible.module_utils.common import MutableMapping, MutableSequence ```
After some thinking: it does not make sense to have this `HAS_TOML` with fallback to `AnsibleTomlEncoder = None` because you're not going to use it anyway. Just check for `ImportError` where you import this plugin and that's it.
```python from functools import partial ```
This was probably discussed in the KIP, but obviously the downside is that users won't get any warning or hint that they should transition. But I guess we don't get a substantial benefit from removing `AdminClient`, so maybe we'll just never do it.
This is a breaking change, right? Same for the other `create` method in this class.
there could be a function to convert entire list, as this code is repeated below
Please put these back.
It looks like you're double-nesting `ansible_facts` dictionary, on line 406/409/412 you have the facts being saved in `result = { 'ansible_facts': { 'cloudfront':...` but then here you pass to exit_json under `ansible_facts` so your output looks like: ``` localhost | SUCCESS => { [479/1550] "ansible_facts": { "ansible_facts": { "cloudfront": { "E22CS9R7XQ0CWU": { "distribution": { .... ``` To fix this you can instead do `module.exit_json(msg="Retrieved cloudfront facts.", **result)` or stop nesting the `cloudfront` key under `ansible_facts` on 402/405/408/411.
just don't know exactly what's in the properties :-)
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Not for `Streamable`. If you switch it to `Writeable` then yes. But that might make sense to wait for another PR? I don't know, I haven't been following this one very closely.
nit: new lines are generally not recommended to break object type declaration with object name. For this specific line I think we can still make them in one line.
should it be `final` ? seems to be a const semantics
ditto on the properties and the driver.
nit: `final` + next line and might as well do the previous while you are at it ;-)
this `readStringProperty`? it is not parsing script code, it is an ingest-node config reader
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
Given that there are 3 tests it would be nice to give all of them descriptive names.
The Achilles heel of implementing new KTable features has historically been that we forgot to test them in a context that required the ValueGetter to work properly, of which Join is a notable use case. I'd actually say it should be required for every KTable operator to have a test where it's the source of a Join. For stateless operators, we should test both with and without a Materialized argument on the operator.
Aha, so there was a good reason for it ð
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
where is this method used? I can't find it
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
where is this method used? I can't find it
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
It might be nice to factor out a helper to build the controller and broker nodes. It would make it a little easier to process this method visually.
nit: this seems unnecessary. We're already using the constant below anyway.
Actually let me put in this way: `restoredPartitions` could just be local to this function? It's only usage outside is in `clear` so it seems we can keep it local or just use `restored` directly and remove it from `clear`.
Shouldn't this be a config exception? It is not really invalid partitions.
If the subscription changes, the `onPartitionsRevoked` would be triggered and the owned-partitions in subscription would not include them. The original reasoning is just to make sure all partitions except the ones that are attempted for reassignment-hence-revocation-first are owned by someone. But like we discussed in the other PR, today we are not checking these conditions anyways, e.g.: 1. assignor assign one partition to multiple consumers. 2. assignor assign one partition to no one. They are both bad situations but Coordinator does not check for those today. We discussed about this and think it worth a more general solution as a separate JIRA.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
It might be nice to factor out a helper to build the controller and broker nodes. It would make it a little easier to process this method visually.
nit: this seems unnecessary. We're already using the constant below anyway.
Actually let me put in this way: `restoredPartitions` could just be local to this function? It's only usage outside is in `clear` so it seems we can keep it local or just use `restored` directly and remove it from `clear`.
Shouldn't this be a config exception? It is not really invalid partitions.
If the subscription changes, the `onPartitionsRevoked` would be triggered and the owned-partitions in subscription would not include them. The original reasoning is just to make sure all partitions except the ones that are attempted for reassignment-hence-revocation-first are owned by someone. But like we discussed in the other PR, today we are not checking these conditions anyways, e.g.: 1. assignor assign one partition to multiple consumers. 2. assignor assign one partition to no one. They are both bad situations but Coordinator does not check for those today. We discussed about this and think it worth a more general solution as a separate JIRA.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
This name seems backwards.
I don't think we need a synchronized block here since `start()` is always called once at the very start
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
This probably shouldn't be called "prepare", right? It is the main Callable here and we expect to stay in it for a while.
nit: this seems unnecessary. We're already using the constant below anyway.
Shouldn't this be a config exception? It is not really invalid partitions.
Please include the problem in the errMsg which is used to complete `doneFuture`. For example: ``` errMsg = "Failed to start the external process: " + e.getMessage(); ```
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
This name seems backwards.
I don't think we need a synchronized block here since `start()` is always called once at the very start
Not really against the style, just a nit of mine (My IDE recommends removing it). feel free to ignore.
nit: Could just to `new ArrayList<>();`
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
This probably shouldn't be called "prepare", right? It is the main Callable here and we expect to stay in it for a while.
nit: this seems unnecessary. We're already using the constant below anyway.
Shouldn't this be a config exception? It is not really invalid partitions.
whenever referring to Connect as the framework (as opposed to the verb) I'd use `Connect`. Same as `Kafka cluster` and `Connect framework` a few words after. It's easy to miss that you are referring to the framework if it's not capitalized.
also can it be final
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
Also add `@params topics`
can we add a shortcut for `all`? we lost it...
nit: remove `which is`
I think we should use the `ElasticsearchSingleNodeTest.class.getName()` as the cluster name then we know exactly what is going on.
we should set a node name too...
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
You might consider using `OptionalDouble`.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Nit: move these two static factory methods above the non-static member variables, so all static and non-static members are together.
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Maybe we could use a different value here.
nit: I think we could use a more convenient type, such as `Map<Integer, InetAddressSpec>`. Ultimately this just needs to make it down to `KafkaNetworkChannel.updateEndpoint` so the conversion to the config value is unnecessary.
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
nit: maybe we can separate AbstractTaskCreator and its two impls into separate classes once we are finalizing the refactoring in a follow-up PR (this PR can stay as is to keep it from exploding LOC)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I have a similar concern here for when entry.getValue is not a Map
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I have a similar concern here for when entry.getValue is not a Map
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
nit: put `@Override` on its own line
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
Just thinking about is once more: why do we need to make this interface public? We have `Named` as public method to use `NamedOperation` and other public control objects (`Consumed` etc) that implement it -- but I actually think, users don't need to know about this interface? \cc @fhussonnois @bbejeck @guozhangwang @vvcephei @ableegoldman
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
public access? I can see this being accessed by another package too (such as `rest.resources`)
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
nit: put `@Override` on its own line
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
Just thinking about is once more: why do we need to make this interface public? We have `Named` as public method to use `NamedOperation` and other public control objects (`Consumed` etc) that implement it -- but I actually think, users don't need to know about this interface? \cc @fhussonnois @bbejeck @guozhangwang @vvcephei @ableegoldman
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
public access? I can see this being accessed by another package too (such as `rest.resources`)
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: extra blank line ```suggestion ```
Can we actually include UUID type? It always 16 bytes.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
It's better to avoid "double-brace initialization", which is actually declaring a new anonymous subclass of HashMap just to add some stuff to it in one statement. A little while back, I added this method for accomplishing the same thing more safely: `org.apache.kafka.common.utils.Utils#mkMap`, and the accompanying `org.apache.kafka.common.utils.Utils#mkEntry`.
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
Yes, this should on an internal package (eg `common.internals`).
@gwenshap meant that `kafka.common.Topic.InternalTopics` should be removed in favour of the `INTERNAL_TOPICS` defined in this PR.
It would be good to have constants instead of hardcoding the fields in many places.
this four lines can just be one line: `Topics.validate(topicName)`
`Integer.toString` is a slightly more concise way of doing this.
i think this should be `maybeForward` - `checkForNonFlushForward` indicates to me that it is just going to check and return if it should forward.
I fixed this one to use the constant before merging.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
use `try-catch` instead of `expected` annotation -- not a single line test.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Why do we need to do this? `log` is private and is not used
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
nit: could use Utils.mkSet
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
large and deeply nested method here -- recommend splitting into multiple smaller private methods where possible
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should be done in reset()
This is a breaking change, right? Same for the other `create` method in this class.
nit: no new paragraph required
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
Sounds good. Would be helpful for users to understand. The exception message should explain what they need to do to avoid the exception.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
nit: `{@code null}`
This was probably discussed in the KIP, but obviously the downside is that users won't get any warning or hint that they should transition. But I guess we don't get a substantial benefit from removing `AdminClient`, so maybe we'll just never do it.
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
explain why `Integer`, `Long` is used instead of `int`, `long`
Fails checkstyle, needs to be final
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
oh, yeah, it's not a bug, just a little confusing. I neglected to say that.
Good catch. I think you're right.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: We use singular verbs in other functions (e.g. line 54 above), would be better to be consistent.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
probably not required to do a special logic for ConnectHeaders. The equals check using iterator below should probably be suffice.
Maybe use Objects.requireNonNull
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
nit: should be `ConnectHeaders`. *probably* would be easy to figure out, but better to just get it right :)
Exception message doesn't look right (the word "list").
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
nit: one too many line break? :)
No tabs in python code.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
this should be declared volatile (considering the double-checked locking below)
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
Seems to fit in one line
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
`final` and initialize in constructor instead? Doesn't seem to depend on the config at all.
Nit: I think `"not-null"` might be confusion. I think a better naming would be `"null-encoding-that-is-not-just-'null'"`
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
getters should not use get. i.e. use `networkDevice` here, etc.
this should be declared volatile (considering the double-checked locking below)
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
Seems to fit in one line
`final` and initialize in constructor instead? Doesn't seem to depend on the config at all.
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
what happens if there is no mapper? I would tend to simply ignore (to match the logic we have for stored fields now)
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
getters should not use get. i.e. use `networkDevice` here, etc.
this should be declared volatile (considering the double-checked locking below)
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
Seems to fit in one line
`final` and initialize in constructor instead? Doesn't seem to depend on the config at all.
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
what happens if there is no mapper? I would tend to simply ignore (to match the logic we have for stored fields now)
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
This could be final.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
Why do we need to do this? `log` is private and is not used
```suggestion /** * Metadata of a task. */ ```
There is a built-in for this `Function.identity()`
nit: move parameter to it's own line (same below)
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
getters should not use get. i.e. use `networkDevice` here, etc.
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
otherwise, if you want it for testing, it can be done once in the ctor
ditto here and others below
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
same question as above
same for tests below as well
nit: remove empty line
maybe use "a", "b", "c" as values, as the transformer counts the number of calls to `process` (for better distinction with next test)
nit: remove empty line
store not used
store not used
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
set supports_check_mode=True after the check mode implementation
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
Missing `=dict` on this and the next few lines
I think this is only returned on changed, again, diff against eos_banner in devel
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
I think it is better to pass module as argument to build_xml() and handle lxml install check-in module_utils instead of having it in each module
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
not sure why you moved all the code to _version ... why not keep here? seems like useless jump
`< Callback >` this explicit type is not necessary.
I'm about to change this in #22586 so that DeleteResponse/IndexResponse/UpdateResponse don't have to repeat all these checks. There will be a assertDocWriteResponse() method, and here we only have to check for UpdateResponse specific fields.
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
typo: byteArrray -> byteArray
you are right thanks a lot for catching this
There is a problem with this test setup that I just found: the xContentType that is used for parsing here is not necessarily the same as the one that is used int randomUpdateResponse(). So the expected values might be off, e.g. if in randomUpdateResponse() SMILE is used and here xContentType is Yaml.
empty line needed
I think an exception other than an `AssertionError` will stop the busy loop. So if an `IOException` can be thrown that _shouldn't_ terminate the busy loop then it needs to be caught here. But maybe there isn't.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
As I suggested before, to not expose the node information, we should remove this function.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
nit: add `final` (same below)
nit: remove the redundant line. Same as below.
The test name is not self describing: what about `shouldAlllowToSpecifyRocksDBConfigSetterClassAsString`
`asList` -> `Collections.singletonList`
use `try-catch` instead of `expected` annotation -- not a single line test.
redundant type arguments `<ProducerRecord<byte[], byte[]`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
Nit: can be `final`
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
As I suggested before, to not expose the node information, we should remove this function.
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
This is `ListDeserializer` hence, shouldn't we use `ConsumerConfig.LIST_KEY_DESERIALIZER_INNER_CLASS_CONFIG` ? The "SERDE" config should be used in Kafka Streams codebase only? (Same for value, and for both inner types in the next line).
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
Cool. I think the fewer configs overall, the better. If we can get away with just the Serde configs then let's do so to keep the API surface area smaller for users ð
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ok I understand better your intention now. I think it is still weird from a user perspective to have to pass in `null`, not loving the nullable arguments. That said it is not a huge deal, can leave as-is.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
thanks for adding this
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
same 1+ randomInt
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
I think we can check also randomly on a shard that relocates _to_ the local node
Same here - more randomization would be nice
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
same 1+ randomInt
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
I think we can check also randomly on a shard that relocates _to_ the local node
Same here - more randomization would be nice
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Please could you assert that the content of the message is correct? (`expectThrows` returns the exception thrown, so you just need to assign it to a variable and check its message.)
ditto here and others below
this is not needed. createIndex automatically reroutes.
Hmm, we're using a raw type here and a few other places. This is discouraged (type checking is disabled in these cases). If we don't want to propagate the generics when we use the superclass, we should probably drop them.
same for tests below as well
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
Same here - more randomization would be nice
I think we can check also randomly on a shard that relocates _to_ the local node
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Wouldn't it be much easier to do the following: ``` public Connector createConnector(String listener, String name) { ... String hostname = ... int port = ... ... if (name == null || name.trim().isEmpty()) { name = String.format("%s_%s%d", PROTOCOL_HTTPS, hostname, port); } connector.setName(name); ... ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
nit: I don't spot any, but safer to avoid typos by just having constants for these
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I don't think this is necessary. The SecurityFileChangeListener thread may not yet have started, but the watch services are already registered after `factory.configure(configs)`. The file change below should queue a change even if the thread hasn't started.
Yes, we should remove `sleep` in the tests and ensure they work without them.
rewrite test as above using `assertThrows()`.
remove try-catch and replace with: ``` final StreamsException s = assertThrows(StreamsException.class, () -> testDriver.pipeInput(consumerRecord)); ``` assert afterwards and don't re-throw.
could these three methods somehow be in the base test class, at least partially? what I am looking for is avoiding copy pasting when writing new tests, and possibly not forgetting to cover important scenarios.
ditto here and others below
same for tests below as well
It feels weird that this is empty.
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Wouldn't it be much easier to do the following: ``` public Connector createConnector(String listener, String name) { ... String hostname = ... int port = ... ... if (name == null || name.trim().isEmpty()) { name = String.format("%s_%s%d", PROTOCOL_HTTPS, hostname, port); } connector.setName(name); ... ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
nit: I don't spot any, but safer to avoid typos by just having constants for these
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
same for tests below as well
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
i.e., add `fail` after this line
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
use `try-catch` instead of `expected` annotation -- not a single line test.
req: Since we do not need to validate `valueTransformer`, could you please remove it from the `verify()`.
req: Could you please replace `.andReturn()` with `.andStubReturn()`? This avoids the verification of the call to `valueTransformer.transform(inputKey, inputValue)` which I consider setup and not validation.
Looks good. I like the additional checking that you're doing here.
nit: remove empty line
nit: add `final` (2x)
nit: fix indention (we usually use 4 spaces, not 8)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
I have a similar concern here for when entry.getValue is not a Map
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I think you can initialize the capacity.
Doesn't hurt, I guess, but it might obfuscate the fact that all the parsed aggregations don't implement equals/hashCode. At a quick glance people might think all subclasses properly implement equals()...
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
I don't think it's important for now
did you plan to add here the list of nodes or something? looks like there is a missing argument.
Ok, just checking.
Maybe only invoke `processorIdGenerator.getAndIncrement()` when no id has been specified in a if statement? Otherwise there will be holes in the numbers generated if only some processors have a user specified id.
Should we keep in incrementing even for cases where we find the id? or only increment for cases when the id is not provided? I am not sure myself, just wondering, maybe not that important either at the moment.
also, at the moment we don't check for ids uniqueness, which is probably fine given what we need ids for, just double checking that we don't rely on uniqueness anywhere
This sucks.. I want to see how big of a deal it is to keep things as they were. Indeed snapshotting a commit will keep it's translog around but I'm not sure anymore it's worth this kind of wrapping layers. Maybe we should invest in faster clean up on those snapshotted commits. I'll reach out to discuss.
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
req: we'll never hit this, as `taskToCaughtUpClients` only contains tasks _with_ caught-up clients IIUC. Can we just construct `unassignedTasksWithoutCaughtUpClients` as the set `totalTasks - taskToCaughtUpClients.keySet`? We can do that in `assignTasksWithoutCaughtUpClients` and remove `unassignedTasksWithoutCaughtUpClients` from `assignTasksWithCaughtUpClients` entirely
req: drop the `!caughtUpClients.isEmpty()` check here, if it's in the map it should have at least 1 caught-up client
Fine with me -- it's just a "prop" after all. FWIW I generally find these functional-style methods harder to read, but for whatever reason in this case I was finding the original a bit hard to understand and thought this suggestion helped to "get to the point" faster. But of course it's always easier to read your own code than someone else's ð
```suggestion final Map<TaskId, List<ID>> taskToCaughtUpClients = statefulTasksToRankedClients.entrySet().stream().collect(Collectors.toMap( Entry::getKey, t -> t.getValue().stream() .filter(c -> c.lag() == 0 || c.lag() == Task.LATEST_OFFSET) .map(ClientIdAndLag::clientId) .collect(Collectors.toList()))); ```
req: rename `clientHostingTask` -> `previousHostingClient` (or similar)
Not sure if this will actually be cleaner or end up more complicated, but you may be able to reuse some of the `StickyTaskAssignor` code here which does similar things
```suggestion // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks ```
```suggestion // If a task was previously assigned to a client that that is caught-up and still exists, give it back ```
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
req: I think we want to introduce some `acceptableLag` config within which a task is considered caught-up, otherwise this is way too strict. ie the condition should be `lag <= acceptableLag`
req: we'll never hit this, as `taskToCaughtUpClients` only contains tasks _with_ caught-up clients IIUC. Can we just construct `unassignedTasksWithoutCaughtUpClients` as the set `totalTasks - taskToCaughtUpClients.keySet`? We can do that in `assignTasksWithoutCaughtUpClients` and remove `unassignedTasksWithoutCaughtUpClients` from `assignTasksWithCaughtUpClients` entirely
req: drop the `!caughtUpClients.isEmpty()` check here, if it's in the map it should have at least 1 caught-up client
req: rename `clientHostingTask` -> `previousHostingClient` (or similar)
prop: rename `taskCount` -> `minTaskCount`
Not sure if this will actually be cleaner or end up more complicated, but you may be able to reuse some of the `StickyTaskAssignor` code here which does similar things
```suggestion // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks ```
```suggestion // If a task was previously assigned to a client that that is caught-up and still exists, give it back ```
maybe also add a `lastAssignedTask(List<TaskId>)` helper to clean up `source.get(source.size() - 1)` used here and below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
Looks good. I like the additional checking that you're doing here.
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
Looks good. I like the additional checking that you're doing here.
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
Looks good. I like the additional checking that you're doing here.
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
Can be final
Nit: I know this was inherited from the existing code, but it would be nice to do something like `ByteArrayDeserializer.class.getName()` for serializers and deserializers.
Hmm. I feel the `final` would be worth capitalizing the var name.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
Ok, I'm convinced :) Thanks for clearing up my confusion.
Not sure what the intent is here, to increment the number between each test, or between each instance of this integration test class within the JVM... It actually does the latter.
MILLIS => MS to be consistent with other places. Ditto in a few other places.
These three fields should be final as well.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
nit: simplify -> `throws Exception` (also above)
nit: add a size? There are a few cases in here where we could do this.
Can be final
Nit: I know this was inherited from the existing code, but it would be nice to do something like `ByteArrayDeserializer.class.getName()` for serializers and deserializers.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
Not sure what the intent is here, to increment the number between each test, or between each instance of this integration test class within the JVM... It actually does the latter.
Ok, I'm convinced :) Thanks for clearing up my confusion.
MILLIS => MS to be consistent with other places. Ditto in a few other places.
These three fields should be final as well.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
nit: simplify -> `throws Exception` (also above)
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
nit: extra space before `anyObject`
nit: the `20` here means version 2.0, since we mistakenly made a compatible breaking change in 2.0 and this test is specifically for that. So let's just keep the suffix.
Can we cover the other error cases? For example, INVALID_REQUEST and UNKNOWN_TOPIC_OR_PARTITION. It also looks like it's possible to receive no error, but an unknown offset. Having all of these test cases protects us when we change the code in the future.
could be named as `processingMode`
@mjsax if `resume()` is called on the consumer `verify` will fail the test.
ditto here and others below
same for tests below as well
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
As I suggested before, to not expose the node information, we should remove this function.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
`final` and initialize in constructor instead? Doesn't seem to depend on the config at all.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
nit: extra space before `anyObject`
nit: the `20` here means version 2.0, since we mistakenly made a compatible breaking change in 2.0 and this test is specifically for that. So let's just keep the suffix.
Can we cover the other error cases? For example, INVALID_REQUEST and UNKNOWN_TOPIC_OR_PARTITION. It also looks like it's possible to receive no error, but an unknown offset. Having all of these test cases protects us when we change the code in the future.
could be named as `processingMode`
@mjsax if `resume()` is called on the consumer `verify` will fail the test.
ditto here and others below
same for tests below as well
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
correction: It's not a byte string, it's a raw-string literal
```suggestion - "You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)." ```
You probably should add yourself to the authors list as well.
You should really have at least one example with `state=absent`.
Can you explain what this option does and why it is needed? From the implementation, it looks like this can be used to overwrite arbitrary module options, without any type checks or other sanity checks. I don't think modules should have such options.
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
correction: It's not a byte string, it's a raw-string literal
```suggestion - "You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)." ```
You probably should add yourself to the authors list as well.
You should really have at least one example with `state=absent`.
Can you explain what this option does and why it is needed? From the implementation, it looks like this can be used to overwrite arbitrary module options, without any type checks or other sanity checks. I don't think modules should have such options.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
We should fail if the put replaced an existing entry? Or rather, not replace if the mapping already exists (ie where a 2 different whiteslists are whitelisting methods on the same class). But surely they can't be allowed to have different names in painless for the same java class (one would overwrite the other here).
nit: Starting a message with lower case feels a little unusual.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
Ok sounds fine then.
I would simplify this to just "importedClassName". Any name used in code always has to be canonical (like in java).
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
We should fail if the put replaced an existing entry? Or rather, not replace if the mapping already exists (ie where a 2 different whiteslists are whitelisting methods on the same class). But surely they can't be allowed to have different names in painless for the same java class (one would overwrite the other here).
nit: Starting a message with lower case feels a little unusual.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
Ok sounds fine then.
I would simplify this to just "importedClassName". Any name used in code always has to be canonical (like in java).
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
The first two of these fields are unused. I think that's right, and we should remove them and also `ec2Bucket`, by generating the key and token and then passing them into the bucket's constructor.
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
Probably worth asserting that they return success. I've never seen them not do so but if they ever start then this test won't have many segments and will fail in strange ways to anyone trying to debug it.
Is this any quicker if you use bulks? I tend to do that out of habit.
Its a bit silly that an instance of this will return true for instanceof ImmutableTestCluster - its certainly not immutable. Not a big deal, probably.
It's minor, but we usually lowercase exceptions and elide ending punctuation
I think we should keep it in 5.x and remove in 6.0.
It drives me bonkers that this is called "scroll" everywhere instead of "scrollId", but it's a matter of taste, no impetus to change it if you like it :)
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
This shouldn't be needed anymore. By default we wait for the index to be created now.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
probably not required to do a special logic for ConnectHeaders. The equals check using iterator below should probably be suffice.
nit: should be `ConnectHeaders`. *probably* would be easy to figure out, but better to just get it right :)
Maybe use Objects.requireNonNull
Exception message doesn't look right (the word "list").
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
nit: list the members list here would help trouble shoot.
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
Could you please add some line breaks? This and some of the other verifications are too long.
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
Is this just to prevent it from processing anything until you're ready to proceed? It seems like you can/are doing that just by controlling when to produce input messages and doing so one at a time (if that's accurate, then WDYT about renaming `process` to `processed` and flipping the boolean so it more clearly serves the purpose of indicating whether a record has yet been processed)
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
nit: list the members list here would help trouble shoot.
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
Could you please add some line breaks? This and some of the other verifications are too long.
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
Is this just to prevent it from processing anything until you're ready to proceed? It seems like you can/are doing that just by controlling when to produce input messages and doing so one at a time (if that's accurate, then WDYT about renaming `process` to `processed` and flipping the boolean so it more clearly serves the purpose of indicating whether a record has yet been processed)
Let's use try with resources here and the other test so that the file is closed after it's used.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
it is preferable to have descriptive test names, i.e., `emptyIteratorAlwaysReturnsFalse` `emptyIteratorPeekNextKeyShouldThrowNoSuchElementException` etc
Nit: somehow I don't like `blah`. Otherwise LGTM
Are you planning to add this? It should be straightforward once you set a limit on the maximum size.
It will good to clear the requests and test when empty as well.
May be worth adding an error message for `aasertTrue` (in all the places where assertTrue is used).
Should we close the task first before re-initialize it to another StreamTask? Ditto below.
Unify "create task" code with `shouldThrowExceptionIfAnyExceptionsRaisedDuringCloseTopology` -- it's almost the same and both test cases can use the same topology structure.
It will be better to use `MockTime` rather than `SystemTime`. That will make it easier to test timeouts
I see that you are actually printing the sink nodes. I'm wondering if this if condition is necessary since in line 85 this function will be skipped anyway.
There's a trailing comma issue
need a newline after the group before the underline, and a double newline after the underline
The second newline should be left for the caller, as it otherwise causes an extra line before 'Dependents' in the enriched RST
these 2 lines shouldn't be here
Also we can just pass in the `StringBuilder` as an argument rather than create a new one here
perhaps a better name is `getConfigKeyRst()`
I see. I do not have a strong preference actually. But I remember we use singulars not plurals in many other classes and just wanted to be consistent. If it is actually the opposite case I'm happy to have them all to be plural.
I meant to have all "singulars" for consistency, i.e * Creates a * Starts the * Shuts down this * Does a clean up I'm OK with imperative style.
```suggestion // TODO K9113: this is used from StreamThread only for a hack to collect metrics from the record collectors inside of StreamTasks ``` Just marking this for later follow-up.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
Nit: I think you can leave out ESTestCase here.
I think you meant `get_ellipsized_page_range` here. Use `number` instead of `page_num` which matches the argument name used by `Paginator.get_page()`.
There is no need to provide a value for `max_pages_num` - I think it should be calculated automatically: ```python (self.on_each_side + self.on_ends) * 2 ``` Otherwise developers can provide values that are incompatible with each other...
In Python3, `super()` is enough.
That's right - you need to call them out explicitly.
This probably isn't required - other highlighters can just be called out in the request if you want them.
This was changed to`INVALID_PRODUCER_EPOCH` in the kip. Let's change it here too.
Just wanted to say I really like the way this unit test is written! With the right usage of mocks we would avoid having any time-dependent flakiness.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
No need to parametrize with just one case.
It *looks* to me like this will hit a `NullPointerException`.
When you use it with an instance of `PreBuiltAnalyzers`.
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
did you plan to add here the list of nodes or something? looks like there is a missing argument.
I don't think it's important for now
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
I like dummy because it implies fake and the index is fake - not just empty.
I meant empty as in the settings are empty.
tokeinzer -> tokenizer
```suggestion elif databases[DEFAULT_DB_ALIAS] == {}: ```
I presume it was intentional to change this to `.update()` so that `self._settings` is modified? I expect that could just do this instead: ```python databases[DEFAULT_DB_ALIAS] = {'ENGINE': 'django.db.backends.dummy'}
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
You have some unmerged lines here
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
nit: I don't spot any, but safer to avoid typos by just having constants for these
It is probably better to use nanoTime here so you don't get clock skew giving you weird numbers. Not like it matters a whole lot here though.
Nit: If we do fix up the above example of this it makes sense to fix this up too.
How about we reset the offsets between tests? I think that may be what you're suggesting. It would be cleaner not to accumulate metadata over time.
Same here, original exception is dropped.
Ah nevermind, I see where we use it :-/
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
I think you use it indirectly through `parser. isBooleanValueLenient`.
I don't believe this is only kept for BWC. You use this to parse `_source` above.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This is no longer used, could be removed
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
Is this just to prevent it from processing anything until you're ready to proceed? It seems like you can/are doing that just by controlling when to produce input messages and doing so one at a time (if that's accurate, then WDYT about renaming `process` to `processed` and flipping the boolean so it more clearly serves the purpose of indicating whether a record has yet been processed)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
Just a reminder, `ByteBuffer` again :)
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
probably not required to do a special logic for ConnectHeaders. The equals check using iterator below should probably be suffice.
Exception message doesn't look right (the word "list").
Maybe use Objects.requireNonNull
It's not super-important, but it probably makes sense to set -1 as the default for `ProducerId` in `InitProducerIdResponse`. Same for `ProducerEpoch` But maybe keep the explicit assignment as well since that makes it very clear...
Let's use `Map` on the left side instead of `HashMap`
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
I would say it's important _not_ to be able to create bogus requests. ;) We can introduce specific mechanisms for testing, but a public constructor for a request should do its own validation.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
Exception message doesn't look right (the word "list").
Just a reminder, `ByteBuffer` again :)
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
That is right, since Kafka Streams processor topology traversal is Depth First, when we finished one child route we need to go back to the next child route, and hence resetting the the currNode.
I think it is important to keep different classes on the client-side so that we can have more type safety and potentially add some methods to only eg. avg in the future
Nit: rename to `shouldThrowOnInvalidTopicNames`
This needs to be protected by a `if (in.getVersion().onOrAfter(Version.V_1_3_0)) {`
anti-pattern: ``` if (...) { return x; } else if (...) { return y; } else { return z; } ``` Can be simplified to: ``` if (...) { return x; } if (...) { return y; } return z; ```
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
Just a reminder, `ByteBuffer` again :)
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
Exception message doesn't look right (the word "list").
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
Just a reminder, `ByteBuffer` again :)
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
probably not required to do a special logic for ConnectHeaders. The equals check using iterator below should probably be suffice.
Exception message doesn't look right (the word "list").
Maybe use Objects.requireNonNull
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
Nice, thanks for the update. Looks good
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
nit: remove the redundant line. Same as below.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
Let's replace the `assertTrue` by more effective matchers, and replace the `assertEquals` by `assertThat(..., equalTo(...))`.
Usually we also make a few API calls to the server, e.g. https://github.com/elastic/elasticsearch/blob/2aba52de8f9315b0e384e1c657d7b0401d26a1b0/qa/vagrant/src/main/java/org/elasticsearch/packaging/test/PackageTestCase.java#L121-L122 I'm not completely sold on the value of those though
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
Let's replace the `assertTrue` by more effective matchers, and replace the `assertEquals` by `assertThat(..., equalTo(...))`.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
As I suggested before, to not expose the node information, we should remove this function.
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
As I suggested before, to not expose the node information, we should remove this function.
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
I think we should provide some context on the exception here.
nit: add `final`
`UnknownTopicOrPartitionException` is the cause of the actual exception `e`, so we cannot just catch it here.
Might be better to add a catch-clause for this case instead? ``` try { ... } catch (final UnknownTopicOrPartitionException ignoreAndSwallow) { } catch (final InterruptedException | ExecutionException e) { throw new RuntimeException(e); } ```
nit: add `final`
ditto here and others below
ah I mean't Throwable.... sorry
just use `IOUtils.closeWhileHandlingException(is)` instead of the 6 lines in the finally block
same for tests below as well
Not saying you need to change this or anything, but just want to point out that once everyone is on cooperative this state change actually indicates the _end_ of a rebalance.
I think we should provide some context on the exception here.
nit: add `final`
`UnknownTopicOrPartitionException` is the cause of the actual exception `e`, so we cannot just catch it here.
Might be better to add a catch-clause for this case instead? ``` try { ... } catch (final UnknownTopicOrPartitionException ignoreAndSwallow) { } catch (final InterruptedException | ExecutionException e) { throw new RuntimeException(e); } ```
nit: add `final`
ditto here and others below
ah I mean't Throwable.... sorry
just use `IOUtils.closeWhileHandlingException(is)` instead of the 6 lines in the finally block
same for tests below as well
Not saying you need to change this or anything, but just want to point out that once everyone is on cooperative this state change actually indicates the _end_ of a rebalance.
I think it will be cleaner? not a biggy though
> Why do you think that? Does having a hard reference to an object guarantees all weak references to it are kept around? I was worried the GC might decide to remove a weak reference just because, in which case we will create another marker. Again - not saying this is wrong, but looking to learn.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Same concern regarding the leniency.
Same concern regarding the leniency.
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
maybe just use `IOUtils` here they handle null values as well
maybe just `esVersion()`
ah, right. nah, that's fine. just when reviewing I had the thought that if we guaranteed non-`null`/non-empty in the constructor, this wouldn't be necessary. i realized that it was actually intentional, but easy to miss when reviewing here and not getting the same highlighting as an IDE
might want to rename `workerId` so it doesn't shadow the member field. something like `workerIdOpt` could work
I think it will be cleaner? not a biggy though
> Why do you think that? Does having a hard reference to an object guarantees all weak references to it are kept around? I was worried the GC might decide to remove a weak reference just because, in which case we will create another marker. Again - not saying this is wrong, but looking to learn.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
can we not short cut return, but rather set the hostList to empty and continue the same execution path (with the same logging)
I really don't think we need this leniency, I'd like to understand why we're introducing it. I think we should just blow up the pings.
maybe just use `IOUtils` here they handle null values as well
seems dangerous to use the thread name to check ownership. might be safer to check reference equality on `Thread`
I am wondering if we should throw an `IllegalStateException` here, because it seems illegal to me to request a lock of a task directory in a state directory that does not exist.
add space after `=`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
@dakrone Ha thanks! :D
@dadoonet "iff" is a synonym for "if and only if"
I would debug log it, not warn, this is not always caused by user permission (getting null when listing files)
Use constant when possible
Use constant when possible.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think it is not OK because of the lack of symetry of the equals method: although `new ClosestNestedParentFilter(parentAggregator).equals(parentFilter)` would return true, `parentFilter.equals(new ClosestNestedParentFilter(parentAggregator))` would return false, which means we might pollute the filter cache with a new filter that will never be reused every time this aggregation is used. So I think we need to fix the root issue, that is that parent aggregators should be fully constructed before constructing sub aggregators, before fixing this one.
I think we need a better fix for this: it's bad that we pass the parent aggregator in but it's not fully constructed yet. Additionally, I'm concerned that the equals method of `ClosestNestedParentFilter` is not symetric, this could lead to duplicates in the filter cache.
we need to remember to update this when we add the reverse_nested aggregator :)
I don't like it much when constructors have side-effects. Can we maybe move the API from ``` java new PidFile(path, true); ``` to something like ``` PidFile pidFile = PidFile.create(path, true); ``` to make it clear that there is something happening (since there is a verb)
Since `children`, `properties` and other's are defined as module args, the key will be present in `params` and initialized to is a default value. Hence the `if` check here and above is not required. `self.children = module.params['children']` is sufficient
I think most if not all of this can be removed and replaced with argspec code https://github.com/gundalow/ansible/blob/docs-argspec/docs/docsite/rst/dev_guide/developing_modules_general.rst#main-and-ansiblemodule-argument-spec
Sure, that sounds sensible.
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
Now you are using subboptionsn you only need `no_log` on password, & api key.
inventory plugin, not module ... also we can use 'short form' for licenses now
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
i want to standarize on 'inventory_hostname' and allow either free jinja2 form or 'choices' depending on plugin, not showstopper, but something to think about to standarize across plugins.
it seems i misunderstood the feature, i thought this controlled what OS property populated the inventory_hostname
You probably should add yourself to the authors list as well.
You should really have at least one example with `state=absent`.
Tests for `formset_factory()` and `formset_factory()` are missing.
I think we can check the beforePart == null out of the if(!..equals) and it will make it cleaner.
We need to close this thread pool at the end of the test
this seems to be called when `upgrader.needsUpgrading(shardId)` indicates true, so this is not needed. Do we want an assert `needsUgrading(shardId)` instead? if we want the log (which should be debug imho) it should be moved to the calling function. It's not visible now.
also, I think the opened channel needs to be closed at one point
should be cached thread pool, the default constructor does the right thing here
Thanks a lot for this! Definitely better to generate that in a temp dir on the fly instead of having those files as part of the git repo!
`Arrays.toString(paths)` already adds [] , no need to add them
can we add the index name, shard id and the paths looked at as the exception? it's especially interesting because needsUpgrading checks for the state folder. Also, do we care about nodes that have the state folders but no data in them? should we fail the node in that case? if so, may change the message to say "no shard state found in any of [FOLDERS], please check and remove them if possible".
I think in this case we should add `null` to the lagWindow and not calculate the diff value for the bucket that is `lag` buckets from this one too. otherwise we will get out of step when we encounter missing data. This would match the behaviour in the derivative agg.
this file needs formatting
I'm fine as well, will make a reference to 10055 of this PR
It seems not possible in Java
Maybe an `assert` for unit tests (are `asserts` common in Kafka code base?). As `WrapperSerde` is private, nobody else can use it -- so no need to check for `null` IMHO.
ditto here and others below
Do we need to do this at this point? I guess so at it makes sense to have `sourceTopicNames` match what's in `nodeToSourceTopics`. I'm only asking as we never had this before and I'm curious as to why.
make this an atomicreference to throwable so we can see what it was in the failure message? (use assertNull)
same for tests below as well
@akarnokd please correct me if I'm wrong, but on machine (VM) with only one core this won't be async at all because `Schedulers.computation()` has `count of threads == Runtime.getAvailableProcessors()`, I'd replace it with `Schedulers.newThread()`
make this Error? we alway want to use this.
nit: extra line
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
this _technically_ changes the public interface and would require a KIP if we're being pedantic about the process. I personally think we can go by without a KIP but we obviously need a committer to say what they think
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
s/payload is/payloads are
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same for tests below as well
typo: byteArrray -> byteArray
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same for tests below as well
typo: byteArrray -> byteArray
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Minor: it seems like this test would be a little simpler if you start subscribed to topic1 and then switch to topic2.
Similarly, everything up to the fetch (i.e. coordinator lookup, join group, and sync group) are pretty much the same in all of these methods. Maybe we turn it into a function (e.g. `prepareRebalance`).
ditto on removing before/after.
ditto on (what I think is) the impossibility of this condition being false.
Ditto on removing these before/after methods.
ditto on removing before/after.
Ditto on removing before/after
nit: should we inline these? The variable names are barely shorter than the method names.
ditto on the properties and the driver.
same for tests below as well
ditto on the properties and the driver.
ditto on removing before/after.
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
ditto here and others below
I think we can now remove this condition as the client can not be null because we throw now `new ElasticsearchException("Unable to configure Azure compute service", e);` in the CTOR
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Maybe the `testConfiguration` methods should be called `checkConfiguration` to distinguish from the test cases. Similarly for `testInvalidConfiguration`.
I think I'd just do: ```java List<String> lines = asList(loginType.contextName() + " { ", jassConfigProp, "};") Files.write(jaasConfigFile.toPath, lines); ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
same for tests below as well
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
Good catch, thanks for cleaning this up!
Well, it's not at the end of the file right? But if you'd prefer to keep it that's fine too, was just a "super nit" suggestion ð
super nit: extra blank line
Cool. I think the fewer configs overall, the better. If we can get away with just the Serde configs then let's do so to keep the API surface area smaller for users ð
When you use it with an instance of `PreBuiltAnalyzers`.
It *looks* to me like this will hit a `NullPointerException`.
```suggestion throw new ConfigException(innerSerdePropertyName, innerSerdeClassOrName, "Deserializer's inner serde class \"" + innerSerdeClassOrName + "\" was not a valid Serde/Deserializer."); ```
I don't think it's important for now
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
nit: extra blank line ```suggestion ```
Do we really need to print `super.toString`? Ditto above.
We also need a test to validate that some extensions can be ignored (neither valid nor error).
Does this test ever encounter this exception? I don't think we will be able to backport this test to < 2.6 because the method won't exist at all, much less generate the exception that is being caught here. If anything, this generates a less informative NPE later in `put`, and hides the actual root cause.
same here. let's make all method params as `final`
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
This name seems backwards.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
nit: simplify to `final String propFileName = args[0];` -- was checked above already
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I would rather test this by calling the newFilter static method. In fact the check that we left there instead of relying on validate is there ony to protect other code paths from the outside (newFilter is public)
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
nit: add `final`
nit: add `final`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
same for tests below as well
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
Let's use `Map` on the left side instead of `HashMap`
I hope we can get rid of those conversion in the future :)
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
Do we need this Constructor? It looks like it's only called from `parse()` which has the version so it could call the other constructor
Similar here, we can cache the result in case to be reused.
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
Let's use `Map` on the left side instead of `HashMap`
I hope we can get rid of those conversion in the future :)
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
Do we need this Constructor? It looks like it's only called from `parse()` which has the version so it could call the other constructor
Similar here, we can cache the result in case to be reused.
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
Let's use `Map` on the left side instead of `HashMap`
I hope we can get rid of those conversion in the future :)
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
Do we need this Constructor? It looks like it's only called from `parse()` which has the version so it could call the other constructor
Similar here, we can cache the result in case to be reused.
extract to variable
```suggestion waitForCondition( this::checkForPartitionAssignment, CONNECTOR_SETUP_DURATION_MS, "Connector tasks were not assigned a partition each." ); ```
This cleanup seems a bit awkward. It assumes that tests will initialize the driver but not close it, which seems like a strange abdication of responsibility. I think it would be cleaner and clearer to get rid of the driver field entirely. Tests that need the driver already initialize it; they can declare it as a local variable as well. Then, they clearly need to close it as well. Since `TopologyTestDriver` is `AutoCloseable`, one option is to declare the driver in try-with-resources style: ```java @Test public void myTest() { try (final TopologyTestDriver driver) { // the test code } } ```
nit: remove empty line
ditto on removing before/after.
ditto on removing before/after.
do we need this invalid config step here
Alternatively, we could ditch the `driver` field and just make it a local variable in every test. Having it as a field made more sense when it was `setUp` in each methods, but now that it's instantiated in each test, it would be simpler to limit the scope to a local variable. Each test would need to call close at the end, but that's fine with me. If anything, it demonstrates proper use of the driver.
Ditto on removing before/after
This is because we are inheriting a Scala class, and moving forward we should remove this with the Java version `org.apache.kafka.copycat.util.ShutdownableThread` that can be moved into `o.a.k.common.utils`. We can leave it as is for now.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
I don't know that we should fix this now, but I think failures of this test will miss the gradle reproduction steps, right? I've been thinking of pulling those into a tiny shared project without dependencies just so we don't have trouble with stuff like this but I haven't looked into it deeply enough to be sure.
The KIP has the following method and is missing in the PR. `void updateRemotePartitionDeleteMetadata(RemotePartitionDeleteMetadata remotePartitionDeleteMetadata)`
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
I think we can check also randomly on a shard that relocates _to_ the local node
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
I think we can check also randomly on a shard that relocates _to_ the local node
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
same 1+ randomInt
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
I think we can check also randomly on a shard that relocates _to_ the local node
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
I think we can check also randomly on a shard that relocates _to_ the local node
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
I think we can check also randomly on a shard that relocates _to_ the local node
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
makes sense - treat whatever I wrote as a draft that can be adjusted as more metrics are added
I think we can use `Class.isAssignableFrom` to see what type it is rather than catching the exception. See `ChannelBuilders.createPrincipalBuilder` for a similar use case.
well, i thought a method reference would work here for the hash map, but I tried it and it doesn't seem to work. ð¤
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Then the log message should state the reason (e.g., the class was not found) and that the named provider will not be used. However, it does seem strange that this is technically an invalid configuration, so why would we not just throw a ConfigException? Note around lines 723 how any configuration property whose value is a Class name will be invalid if a `ClassNotFoundException` is caught, and this leads to a `ConfigException`. Silently ignoring seems at best inconsistent but at worst a bad idea.
@becketqin is right-- you should handle this case. Perhaps the server sent back bad data. The way to handle it is not to throw an exception, but to complete the relevant future(s) with an error. There are a few other cases where we handle bad server data by completing a future with failure in AdminClient.
If we do not expect this to happen. Shouldn't we throwI IllegalStateException? In this case, if the broker returned a replica that is not in the request, the broker may have somehow misplaced a replica. We should probably alert in this case.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
Yeah, I am not sure. I was thinking we might run into situations where we are trying to detect when a cached image has changed. It is a conventional thing to do, but I don't feel too strongly about it.
nit: maybe worth adding `this == o` to these `equals` implementations. This applies to all of the similar classes in this PR.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: can we call it getParseFieldMatcher? now that we have an interface it should be easy to rename all the existing impls at the same time. If you feel like it should be a follow-up, I am fine with that.
typo `to to` (also missing `.` at the end of the sentence)
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
```suggestion /** * The value of {@link StreamsConfig#APPLICATION_SERVER_CONFIG} configured for the Streams * client. * * @return {@link HostInfo} corresponding to the Streams client */ ```
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
Nit: `.` missing at end of sentence
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
nit: parameter descriptions are no sentences, thus no `.` at the end (on many other places, too). If we say they are sentences, they it should start with upper case `[T]he TopicPartition`
Existing issue, space should be after the colon.
It looks like `(' %s' % order).strip()` can simply be `order` now.
put the closing parenthesis on the next line
`%(expressions)s)` not `%(expression)s)`. You're missing the `s` at the end of `expressions`
I think these _could_ be: ``` __str__ = render __html__ = render ``` Avoiding +1 depth (and it's faster). Off the top of my head, the only reasons _not_ to would be: - `x.__str__` would report `<bound method X.render of ...>` instead of `<bound method X.__str__ of ...>` - you _could_ technically manually call `x.__str__(template_name='a')` but I mean, who's doing that? Discuss amongst yourselves whether to change it, I don't think it really matters much :)
Remove `self.function = 'CONCAT_WS'` and the following line which mutates `self.template` and instead: ``` return super(ConcatPair, self).as_sql( compiler, connection, function='CONCAT_WS', template="%(function)s('', %(expression)s)" ```
I would like to avoid using of regexp here, it is always clunky. We should take into account that only the `ArrayField` is affected but it's more complicated then it looks like, e.g. if we decrease a size and change a `base_field` in a single alteration then we still have a data loss: - `_field_data_type(ArrayField(IntegerField(), size=5))` returns `integer`, - `_field_data_type(ArrayField(CharField(max_length=16), size=4` returns `varchar`. So for `ArrayField` we should cast only when `base_field` is different and `size` (in any dimension) is not smaller than the previous one. It's complicated :disappointed: and would require a very special treatment of `ArrayField`'s. (\cc @charettes )
I think you meant `get_ellipsized_page_range` here. Use `number` instead of `page_num` which matches the argument name used by `Paginator.get_page()`.
recommended; ditto below.
Could you clarify what's happening by adding an example 2-line CSV file? I think that would improve the docs.
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
Fails checkstyle, needs to be final
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
Fails checkstyle, needs to be final
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
Fails checkstyle, needs to be final
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same as above, missing . at end
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
`keySerde` -> `valueSerde`
recommended; ditto below.
Wildcard imports should be caught by checkstyle, and should fail the build. In any case, please replace with non-wildcard imports.
We would like to avoid wildcard import in the code base.
thinking aloud: even though we are binding to a specific StateStoreProvider implementation here, it seems fine,since there are n't any other really in a topology
The purpose of this change was to highlight that the data structure is required to be concurrent. Of course if a method that existed in `ConcurrentMap` and not in `Map` was used, that would be a hard requirement. `putIfAbsent` used to be such a method but that's not the case after 1.8. In any case, the use of the more accurate interface is valid even if we don't explicitly use methods that don't exist in the parent. That's because the need for this implementation to be thread safe is a requirement here.
Since log.error(.. ex) will print the stack trace already, may be we can save re-throwing the exception again. EDIT: if we want to stop the whole process by throwing the exception, we can then save log.error().
The first two of these fields are unused. I think that's right, and we should remove them and also `ec2Bucket`, by generating the key and token and then passing them into the bucket's constructor.
I was trying to understand why this step got necessary, can you briefly explain? I'm just curious what happens here since it didn't happen in the test before.
Hmm, I think I'd prefer two separate maps with two separate fields in `LoginManager`. It makes things more explicit and easy to understand in my opinion (even though it's a bit more code).
I _think_ (Collections.&lt;String, DiskUsage&gt;emptyMap(), Collection.&lt;AllocationId, Long&gt;emptyMap()) is more "java" here even (and maybe especially) if it is a horrible mouth full.
prop: make the value a `SortedSet` so we can just insert clients as we build the map and use a custom comparator to automatically sort the clients based on lag
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Maybe we could use a different value here.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
Can remove if initialize above
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
nit: add a size? There are a few cases in here where we could do this.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
Seems to fit in one line
This doesn't seem to be used.
extension name must not be empty
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
nit: add `final` (same below)
This doesn't seem to be used.
The test name is not self describing: what about `shouldAlllowToSpecifyRocksDBConfigSetterClassAsString`
For `all()` function, its returned type should be `KafkaFuture<Void>`; ditto for other two Results as well.
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
nit: add `final` (same below)
This doesn't seem to be used.
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
nit: add `final` (same below)
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
This doesn't seem to be used.
For `all()` function, its returned type should be `KafkaFuture<Void>`; ditto for other two Results as well.
extension name must not be empty
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
```suggestion /** * Metadata of a task. */ ```
You might consider using `OptionalDouble`.
Nit: go with single parameter per line.
@vahidhashemian, yes, that's what I mean.
Do we really want anything related to internal topics to be client side? This could change in brokers from version to version and the clients should still work. I understand that for now we have no way to get that information, but we will soon (KAFKA-3306). I imagine removing the client side list would be part of the cleanup once thats available. So whatever exists in the mean time should be private so we don't need a deprecation cycle.
Yes, this should on an internal package (eg `common.internals`).
@gwenshap meant that `kafka.common.Topic.InternalTopics` should be removed in favour of the `INTERNAL_TOPICS` defined in this PR.
It looks like we don't support mixed mode testing. That seems worth a follow-up JIRA. It is definitely an interesting case from the perspective of the raft implementation since it involves two listeners.
Maybe we could use a different value here.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
I think the result does not need to include anything here if we organize the top-level future as a map of members -> the corresponding futures of `Void`.
```suggestion /** * Metadata of a task. */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
Nit: go with single parameter per line.
Remove the last sentence, since the `reset` method is private, and looks like it's handle automatically.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Should this be abstract? It feels weird to use it without actually configuring any scripts. I think maybe in `StoredScriptsIT` just extend it and return `emptyMap` there. That seems like a special case of using this.
If you think lots of places will use the empty definition then I don't think it should be abstract. I thought only a few script would use the empty definition though.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: add a size? There are a few cases in here where we could do this.
For `all()` function, its returned type should be `KafkaFuture<Void>`; ditto for other two Results as well.
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
This doc seems wrong for `retry.timeout`. Or is this really a retry limit? Either way, might want to mention the constraints (e.g., "Must be a positive number.") that are enforced by the config.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
I think the result does not need to include anything here if we organize the top-level future as a map of members -> the corresponding futures of `Void`.
```suggestion /** * Metadata of a task. */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
Nit: go with single parameter per line.
Remove the last sentence, since the `reset` method is private, and looks like it's handle automatically.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I have a similar concern here for when entry.getValue is not a Map
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I have a similar concern here for when entry.getValue is not a Map
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I have a similar concern here for when entry.getValue is not a Map
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It's different because the join and split actually do something and have a clear reason for being included. It also correctly handles versions like 3.4.1, which chopping off the end of the string doesn't. ``` >>> srv_version = '3.4.16' >>> srv_version[:-3] '3.4' >>> srv_version = '3.4.1' >>> srv_version[:-3] '3.' ```
I'm not sure what the purpose of the split and join currently are. Shouldn't this be splitting and joining on `.`? ```suggestion loose_srv_version = LooseVersion('.'.join(srv_version.split('.')[:2])) ```
Could we move these two functions to `org.apache.kafka.common.utils.Utils`? And we can then also remove the duplicate sort function in `DefaultPartitionGrouper`.
Is this requirement no longer true? The old logic doesn't match the error message, but you haven't replaced it with anything at all.
This logic tried to enforce a minimum version requirement, which the new code does not. Since it doesn't sound like you have added compatibility with older versions (or have any reason to), why not do something like: ``` min_version = '2.4' if loose_srv_version < LooseVersion(min_version): module.fail_json(msg='MongoDB {0] found, the minimum version supported by this module is {1}'.format(srv_version, min_version)) ```
```suggestion msg = ' (Note: you must use pymongo >= {0} with MongoDB {1})'.format(loose_srv_requirement, loose_srv_version) ```
Should we call close in the `finally` block? Here and elsewhere
Why we need to call `streams.close()` inside the function given they are always called in `tearDown`? Ditto below.
Well, won't we end up deleting the topics before closing it if we never reach the first `streams.close` ? Or does it not really matter in that case since something has already gone wrong (just curious, I'm fine with it as-is btw)
I think, here it makes sense to wait until all Streams clients are `RUNNING` so that we know that the rebalance is done.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You have some unmerged lines here
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
Can you use `== false` here...the `!` is almost hidden in all the other text around it...
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
Could you please add some line breaks? This and some of the other verifications are too long.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
does it need to be protected? Also maybe rename to something like collectValue ? I find it weird to call add against the script itself
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
can't help but wonder if these two impls could share more of their code. I guess that it all starts with the factories not sharing a base class, and I vaguely remember talking with @nik9000 about this not being straight-forward...
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
you could rewrite this as ``` ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(config)); assertThat(e.getMessage, ... ); ```
++, it's a java 8 only idiom, which is not a problem for ingest, no backports
I think we shouldn't call the error handler if the error can be delivered or replaced on the normal path.
Maybe use `expectThrows(...)` instead? It is much cleaner and safer than try-catch blocks: ``` java ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(config)); assertThat(e.getMessage(), equalTo("[regex_file] regex file [does-not-exist.yaml] doesn't exist (has to exist at node startup)")); ```
can we remove this one, so it won't be called by mistake? I think only the benchmark calls it, in which case, the benchmark can call the one with the concurrencyLevel parameter using the available processors
`State<T>` can implement `OnSubscribe<T>` and you save one object allocation.
If `isUnsubscribed != 0` then the CAS in `unsubscribe` will fail and nothing happens. If you wanted to delay the unsubscription to the time when nextIteration is not running, then you need a separate indicator, i.e., unsubscribeRequested.
If `nextIteration` has terminated, the queue may still hold requested values so it might be worth considering calling `clear()` before quitting.
I think this may race with the termination of the generated `Observables` if they are async.
If terminated, you can skip the poll; I assume it is legal to call `onNext()` and `onCompleted()` from the user-supplied function.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: move parameter to next line
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
I reordered the method from "few parameter" to "more parameters" to make it easier to navigate within the file.
This is not in this PR: I realized that in `KGroupedStreamsImpl#repartitionIfRequired`, in the return statement: ``` return KStreamImpl.createReparitionedSource(this, keySerde, valSerde, queryableStoreName); ``` We pass the `queryableStoreName` as the prefix of the repartition topic. That seems not correct to me? cc @enothereska since it seems from one of your previous commits,.
This overload does not take `Materialized` parameter
can we factor the lentient handling part out in a single mehtod? ``` private Query rethrowUlessLentient(RuntimeException e) { if (settings.lenient()) { return null; } throw e; } ``` man I with we had support for annonymous functions here or macros even :)
nit: add `final`
There is no need to add quotes here. Please remove them from all modules.
So, looking at our existing list of modules, **api_url** is more popular than **server_url**. I guess we need to make sure we are making the right changes wrt. parameter naming. ``` [dag@moria ansible.git]$ grep -rl 'api_url' lib/ansible/modules | grep '\.py$' | wc -l 77 [dag@moria ansible.git]$ grep -rl 'server_url' lib/ansible/modules | grep '\.py$' | wc -l 21 ```
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
what about throwing an IllegalFormatException instead? I'm a bit concerned about catching IAE as this is a very generic exception.
just please don't add one. There are too many classes already.
ok, fair enough
oh boy I was hoping we would not need this sort of stuff, but I guess we do? I mean the instanceof as well as the cast to double array
As this is just a public wrapper for new Snapshot(...), I prefer that we make the constructor public and get rid of this method.
These look like leftovers.
Good idea to add this safety net.
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
`< Callback >` this explicit type is not necessary.
If it is no more an integration test, this should be removed.
Why do you need to prepare `KafkaStreams` for testing? Only classes that are mocked and that are either `final` or have static methods need to be prepared.
Ah, yes, it's `org.apache.kafka.test.TestUtils#tempDirectory()`. My mistake. The protocol is for all temporary state in Kafka tests to use that method. The change I made in `QueryableStateIntegrationTest` is basically what we should do here as well.
This is neat, but we shouldn't use it. There's an IntegrationTestUtil for getting a temporary folder, which is hooked in to support for different testing environments to set their desired temporary file location.
nit: one too many line break? :)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
Originally this was just intended as a sanity check. However, thinking about it more, it might be better to change it to a much longer period, or even get rid of it entirely. It should not be needed since there is a task `durationMs`, of course. That might make sense as a separate PR, since we should change all the workloads.
How about just ``` log.info("{}: (stdout): {}", id, resp.get("log").toString()); ```
How about just ``` log.error("{}: (stderr):{}", id, line); ```
@cmccabe is right about the race condition I think. we should probably check that `controlChannel` is initialized here
It seems a little harsh to set a fatal error condition because the process logged something on stderr. A lot of applications use stderr as an output. Maybe we should just log this with `log.error`.
Let's call this "StdoutMonitor" since that makes it more clear what it is doing. We may want to pass things other than status eventually. Also, the instance variable is called `stdoutMonitor`, which suggests that this is a better description.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
same for tests below as well
Why are we generating the connect internal topic names here? if there's a rule for the topic naming convention it should be defined in one place which is `ReplicationPolicy`.
One issue with c. is that it works for new environments. If users already have MM2 running, it's using topics with the current names.
> Oh no, this lines replace the original props.putIfAbsent(DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG, "mm2-offsets." + sourceAndTarget.source() + ".internal");, etc. not Connect's internal topics. `DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG` is one of the connect's internal topics. ``` private static final String OFFSET_STORAGE_TOPIC_CONFIG_DOC = "The name of the Kafka topic where connector offsets are stored"; ``` My point is users already can control these types of topics using the `DistributedConfig` so there's no point in controlling them again using the separator. The main issue I think we need to fix first is preventing is the replication of these topics.
> only when MM2 is running in standalone mode. They are created in any mode if there is no value for DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG > If the user is running MM2 in connect mode, the user is responsible for configuring DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG, DistributedConfig.CONFIG_TOPIC_CONFIG, etc. It is what you are meaning. Right? Small clarification, users can use `DistributedConfig` with any mode (even standalone) to override the name of these topics. And they always had the power to do so, even before KIP-690, and if this new topic name didn't match the `isInternalTopic` policy, it would replicate. The PR's approach is trying to control the Connect topics that MM2 needs to set up using the separator; this is where I am not sure it's a minor fix or something that requires a KIP that follows KIP-690. My suggestion, is to introduce the minor fix first and propose another KIP if you believe that Connect internal topics created by MM2 Workers should to be controlled by the separator as well.
We did not have this check before, why is it needed? Also checks here are only applied when running in "driver" mode.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Oh I see. I like it better the current way better then. I was confused by the fact that you could have both ALWAYS and PARTIAL in the same doc, maybe we could add an assertion that it never happers.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I usually prefer avoiding lambdas when it is possible, in that case that would give something like this: `Collections.sort(this.filters, Comparator.comparing(KeyedFilter::key));`
This idiom is used across a bunch of the tests, which is fine, but it's also a pretty generic bit of logic. I wonder if it would be better to move it to TestUtils. In fact, there are already a couple of utilities there for comparing iterators, and I bet there are also Hamcrest matchers that compare iterators. I'm fine with this as-is, if you prefer it; I just wondered if you knew about those other options.
I like the use of `Optional`. I think, you could make it even simpler: ``` final Sensor sensor = Optional.ofNullable(metrics.getSensor(fullSensorName)).orElseGet(() -> { final Sensor newSensor = metrics.sensor(fullSensorName, recordingLevel, parents); threadLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName); return newSensor; }); ``` Please use the correct indentation. We use 4 spaces. Same applies to the changes below.
The number of elements is not always 1. Each created thread-level sensor is added to this queue, e.g., `processLatencySensor`, `pollRecordsSensor`, etc. Check out the callers of `threadLevelSensor()`. Each queue contains all thread-level sensors for one single stream thread.
Probably not, and since sensor names are only used for internal bookkeeping there should be no compatibility issues with the change.
Why not organizing the thread-level sensors as cache-level sensors as well? I.e. `Map<String, Deque<String>> threadLevelSensors = new HashMap<>()` where the string key is just `threadName`, since we will only remove sensors for the whole thread at once.
Makes sense, we can do that later.
Child-Index was deprecated recently -- should we remove it? Also, with KIP-251, we should capture output timestamps, too.
For this specific API, I suspect it is ever commonly used in PAPI, so I'm fine with not supporting it right away, also as a way to encourage users to change code sooner than later, if there's anyone.
I'm +1 on supporting the timestamps, even if it's not commonly used now, users will often look to tests for example usage (at least I do). I'm also +1 on removing `childIndex` for the same reason, but I don't have too strong an opinion on that.
Do you think it would be clearer if we don't rely on the defaults, but just explicitly include both branches? Oh, also, this isn't an immutable builder, so you can just do: ```suggestion if (cachingEnabled) { stateStoreConfig.withCachingEnabled(); } else { stateStoreConfig.withCachingDisabled(); } if (loggingEnabled) { stateStoreConfig.withLoggingEnabled(new HashMap()); } else { stateStoreConfig.withLoggingDisabled(); } ```
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
You might consider: ```suggestion try (final KeyValueIterator<String, String> scanIterator = forward ? stateStore.range(null, null) : stateStore.reverseRange(null, null)) { TestUtils.checkEquals(scanIterator, dataIterator); } ```
Do you think it would be clearer if we don't rely on the defaults, but just explicitly include both branches? Oh, also, this isn't an immutable builder, so you can just do: ```suggestion if (cachingEnabled) { stateStoreConfig.withCachingEnabled(); } else { stateStoreConfig.withCachingDisabled(); } if (loggingEnabled) { stateStoreConfig.withLoggingEnabled(new HashMap()); } else { stateStoreConfig.withLoggingDisabled(); } ```
should we put `kafka` and `numThread` directly into `props` and reduce number of parameters here (would also simplify all the "passing through" code.
Not saying you need to change this or anything, but just want to point out that once everyone is on cooperative this state change actually indicates the _end_ of a rebalance.
Why do we need this? This is logged anyway.
How about we reset the offsets between tests? I think that may be what you're suggesting. It would be cleaner not to accumulate metadata over time.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Same here, original exception is dropped.
Log the **node** versions? Can also be done directly in the loop where you are adding the nodes :-)
This is no longer used, could be removed
we throw the exception and thus take care of the interrupt. We don't need to set it...
this is not needed. createIndex automatically reroutes.
OMG `== false`! ð±
You can push a fix for this oversight directly, dismiss my disapproving review, and merge. ð
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
I see that we need it from another package, I think it's ok.
same for tests below as well
ditto here and others below
You should be able to collapse this to `IOUtils.close(this.current, uncomittedTranslogs)`
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
confuses the shit out of me everytime :)
Not sure if this already includes the shard context, but if it doesn't can you change it to: ``` logger.debug("{} found local translog with id [{}]", this.shardId, id); ```
You don't need to specify any symbolic name for a group since you have only one.
This method can be public, static, and take a String instead of a Path, which would allow us to unit test it. It will require moving the logging up one level higher though, but still nice to be able to unit test.
Ah! I misread this as turning `logAll` *on* instead of *off*. Now I get it :)
you are perfectly right Christoph, let's merge the two and keep the existing class.
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
I think it's always a single node cluster, but I'm good to keep it like this.
look into `StreamInput#readMap`
you can fold this into the previous `if` block, so it reads: ``` if (in.readBoolean()) { this.nodeDecisions = Collections.unmodifiableMap( in.readMap(StreamInput::readString, NodeAllocationResult::new)); } else { this.nodeDecisions = null; } ```
At minimum this should be typed (we should have separate script classes for each underlying doc values type), but I would much rather this be built into the script itself, so instead of setting the value, an iterate type call is made, similar to the doc values api.
Rather than use `0` in the case of "unknown" in a mixed version cluster it would be nicer to have a specific "unknown" value, say `-1`, and then not include the count in the JSON output if it's unknown. For example: ``` if (in.getVersion().onOrAfter(Version.V_6_5_0)) { this.nodeCount = in.readInt(); } else { this.nodeCount = -1; } ```
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
Nit: add `final` to both parameters -- please follow a "one parameter per line" formatting.
why do you need `CopyOnWriteHashMap` here? you don't really edit the map, you only replace it.
sounds great thanks
we can use Writeable here instead of Streamable so fields can become final and default constructor can go away
Nit: `final` and formatting
@rajinisivaram The login callback handler class isn't getting its #configure(Map<String, ?>, String, List<AppConfigurationEntry>) invoked. Perhaps it might be better to treat the login callback handler class the same way the client and server callback handler classes are treated, which is to create/configure them in SaslChannelBuilder? Note that the login callback handler class is potentially used both on the client side **and** on the server side (it is used on the broker when the mechanism is the inter-broker protocol).
Rather than use `0` in the case of "unknown" in a mixed version cluster it would be nicer to have a specific "unknown" value, say `-1`, and then not include the count in the JSON output if it's unknown. For example: ``` if (in.getVersion().onOrAfter(Version.V_6_5_0)) { this.nodeCount = in.readInt(); } else { this.nodeCount = -1; } ```
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
why do we have this API bloat with all the Builders? Can't we simply use a constructor? All the factories etc are not really needed IMO
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Nit: add `final` to both parameters -- please follow a "one parameter per line" formatting.
why do you need `CopyOnWriteHashMap` here? you don't really edit the map, you only replace it.
sounds great thanks
we can use Writeable here instead of Streamable so fields can become final and default constructor can go away
Nit: `final` and formatting
@rajinisivaram The login callback handler class isn't getting its #configure(Map<String, ?>, String, List<AppConfigurationEntry>) invoked. Perhaps it might be better to treat the login callback handler class the same way the client and server callback handler classes are treated, which is to create/configure them in SaslChannelBuilder? Note that the login callback handler class is potentially used both on the client side **and** on the server side (it is used on the broker when the mechanism is the inter-broker protocol).
Rather than use `0` in the case of "unknown" in a mixed version cluster it would be nicer to have a specific "unknown" value, say `-1`, and then not include the count in the JSON output if it's unknown. For example: ``` if (in.getVersion().onOrAfter(Version.V_6_5_0)) { this.nodeCount = in.readInt(); } else { this.nodeCount = -1; } ```
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
why do we have this API bloat with all the Builders? Can't we simply use a constructor? All the factories etc are not really needed IMO
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
I think it's always a single node cluster, but I'm good to keep it like this.
Same minor nitpick about whether or not we need to check for an empty group ID.
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
@rajinisivaram The login callback handler class isn't getting its #configure(Map<String, ?>, String, List<AppConfigurationEntry>) invoked. Perhaps it might be better to treat the login callback handler class the same way the client and server callback handler classes are treated, which is to create/configure them in SaslChannelBuilder? Note that the login callback handler class is potentially used both on the client side **and** on the server side (it is used on the broker when the mechanism is the inter-broker protocol).
At minimum this should be typed (we should have separate script classes for each underlying doc values type), but I would much rather this be built into the script itself, so instead of setting the value, an iterate type call is made, similar to the doc values api.
here you may be able to use copyCurrentStructure
you can fold this into the previous `if` block, so it reads: ``` if (in.readBoolean()) { this.nodeDecisions = Collections.unmodifiableMap( in.readMap(StreamInput::readString, NodeAllocationResult::new)); } else { this.nodeDecisions = null; } ```
Rather than use `0` in the case of "unknown" in a mixed version cluster it would be nicer to have a specific "unknown" value, say `-1`, and then not include the count in the JSON output if it's unknown. For example: ``` if (in.getVersion().onOrAfter(Version.V_6_5_0)) { this.nodeCount = in.readInt(); } else { this.nodeCount = -1; } ```
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: `== false`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Nit: should we call this `rateUnit`? Same for the other constructor.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should only be done in close()
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
I think we should call `deserializer.configure(...)` here
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
nit: could use Utils.mkSet
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
nit: add a size? There are a few cases in here where we could do this.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Just wondering if this test is good. Seems like a "RoundRobinAssigner" might compute the exact same assignment. Some more "randomness" would be good IMHO. (Not a must though.)
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
ditto here and others below
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
same for tests below as well
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
maybe just : ``` final ShardRecoveryContext shardContext = ongoingRecoveries.computeIfAbsent(shard, s -> new ShardRecoveryContext()); return shardContext.addNewRecovery(() -> createRecoverySourceHandler(request, shard, shardContext)); ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I think most assertEqual don't include a comma on this line.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Adding the exception is fine, but you can just throw it directly: ``` throw new OffsetOutOfRangeException(...)` ``` Not need to assign it to variable first :)
variable exception unnecessary
Let's stop this on shutdown.
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
This seems not to be the right exception message here (looks like cp'ed from term query).
not sure this suppress warnings is needed
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
This seems not to be the right exception message here (looks like cp'ed from term query).
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
Adding the exception is fine, but you can just throw it directly: ``` throw new OffsetOutOfRangeException(...)` ``` Not need to assign it to variable first :)
variable exception unnecessary
Let's stop this on shutdown.
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
This seems not to be the right exception message here (looks like cp'ed from term query).
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
You might consider using `OptionalDouble`.
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
nit: could use Utils.mkSet
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should be done in reset()
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
The other constructor calls the parameter `sampledStat`. We should be consistent.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
Do we want to consider using a configuration for this and other spots where we have hard-coded values? With KIP-276 merged users can specify different timeouts per consumer type.
Nit: -> `messagePrefix + "It shouldn't be null.")` (remove space -- this allows to hand is an empty prefix without getting an undesired whitespace (ie, `""`, if prefix is not desired). Similar below.
`doWork` is just one iteration. `ShutdownableThread` has the loop. I'm ok with the change, but we probably will need to copy over some of the shutdown logic.
Was just thinking about how long a. transaction might possibly be open. 1 minute SGTM
nit: move `windowBy()` to it's own line -- also `count()` (similar below)
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
It may also be useful to assert that the current consumer position is equal to `rde.offset`.
To close out the earlier thread.. This test is okay, since `NOT_RUNNING` will make that instance go to DEAD state (or some non functional state like that) where the store cannot be obtained.. the lines below check that we can stil retrieve the keys from the other replica
Might be simpler to use the mock deserializer only for values.
Stream instance "one" -> "two"
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
How about "runs an external command for the worker."
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
As @s1monw would say, "you have 140 characters, use them". ð
Yet it's reverted now. ð
something like this: ```Java public SearchOnlyEngine(EngineConfig config) { super(config); try { Store store = config.getStore(); store.incRef(); DirectoryReader reader = null; boolean success = false; try { this.lastCommittedSegmentInfos = Lucene.readSegmentInfos(store.directory()); this.translogStats = new TranslogStats(0, 0, 0, 0, 0); final SequenceNumbers.CommitInfo seqNoStats = SequenceNumbers.loadSeqNoInfoFromLuceneCommit(lastCommittedSegmentInfos.userData.entrySet()); long maxSeqNo = seqNoStats.maxSeqNo; long localCheckpoint = seqNoStats.localCheckpoint; this.seqNoStats = new SeqNoStats(maxSeqNo, localCheckpoint, localCheckpoint); reader = SeqIdGeneratingDirectoryReader.wrap(ElasticsearchDirectoryReader.wrap(DirectoryReader .open(store.directory()), config.getShardId()), config.getPrimaryTermSupplier().getAsLong()); this.indexCommit = reader.getIndexCommit(); this.searcherManager = new SearcherManager(reader, new SearcherFactory()); success = true; } finally { if (success == false) { IOUtils.close(reader, store::decRef); } } } catch (IOException e) { throw new UncheckedIOException(e); // this is stupid } } ``` I did something similar a while back so I had it ready... I am not sure it safe to use ð¯
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
How about "runs an external command for the worker."
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
As @s1monw would say, "you have 140 characters, use them". ð
Yet it's reverted now. ð
something like this: ```Java public SearchOnlyEngine(EngineConfig config) { super(config); try { Store store = config.getStore(); store.incRef(); DirectoryReader reader = null; boolean success = false; try { this.lastCommittedSegmentInfos = Lucene.readSegmentInfos(store.directory()); this.translogStats = new TranslogStats(0, 0, 0, 0, 0); final SequenceNumbers.CommitInfo seqNoStats = SequenceNumbers.loadSeqNoInfoFromLuceneCommit(lastCommittedSegmentInfos.userData.entrySet()); long maxSeqNo = seqNoStats.maxSeqNo; long localCheckpoint = seqNoStats.localCheckpoint; this.seqNoStats = new SeqNoStats(maxSeqNo, localCheckpoint, localCheckpoint); reader = SeqIdGeneratingDirectoryReader.wrap(ElasticsearchDirectoryReader.wrap(DirectoryReader .open(store.directory()), config.getShardId()), config.getPrimaryTermSupplier().getAsLong()); this.indexCommit = reader.getIndexCommit(); this.searcherManager = new SearcherManager(reader, new SearcherFactory()); success = true; } finally { if (success == false) { IOUtils.close(reader, store::decRef); } } } catch (IOException e) { throw new UncheckedIOException(e); // this is stupid } } ``` I did something similar a while back so I had it ready... I am not sure it safe to use ð¯
@rajinisivaram I think @guozhangwang has observed unnecessary empty stub files cluttering the code base in the past, and is suggesting that as a pattern to avoid. Correct me if I'm wrong, but the way this logic is structured, it looks like like very little extra effort to add a default properties file as soon as non-empty defaults are needed (add the file, and switch to `self.prop_file = self.render(...)` Since this is such a minor edit, having an empty stub file in place doesn't really buy much. As for rendering missing templates as empty strings in ducktape - I don't think this is the right approach, since it would hide error conditions and potentially cause confusing behavior. For example, if the user's intention is to use a nonempty template file, but the location is wrong, he or she should receive an error (easy to diagnose) than potentially start up the service with different settings than intended (harder to diagnose).
As mentioned above, to avoid empty dummy files, we can just do something like this for now: ``` self.prop_file = "" self.security_config = SecurityConfig(security_protocol, self.prop_file) self.security_protocol = self.security_config.security_protocol self.prop_file += str(self.security_config) ```
```suggestion self.parser.add_argument("--no-fail-on-errors", action="store_true", default=False, dest='dont_fail_on_errors', ``` A common pattern in CLI args is yup use "no".
unrelated, but maybe worth creating helper method that returns `Optional<GracefulShutdown>` to avoid these null checks throughout
Got it. For future readers the function is `maybeCompleteShutdown`.
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
I usually use `Map<String, Object>` though I suppose it doesn't matter.
I think that such iterables like `[None, False]` should be tuples like `(None, False)`, because it's less memory consuming and faster a bit. Anyway, it is not very important, because of small container size.
Just to make an attempt at word-smithing > When doing an --list, represent shared variables inside groups or the inventory, > which has a smaller memory footprint but is not Ansible's internal representation
Can you use `== false` here...the `!` is almost hidden in all the other text around it...
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
to match the behavior of `_get_raw_host()` I think this reconstruction should only occur in the `SERVER_NAME` scenario.
ð on get_config for clarity.
Just a thought, you could leverage get_config from [constants.py](https://github.com/ansible/ansible/blob/a0344acd78c422457b5a018b9de59e213f39dc87/lib/ansible/constants.py#L58) to allow end users to use env variables or ansible.cfg as they prefer instead of relying on a different config file. Example usage in ARA: https://github.com/openstack/ara/blob/master/ara/config.py
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
Usually we also make a few API calls to the server, e.g. https://github.com/elastic/elasticsearch/blob/2aba52de8f9315b0e384e1c657d7b0401d26a1b0/qa/vagrant/src/main/java/org/elasticsearch/packaging/test/PackageTestCase.java#L121-L122 I'm not completely sold on the value of those though
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
to match the behavior of `_get_raw_host()` I think this reconstruction should only occur in the `SERVER_NAME` scenario.
ð on get_config for clarity.
Just a thought, you could leverage get_config from [constants.py](https://github.com/ansible/ansible/blob/a0344acd78c422457b5a018b9de59e213f39dc87/lib/ansible/constants.py#L58) to allow end users to use env variables or ansible.cfg as they prefer instead of relying on a different config file. Example usage in ARA: https://github.com/openstack/ara/blob/master/ara/config.py
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
Usually we also make a few API calls to the server, e.g. https://github.com/elastic/elasticsearch/blob/2aba52de8f9315b0e384e1c657d7b0401d26a1b0/qa/vagrant/src/main/java/org/elasticsearch/packaging/test/PackageTestCase.java#L121-L122 I'm not completely sold on the value of those though
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
Nice, thanks for the update. Looks good
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
nit: line too long
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You have some unmerged lines here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
to match the behavior of `_get_raw_host()` I think this reconstruction should only occur in the `SERVER_NAME` scenario.
ð on get_config for clarity.
Just a thought, you could leverage get_config from [constants.py](https://github.com/ansible/ansible/blob/a0344acd78c422457b5a018b9de59e213f39dc87/lib/ansible/constants.py#L58) to allow end users to use env variables or ansible.cfg as they prefer instead of relying on a different config file. Example usage in ARA: https://github.com/openstack/ara/blob/master/ara/config.py
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
Usually we also make a few API calls to the server, e.g. https://github.com/elastic/elasticsearch/blob/2aba52de8f9315b0e384e1c657d7b0401d26a1b0/qa/vagrant/src/main/java/org/elasticsearch/packaging/test/PackageTestCase.java#L121-L122 I'm not completely sold on the value of those though
Nice, thanks for the update. Looks good
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
Nice, thanks for the update. Looks good
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
perfect thanks. sorry for the confusion.
we can just call `terminate(threadPool)` here
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
`name()` -> `wrapped.name()`
same here as what i said below. You can use a `assertThat`
this shouldn't be public, potentially private, otherwise package private if we call it from tests.
`wrappedStore()` should `return wrapped;` -- that's why I argue for renaming the variable.
Not sure about this -- why not add two generics to the store, one for "wrapped" and one for "root" and keep this method that return the root type? I would also rename `inner()` -> `root()`
same as above, no need for try catch
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
Just a thought: maybe instead of referring to the Delimiter in Aggregations we can have an own constant in Suggest and either declare the same symbol there or delegate to InternalAggregation.TYPED_KEYS_DELIMITER? The delimiter doesn't need to be the same in aggs and suggestions, only the parsing part needs to refer to it (although its good to have the same like we do now I think)
as I said above, that makes sense, I adjusted it on our branch that way.
@original-brownbear I understand that part, but IMHO it's best if we stick to some basic guidelines for our tests/benchmarks. To reduce the GC impact how about we decrease the cache size to 5, and the number of records to insert 25 or so? Or just create an array inline with the keys and declare as a private variable? Either way, we should be able to do the work in the `setUp` method.
Sorry for being late on this. Populating static variables from a non-static method is generally not a good practice since it's generally not thread-safe. Given how JMH works, it's fine for those fields to be non-static right? Also, it seems more realistic since the data is isolated per run.
maybe rename this to `setUp` and put the loop populating the array in this method
This is the essential line of the test that verifies the change in #7097. Without the fix in #7097, the listener will get an update with *all 3 task IDs*, and to pass this line would then need to be changed to: ``` configUpdateListener.onTaskConfigUpdate(Arrays.asList(TASK_IDS.get(2), TASK_IDS.get(0), TASK_IDS.get(1))); ``` However, we don't want *all* task IDs to be updated. Instead only want only the task ID(s) for the tasks that were indeed updated. That's why this test case expects that the task config update only includes the one ID of the task that is actually updated (i.e., `TASK_IDS.get(2)`). So as is, this test method will fail unless the fix for #7097 is actually applied.
Do we really need to also duplicate the typed_keys logic here? Can't we just print out the name of the parsed aggregation (it can be initialized with type#name)
I understand. But this requires to grab back the type and delimiter where initializing the parsed aggregation directly with the name "type#name" would allow to parse back the result too. Also, in a client side point of view, the name is "type#name". But I'm nitpicking, we can change this later if we want.
Yes, it makes sense to return a range for an ApiKey instead of a single version. I was just wondering if this method is redundant given NodeVersions.apiVersionRange(ApiKey api). Also, it feels a bit weird for a public facing class to reference Protocol, which is not a public facing one.
But `toString` by default returns `name()`. So, I don't understand why we are overriding it.
I dont' think this is possible? `getFields()` never returns null
Should we have tests for the `DistributedConfig` class? Again, much of the logic should be the same, but the tests would each be simpler if using a `ConfigDef.Validator`.
Can we fold this into `writeTo` and add a boolean to the signature (maybe `includeRequestHeaders`)? It seems like it just requires adding a if/else block
Nit: `active.size()-1` -> `active.size() - 1`
Ah yes, thanks!
can we just return here to make it clear that we are baling out? We then don't need the further `if(!initializable.isEmpty())` checks below
ok - same thing three times. Maybe extract it to a method `verifyTransactionInflight`
Looks good. I like the additional checking that you're doing here.
It might be worth adding a default implementation of it to whatever interface declares it. The vast majority of the time its a noop.
can you just leave the constant in this class? There isn't a need to put it in realm imo
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
getters should not use get. i.e. use `networkDevice` here, etc.
nit: Starting a message with lower case feels a little unusual.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
nit: I know it was already like that, but since we are now passing the actual class object, you might want to refer to the class object as `klass` (I like the keystrokes on this one) or `clazz`, which are common naming conventions when using class objects. Then call the String field `className` or similar. Of course JsonProperty will continue to be called `class`. Up to you.
Suggest using `Executors#newCachedThreadPool` rather than manually counting threads. We don't need a `ScheduleExecutorService` here either... just a plain `ExecutorService` is fine.
I think these need to be `volatile` if we want them to work cross threads. I was thinking we should consider using `AtomicInteger` to avoid the need to increment these variables inside synchronized variables. I know it has a smaller cap (INT_MAX) but I imagine that should be enough for such a test
Ha, that existed. Strange, I remember searching for such a thing before and not finding it
Each unit test should test one thing, so break this into separate tests for the different test conditions.
Please use string interpolation. There are a few other places like that.
Would `isUnknown` be clearer? I find that boolean methods without any prefix feel a bit ambiguous when reading them.
Hmm, we should probably specify that we can change the output of this String (i.e. parsing may break). I would have preferred if we didn't expose this as a public method and had a utility for it.
same for tests below as well
The reason should be more explicit about why this needed.
Nit: `findHostName` -> `getHostName`
the AnsibleModule class has a method to find executables. Use that method: kinit_cmd = module.get_bin_path("kinit", required=True)
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
Do note that this does not take `self.principal` into account, neither is that being checked. So you might return with `changed=False` if there's a tgt for a totally different principal.
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
This would no longer raise `ValueError` but `PageNotAnInteger` or `EmptyPage`. I think this PR needs some more consideration and tests.
nit: one too many line break? :)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
It would probably be helpful to include the old constructor. At least I can imagine users having test cases where they construct SinkRecords directly and it would be nice not to break those unnecessarily.
I think `kafkaOffset` was incorrectly changed to `Long`. We'll always have a Kafka offset, so it should be `long`. Also, the current version breaks compatibility since the old signature constructor is no longer available.
We need to keep this public method and deprecate. Perhaps throw an exception if multiple group ids were specified and retain existing behaviour for single group id.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
nit: no new paragraph required
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
We should actually remove the reference to `KTable` as we don't currently support it
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
It would probably be helpful to include the old constructor. At least I can imagine users having test cases where they construct SinkRecords directly and it would be nice not to break those unnecessarily.
I think `kafkaOffset` was incorrectly changed to `Long`. We'll always have a Kafka offset, so it should be `long`. Also, the current version breaks compatibility since the old signature constructor is no longer available.
We need to keep this public method and deprecate. Perhaps throw an exception if multiple group ids were specified and retain existing behaviour for single group id.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
nit: no new paragraph required
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
We should actually remove the reference to `KTable` as we don't currently support it
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
Please remove empty line.
Here you should test if the stream thread has the name of the stream thread that was removed before.
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
nit: new line
same for tests below as well
I think it would be better to wait until the Kafka Streams client id in state `RUNNING` and then verify if the history of the states transitions after adding the stream thread is first `REBALANCING` and then `RUNNING`. Currently, the order is not verified as far as I can see.
nit: new line
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
Closing does not need `keyfile`. (Tested it with the module, works fine without `keyfile` option.)
Ah, I misread that. Totally makes sense :)
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
```suggestion - Path of the authentication file. Default is ``${XDG_RUNTIME_DIR}/containers/auth.json`` ```
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
when you opt-in to using a CM like this, make sure you only patch lines that you really need to patch. and put any assertions outside, whenever possible: ```suggestion assert ret == [] ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
It's already stripped: ```suggestion (PODMAN_OUTPUT, ''), ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
Is there precisely one time you can specify this? It sounds to me like this should be allowed to repeat multiple times. So this should be a `list`. Or maybe even better a `dict`, so people can specify things like ``` blkio_weight_device: /dev/sda: 100 /dev/sdb: 200 ```
Closing does not need `keyfile`. (Tested it with the module, works fine without `keyfile` option.)
Ah, I misread that. Totally makes sense :)
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
```suggestion - Path of the authentication file. Default is ``${XDG_RUNTIME_DIR}/containers/auth.json`` ```
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
when you opt-in to using a CM like this, make sure you only patch lines that you really need to patch. and put any assertions outside, whenever possible: ```suggestion assert ret == [] ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
It's already stripped: ```suggestion (PODMAN_OUTPUT, ''), ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
Is there precisely one time you can specify this? It sounds to me like this should be allowed to repeat multiple times. So this should be a `list`. Or maybe even better a `dict`, so people can specify things like ``` blkio_weight_device: /dev/sda: 100 /dev/sdb: 200 ```
I'd also consider removing this one too if we are not using it.
`Integer.toString` is a slightly more concise way of doing this.
I'd suggest to use a more descriptive test name, e.g. in the form of `shouldDoXYZ`.
It would be better to do the assertion in the test rather than here. It will make the test clearer.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
nit: this doesn't throw IOException. You can remove all of these all the way up to `MetadataImage.write`.
This can be initialized here and be `final`
I think @becketqin was suggesting that we can add a method to `Kafka` that would cause the thread waiting on `KafkaServer.shutdownLatch` to resume and call `System.exit()` with the appropriate exit status.
I am wondering would it be better to have this logic in `kafka.Kafka.main()` instead of in the exception? Also it seems that after calling shtudownSystem() the thread will continue to run in this case, which is different from the previous behavior, i.e. system.exit() does not return. If we do so we need to inspect all the cases where we call `System.exit()` and make sure all the threads will exit after we change it to throw the exception. By putting this logic in `kafka.Kafka.main()`, we can still call System.exit() in any of the Kafka thread after catching the `FatalExitError` exception and it is guaranteed the thread won't run anymore.
If there are multiple FatalExitError thrown, do we want call `System.exit()` only once instead of creating a thread for each of them? Maybe we can just log the error and return.
`Integer.toString` is a slightly more concise way of doing this.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: add `final` (same below)
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
I fixed this one to use the constant before merging.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
The test name is not self describing: what about `shouldAlllowToSpecifyRocksDBConfigSetterClassAsString`
use `try-catch` instead of `expected` annotation -- not a single line test.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
I fixed this one to use the constant before merging.
nit: add `final` (same below)
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Fails checkstyle, needs to be final
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
nit: move parameter to it's own line (same below)
There is a built-in for this `Function.identity()`
nit: could use Utils.mkSet
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
`Arrays.asList` could be replaced with `Collections.singletonList`
We really need a docstring here. `ConsumerRecordTimestampExtractor` enables event-time processing, which is a crucial functionality for stream processing. Also, the name `ConsumerRecordTimestampExtractor` (which IMHO we should keep) does not hint at "hey, if you use me, then you'll get event-time processing in return". Idea: > Retrieves built-in timestamps from Kafka messages (introduced in [KIP-32: Add timestamps to Kafka message](https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message)), thus providing event-time processing semantics. > > Here, "built-in" refers to the fact that compatible Kafka producer clients automatically and transparently embed such timestamps into messages they sent to Kafka, which can then be retrieved via this timestamp extractor; i.e. these built-in timestamps are different from other timestamps that the user may have included in the _payload_ of the Kafka message. However, I remember that KIP-32 actually defines: > (From KIP-32) > Add the following two configurations to the broker > - message.timestamp.type - This topic level configuration defines the type of timestamp in the messages of a topic. The valid values are _CreateTime_ or _LogAppendTime_. The docstring idea above only covers CreateTime semantics (= producer-time), not LogAppendTime (= broker-time). So we may need to correct the docstring idea.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
Nit: could just throw the exception directly here; doesn't appear to be much benefit to putting that in a separate `setup` method.
Cheating the compiler, woohoo!
public access? I can see this being accessed by another package too (such as `rest.resources`)
Passing through Jackson seems to be the real test we need here (though checking `toString()` itself is also useful for logging elsewhere if we want consistency).
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
There are some request header tests in `RequestResponseTest`, we should move them here so that we can find them all in one place.
There is a built-in for this `Function.identity()`
nit: move parameter to it's own line (same below)
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
@guozhangwang i'm not sure why we would want to enforce caching? Perhaps the custom store is already an in memory store? Why would we cache that? Perhaps there is some other reason why they don't want caching for a given store.
@duy @jeyhunkarimov Got it. So I think the question is whether we want to partially solve the "not be able to have finer-grained caching" problem here or just keep it as is and wait for a more focused shot later in another ticket. I think we can argue that it is OK to be "soft" and potentially change it later when we have another mechanism for fine-grained caching. My concern, though, is that by opening the pandora box of allowing users to do caching like this we are not long complicating the internal implementation (which, as we talked, is OK as long as this tech debt can be simplified later), but also about exposing the internal classes like CachingXXStores to public user interfaces, and this box is hard to be closed later. Anyways, my take is that eventually the finer-grained caching support should be added, but not by exposing the CachingXXStores to users.
Synced with @dguy offline on caching, the current semantics "only dedup on forwarding if it is the default CachingXXStore with wrapper RocksDB" looks OK to me. I think we need to re-consider the unification of caching with dedupping after this since now with user customizable stores this caching mechanism is narrowed to default state store suppliers only.
ok - i see what you are saying. That probably feeds into another issue, though. I know we don't support it now, but the global caching on/off switch is probably too coarse grained. I think we should be able to decide on a per store basis if we want it to be cached or not. I think this has already been asked for by at least a couple of people.
My concern with this approach is that it isn't very flexible, i.e., i either have caching on or off, and that if i'm using any custom stores (and there might be a mix of custom/non-custom), and i don't need/want the custom store to be cached, then i need to turn it off for everything.
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
I really like this class.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
nit: move parameter to it's own line (same below)
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
`Arrays.asList` could be replaced with `Collections.singletonList`
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
I fixed this one to use the constant before merging.
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
nit: add `final` (same below)
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
nit: remove the redundant line. Same as below.
use `try-catch` instead of `expected` annotation -- not a single line test.
Fails checkstyle, needs to be final
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: could use Utils.mkSet
I fixed this one to use the constant before merging.
nit: add `final` (same below)
```suggestion public void shouldInstantiateAssignor() { ```
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Fails checkstyle, needs to be final
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
This could be final.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I fixed this one to use the constant before merging.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
`Integer.toString` is a slightly more concise way of doing this.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: add `final` (same below)
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
This could be final.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I fixed this one to use the constant before merging.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
`Integer.toString` is a slightly more concise way of doing this.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: add `final` (same below)
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
Ditto on the properties and the driver.
Same here - more randomization would be nice
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
Ditto on the properties and the driver.
Same here - more randomization would be nice
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
Ditto on the properties and the driver.
Same here - more randomization would be nice
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Yeah but I expect the value for this config to come from a class implementing the interface so in this case `DefaultReplicationPolicy`.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
> I think we're talking about two different sets of leniency :) ++ :smile:
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
This could be `Strings.hasLength(tokenizerName)`
This is not good for backword compatibility. Instead it should do: ``` if (indexSettings.getIndexVersionCreated().before(Version.V_6_0_0)) { String tokenizerName = settings.get("tokenizer", "whitespace"); tokenizerFactory = ...; } else { tokenizerFactory = null; } ```
I don't think we should swallow the exceptions here, instead, this could be a try-with-resources block like: ``` java try (BufferedReader br = new BufferedReader(rulesReader)) { .. read the string .. } ```
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Both `GZipInputStream` and `SnappyInputStream` read the header in the constructor, so it would make sense to me to remain consistent in that respect.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
I don't think we should swallow the exceptions here, instead, this could be a try-with-resources block like: ``` java try (BufferedReader br = new BufferedReader(rulesReader)) { .. read the string .. } ```
This could be `Strings.hasLength(tokenizerName)`
This is not good for backword compatibility. Instead it should do: ``` if (indexSettings.getIndexVersionCreated().before(Version.V_6_0_0)) { String tokenizerName = settings.get("tokenizer", "whitespace"); tokenizerFactory = ...; } else { tokenizerFactory = null; } ```
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Both `GZipInputStream` and `SnappyInputStream` read the header in the constructor, so it would make sense to me to remain consistent in that respect.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
I don't think we should swallow the exceptions here, instead, this could be a try-with-resources block like: ``` java try (BufferedReader br = new BufferedReader(rulesReader)) { .. read the string .. } ```
This could be `Strings.hasLength(tokenizerName)`
This is not good for backword compatibility. Instead it should do: ``` if (indexSettings.getIndexVersionCreated().before(Version.V_6_0_0)) { String tokenizerName = settings.get("tokenizer", "whitespace"); tokenizerFactory = ...; } else { tokenizerFactory = null; } ```
nit : missing new line
"with a read-only key"
with a read only key
Pls use caps :) (see your `ErrorReporter` above).
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
typo `to to` (also missing `.` at the end of the sentence)
since this wrapper just exposes a new constructor, consider making it a factory method instead
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
nit: single parameter per line
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
```suggestion /** * Metadata of a stream thread. */ ```
Should this be retriable? Same question for `FetchSessionIdNotFoundException`.
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
```suggestion * Metadata of a Kafka Streams client. ```
Seems that this class is a bit redundant, i.e, we could just construct an `AssignedTasks` with the `logContext` and `"standby task"`
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
typo `to to` (also missing `.` at the end of the sentence)
since this wrapper just exposes a new constructor, consider making it a factory method instead
Nit `{@code StateRestorerListener}`
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Pls use caps :) (see your `ErrorReporter` above).
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
typo `to to` (also missing `.` at the end of the sentence)
This style of setters is not AK convention.
nit: in kafka we normally don't use `get`/`set` prefixes
nit: single parameter per line
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
"given a read-only key"
Maybe an `assert` for unit tests (are `asserts` common in Kafka code base?). As `WrapperSerde` is private, nobody else can use it -- so no need to check for `null` IMHO.
We should log an error that prints out what the two configs actually are
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
I think we want to test index level blocks too here
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
Fine by me.
Maybe this one too, I'm not sure.
this new exception is going to trigger errors too if we try to serialize it to an older node
I don't think it's important for now
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
deprecated names match too. match should always return true, or rather throw an exception in strict mode if you use a deprecated name. I think it should be an assert. We had the same discussion with Colin in IndicesQueriesRegistry I think :)
the fact that the parse field matcher matches is a requirement, I think it should be an assert instead. It's really a our bug if it doesn't and we should catch it differently compared to "no function found"
I think we want to test index level blocks too here
rewrite test as above using `assertThrows()`.
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
Same question here as earlier about the `Locale`
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
I don't think it's important for now
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
ditto on the properties and the driver.
ditto on the properties and the driver.
Ditto on the properties and the driver.
nit: should we inline these? The variable names are barely shorter than the method names.
Ditto on the properties and the driver.
ditto on removing before/after.
If it is no more an integration test, this should be removed.
Why do you need to prepare `KafkaStreams` for testing? Only classes that are mocked and that are either `final` or have static methods need to be prepared.
Ditto on the properties and the driver.
nit: one too many line break? :)
same here. I think we should throw an exception when running into an error. No need to accumulate things and return them
Recently, we prefer to use `assertThat()` instead of `assertEquals()`.
Should this else clause be returned to what it was before the original refactoring PR? https://github.com/elastic/elasticsearch/pull/32068/files#diff-c94184ea4ef180f10817aa2bbd41a8edL119
Could also purge the local state before tests, just in case.
If we swallow the exception here, and the test always throws an IO exception, we will never notice. I guess it would be better to use `fail()` with a message.
The order is not really that important here, either way works
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: avoid double spaces
nit: why double space? (similar below and further below)
This can be `Files.notExist(...)`
This could be deleteIfExists
nit: extra line
we could pass a glob with regex:xxx to newDirectoryStream if we want
This method can be public, static, and take a String instead of a Path, which would allow us to unit test it. It will require moving the logging up one level higher though, but still nice to be able to unit test.
confuses the shit out of me everytime :)
Not sure if this already includes the shard context, but if it doesn't can you change it to: ``` logger.debug("{} found local translog with id [{}]", this.shardId, id); ```
"new" -> "now"
You should be able to collapse this to `IOUtils.close(this.current, uncomittedTranslogs)`
This seems like as super critical thing not to have a stronger assertion about. I think it is worth brainstorming a better test for a followup.
typo: an -> a, concat -> concatenated
Well, maybe I should have pointed them _all_ out the first time.
Same thing here with the `connectorProps` vs the `config`.
Also set the store name in this test.
I would name the method `passwd_check`.
It would be nice to be consistent about the ordering in `assertEqual` using it's `(variable, 'expected value')` but here and a couple other places it's opposite.
I would name the method `passwd_set`.
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
I would remove the emoji here ;o)
Break the line after the `(` to unify the style across the file.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
nit: can we make this debug level? Otherwise it will make this test a little spammy.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
All methods only used once should be explicitly inlined.
`fatal=False` will print error wen failed. Instead it should be optional and not print any error.
confuses the shit out of me everytime :)
Not sure if this already includes the shard context, but if it doesn't can you change it to: ``` logger.debug("{} found local translog with id [{}]", this.shardId, id); ```
`note` and `errnote` of `_download_json` instead.
This is fatal.
`int_or_none` for all int fields.
Code duplication. Prepare message and then throw only once.
Should this else clause be returned to what it was before the original refactoring PR? https://github.com/elastic/elasticsearch/pull/32068/files#diff-c94184ea4ef180f10817aa2bbd41a8edL119
nit: use assertThat(...) with isNull() as matcher instead? I think in general that is the preferred way of writing test assertions.
That's just a mistake. Initially I had separate priorities for `ADD_PARTITIONS` and `ADD_OFFSETS`, but forgot to adjust the `END_TXN` priority after combining them.
Let's make this an `UncheckedIOException` too.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
The order is not really that important here, either way works
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
I think that instead of looping here just checking that the index that is supposed to be removed is removed and checking that the number of indices is decremented by one is sufficient.
Might be simpler to use the mock deserializer only for values.
We can use `assertThrows` for this kind of pattern: ```java RecordDeserializationException rde = assertThrows(RecordDeserializationException.class, () -> consumer.poll(Duration.ZERO)); assertEquals(invalidRecordOffset, rde.offset()); assertEquals(tp0, rde.partition()); ```
Same as before, parameters of `assertEquals` should be the other way round.
Maybe we should remove the `Collections.synchronizedList` wrapper(s).
we do this kind of parsing in several places maybe a util can help at some point? not sure just an idea
this will not work, right? cause the default is `9300-9400`, which is good, since we want to try another port on the second instance we start on the same machine.
one assert per member is better then you see what's not null :0
nit - "once once"
don't drink and code ð» (same line twice)
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
spaces missing after `if` and before `{` ð¡
I see that we need it from another package, I think it's ok.
should we move the `configureSocketChannel` call into the try block as well here? seems cleaner
Same as before, parameters of `assertEquals` should be the other way round.
here I'd do the same as above an pass in an some kind of BytesReference factory that can produce new BytesReferences and return a `CompositeBytesReference` instead the `int` to signal how much has been read. We can figure out how to do SSL and stuff afterwards this is too hard to do in one step
I think here we can go with an ordinary `BytesReference` and use it's efficient iterator `BytesRefIterator iterator()` the returned `BytesRef` is just a pointer into the underlying `byte[]` that you can wrap in with `ByteBuffer#wrap` and do your accounting what is left for writing in this method. so there is no need to use a `NetworkBytesReference`
Not sure about this. `SslTransportLayer#hasBytesBuffered` returns true if there is any data in `netReadBuffer`. If more data is needed to unwrap and no data arrives from the client, I think the handling of `keysWithBytesBuffered` results in a tight polling loop with timeout=0.
You want the loop to read even when there is no data from the network. So the condition needs to be something along the lines of `if (channel.ready() && (key.isReadable() || channel.hasBytesBuffered()) && !explicitlyMutedChannels.contains(channel) && !hasStagedReceive(channel))`
I think it would be slightly neater to store the muted state in channel rather than Selector (not necessarily to save on cost, it just feels like channel state).
Since`keysWithBytesBuffered` was cleared earlier, it needs to be populated regardless of the status of staged receives. I think `"if(..) { keysWithBytesBuffered.add(..); }"` should be done outside the outer if that checks staged receives.
previous message => previous receive
So it seems the only reason for this method is to optimize iterator.remove (by using keysHandled .clear())? If so, I am not sure if it's worth doing this optimization since this makes the code a bit harder to read.
Nit: somehow I don't like `blah`. Otherwise LGTM
Rather than filtering ourself, we could alternatively pass prefix as glob to newDirectoryStream, and it would follow filesystem rules.
Nitpick, how about: ``` java public static File tempDirectory(Path parent, String prefix) { final File file; prefix = prefix == null ? "kafka-" : prefix; try { file = parent == null ? Files.createTempDirectory(prefix).toFile() : Files.createTempDirectory(parent, prefix).toFile(); } catch (IOException e) { throw new RuntimeException("Failed to create temporary directory", e); } file.deleteOnExit(); Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { Utils.delete(file); } }); return file; } ```
I would add a flush(), since we expect people to see those bytes and we want to be independent of the filesystem impl (what if it uses buffering, thats its choice)
could be shorted using `com.google.common.io.Files.write`
Again, need to figure out what to do if ATOMIC_MOVE is not supported
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
This is not longer correct - more like "Creates a new QueryBuilder from the query represented by the xcontent in the parser." or something.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
```suggestion * Any object created with {@code new} in {@link RocksDBConfigSetter#setConfig setConfig()} and that inherits ```
Typo: > Similar[ly], you can ... with [a] custom ...
Consistency: Here we say > with [a] custom "auto.offset.reset" strategy and below we say > Enum used to define auto offset reset policy when creating {@link KStream} or {@link KTable}. The AK docs say neither "strategy" or "policy", it's just a config like any other. Hence I'd suggest to change the above consistently to sth like: > with [a] custom {@code auto.offset.reset} configuration and > Sets the {@code auto.offset.reset} configuration when creating {@link KStream} or {@link KTable}.
Suggestion: We already say "Kafka Streams API", "DSL", and "Processor API". That's already a lot of "APIs" even though it's all about the same thing. I wouldn't label interactive queries to be yet another API. I'd just say: > ... to access the content via interactive queries:
At this point I don't know that `@param` adds anything either.
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
This is still missing in the KIP wiki page.
This is not longer correct - more like "Creates a new QueryBuilder from the query represented by the xcontent in the parser." or something.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
```suggestion * Any object created with {@code new} in {@link RocksDBConfigSetter#setConfig setConfig()} and that inherits ```
Typo: > Similar[ly], you can ... with [a] custom ...
Consistency: Here we say > with [a] custom "auto.offset.reset" strategy and below we say > Enum used to define auto offset reset policy when creating {@link KStream} or {@link KTable}. The AK docs say neither "strategy" or "policy", it's just a config like any other. Hence I'd suggest to change the above consistently to sth like: > with [a] custom {@code auto.offset.reset} configuration and > Sets the {@code auto.offset.reset} configuration when creating {@link KStream} or {@link KTable}.
Suggestion: We already say "Kafka Streams API", "DSL", and "Processor API". That's already a lot of "APIs" even though it's all about the same thing. I wouldn't label interactive queries to be yet another API. I'd just say: > ... to access the content via interactive queries:
At this point I don't know that `@param` adds anything either.
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
This is still missing in the KIP wiki page.
Checkstyle is unhappy with this.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It seems to me this check should be moved to ```ApiMessageTypeGenerator``` as it is a generated code from json.
> it doesn't seem particularly beneficial It seems to me the benefit is the error happens from runtime/test_runtime to build time (generate message code).
That alternative looks good to me :)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
same for tests below as well
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
I would include the non-null constraint in the sentence, eg "Returns a non-null resource pattern on which this action is being performed".
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
It would be good to have constants instead of hardcoding the fields in many places.
We need idempotent functions that work reliably between python 2 and python 3. Then if the caller has specific needs, they can take care of their own edge cases. Whatever goes in `utils/encoding.py` should be considered "library" grade, just like werkzeug.
Why can't we just return unicode (i.e. decoded bytestring, so `str` on PY3 and `unicode` on PY2)? In that case the signature would be `uri_to_iri(uri, encoding='utf-8')` just like werkzeug.
When you do `iri.decode(encoding)` you are getting unicode, so effectively you sometime have unicode, sometime bytes. If the caller needs bytes, it can encode in whatever encoding it desires .
Interesting! I guess we could implement it at some point, but that seems like a fair amount of work.
We don't need this message anymore as the future package is no longer used.
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
Don't put a newline in the middle of a work, put the newline before the work actually starts. There are a few examples of that in the module.
I would include the non-null constraint in the sentence, eg "Returns a non-null resource pattern on which this action is being performed".
It would be good to have constants instead of hardcoding the fields in many places.
They can only be decoded if these bytes were previously encoded in this encoding.
"If the charset is set to `None` no unicode decoding is performed and raw bytes are returned.". In that case you are returning unicode (already decoded) not raw bytes.
Interesting! I guess we could implement it at some point, but that seems like a fair amount of work.
We don't need this message anymore as the future package is no longer used.
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
When you do `iri.decode(encoding)` you are getting unicode, so effectively you sometime have unicode, sometime bytes. If the caller needs bytes, it can encode in whatever encoding it desires .
It would be good to have constants instead of hardcoding the fields in many places.
They can only be decoded if these bytes were previously encoded in this encoding.
"If the charset is set to `None` no unicode decoding is performed and raw bytes are returned.". In that case you are returning unicode (already decoded) not raw bytes.
snake_case, value to lower (linux/windows)
Interesting! I guess we could implement it at some point, but that seems like a fair amount of work.
same here, snake case, and convert value to lowercase
I did not check this in detail but if `UCharacter.getPropertyValueEnum()` returns values > `UScript.CODE_LIMIT`, then it would break your code that populates the `breakers` array below. In that case I would add an explicit check and throw an exception.
Ok, then it's fine.
Actually this line is not the actual problem, but this one is: ``` java final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT]; ``` together with ``` java breakers[code] = parseRules(resourcePath, env); ``` If `code` is greater than `UScript.CODE_LIMIT` then this will result in an `ArrayIndexOutOfBoundsException`. But I do not know whether it is possible that this condition occurs in practice.
shall we make some of these protected? sounds quite wrong to be using this exception without providing a status. Would be nice to remove some of these variants but I guess they are needed by EsSecurityException.
This whole loop reads fairly low-level. If config files can be considered small, we could just read them much more concisely with the Stream API (untested): ``` java String rules = Files.readAllLines(path) .stream() .filter((v) -> v.startsWith("#") == false) .collect(Collectors.joining("\n")); ``` All the low-level stuff is gone. But this relies on Java 8 features and will only work on master.
We can rely on auto-closeables here (i.e. we could use just the try-with-resource statement). Not necessary if you use my suggestion with the Stream API.
I am wondering would it be better to have this logic in `kafka.Kafka.main()` instead of in the exception? Also it seems that after calling shtudownSystem() the thread will continue to run in this case, which is different from the previous behavior, i.e. system.exit() does not return. If we do so we need to inspect all the cases where we call `System.exit()` and make sure all the threads will exit after we change it to throw the exception. By putting this logic in `kafka.Kafka.main()`, we can still call System.exit() in any of the Kafka thread after catching the `FatalExitError` exception and it is guaranteed the thread won't run anymore.
I think @becketqin was suggesting that we can add a method to `Kafka` that would cause the thread waiting on `KafkaServer.shutdownLatch` to resume and call `System.exit()` with the appropriate exit status.
If there are multiple FatalExitError thrown, do we want call `System.exit()` only once instead of creating a thread for each of them? Maybe we can just log the error and return.
Include class name here? This seems like it would be confusing if logged.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
```suggestion // TODO K9113: this is used from StreamThread only for a hack to collect metrics from the record collectors inside of StreamTasks ``` Just marking this for later follow-up.
I don't think it's important for now
did you plan to add here the list of nodes or something? looks like there is a missing argument.
Should this be included here, or should it refer to a dedicated section in the connect docs? I guess there's two cases: bootstrapping a whole new connect cluster, or upgrading an existing one. For the bootstrapping case it's not completely clear whether the "preparing" round is required.
is it an option to make this method package private? Then it would become more of an internal thing. Thanks for addressing this!
I did not check this in detail but if `UCharacter.getPropertyValueEnum()` returns values > `UScript.CODE_LIMIT`, then it would break your code that populates the `breakers` array below. In that case I would add an explicit check and throw an exception.
Ok, then it's fine.
Actually this line is not the actual problem, but this one is: ``` java final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT]; ``` together with ``` java breakers[code] = parseRules(resourcePath, env); ``` If `code` is greater than `UScript.CODE_LIMIT` then this will result in an `ArrayIndexOutOfBoundsException`. But I do not know whether it is possible that this condition occurs in practice.
shall we make some of these protected? sounds quite wrong to be using this exception without providing a status. Would be nice to remove some of these variants but I guess they are needed by EsSecurityException.
This whole loop reads fairly low-level. If config files can be considered small, we could just read them much more concisely with the Stream API (untested): ``` java String rules = Files.readAllLines(path) .stream() .filter((v) -> v.startsWith("#") == false) .collect(Collectors.joining("\n")); ``` All the low-level stuff is gone. But this relies on Java 8 features and will only work on master.
We can rely on auto-closeables here (i.e. we could use just the try-with-resource statement). Not necessary if you use my suggestion with the Stream API.
I am wondering would it be better to have this logic in `kafka.Kafka.main()` instead of in the exception? Also it seems that after calling shtudownSystem() the thread will continue to run in this case, which is different from the previous behavior, i.e. system.exit() does not return. If we do so we need to inspect all the cases where we call `System.exit()` and make sure all the threads will exit after we change it to throw the exception. By putting this logic in `kafka.Kafka.main()`, we can still call System.exit() in any of the Kafka thread after catching the `FatalExitError` exception and it is guaranteed the thread won't run anymore.
I think @becketqin was suggesting that we can add a method to `Kafka` that would cause the thread waiting on `KafkaServer.shutdownLatch` to resume and call `System.exit()` with the appropriate exit status.
If there are multiple FatalExitError thrown, do we want call `System.exit()` only once instead of creating a thread for each of them? Maybe we can just log the error and return.
Include class name here? This seems like it would be confusing if logged.
what is this provider doing here? We can't do this in our production code this will take hours for decouple again We either pass a client or not but not yet another indirection.
This seems to be redundant from above (or already the merged test...) -- restore-consumer and adminclient would be missing though.
add check for restore-consumer and admitclient
I think, we should use three different values to make sure that the different prefixes overwrite the configs for the corresponding clients. Looking into the test below, they seem to be redundant with this one? We can also remove this test and keep the other three (that would avoid redundancy, too)
as above -- add check for two missing clients
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
I don't think it's important for now
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
Nit: you can remove `value =`
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
As I suggested before, to not expose the node information, we should remove this function.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
Nit: you can remove `value =`
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
I've seen alternative solutions floating around that use a configurable source here. Basically, the configuration passed to configure() is consulted to find the "source cluster", rather than looking at the topic name. That approach lets you return an actual source here, which obviates the new canTrackSource() method etc.
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
recommended; ditto below.
Thanks. Not a blocker.
If these aren't expected to change at runtime, I'd suggest initializing the `HashMap` in the static block as a temporary variable , then wrapping it to create an unmodifiable map which is then used for the constant here: ```java Map<String, File> pluginJars = new HashMap<>(); try { pluginJars.put(..., ...); // More of the same } finally { PLUGIN_JARS = Collections.unmodifiableMap(pluginJars); } ```
And if they are not used yet, we can probably remove them for now.
My minor concern is that KeyFactory and ValueFactory may be only specific to key-value stores, not not any general stores; for example for database stores you may have some functions like ``` withSchema() ``` that defines the data types for each column but not using "withKey / Value" any more. But since it is only for future improvements let's revisit this nested mechanism later.
Does this factory need to extend key-value store factory? It seems a general in-memory factory, not specifically for key-value stores, right? And same for OffHeapFactory.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
I believe this will inject non-determinism ... notifications will be capable of interleaving and being out of order. I think we need to combine this with `ScheduledObserver` which maintains a queue and event loop for handling each notification sequentially on the given scheduler.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
maybe also test a nested conditional setup? (So have conditional and then another conditional in the matched or unmatched list)
redundant type arguments `<ProducerRecord<byte[], byte[]`
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Please note that in Python we don't use brackets unless really needed.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
You have some unmerged lines here
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: remove empty line
maybe use "a", "b", "c" as values, as the transformer counts the number of calls to `process` (for better distinction with next test)
nit: remove empty line
store not used
nit: fix indention (we usually use 4 spaces, not 8)
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
I really like this class.
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.
We also need to explain a bit why we add a type converter at this layer of the store hierarchy.
"this until it is" doesn't quite parse.
The other constructor calls the parameter `sampledStat`. We should be consistent.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
Thanks for the explanation, and thanks for fixing the synchronization. As an optimization, I think we should use something like `ConcurrentMap` here rather than synchronized blocks, so that we can minimize the amount of time threads spend waiting. This will be a bit more tricky to use, but more scalable. I guess when I thought about KIP-511, I thought of it in terms of metrics and perhaps occasional samples of connections (similar to how we do request sampling by logging a few selected requests). I don't see why we'd ever need a full snapshot of all existing connections. The snapshot would probably be out of date by the time it had been returned, since new connections are closed and opened all the time. Reading the KIP more carefully, I see that KIP-511 does specify a metric which essentially requires each connection to register itself. Considering we don't even have a way to visualize or graph this metric, I'm not sure this belongs in JMX. I have to think about this more...
I don't think it's necessary to keep a central registry of all this information for all connections. We really just need the metrics, most of which can just be simple counters. If we need more information about a connection, we can look at the request context of that connection. But it doesn't have to be stored here.
We also need to explain a bit why we add a type converter at this layer of the store hierarchy.
Nit: unnecessary new line.
"this until it is" doesn't quite parse.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
use `try-catch` instead of `expected` annotation -- not a single line test.
Nit: can be `final`
Nit: both parameters can be `final`
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.
We also need to explain a bit why we add a type converter at this layer of the store hierarchy.
"this until it is" doesn't quite parse.
The other constructor calls the parameter `sampledStat`. We should be consistent.
nit: Seems that this is not the right place for this method. It's now between static and non-static field members. It's used in the constructor, but still, it should probably be placed lower in the class.
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
I really like this class.
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.
We also need to explain a bit why we add a type converter at this layer of the store hierarchy.
"this until it is" doesn't quite parse.
The other constructor calls the parameter `sampledStat`. We should be consistent.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
oh, multi-bucket comparisons are ready already? :)
nit: than -> that
hopefully the `System.nanoTime` goes away once you merge master in.
nit: shall we rather initialize to empty and replace this with an empty check? I see that empty is currently not an option anyways.
and -> a
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
and -> a
base -> based progress -> progressed
any chance we can use `org.elasticsearch.common.xcontent.ObjectParser` here instead of the old style way of parsing stuff.
Have a look at `ConstructingObjectParser` which is designed for those cases where you have required parameters for the constructor. Alternatively you may end up making an object that has writeable parameter and then building the script from that. Whatever you think is more readable.
Perhaps say that the repartitioning will happen automatically, i.e., user doesn't need to do anything.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: add a size? There are a few cases in here where we could do this.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Can remove if initialize above
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
extension name must not be empty
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: add a size? There are a few cases in here where we could do this.
Can remove if initialize above
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Yes it will
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: add a size? There are a few cases in here where we could do this.
Can remove if initialize above
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Yes it will
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: add a size? There are a few cases in here where we could do this.
Can remove if initialize above
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
Can remove if initialize above
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
MILLIS => MS to be consistent with other places. Ditto in a few other places.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
Is this an oversight? `DEFAULT_KEEPALIVE_SETTING.get(settings)`
There's still a usage as `applicationId + "-" + topic` in the `SinkNodeFactory` subclass. The structure of that class is now a bit odd as the `applicationId` is passed as a parameter, but it's a non-static so it captures the parent reference and actually uses it for at least one other member of the parent class (`internalTopicNames`). I'm fine committing as is if this is consistent with trunk since then a clean up could easily be cherry picked if that was desired. But it looks like this patch and what's on trunk differ significantly. This method name doesn't even seem to exist on trunk? Are you sure you want to diverge so wildly? It's going to make any more backports/cherrypicks really annoying...
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
We should deprecate this one too I believe.
exiting -> exists
I think this would be cleaner as ```java aliasAndIndexLookup.compute(aliasMetaData.getAlias(), (aliasName, alias) -> { if (alias == null) { return new AliasOrIndex.Alias(aliasMetaData, indexMetaData); } else { ((AliasOrIndex.Alias) alias).addIndex(indexMetaData); return alias; } }); ```
Given that signaling this failure up the stack would be a mess, I wonder if partial results really bring us any advantage. I suggest we fail (call the listener's failure handle). When we'll move the security searches over a different threadpool, partial results would be even scarier.
Missing `assertAcked()` or call to .get()
Is this an oversight? `DEFAULT_KEEPALIVE_SETTING.get(settings)`
There's still a usage as `applicationId + "-" + topic` in the `SinkNodeFactory` subclass. The structure of that class is now a bit odd as the `applicationId` is passed as a parameter, but it's a non-static so it captures the parent reference and actually uses it for at least one other member of the parent class (`internalTopicNames`). I'm fine committing as is if this is consistent with trunk since then a clean up could easily be cherry picked if that was desired. But it looks like this patch and what's on trunk differ significantly. This method name doesn't even seem to exist on trunk? Are you sure you want to diverge so wildly? It's going to make any more backports/cherrypicks really annoying...
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
We should deprecate this one too I believe.
exiting -> exists
I think this would be cleaner as ```java aliasAndIndexLookup.compute(aliasMetaData.getAlias(), (aliasName, alias) -> { if (alias == null) { return new AliasOrIndex.Alias(aliasMetaData, indexMetaData); } else { ((AliasOrIndex.Alias) alias).addIndex(indexMetaData); return alias; } }); ```
Given that signaling this failure up the stack would be a mess, I wonder if partial results really bring us any advantage. I suggest we fail (call the listener's failure handle). When we'll move the security searches over a different threadpool, partial results would be even scarier.
Missing `assertAcked()` or call to .get()
`}` and `else if` should be on the same line
Nit: The default constructor `AtomicBoolean#<init>()` can be used.
Why is this `volatile`? It doesn't look necessary to me.
This also seems like the kind of leniency that we'd want to remove in the future.
But yeah, keep it now.
I would simplify this to just "importedClassName". Any name used in code always has to be canonical (like in java).
Ok sounds fine then.
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
5.1+ I think, actually. Have a look at `VersionTests#testUnknownVersions` and the note right underneath `Version#CURRENT`.
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
I have a small preference for `Future<Map<Integer, Future>>` because it seems more aligned to how we do it for other APIs but I don't feel strong about it.
This is the only remaining point of discussion. I don't have a strong preference for any of them so I leave it up to you.
This name seems backwards.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
Can remove if initialize above
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
nit: extra blank line ```suggestion ```
In the other constructor we have some nice preconditions and defensive copies, should we do the same here? Or maybe this constructor is meant to be private to `cloneWithFencing` below
but if you are in strict mode you get an exception so you don't get back false :)
what happens if there is no mapper? I would tend to simply ignore (to match the logic we have for stored fields now)
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
```suggestion - Add devices (spare or mirror) to an existing zpool. ```
```suggestion - Manage virtual storage pools using zfs zpools. ```
I would rename this to vdevs and add "vdev" as alias.
```suggestion - The name of the pool. type: str ```
The authors should include a Github handle, like: ```suggestion - Remy Mudingay (@rmudingay) ``` This is needed so you are properly notified as a maintainer.
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
```suggestion - Add devices (spare or mirror) to an existing zpool. ```
```suggestion - Manage virtual storage pools using zfs zpools. ```
I would rename this to vdevs and add "vdev" as alias.
```suggestion - The name of the pool. type: str ```
The authors should include a Github handle, like: ```suggestion - Remy Mudingay (@rmudingay) ``` This is needed so you are properly notified as a maintainer.
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
```suggestion - Add devices (spare or mirror) to an existing zpool. ```
```suggestion - Manage virtual storage pools using zfs zpools. ```
I would rename this to vdevs and add "vdev" as alias.
```suggestion - The name of the pool. type: str ```
The authors should include a Github handle, like: ```suggestion - Remy Mudingay (@rmudingay) ``` This is needed so you are properly notified as a maintainer.
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
ok, potentially reduces allocations for the user, thanks
Why do you remove this check? A `TimeWindow` should not allow this case.
I reordered the method from "few parameter" to "more parameters" to make it easier to navigate within the file.
Because there is not `CogroupedKStream#reduce()` method this sentence is not useful and should be removed.
as above (more often below -- please fit all)
nit: remove empty link
`scheduler` does not appear in parameter list of this method...
This overload does not take `Materialized` parameter
Perhaps say that the repartitioning will happen automatically, i.e., user doesn't need to do anything.
We can call the static function of KStreamImpl directly and get rid of the additional function in `InternalStreamsBuilder`.
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
ditto here and others below
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
ditto here and others below
nit: remove `this` (not required)
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
This may indicate a bug in `SessionWindowedDeserializer`
That class is different because it doesn't actually `define` the config, it's just an undeclared "extra" config that gets passed around to be interpreted inside the serde. Actually, this _is_ a bug, and that config _should_ be `define`d there the way you do it here.
we can make method this public in `EmbeddedConnectCluster`.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Can we pull this initialisation code into a method. I imagine most derived classes will implement `updateRemoteCluster` by storing the cluster names/addresses into some form of collection. But if that collection is a field, then it won't have been initialised at this point (in the parent constructor). The typical constructor is going to need to look like: ``` { super(settings, false); clusterNames = new ArrayList<>(); initialize(); } ```
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
nit: What do you think about sprinkling a bit of docstrings in this interface while we're rewriting it? I like the original description of `An MBean that allows the user to dynamically alter log4j levels at runtime.`
@wicknicks would be useful to have some unit test for this class.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
```suggestion * <p>A {@code retryBackoffMs} that is negative or zero will result in no delays between retries. ```
```suggestion * @param timeoutDuration timeout duration; must not be null ```
```suggestion * @param retryBackoffMs the number of milliseconds to delay upon receiving a * {@link org.apache.kafka.connect.errors.RetriableException} before retrying again ```
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Better name as "setCurrentNodeInProcessorContext"? And then in java docs mention that it returns the processor context with current node set.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
maybe just use `IOUtils` here they handle null values as well
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
same here as what i said below. You can use a `assertThat`
nit: make the keys a `Set<String>` and then do `assertThat(keys, equalTo(Utils.mkSet("2","3")`
I do not think we should log here. This is on the reload of a file and not an update to the ciphers settings
nit: remove (was tested already)
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
I would add an `assert this.context != null` here just to make sure
Seems like this might occur only in a programming error, which we could test for in a unit test.
Can you point out where it would fail? Unclear to me atm.
nit: remove -- not used
I would add an `assert this.context != null` here just to make sure
The map is not used.
Same as before, parameters of `assertEquals` should be the other way round.
clarify the error message specifying what needs to be non null? the inner query...also remove empty, doesnt make sense here
request1 and request 2 are not used.
We may need to call sender.run() one more time to ensure the message is not reenqueued. The reqenqueued message won't be sent out again in the same sender.run().
The map is not used.
Yup, I think that's also fine.
Should really ask for `toString()`s on these handlers too, although this adds noise.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
Nit: spacing between `while` and `(`.
Nit: spacing between `!` and `value`.
I see. Do not bother then :) At lease we are not introduce a regression to make perf worse :)
It's unusual to hold a reference to an abstract class like this. I believe the intent is to be able to transparently handle either `KeyValueSegments` or (I'm guessing) `KeyValueTimestampSegments`. The full expression would be to have a `Segments` interface implemented by `AbstractSegments`, which is then extended by your two implementations. Then this line would reference `Segments<S>`. It's fine to collapse this into just the abstract class (although questionable in the presence of package-protected fields). But to maintain transparency, I'd name the abstract class `Segments` instead of `AbstractSegments`. That way, to an outsider class (like this one), you're still just interacting with the interface (i.e., the public interface of the class), rather than specifically an abstract class. Adhering to this pattern leaves the door open in the future to extract `Segments` into a full interface without having to change any outside code (which is what I meant by maintain transparency).
My idea was to make the BulkRequestSource hold what it has to hold (the failed items), be able to retrieve them and act accordingly from processBulkIndexRequest, rather than have logic to deal with failures within the BulkRequestSource itself. Exposing different getters might help as well, that's another option. I tend to think that extracting the "processing" part would make things cleaner but I may be wrong.
Before calling this, we should probably add a check that the `batchedIterator.hasNext()` and throw if not. It might make our future life easier when trying to debug stuff :-)
Good call-- thanks for the correction.
This does work, but for a reason that is a bit obscure. When using an `ImplicitLinkedHashMultiCollection`, `remove` will remove the element b such that a == b, if it exists. This is necessary since if it just took the first element where `a.equals(b)`, it might be a different one than expected. It might be clearer to directly call `removeElementAtSlot`, since we already know the slot number.
Could combine these into a single `testCycleCollection()` method if you put a `null` value in the list (e.g. `"A", null, "C"`) and for every one of the 4 positions (0-2 and cycling back to 0) you also check the `peek()` value. I think it would be clearer compared to what you have currently since the last 2 methods you have now are a bit haphazard.
Note that `Hashtable` uses 11 (a prime number) as the default.
Nit: spacing between `while` and `(`.
Nit: spacing between `!` and `value`.
I see. Do not bother then :) At lease we are not introduce a regression to make perf worse :)
It's unusual to hold a reference to an abstract class like this. I believe the intent is to be able to transparently handle either `KeyValueSegments` or (I'm guessing) `KeyValueTimestampSegments`. The full expression would be to have a `Segments` interface implemented by `AbstractSegments`, which is then extended by your two implementations. Then this line would reference `Segments<S>`. It's fine to collapse this into just the abstract class (although questionable in the presence of package-protected fields). But to maintain transparency, I'd name the abstract class `Segments` instead of `AbstractSegments`. That way, to an outsider class (like this one), you're still just interacting with the interface (i.e., the public interface of the class), rather than specifically an abstract class. Adhering to this pattern leaves the door open in the future to extract `Segments` into a full interface without having to change any outside code (which is what I meant by maintain transparency).
My idea was to make the BulkRequestSource hold what it has to hold (the failed items), be able to retrieve them and act accordingly from processBulkIndexRequest, rather than have logic to deal with failures within the BulkRequestSource itself. Exposing different getters might help as well, that's another option. I tend to think that extracting the "processing" part would make things cleaner but I may be wrong.
Before calling this, we should probably add a check that the `batchedIterator.hasNext()` and throw if not. It might make our future life easier when trying to debug stuff :-)
Good call-- thanks for the correction.
This does work, but for a reason that is a bit obscure. When using an `ImplicitLinkedHashMultiCollection`, `remove` will remove the element b such that a == b, if it exists. This is necessary since if it just took the first element where `a.equals(b)`, it might be a different one than expected. It might be clearer to directly call `removeElementAtSlot`, since we already know the slot number.
Could combine these into a single `testCycleCollection()` method if you put a `null` value in the list (e.g. `"A", null, "C"`) and for every one of the 4 positions (0-2 and cycling back to 0) you also check the `peek()` value. I think it would be clearer compared to what you have currently since the last 2 methods you have now are a bit haphazard.
Note that `Hashtable` uses 11 (a prime number) as the default.
what is this provider doing here? We can't do this in our production code this will take hours for decouple again We either pass a client or not but not yet another indirection.
can we factor the lentient handling part out in a single mehtod? ``` private Query rethrowUlessLentient(RuntimeException e) { if (settings.lenient()) { return null; } throw e; } ``` man I with we had support for annonymous functions here or macros even :)
There is history around the azure plugin so I won't take this as an example. > Unless you have other thoughts I will go ahead and have a simple private method inside the BlobStore that returns the Storage instance. Code inside the Blobstore is responsible for not caching the instance. :+1: Let's do that and not block this PR. This is something we can still revisit later on.
I understand why you did that but I find that the two storageAccess() just adds extra unnecessary noise. I think we could instead have a simple private `safeClient()` method that returns the `Storage` client to use, and later do things like: ` SocketAccess.doPrivilegedIOException(() -> safeClient().get(bucketName));` I find this easier to read and to understand where the stack is cut for access control.
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
When you use it with an instance of `PreBuiltAnalyzers`.
It *looks* to me like this will hit a `NullPointerException`.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
I think it'd be nice to remove this second ctor so we're explicit every time.
But I wouldn't be afraid to just use a full if/else block, either. ```suggestion final WindowBytesStoreSupplier storeSupplier; if (inOrderIterator) { storeSupplier = new InOrderMemoryWindowStoreSupplier("InOrder", 50000L, 10L, false); } else { storeSupplier = Stores.inMemoryWindowStore("Reverse", ofMillis(50000), ofMillis(10), false); } ```
This is how I typically break up ternaries. ```suggestion final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier("InOrder", 50000L, 10L, false) : Stores.inMemoryWindowStore("Reverse", ofMillis(50000), ofMillis(10), false); ```
The original intent of the test was to ensure, we don't write into non-exiting topics, ie, create a topic out of nowhere -- but with the new abstraction that cannot happen anyway I guess.
This must be `OUTPUT_TOPIC_2`
Same as above mentioned, the validation didn't get handled in new API.
Nit: -> `messagePrefix + "It shouldn't be null.")` (remove space -- this allows to hand is an empty prefix without getting an undesired whitespace (ie, `""`, if prefix is not desired). Similar below.
```suggestion final StreamJoined<String, Integer, Integer> streamJoined = StreamJoined .with(Serdes.String(), Serdes.Integer(), Serdes.Integer()) .withStoreName("store") .withLoggingEnabled(Collections.emptyMap()); ```
```suggestion left.join( right, (value1, value2) -> value1 + value2, joinWindows, streamJoined ); ```
So there are metrics we would like to add but can't until we upgrade RocksDB? Can we create a 3.0 blocker ticket to add them back in when we bump rocks (and/or maybe a separate ticket to consider a major version bump of rocks with the next major version bump of kafka)
This is not completely compatible with the behavior of older Streams apps. See #10953 for a fix and more details.
same for tests below as well
method name changes
It should be robust in case of some missing fields.
nit. I think there is `.` missing `since 3.0[.] Use`
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
and -> a
I see that we need it from another package, I think it's ok.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It feels weird that this is empty.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
nit: remove `this` (not required)
That class is different because it doesn't actually `define` the config, it's just an undeclared "extra" config that gets passed around to be interpreted inside the serde. Actually, this _is_ a bug, and that config _should_ be `define`d there the way you do it here.
This may indicate a bug in `SessionWindowedDeserializer`
we can make method this public in `EmbeddedConnectCluster`.
Can we pull this initialisation code into a method. I imagine most derived classes will implement `updateRemoteCluster` by storing the cluster names/addresses into some form of collection. But if that collection is a field, then it won't have been initialised at this point (in the parent constructor). The typical constructor is going to need to look like: ``` { super(settings, false); clusterNames = new ArrayList<>(); initialize(); } ```
Change to Throwable.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
Code convention nitpick: there should be a space before the colon.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
nit: use `logContext
nit: make `Metrics` a field
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
nit: remove `this` (not required)
That class is different because it doesn't actually `define` the config, it's just an undeclared "extra" config that gets passed around to be interpreted inside the serde. Actually, this _is_ a bug, and that config _should_ be `define`d there the way you do it here.
This may indicate a bug in `SessionWindowedDeserializer`
we can make method this public in `EmbeddedConnectCluster`.
Can we pull this initialisation code into a method. I imagine most derived classes will implement `updateRemoteCluster` by storing the cluster names/addresses into some form of collection. But if that collection is a field, then it won't have been initialised at this point (in the parent constructor). The typical constructor is going to need to look like: ``` { super(settings, false); clusterNames = new ArrayList<>(); initialize(); } ```
Change to Throwable.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
Code convention nitpick: there should be a space before the colon.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
nit: use `logContext
nit: make `Metrics` a field
Even though this one should work, exact double comparisons tend to scare me a bit: should we use `null` instead of `-1` for non-existing x-axis units? (and store it in a Double)
Side note: we need to rename Reducer.FUNCTION to have a more explicit name.
I know it was already the case, but can we make this allocationFound parmater actually count the number of allocation found (i.e. all shards with an allocation id, matching or not) Later we can refactor this maybe and remove it completely but for now let's keep it consistent.
The indentation is off here and the rest of the way through this test.
no need for iteration here, you can get the node directly by calling `state.getNodes().get(shardRouting.currentNodeId())` (which will return `null` if no node found)
This should say `higher cluster state version` instead of `higher id`.
we don't need to determine `replicaToBePromoted`. Candidates also does not need to be filtered with ` !s.equals(replicaToBePromoted)`. It's ok to just check candidates.size() > 0 here to see whether there is going to be a new primary. In that case, we fail the primary + `random(0, candidates.size() - 1)` replicas and check afterwards that the new primary is on a node that is at least as high as all replicas.
I think "by" in this sentence should be replaced by "with": normally we'd say "tried to replace X _with_ Y"
I think for the benefit of Python 3 users at least we should set `__cause__` on this new exception to the original `KeyError`.
nit: Add `.` at the end of the sentence.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
nit: one too many line break? :)
I mean to close `node` and safe the conditional... but it's Releasable so you can use `Releasables.close()`
ditto here and others below
I think this constructor can go away
That's certainly a funky corner case, right? Its a broken plugin that does that.
Also, we were testing in the past that `sourceConfigDirectory` is actually a dir and not only an existing file. Did you change that on purpose? Or should it be `if (Files.isDirectory(sourceConfigDirectory)) {`
same for tests below as well
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
I don't think it's important for now
The logging brackets are off here: `[{} to [{}]]`.
`ConsumerRecords` -> `ConsumerRecords<byte[], byte[]>`
We could use a "for each" loop here, something like: ``` for (Class<? extends Connector> connector : connectorClasses) { connectCluster.configureConnector(connector.getSimpleName(), mm2Config.connectorBaseConfig( new SourceAndTarget(primary, backup), connector)); } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This intermediate `List` is not really useful. We could just change the loop below to iterate over the connector classes and call `getSimpleName()` on each of them
I'm assuming it's worth keeping this 2nd loop separate from the first one for performance reasons. At first glance it looks strange to iterate over the same collection twice in a row
Yes but the code that created the consumer should close it. If I call `waitForConsumingAllRecords()`, I'd not expect it to close my consumer instance.
I find it strange that this method closes the consumer it received.
I don't understand what this test is doing. Why do we need background clients instead of producing upfront and consuming the data mirrorred at the end of the test? It looks like we are testing the primary->backup scenario but we are restarting the backup cluster. The source connector should not interact with the backup cluster.
Actually the constructor of all such description classes can just be default package-private since they are only used by KafkaAdminClient, and hence can just be private APIs, and we do not need to deprecate-overload any more.
new ArrayList<String>() => new ArrayList<>()
I'd keep it as member field. Having to declare the type in every test case to which you use it is be a bit annoying. Also, if you reuse this variable in consecutively in the same test case, the fact that in the first occurrence you have to specify the type but in the next ones it's already declared, breaks a symmetry in assignments that's otherwise good. Finally, having it `final` is not all that useful.
This method is usually called `setUp()`.
This isn't your name
No need to repeat the choices.
Is this really necessary? Seems like it will produce a lot of noise.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
can we make `"security.manager.enabled"` a constant please
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
I mean to close `node` and safe the conditional... but it's Releasable so you can use `Releasables.close()`
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
https://github.com/ReactiveX/RxJava/blob/1.x/CONTRIBUTING.md > When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.
same for tests below as well
nit: one too many line break? :)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
https://github.com/ReactiveX/RxJava/blob/1.x/CONTRIBUTING.md > When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.
same for tests below as well
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
I did notice that you renamed the method in a subsequent commit which covers the "name should also ideally indicate the difference" part. :)
Maybe this should be a class docstring :thinking:
Hmm, I don't think this is right. We still need to build Scala 2.12 separately since it requires Java 8.
I think what you have here works fine. Thanks @umesh9794 for your PR.
Instead of pulling the value out with a regex, what do you think of `streamsString.contains("appId")`. Although what you have works as well.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
empty line needed
need to update `./gradlew uploadArchivesAll` at line no: 644
s/HashMap<String, Object> fields/Map<String, Object> fields
I think key-pairs of strings as list is brittle. But we inherited that.
I did notice that you renamed the method in a subsequent commit which covers the "name should also ideally indicate the difference" part. :)
Hmm, I don't think this is right. We still need to build Scala 2.12 separately since it requires Java 8.
I also think we can add a method that checks for precision to simplify this! please
need to update `./gradlew uploadArchivesAll` at line no: 644
maybe `Objects.equal` could make it easier to read
Note that `Hashtable` uses 11 (a prime number) as the default.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Shouldn't use a mutable container as default arg in python. If you ever add to the container you then find that you're sharing a single opy of that container everytime the function in python. You can do one of these two instead: ``` python # If you don't need to add to the container now. This just prevents doing something stupid when the code is changed in the future. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=tuple()): # if matches needs to be a mutable container. This creates a fresh list everytime the function is called. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=None): if matches is None: matches = [] ```
This applies to the other functions where a list is the default value as well.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
you don't need this. Junit gives you a new instance of the test class for every test method
I'd suggest to use a more descriptive test name, e.g. in the form of `shouldDoXYZ`.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
It would be better to do the assertion in the test rather than here. It will make the test clearer.
Sorry for that -- You are of course right. `final` only for iterator loops...
style nit: if the entire body is surrounded in a conditional, it's usually more readable to just check the negation and return, then reduce indentation with the rest of the body. no real need to fix here, just a style thing to watch out for moving forward.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
nit: Starting a message with lower case feels a little unusual.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
What about inlining `transformations` and having something like: ``` when(plugins.transformations()).thenReturn(Collections.singleton(transformationPluginDesc())); ```
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
I don't think it's important for now
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
I think this behavior should be shown in the examples since it is tricky to explain.
`WindowStore` is public API -- we need a KIP if we want to deprecate something. Thus, this is not a `MINOR` PR.
```suggestion - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key ```
Use URL instead of Url. ```suggestion - The URL of the Gitlab server, with protocol (i.e. http or https). ```
There is no need to add quotes here. Please remove them from all modules.
This needs to be C(validate_certs) which is the standardized parameter name.
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
So, looking at our existing list of modules, **api_url** is more popular than **server_url**. I guess we need to make sure we are making the right changes wrt. parameter naming. ``` [dag@moria ansible.git]$ grep -rl 'api_url' lib/ansible/modules | grep '\.py$' | wc -l 77 [dag@moria ansible.git]$ grep -rl 'server_url' lib/ansible/modules | grep '\.py$' | wc -l 21 ```
Please don't add any aliases except for backward compatibility. We don't want to offer more choice than necessary.
Is the following error code also retriable? 0x15 | KDC_ERR_CLIENT_NOTYET | Client not yet validâtry again later
We are using options in an inconsistent way here compared to other APIs. A good example to follow would be: ``` public ListOffsetsResult listOffsets(Map<TopicPartition, OffsetSpec> topicPartitionOffsets, ListOffsetsOptions options) ``` Options here are additional options that apply to the request. Data for the request comes from the first argument. We could do something similar for listConsumerGroupOffsets.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: line too long
We are using options in an inconsistent way here compared to other APIs. A good example to follow would be: ``` public ListOffsetsResult listOffsets(Map<TopicPartition, OffsetSpec> topicPartitionOffsets, ListOffsetsOptions options) ``` Options here are additional options that apply to the request. Data for the request comes from the first argument. We could do something similar for listConsumerGroupOffsets.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
Why does it have the same issue if added to `MaterializedInternal`? ``` class MaterializedInternal extends Materialized { protected MaterializedInternal(final Materialized m) { super(m); // } public static MaterializedInternal fromMaterialized(final Materialized m) { return new MaterializedInternal(m); } } ```
I was not sure if `MaterializedInternal` constructor can be public if `Materialized` constructor is protected. But as it can be, we don't need a static method (that would have been a workaround if `MaterializedInternal` constructor would have been protected, too)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: line too long
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
this is a personal preference, I like to avoid overriding the setup and teardown methods of estestcase and use separate one
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we can just call `terminate(threadPool)` here
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I've move all of this into the EXAMPLES block
There is a `requirements:` than should be used for this, see other modules for examples
I don't think we can do this. Also, I would only mention it, when we start to deprecate an API.
This isn't valid yaml ` : `
I reordered the method from "few parameter" to "more parameters" to make it easier to navigate within the file.
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
as above (more often below -- please fit all)
Because there is not `CogroupedKStream#reduce()` method this sentence is not useful and should be removed.
This overload does not take `Materialized` parameter
This is not completely compatible with the behavior of older Streams apps. See #10953 for a fix and more details.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I like this cleanup, but I think we still need the `null` check. Since it's possible for the value to be `null`, we should probably be defensive about it. Or were you thinking that we should just let the `NullPointerException` occur and kill the connector? Something in the middle of these two cases might be to log a warning so hopefully the connector developer can fix their code. (The only reason we even need to validate this is due to the `SinkTaskContext.offset(Map<TopicPartition, Long> offsets)` variant, the single partition variant with `long` obviously doesn't have the same issue.)
We use line lengths up to 119 characters when it helps readability. I wouldn't reformat this line when it doesn't have any other changes.
can we check the commit id in the stats and make sure it's the same? alternatively, can we maybe find the segments info for the right commit and create a stats object there? You're right about the synced flush not caring, but I'm worried that we get false scary warn message. I want to avoid that.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
Please add trailing comma.
Please use single quotes in added or changed strings.
I think you need `Utils#join` here. Calling `toString` on an array will give you something like `[Values@3343c8b3`
OK. Sorry, I looked at this first before I saw the update to `TaskStateType.`
I checked again, `json()` can return `None`, you're right, this check is useful. You might want to add a `try/except ValueError` around `resp.json()` (requests [doc](http://docs.python-requests.org/en/master/api/#requests.Response.json)).
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
Nit: you can call `Thread.enumerate` directly. Also, it would be good to assert that `threadCount` is < than `threads.length`.
This can be single-lined.
This can be single-lined.
I think these are too internal, I would rather check that `MultiValueDict` is pickleable: ```python pickle.loads(pickle.dumps(...)) ```
nit: new line
typo: byteArrray -> byteArray
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
If this is set to type='int' this should avoid the later type conversion
Catch botocore.exceptions.ClientError instead of Exception here too.
It would be good to have a try/except around this call.
This can be single-lined.
I think these are too internal, I would rather check that `MultiValueDict` is pickleable: ```python pickle.loads(pickle.dumps(...)) ```
`< Callback >` this explicit type is not necessary.
and here too ;)
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
Maybe pull this guy into BackoffPolicy? I figure it'd be useful for anyone uses BulkProcessor in tests. You'd want to make the DELAY configurable, but that is pretty simple.
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
I'm not certain this requirement is enough because if a source doesn't deliver the requested amount, it will keep the client hanging which may not request a new batch. There is also the problem if the first observable delivers less than requested, the missing amount is not replenished/considered by the second Observable and thus the client may starve. This is why `concat` uses the `SubscriptionArbiter` so that if an Observable didn't deliver enough, the next is requested for the missed amount. Similar measures might be required with this `AsyncOnSubscribe`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
req: move this to `StreamsPartitionAssignor`, where we'll be building and passing the `Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients` map around
Actually, WDYT about adding this class in the "add configs" PR and then rebasing this PR on top of that? Then I could do the same (since I need this class in my next PR as well)
Asking because neither a `List<T>` nor a `Deserializer<T>` need a `Comparator`.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Good thought. Lag was originally proposed in the KIP, but it's not what we're using anymore.
WDYT about renaming `lag` to `rank`, or `effectiveLag`, or something else that reminds us this isn't the actual literal lag? cc/ @vvcephei
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
In the previous version, we didn't delay the onCompleted event.
"this until it is" doesn't quite parse.
can we invert this and say `if (suggestStats != null)`
I'm not certain this requirement is enough because if a source doesn't deliver the requested amount, it will keep the client hanging which may not request a new batch. There is also the problem if the first observable delivers less than requested, the missing amount is not replenished/considered by the second Observable and thus the client may starve. This is why `concat` uses the `SubscriptionArbiter` so that if an Observable didn't deliver enough, the next is requested for the missed amount. Similar measures might be required with this `AsyncOnSubscribe`.
this file can go back to 140 chars as well...
Okay, I see later that we catch the overflow exception and that we skip adjusting; I need to think about this.
I'm not convinced in th soundness of the bookkeeping here. I think that `totalNanos` can include the total task time for more than `tasksPerWindow` tasks.
I'm not convinced we should ignore failures. These tasks still occupy queue capacity, and there is no guarantee they failed quickly, a thread can be executing for awhile before failing.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
```suggestion /** * Metadata of a task. */ ```
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
You might consider using `OptionalDouble`.
We should limit this suppression to the method for which we really need it instead of the whole class
We should mention somewhere that users should prefer this new assignor for newer clusters.
nit: fix indention (same below in other constructor)
Maybe we could use a different value here.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
I fell like a functional interface here doesn't really buy us anything comparing to a simple if statement with two calls.
Both `GZipInputStream` and `SnappyInputStream` read the header in the constructor, so it would make sense to me to remain consistent in that respect.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
@hachikuji asked you to change the name originally: ```text hachikuji 5 days ago Contributor nit: the name is a little awkward. How about hasRemaining to match ByteBuffer? ``` :)
Sorry for the confusion. I thought `hasRemaining` made sense initially, but then I realized that the name should be more suggestive of its usage. I'd prefer something like `ensureNoneRemaining`, but it's not a dealbreaker for me.
The first condition seems to be redundant, but it might be ok to leave it in for clarity.
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
+1 on removing this
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
I think we should use `writeAtomic` everywhere just to reduce the complexity.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
ditto here and others below
same for tests below as well
Nit: add `Cannot be {@code null}.` (maybe somewhere else, too)
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
ditto here and others below
same for tests below as well
You have some unmerged lines here
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I realize that the "streams-file-input" topic is used for multiple purposes in the upcoming quickstart/demo instructions. In this case, feel free to keep the input topic name as is.
"over text files": This is confusing because we're not using text files anywhere. What about the following: > Implements the WordCount program that computes a simple word occurrence histogram from an input text. > Assumes the input text is read from the Kafka topic "streams-lines-of-text", where the values of messages represent lines of text.
ditto on removing before/after.
Ok, I'm convinced :) Thanks for clearing up my confusion.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
Not sure what the intent is here, to increment the number between each test, or between each instance of this integration test class within the JVM... It actually does the latter.
These three fields should be final as well.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
This can (and should) be a unit test, since we don't need to produce data or run Kafka to build and verify the topology.
should be final
ditto here and others below
same for tests below as well
Nit: add `Cannot be {@code null}.` (maybe somewhere else, too)
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
You have some unmerged lines here
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
As soon as external JSON names are stable we should use the same names inside for variable names I think. Can be done in a separate PR though.
I think this should be moved to QueryCreationContext and exposed here through it temporarily
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
We tend to prefer `false ==` over `!` because it is harder to miss the `!`.
5.1+ I think, actually. Have a look at `VersionTests#testUnknownVersions` and the note right underneath `Version#CURRENT`.
Could you move `writeTo` up here? It is easier to compare them if they are together.
Maybe add "for example"
rewrite test as above using `assertThrows()`.
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I think this way of triggering the exception is not only complicated but it even might be a source of flakiness. Could we have some more straightforward? I think the original solution (overriding getResponse) was better than this.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Maybe call this "testEmptyBoolSubclausesMatchAll()"? Sorry if I misunderstood what the test is doing, I just think having a github issue number in the name is unhelpful to someone if they see a failure.
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
this is great
This seems to be safely handling unsubscribe by doing it in the right thread so 'unsubscribeOn' is not needed.
This is a hard override (via index.mapping.date.round_ceil setting, which default to true) to disallow rounding up. Not sure if this actuall set to false, seems undesired to me.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Which future? Did you mean `Event`. I assume that `deadlineNs` is the deadline for scheduling/executing the `run` method. The `run` method can take longer than `deadlineNs`.
The headline description says "Schedule an event to be run at a specific time" yet this param's description seem to indicate a different behavior.
In Java the unit of measure `timeUnit` and scalar `timeSpan` are declare in reverse order. For example: ```java void beginShutdown(String source, Event cleanupEvent, long timeSpan, TimeUnit timeUnit); ```
The headline description says "Enqueue an event to be run in FIFO order." but looking the param description it doesn't looking like it is FIFO order since it support prepend, append and deferred. What do you mean by DEFEREED? How is the delay specified? I see the param `deadlineNsCalculator` but it looks like this describe the maximum amount of time this event is allowed to stay in the queue before it is cancelled by the queue.
"the event will be prepended to the queue" : This is no longer true in the implementation.
this is great
This seems to be safely handling unsubscribe by doing it in the right thread so 'unsubscribeOn' is not needed.
This is a hard override (via index.mapping.date.round_ceil setting, which default to true) to disallow rounding up. Not sure if this actuall set to false, seems undesired to me.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Which future? Did you mean `Event`. I assume that `deadlineNs` is the deadline for scheduling/executing the `run` method. The `run` method can take longer than `deadlineNs`.
The headline description says "Schedule an event to be run at a specific time" yet this param's description seem to indicate a different behavior.
In Java the unit of measure `timeUnit` and scalar `timeSpan` are declare in reverse order. For example: ```java void beginShutdown(String source, Event cleanupEvent, long timeSpan, TimeUnit timeUnit); ```
The headline description says "Enqueue an event to be run in FIFO order." but looking the param description it doesn't looking like it is FIFO order since it support prepend, append and deferred. What do you mean by DEFEREED? How is the delay specified? I see the param `deadlineNsCalculator` but it looks like this describe the maximum amount of time this event is allowed to stay in the queue before it is cancelled by the queue.
"the event will be prepended to the queue" : This is no longer true in the implementation.
There is a built-in for this `Function.identity()`
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
Nit: since we require a non-null `Duration`, we should state that here: ```suggestion * @param timeoutDuration timeout duration; may not be null ```
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
```suggestion * <p>A {@code retryBackoffMs} that is negative or zero will result in no delays between retries. ```
How about "runs an external command for the worker."
Earlier we discussed sending the task spec on the process' standard input. Did you decide not to do this? It seems like using a command-line option will be pretty awkward...
```suggestion * @param timeoutDuration timeout duration; must not be null ```
The other constructor calls the parameter `sampledStat`. We should be consistent.
Nit: unnecessary new line.
If it is no more an integration test, this should be removed.
Why do you need to prepare `KafkaStreams` for testing? Only classes that are mocked and that are either `final` or have static methods need to be prepared.
use `try-catch` instead of `expected` annotation -- not a single line test.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Fails checkstyle, needs to be final
Given that there are 3 tests it would be nice to give all of them descriptive names.
Ah, yes, it's `org.apache.kafka.test.TestUtils#tempDirectory()`. My mistake. The protocol is for all temporary state in Kafka tests to use that method. The change I made in `QueryableStateIntegrationTest` is basically what we should do here as well.
This is neat, but we shouldn't use it. There's an IntegrationTestUtil for getting a temporary folder, which is hooked in to support for different testing environments to set their desired temporary file location.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
same for tests below as well
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
`retry < this.numberOfRetries` is implied here due to the outer check.
I also wonder if we should log `TRACE`/`DEBUG` issues for this.
same for tests below as well
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
ditto here and others below
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
You have some unmerged lines here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
lib/ansible/modules/network/aos/aos_ip_pool.py:191:1: M511 - mutable default arg of type List There is only one caller of create_new_ip_pool() and it provides all three args, so subnets doesnt need to be keyword arg or optional.
Import only what you need and not `*`
Ah, yes, I miss read the code. Nothing to change here.
As far as I can tell, the 'in_use' is never used.
TODO add Exception handling for login error
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: Indicate that this needs shallow iterations on the entries.
It should be robust in case of some missing fields.
This statement is a bit misleading, how about "to the format indicated by the given magic value".
nit: Indicate that this needs deep iterations on the entries.
You don't need to specify any symbolic name for a group since you have only one.
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: Indicate that this needs shallow iterations on the entries.
It should be robust in case of some missing fields.
This statement is a bit misleading, how about "to the format indicated by the given magic value".
nit: Indicate that this needs deep iterations on the entries.
You don't need to specify any symbolic name for a group since you have only one.
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: Indicate that this needs shallow iterations on the entries.
It should be robust in case of some missing fields.
This statement is a bit misleading, how about "to the format indicated by the given magic value".
nit: Indicate that this needs deep iterations on the entries.
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
do we need this logic? we know what we will send it
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
typo `to to` (also missing `.` at the end of the sentence)
This style of setters is not AK convention.
nit: in kafka we normally don't use `get`/`set` prefixes
Remove the last sentence, since the `reset` method is private, and looks like it's handle automatically.
We should mention somewhere that users should prefer this new assignor for newer clusters.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Even if you are in 2.4+, if you want to switch from EAGER to a different COOPERATIVE assignor that new assignor still need to support both in order for a simple rolling bounce path. I think it worth mentioning this as well (maybe better in web docs than here in java docs, just wanted to bring this up).
inventory plugin, not module ... also we can use 'short form' for licenses now
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
Please change this to 2017â2018, as the copyright should normally cover all years of artwork/code creation/updates.
Here you go https://smallbusiness.chron.com/year-copyright-statement-mean-62027.html
excellent question, and one we should probably ask of someone with a legal background - I will find someone and ask, then report back on #45989
#45989 has a response on it. The preferred way is to *not* advance the date or add a range.
Basically, copyright comes into play since content creation, so you need a year, when it's been originally created. When you update content, you "create" new parts of it, that requires new year to be mentioned.
Well, it's easily googlable :) I've shared links in some PR recently. Let me see whether I can find them
Tests for `formset_factory()` and `formset_factory()` are missing.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
No "unsupported HTTP method" message? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
No "unsupported HTTP method" message? :)
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
We don't need to make this change, do we? Let's try to minimize the changes to the existing code.
ditto here and others below
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
maybe rename this to `setUp` and put the loop populating the array in this method
This is no longer used, could be removed
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
same 1+ randomInt
I see that we need it from another package, I think it's ok.
I think we can check also randomly on a shard that relocates _to_ the local node
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
What is the reason for reordering all these parameters? This breaks `blame` attribution for these lines & doesn't improve the code.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
makes sense to me as well now, sorry for the noise.
Worth wrapping all these long fail_json calls at the comma before exception - otherwise it goes off the side at PR (I know there are lots of lines that are already too long but let's not add more)
Nesting under distribution ID is useful when you know it, but when returning a single item it's nice if you can make it available under the key the user asked for it with. Take for example: `ansible -m cloudfront_facts -a 'region=us-east-1 distribution=yes domain_name_alias=rsb.io' localhost`. As a user, I'd like to be able to say something like: `{{ cloudfront['rsb.io].ARN }}` to get the ARN, instead of (currently) `{{ cloudfront.[cloudfront.keys()[0]].distribution.ARN }}`. You could return both, so users could either use the ID or one of the CNAMEs to access the facts. They would be unique, since in CloudFront you can't have overlapping CNAMEs ever.
Perhaps you could drop the `cloud_front_` prefix for methods and variables, since everything refers to Cloudfront properties? Unless of course it is has something to do with being consistent with the corresponding AWS API response.
I think that wildcard imports are generally discouraged, because it makes it difficult to refactor and determine the origin of a function or class. For example, at first the `boto3_conn` function used in the constructor seemed undefined.
It looks like you're double-nesting `ansible_facts` dictionary, on line 406/409/412 you have the facts being saved in `result = { 'ansible_facts': { 'cloudfront':...` but then here you pass to exit_json under `ansible_facts` so your output looks like: ``` localhost | SUCCESS => { [479/1550] "ansible_facts": { "ansible_facts": { "cloudfront": { "E22CS9R7XQ0CWU": { "distribution": { .... ``` To fix this you can instead do `module.exit_json(msg="Retrieved cloudfront facts.", **result)` or stop nesting the `cloudfront` key under `ansible_facts` on 402/405/408/411.
Small typo here probably: `Retreived -> Retrieved`
This is used for both producer and consumer, so we'd better name it `props` not `consumerProps`.
Instead of `new MetricName("batch-size-avg", "producer-metrics", "", tags)`, I think we should use `metrics.metricName("batch-size-avg", "producer-metrics")`, right? The doc says `Please create MetricName by method {@link org.apache.kafka.common.metrics.Metrics#metricName(String, String, String, Map)}`. Same for other MetricName instantiation.
good catch! that means we are not properly testing this case either given that we didn't catch it.
makes sense to me as well now, sorry for the noise.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
Thanks for pointing this out, missed that all other constructors delegate here, my mistake.
Two concerns here: If we convert Strings to BytesRef here, shouldn't we also do so in the (..., String... values) constructor? Also, since this seems a convenience method, I'd prefer converting the content of the Iterable to be converted to some array and then use the (..., Object...) constructor, as there are already too many ways of constructing this query builder.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
ditto here and others below
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
We should use try-with-resources here (for `DataInputStream`).
This covariance stuff is insane.
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
Based on my reading of the MSDN doc this should just result in returning the default value, not throwing an Exception. "Returns the last element of an observable sequence that matches the predicate, or a default value if no value is found." http://msdn.microsoft.com/en-us/library/hh228948(v=vs.103).aspx It should return the last value that matches the predicate, but if nothing matches then it should return the default value.
Great, that solves it then.
Unfortunately these overloaded method signatures have the same arity and will cause problems with Groovy/Clojure/JRuby etc as they can't determine the difference between `Func0` vs `Func1` at runtime. We should either eliminate unnecessary overloads, change signatures or have more descriptive names instead of overloads.
This is called from inside the lock being held which means that replaying all historical values to a new Observer will block all existing Observers and new values from proceeding.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
Oh no! The build failed because of tabs! You can catch these sorts of things with `gradle core:precommit` which is much faster than `gradle core:check` because it doesn't run all the tests. I'll run the tests before pushing but for something like this it ought to be safe for you not to run them.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
The producer in the `WorkerSourceTask` automatically resends records, but if the producer fails to resend the [WorkerSourceTask enqueues the unsent records in `toSend`](https://github.com/apache/kafka/blob/08e8facdc9fce3a9195f5f646b49f55ffa043c73/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java#L343-L348) and send them again. It is true that this happens after each call to `poll()`, but if the send fails then `toSend` is non-null and upon the next iteration of the loop it will not call `poll()` and will then try resending whatever is in `toSend`. This will continue to happen as long as `toSend` is not null. However, in the current PR, even though this might happen, the loop may still ask for the source partitions and offsets and will synchronously commit them using the `offsetWriter`. So it is possible that a record with a particular offset `o1`, for a source partition `p1` fails to send and is retried, but then a connector then sets a later offset `o2` for the same partition and the connector commits offset `o2`. If the connector were to fail at exactly that point (which is possible), the `o2` offset may have been committed without the `o1` record being written. I understand that in your particular use case, you probably would only set the offsets for a particular partition if records were not written recently, but that doesn't change the fact that the `WorkerSourceTask` might be attempting to resend the previous records for quite some time. What if your new block of code were only performed if `sendRecords()` succeeded? I think there are a couple of issues with that as well. First, the offset writer is called synchronously, whereas other calls to commit offsets are sent a separate commit thread that calls multiple tasks. Now there are multiple threads committing offsets with potential race conditions and concurrency issues. Second, it still is a complicated API, and will developers truly understand when and how they use `getSourcePartitionAndOffset()`? Can I call it to read the last offset committed for a particular source partition? The worker doesn't ever set the offsets there. The WorkerSourceTask has a single, ordered pipeline for all records that each have their offsets. I still believe the best and most reliable and deterministic way to solve this is to use that same pipeline.
probably `new ThreadPool(Settings.EMPTY)` :) I wonder if the helper could hide the creation of the thread pool even, maybe not, but we will see that later. As you pointed out it may be that the helper is not needed at all.
got it thank you.
I may have forgotten, but what has changed here compared to the startFlush method? We don't call daemonThreadFactory as we dropped the name and settings requirement for logging right? I wonder if we should still call that and just provide the standard "bulk_processor" prefix.
I think I would consider taking settings out. We try to extract node.name from it as far as I understand, which I don't think is ever going to be set on a transport client. Maybe we can just live without that part of the thread name and remove some complexity. This may very well come from the times where node client was widely used, hence node.name made sense in the past, but it doesn't anymore.
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
nit: new line
and also assert that `startOfThrottle != 0`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Could we collapse the code path for having a queryable store name or not into the same function? For example: ``` filter(.. /*nothing*/) calls filter(.. (String) null); filter(.. "storeName") calls filter(.. storeSupplier); // if storeName is not null, otherwise pass null as well filter(.. supplier) do the actual impl, which checks if supplier is null or not ```
nit: line too long
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: line too long
nit: line too long
This worries me a bit as this is inconsistent with the filters and ranges aggregations.
Nit: rename to `shouldThrowOnInvalidTopicNames`
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
This is neat, but we shouldn't use it. There's an IntegrationTestUtil for getting a temporary folder, which is hooked in to support for different testing environments to set their desired temporary file location.
Ah, yes, it's `org.apache.kafka.test.TestUtils#tempDirectory()`. My mistake. The protocol is for all temporary state in Kafka tests to use that method. The change I made in `QueryableStateIntegrationTest` is basically what we should do here as well.
nit: initialize `appId` with the prefix you want (eg `appID_`, or something more descriptive like `TaskMetadataTest_`) and then just append testId, ie ``` appId = appId + testId; ``` Just makes it easier to locate what the prefix is (same with `inputTopic` below)
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Nit: rename to `shouldThrowOnInvalidTopicNames`
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
This is neat, but we shouldn't use it. There's an IntegrationTestUtil for getting a temporary folder, which is hooked in to support for different testing environments to set their desired temporary file location.
Ah, yes, it's `org.apache.kafka.test.TestUtils#tempDirectory()`. My mistake. The protocol is for all temporary state in Kafka tests to use that method. The change I made in `QueryableStateIntegrationTest` is basically what we should do here as well.
nit: initialize `appId` with the prefix you want (eg `appID_`, or something more descriptive like `TaskMetadataTest_`) and then just append testId, ie ``` appId = appId + testId; ``` Just makes it easier to locate what the prefix is (same with `inputTopic` below)
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
Since this doesn't change functionality, we probably don't want to change this just to update to modern syntax. The more changes we make like this, the harder it is to backport other fixes that might overlap with this diff, and ideally we backport fixes aggressively (and in fact, this could be an example where we might want to backport to a version that supports jdk7).
As mentioned in the KIP discussion thread: it seem unnecessary complex for user, to specify all those value. The only parameter that is mandatory is the window size. If people call `KGroupedStream#windowBy` all other parameters also optional; they should be optional when reading a topic, too.
I think we can fail the shard on _any_ failure here. failAndRemoveShard already does logging under WARN
`indexMetaData.getIndex()` -> NullpointerException!
Ah, yes, the magic is hardcoded here.
We don't need to make this change, do we? Let's try to minimize the changes to the existing code.
Can you enclose the body of if block with curly braces ? Same with else block. It is easier to read.
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
Is it possible to trigger infinite loop: raiseError -> reconfig -> raiseError -> reconfig ...
This always scheduled in the future with `timeout`. Shouldn't it be the time until next timeout? Let's say timeout is 1000ms and I get an onNext call every 50ms. This code seems to schedule each action to execute 1000ms in the future even if it comes in 950ms since the last onNext was permitted through.
Well, that not how unit testing works :)
"with a read-only key"
with a read only key
nit: single parameter per line
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
add `final` twice
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
"given a read-only key"
I actually meant an error (http 400)? Messages can be ignored. This is just an invalid configuration.
Yes I think so.
ignoring the status here makes sense to me, but I wonder if we are 100% sure that the status returned by `ElasticsearchException#status` (which looks at cause etc.) will always be the same as what we got back (either as status code or within response body).
fillResponse can throw an already closed exception. We should make sure we deal with exceptions here correctly
Maybe warp the listener using ActionListener#wrap which does the write things and will simplify the code here too.
I think you should pass in the request here instead of empty params
IMHO this is not python 2.6 compatible (https://docs.python.org/2/library/string.html#format-string-syntax). I usually avoid format at all and use the % syntax.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think it's always a single node cluster, but I'm good to keep it like this.
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I don't think it is overkill either, it is just good OO design. Anyway, i'm not going to block this PR because of it.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: add `final`
nit: add `final`
nit: add `final`
ditto here and others below
nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this: ``` private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) { final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get(); assertThrows(NoSuchElementException.class, iterator::peekNextKey); } ``` and then two public tests ``` @Test public void shouldThrowIfNoPeekNextKeyRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } @Test public void shouldThrowIfNoPeekNextKeyReverseRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } ``` Admittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Oh, right, I forgot that the metrics registry returns the same copy of the sensor when all the name, description, and tags are the same... Thanks.
Hey, I'm sorry, but can you explain what's going on here? `Sensor` doesn't override `equals`, so I'm not seeing how this assertion works.
I was not aware of the restriction on JSON object keys, and that seems like a fine standard to follow. I can't imagine it being too useful.
ditto here and others below
same for tests below as well
remove try-catch and replace with: ``` final StreamsException s = assertThrows(StreamsException.class, () -> testDriver.pipeInput(consumerRecord)); ``` assert afterwards and don't re-throw.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
could these three methods somehow be in the base test class, at least partially? what I am looking for is avoiding copy pasting when writing new tests, and possibly not forgetting to cover important scenarios.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
rewrite test as above using `assertThrows()`.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this: ``` private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) { final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get(); assertThrows(NoSuchElementException.class, iterator::peekNextKey); } ``` and then two public tests ``` @Test public void shouldThrowIfNoPeekNextKeyRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } @Test public void shouldThrowIfNoPeekNextKeyReverseRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } ``` Admittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Oh, right, I forgot that the metrics registry returns the same copy of the sensor when all the name, description, and tags are the same... Thanks.
Hey, I'm sorry, but can you explain what's going on here? `Sensor` doesn't override `equals`, so I'm not seeing how this assertion works.
I was not aware of the restriction on JSON object keys, and that seems like a fine standard to follow. I can't imagine it being too useful.
ditto here and others below
same for tests below as well
could these three methods somehow be in the base test class, at least partially? what I am looking for is avoiding copy pasting when writing new tests, and possibly not forgetting to cover important scenarios.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
rewrite test as above using `assertThrows()`.
It should be robust in case of some missing fields.
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
To be consistent with KAFKA-2388, this should probably be: ``` java void subscribe(Pattern pattern, ConsumerRebalanceListener listener); ```
The indentation is off here.
In fact, it should probably say something like `Remove the plugin specified by {@code pluginName}.`
`pluginName` should still be wrapped in a code block (`{@code}`).
Let's drop the uppercase on `Terminal`.
nit: `, and` (missing comma)
> Did you consider a getAuthenticationFailureHeaders() method instead? +1. I feel like this is the way to go. Ultimately this might allow us to remove the authentication failure handler (way off low priority future idea)
I think it makes sense to let the realms handle this. I don't know what other headers we could expect - but that's kind of the point, we can just support a relatively generic method and let custom realms do whatever they need. My guess is that anything other than `WWW-Authenticate` would be due to weird proprietary protocols, but if they exist then we can support them.
I think we can state this more generally as it's thrown if any I/O exception occurs while performing a file operation (of which there are a few).
Nice tidy up of this test class :-)
This is the default.
Same minor nitpick about whether or not we need to check for an empty group ID.
This is also the default, I think.
Map.Entry<String, String> to avoid the check below
ditto here and others below
unnecessary type in constructor, can use `new HashMap<>()`
Nit: include brackets on all blocks, even if they are a single line. This makes it easier to read, but also reduces the number of affected lines if we have to add another line in the block in the future.
Then the log message should state the reason (e.g., the class was not found) and that the named provider will not be used. However, it does seem strange that this is technically an invalid configuration, so why would we not just throw a ConfigException? Note around lines 723 how any configuration property whose value is a Class name will be invalid if a `ClassNotFoundException` is caught, and this leads to a `ConfigException`. Silently ignoring seems at best inconsistent but at worst a bad idea.
same for tests below as well
Let's use `Map` on the left side instead of `HashMap`
this could be: `assertThat(serializer.serialize(topic, null), nullValue())`
this one, too
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
This is the default.
The serialization package is open to everyone (it's public API and at the lowest layer). So I don't think we should worry about that. It's not like we're avoiding a dependency here, we are just hiding it via a string based config (that still requires the default constructor to be present).
We can pass the serializers in the constructor and it's a bit more concise.
This is also the default, I think.
We don't usually assert on exception messages as it makes tests a bit brittle. This applies to a few other tests too.
unnecessary type in constructor, can use `new HashMap<>()`
ditto here and others below
same for tests below as well
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
Let's use `Map` on the left side instead of `HashMap`
we can maybe use similar technique as we do in `QueryParsingException` and also report the location
As far as I can (brief check only) they are always null, but it wasn't part of the API to change properties that are not part of the json being parsed. Not a big deal..
You could make it the same with an `else if` instead of `else`: ``` } else if (theAnalyzer != null) { builder.searchAnalyzer(theAnalyzer); } ```
Strictly speaking this is different than the previous code - if none of index analyzer , search analyzer and theAnalyzer is set, we reset the indexAnalyzer and searchAnalyzer on the builder to null. We didn't use to do it...
if we only use all names to put things in the map we lose all the deprecation warnings that we might have etc. we should rather keep track of the original ParseField and call ParseFieldMatcher#match.
nice, effectively this change will be backwards compatible for users using this method. Not for users calling the public Builder constructor, but I think that is a good reason to make them switch to this static method.
can we call these indices "short_delay" and "long_delay" ? I think it will be easier to read.
ditto here and others below
same for tests below as well
I think we can now remove this condition as the client can not be null because we throw now `new ElasticsearchException("Unable to configure Azure compute service", e);` in the CTOR
nit: one too many line break? :)
Prefer an anonymous Func1, for example, ``` java public <R> Observable<R> mergeMapIterable(final Func1<? super T, ? extends Iterable<? extends R>> collectionSelector) { return flatMap(new Func1<T, Observable<? extends R>>() { @Override public Observable<? extends R> call(T t1) { return Observable.from(collectionSelector.call(t1)); } }); } public <U, R> Observable<R> mergeMapIterable( final Func1<? super T, ? extends Iterable<? extends U>> collectionSelector, Func2<? super T, ? super U, ? extends R> resultSelector) { return mergeMap(new Func1<T, Observable<? extends U>>() { @Override public Observable<? extends U> call(T t1) { return Observable.from(collectionSelector.call(t1)); } }, resultSelector); } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
ditto here and others below
It the following implementation better? ``` java public <R> Observable<R> mergeMap( final Func1<? super T, ? extends Observable<? extends R>> onNext, final Func1<? super Throwable, ? extends Observable<? extends R>> onError, final Func0<? extends Observable<? extends R>> onCompleted) { return materialize().flatMap( new Func1<Notification<T>, Observable<? extends R>>() { @Override public Observable<? extends R> call(Notification<T> t1) { if (t1.isOnNext()) { return onNext.call(t1.getValue()); } if (t1.isOnError()) { return onError.call(t1.getThrowable()); } return onCompleted.call(); } }); } ```
remove "completes"? It's a Single :)
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could be `contentType = scriptMetadata.getOptions().getOrDefault(Script.CONTENT_TYPE_OPTION, DEFAULT_CONTENT_TYPE);` And then you can remove the null check below
You have some unmerged lines here
I think this would be a bit more readable: ``` return ( '%(func)s %(op)s %(dist)s' % {'func': sql, 'op': self.op, 'dist': dist_sql}, params + dist_params ) ```
same for tests below as well
Also make the comparison case-insensitive, i.e. ```python if self.index_type.lower() != 'gist': ```
I would move it to `_init__()`: ```python def __init__(self, *, name, expressions, index_type=None, condition=None): ... self.index_type = index_type or `GIST` self.condition = condition super().__init__(name=name) ``` and skip the default in `deconstruct()` and `__str__()`: ```python def deconstruct(self): ... if self.index_type != 'GIST': kwargs['index_type'] = self.index_type ```
as above: avoid `/` Update to ``` log.warn("Unable to read '{}{}{}'. Using default inputValues list", "resources", File.seperator, fileName); ```
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
code style can you put the else on the same line as the `}`
This data construction seems better to be put in the `AlterConfigsResponse` constructor.
Yea, my suggestion would be to reuse the existing constructor as the construction of the `AlterConfigsResponseData` seems non trivial for a caller to do, compared with passing a map of errors.
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
Not related to this PR but I think that we should check if what we are trying to remove is not part of the BLACKLIST. Someone could potentially provide a plugin which contains his own `bin/elasticsearch` script, which looks scary to me.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
as above: avoid `/` Update to ``` log.warn("Unable to read '{}{}{}'. Using default inputValues list", "resources", File.seperator, fileName); ```
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
code style can you put the else on the same line as the `}`
please reformat to: ``` java if (logger.isTraceEnabled()) { logger.trace("adding jvm plugin [{}]", plugin.v1()); } ```
Yea, my suggestion would be to reuse the existing constructor as the construction of the `AlterConfigsResponseData` seems non trivial for a caller to do, compared with passing a map of errors.
This data construction seems better to be put in the `AlterConfigsResponse` constructor.
I'm doubting if we should introduce generics for the BatchingTask and batchingKey. I'm fine with keeping as is if you don't like the generic version.
`name()` -> `wrapped.name()`
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
I just thought about this. I think `endOffset` should be actual endOffset, ie, `11` for this test -- we pass in the `offsetLimit` as 5 in `StateRestorer` below.
I think this way of triggering the exception is not only complicated but it even might be a source of flakiness. Could we have some more straightforward? I think the original solution (overriding getResponse) was better than this.
with 10 messages and a commit marker at 5, we need a second commit marker at 11: `0...4,C,6,...11,C` thus, endOffset should be 12. Having say this, I think a simpler setup `0...,9,C` and endOffset `11` would be sufficient for this test case.
as above. endOffset should be `12` and passed offset limit in next line should be 6.
Sneaky tests, testing all the things!
do we need a dedicated test for this? can't we randomize the number of nodes in the normal deletion tests? O.w. we will need to test this situation with both closed indices and open. It's a shame IMO
++ on adding this.
Okay, I see later that we catch the overflow exception and that we skip adjusting; I need to think about this.
```suggestion module.exit_json(changed=True,**camel_dict_to_snake_dict(res))) ```
I'm not convinced we should ignore failures. These tasks still occupy queue capacity, and there is no guarantee they failed quickly, a thread can be executing for awhile before failing.
I'm not convinced in th soundness of the bookkeeping here. I think that `totalNanos` can include the total task time for more than `tasksPerWindow` tasks.
You can achieve this same result output with `module.exit_json(changed=True,**camel_dict_to_snake_dict(execution))` which can be imported from `ansible.module_utils.ec2`. That will automatically cover if AWS ever starts returning additional keys from this API and is generally easier to maintain.
I don't understand wrapping the field name in backticks like this is markdown? (And a many other places.)
I see, it looks like the log message is written as if the size should come after "queue size" and the thread pool name should come after "threadpool: ".
I think that these log parameters are backwards.
I think this can all fit on one line more cleanly if you break after the equal sign.
please assign the `System.nanoTime()` to a local var that way you only need to read it once and you have consistent values.
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The indenting of this line and the next is off a space.
It should be robust in case of some missing fields.
The variable name `shand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
at this point you don't need the restClient variable anymore
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I think you can use `RestClient.SyncResponseListener` here instead
maybe just `esVersion()`
`app_configs` is initialized as an empty dict, so this line should be unnecessary :thinking:
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
oh seems like you also removed some ParseFieldMatcher usages, nice :)
I would have preferred a more explicit removal of `name=(default)` for the removal of the default key. This is to me more confusing (because whether it is set to `yes` or `no` it will delete a key. So I would get rid of this option altogether.
Yes, so what I am saying is to keep it simple, and if no name was provided (with `state=absent`), delete the path. If a `(default)` name was provided, remove that key (as in unsetting it, just as the registry editor is not showing an unset `(default)' key). So you don't need the additional `delete_key` parameter, and it's actually as one would expect it to work. The `name` parameter was optional.
brackets in the URL
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
I think the norm is to use `apps` instead of `app_registry` to designate `Apps()` instances around the codebase.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
nit: reorder according to ordering of params.
oh seems like you also removed some ParseFieldMatcher usages, nice :)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Are you going to update the other two to remove unnecessary operations? That's all that's left and then I can merge the PR. Thanks!
I think the message needs to be updated.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
also use new `writeDoubleArray` here
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Can we keep the refs to these internal clients
Do you think we could have something like: ``` java bulkRetry = Retry.on(EsRejectedExecutionException.class).policy(BackoffPolicy.wrap(backoffPolicy, task::countBulkRetry)); ``` I find it easier to know what's going on on bulk retries.
You don't need to specify any symbolic name for a group since you have only one.
Can we create the exponential back off here and provide a package protected getter for the `BackoffPolicy`? It avoids to jump to another method just to see what kind of policy is created
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we do this kind of parsing in several places maybe a util can help at some point? not sure just an idea
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
I see that we need it from another package, I think it's ok.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
nit: We use singular verbs in other functions (e.g. line 54 above), would be better to be consistent.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
given that we also filter responses by creating a new response filter chain and filtered action listener, this inner class is not just a request filter chain... can we maybe merge the two at this point? Seems like in the end we either filters nothing or both (request and response) anyway...
Correct me if I am wrong but these filters have to be executed in a serial fashion one after another, right? So you can make this async if you need to on top of the blocking loop? I would like to see an example where this is used to understand the rational please :)
can we just have this variant not the one that takes a String.
Can we keep the refs to these internal clients
We should call ignoreReplicaException() imho.
I find these two empty `continueProcessing` methods confusing, if we manage to merge the two filter chains impl as said above, we would get rid of them I think
this class could be made `final`
partially replying to the original message - the idea is to test how this action behaves under different error conditions - a connection error (which is thrown here), a general exception / shard not available (which is typically given as a response , not thrown here (although it's equivalent at the moment).
I guess something went wrong.. no biggy.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: The method signature for StatAndConfig has MetricConfig parameter first and MetricName second. This one has the reverse order.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The message doesn't seem to match the condition above.
you can just do the conversion to unmodifiable map one time in the constructor. it looks like at the moment this is only accessed in tests anyway.
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
I know the naming thing has bit us in the past, is this same approach used elsewhere and/or how was it decided on? Specifically, metric name constraints really shouldn't be JMX specific if that is the case here, despite the fact that the metrics is so obviously JMX-inspired. I can easily find https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/metrics/KafkaMetricsGroup.scala#L46 but nothing else. Have we not had the same problems because metrics w/ topic names in them already have constraints on the naming? If I am remembering correctly, I think maybe both @gwenshap and @junrao were involved in some discussions, I think `-` vs `_` was a problem at some point? Maybe one of them could chime in here.
to me it seems like we can't possibly know what the constraints of all reporters would be and they don't provide an interface for validation, so it should be up to them to figure out how to substitute. but i've also asked some other folks to maybe chime in here who may have better context on how we've handled this elsewhere.
ah, right. nah, that's fine. just when reviewing I had the thought that if we guaranteed non-`null`/non-empty in the constructor, this wouldn't be necessary. i realized that it was actually intentional, but easy to miss when reviewing here and not getting the same highlighting as an IDE
might want to rename `workerId` so it doesn't shadow the member field. something like `workerIdOpt` could work
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
We can call the static function of KStreamImpl directly and get rid of the additional function in `InternalStreamsBuilder`.
sorry I didn't see that you created a copy (I missed the "new HashMap" part)
(and also the fact that it will be lost on serialization, etc.)
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
you could extract this in a private method to share some code with the scritp execution below.
Same question here as earlier about the `Locale`
This method seems like it could be in `JobConfigProvider`? Then we don't have to duplicate it between this action and the put-datafeed action.
Typo: "Dynamics" -> "Dynamic"
or maybe give the return value a variable and name it accordingly
I see that we need it from another package, I think it's ok.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
nit: add `final`
Could you please add some line breaks? This and some of the other verifications are too long.
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: missing a space after the first comma
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
nit: add `final`
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Could you please add some line breaks? This and some of the other verifications are too long.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: missing a space after the first comma
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
nit: add `final`
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Could you please add some line breaks? This and some of the other verifications are too long.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
ditto here and others below
My rationale is mainly around typos :) In the past I have some experience spending much time on troubleshooting a typo caused issue, since these issues are usually not well exposed in the exception messages, e.g. if you had a `stream-record-cach-metrics` in one of the lines it would be hard to find out..
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
We need to cast indeed, but I want to give the compiler opportunities to find errors, which is never possible when one starts definiting methods whose generic parameter is only used in the return value. By the way I'm thinking that we could make casts more safe by making category a class instead of a string, and this class would be the base class of the object that the namedwriteables can deserialize
It should be robust in case of some missing fields.
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Nit: the methods of the `ConnectorStatusListener` and `TaskStatusListener` classes are in very different orders. It would help readability to have them in the same order. IMO, the order of the `TaskStatusListener` methods is nice because it follows the lifecycle.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
This is probably just my style bias, but I wonder if it would be easier (and more readable) to use static factories for atomic vs non-atomic ControllerResult. Something like: ```java ControllerResult.newAtomicResult(records, response) // and ControllerResult.newResult(records, response) ``` Boolean flags as such a pain and easy to mess up. I actually think it might be nice if there are no public constructors for ControllerResult and we use factories for everything. However, this would be a bigger change, so I'm fine if we defer it (if we even decide we need it).
nit: add `{ }` to then block (we always use `{}` for all blocks.)
I don't think you need @Before here, the parent method already has it.
@bbejeck That is a good question! Originally I thought it is okay to always calling `hasNext` inside `next()`, as long as we make sure `hasNext` implementation is idempotent, i.e. calling it multiple times before `next()` does not have side effect is sufficient. But by making it idempotent we could have the corner case you mentioned. For example: ``` t0: call `hasNext()` -> store is still open -> call `makeNext` -> `next` field is set. t1: store is closed. t2: call `next()` -> call `hasNext()` again ``` Without this check, at `t3` we would still return the `next` field.
Sorry for my denseness... Why are these "not re-assigned"? They're part of a data structure called "assigned tasks", which seems to imply that they are assigned.
This is the same code as in `KTableFilter` -- we should refactor and share code.
as above. use `StreamsConfig#...`
@mjsax Got it. Thanks for your response!
For the record, I'm asking because I expect the setter to be called once while these create methods can be called _many_ times
thanks for adding this
nit: keep fields with the same access level together
`maxWrnHeaderSize` -> `maxWarningHeaderSize`
I'm not too keen on these variance changes unless you can show that there is an inference problem with lambdas under 8 without them.
would be nice to allow to configure it to a percentage of the heap size
nit: extra line
this does not need to be volatile anymore.
no need to be volatile anymore
I think these don't need to be volatile any more, now that we read under lock.
why do you need `CopyOnWriteHashMap` here? you don't really edit the map, you only replace it.
what is this provider doing here? We can't do this in our production code this will take hours for decouple again We either pass a client or not but not yet another indirection.
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
makes sense to me as well now, sorry for the noise.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
Thanks for pointing this out, missed that all other constructors delegate here, my mistake.
Two concerns here: If we convert Strings to BytesRef here, shouldn't we also do so in the (..., String... values) constructor? Also, since this seems a convenience method, I'd prefer converting the content of the Iterable to be converted to some array and then use the (..., Object...) constructor, as there are already too many ways of constructing this query builder.
let's see if we get objections on that PR or not
sorry I think I am mistaken here, looking deeper, I think we might need to remove execution from the builder in master instead given that we do nothing with it. Will do that.
spaces missing after `if` and before `{` ð¡
Suggestion: We already say "Kafka Streams API", "DSL", and "Processor API". That's already a lot of "APIs" even though it's all about the same thing. I wouldn't label interactive queries to be yet another API. I'd just say: > ... to access the content via interactive queries:
In general this would be better as a unmodifiable map. I am not a fan of doing it this way. We should be able to challenge with more than a single scheme
Consistency: Here we say > with [a] custom "auto.offset.reset" strategy and below we say > Enum used to define auto offset reset policy when creating {@link KStream} or {@link KTable}. The AK docs say neither "strategy" or "policy", it's just a config like any other. Hence I'd suggest to change the above consistently to sth like: > with [a] custom {@code auto.offset.reset} configuration and > Sets the {@code auto.offset.reset} configuration when creating {@link KStream} or {@link KTable}.
Typo: > Similar[ly], you can ... with [a] custom ...
This is still missing in the KIP wiki page.
can you just leave the constant in this class? There isn't a need to put it in realm imo
recommended; ditto below.
No, I still think that it should not be a method on the `Strings` class.
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
I see that we need it from another package, I think it's ok.
Refer to the `processing.guarantee` config here.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
`scheduler` does not appear in parameter list of this method...
`scheduler` has no effect here...
should we use a native trove collection here from String to long
Not sure if we need to do that it's just one entry per field though.
nit: remove extra line
I realize that these values are the same that are used in the consumer protocol, but perhaps we should just copy the data so there is no unneeded dependence.
nit: maybe utility methods can be moved to the bottom of the class.
But you can simulate a previous assignment by setting the previous assignment in the subscription, right? You don't actually need to have executed the previous assignment.
Refer to the `processing.guarantee` config here.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
`scheduler` does not appear in parameter list of this method...
`scheduler` has no effect here...
should we use a native trove collection here from String to long
Not sure if we need to do that it's just one entry per field though.
nit: remove extra line
I realize that these values are the same that are used in the consumer protocol, but perhaps we should just copy the data so there is no unneeded dependence.
nit: maybe utility methods can be moved to the bottom of the class.
But you can simulate a previous assignment by setting the previous assignment in the subscription, right? You don't actually need to have executed the previous assignment.
`Note when the windowed serde class is used, one needs...`
This selector is never used since we create a Selector a couple of lines below using `createSelector`. We should remove these three lines and the `logContext` created at the start of this test.
doesn't matter that much, I thought -1 didn't make sense :)
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
boost will be gone once you rebase, same for queryName
This and `MockKafkaLog4jAppender` seems unrelated to the thread change.
Do we need this Constructor? It looks like it's only called from `parse()` which has the version so it could call the other constructor
I don't understand why there is either a setter (with null check & exception) here and then direct assignment to fields. Using either one of these would be fine I think. Same for the other options in this constructor.
What about client security related properties? It's weird that we pick up "bootstrap.servers" from one prefix, but the corresponding security properties under a different prefix. If we do provide the security related properties in the same prefix, they seem to be duplicated from those under prefix REMOTE_LOG_METADATA_COMMON_CLIENT_PREFIX, REMOTE_LOG_METADATA_COMMON_CLIENT_PREFIX or REMOTE_LOG_METADATA_CONSUMER_PREFIX.
Other plugins on the broker may also need a bootstrap_server config. To distinguish them, it would be useful to add a prefix that's specific to remote storage.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
i.e., add `fail` after this line
same for tests below as well
nit: remove empty line
nit: fix indention (we usually use 4 spaces, not 8)
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You have some unmerged lines here
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
You verify the wrong name here. ```suggestion assertThat(name2, CoreMatchers.not(Optional.empty())); ```
Here you should test if the stream thread has the name of the stream thread that was removed before.
You have some unmerged lines here
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
You verify the wrong name here. ```suggestion assertThat(name2, CoreMatchers.not(Optional.empty())); ```
Here you should test if the stream thread has the name of the stream thread that was removed before.
You have some unmerged lines here
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
You verify the wrong name here. ```suggestion assertThat(name2, CoreMatchers.not(Optional.empty())); ```
Here you should test if the stream thread has the name of the stream thread that was removed before.
You have some unmerged lines here
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
No, this does not give your any safety.
No, this does not make any sense.
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
This data construction seems better to be put in the `AlterConfigsResponse` constructor.
Yea, my suggestion would be to reuse the existing constructor as the construction of the `AlterConfigsResponseData` seems non trivial for a caller to do, compared with passing a map of errors.
can we init this with `1`
can we hide `shared.refcount` behind a method ie. decRef() / incRef() to be consistent with other stuff
can we make this a `if (!closed) {}`
well maybe you don't like the success pattern though... but I think it should be closed even on Throwable
why don't you use `finally` instead of `catch`? I guess that is legacy or copy/paste
nit: missing a space after the first comma
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Was just thinking about how long a. transaction might possibly be open. 1 minute SGTM
This is not introduced by this PR: the name has a typo: through => throw
And why is this test deprecated as well? More generally it seems the `context#getStateStore` function was being deprecated but it was not explained in the KIP wiki.
Could you please add some line breaks? This and some of the other verifications are too long.
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
nit. I think there is `.` missing `since 3.0[.] Use`
ditto here and others below
Might be simpler to use the mock deserializer only for values.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
You don't need to specify any symbolic name for a group since you have only one.
This is not completely compatible with the behavior of older Streams apps. See #10953 for a fix and more details.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
You have some unmerged lines here
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
This is not completely compatible with the behavior of older Streams apps. See #10953 for a fix and more details.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Thanks. Not a blocker.
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Thanks. Not a blocker.
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Thanks. Not a blocker.
No need for the newline here
possibly use a `SimpleFileVisitor` here to not override all methods
you can reduce this code by using only the `nio` classes instead of moving forth and back between NIO and `File`, see `java.nio.files.Files` for things like moving `Path`
`FileAlreadyExistsException` is an `IOException` and this `IOException` block does the same thing as doing nothing -- `return CONTINUE;`.
Yes, but replace `FileAlreadyExistsException` with `IOException` to maintain the same functionality. Sorry for saying it so confusingly before.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Use https://github.com/ansible/ansible/blob/cd988f645aaf774c55a98a90e3ef42cc5b1a1563/lib/ansible/module_utils/urls.py#L1147 instead of requests.get
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
Indentation doesn't look right here.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
```suggestion public void shouldInstantiateAssignor() { ```
nit: could use Utils.mkSet
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
@cmccabe I think you missed this change.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
nit: remove the redundant line. Same as below.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
Nit: you can remove `value =`
`asList` -> `Collections.singletonList`
redundant type arguments `<ProducerRecord<byte[], byte[]`
typo: byteArrray -> byteArray
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
`<byte[]>` this explicit type is unnecessary
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
Can this lead to user code change? ( as you changed the tests above )
This would be less mysterious if this method were inlined into `updateLimitOffsets`. Right now, it's not terribly clear why it's ok to set the "last update offset time" in a method that doesn't update the offsets.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
instead of creating a new set, thoughts on just returning an empty collection? (`Collections.emptyNavigableSet()`)
you should assign a new list instance (or clear the `abortBenchmarkNodeStatuses` list) to make sure we are not reading an instance that already has some status in the list.
ditto here and others below
it's usually a good idea to print the actual value as the assert message it can be very helpful if it doesn't reproduce
same for tests below as well
nit: one too many line break? :)
Can this lead to user code change? ( as you changed the tests above )
This would be less mysterious if this method were inlined into `updateLimitOffsets`. Right now, it's not terribly clear why it's ok to set the "last update offset time" in a method that doesn't update the offsets.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
instead of creating a new set, thoughts on just returning an empty collection? (`Collections.emptyNavigableSet()`)
you should assign a new list instance (or clear the `abortBenchmarkNodeStatuses` list) to make sure we are not reading an instance that already has some status in the list.
ditto here and others below
it's usually a good idea to print the actual value as the assert message it can be very helpful if it doesn't reproduce
same for tests below as well
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Using generic types instead of raw types for collections is preferable (we can fix elsewhere in the file too) ```suggestion List<?> items = (List<?>) value; ```
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
nit: I think formatting corrects this (at least on intellij). Can be fixed below too ```suggestion for (Object item : items) { ```
nit: Starting a message with lower case feels a little unusual.
`instanceof` checks for `null` too. I wonder if it's better to combine these two cases to say that we expect a list with at least one value (meaning a non-empty list).
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
`call_count` isn't really necessary any more, as accessing `user` or `password` would be an `AttributeError` if the function hadn't been called, but this is a minor issue
Remove unnecessary `toString()` once the Entry type is set above. Other similar cases below too.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
perfect thanks. sorry for the confusion.
maybe not appropriate here, but we can do this with one underlying read of metadata via Files.readAttributes (you then have isRegularFile() and size() available from BasicFileAttributes)
This has to use the new settings API.
I think it'd be nice to have an assertion on the text of one description just so we can look at it.
It would make sense to refactor this into `private Settings newNodeEnvSettings()` since every test requires it, in case it ever has to be changed in the future.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
Maybe use `expectThrows(...)` instead? It is much cleaner and safer than try-catch blocks: ``` java ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(config)); assertThat(e.getMessage(), equalTo("[regex_file] regex file [does-not-exist.yaml] doesn't exist (has to exist at node startup)")); ```
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
> and re-using the `KGroupedStream` results in an `InvalidToplogyException` when building the topology I thought, if there is no user topic-name, old code would create multiple repartition topics? And re-using `KGroupedStream` only throughs if there is a user topic-name (and this restriction is lifted with this PR)
> That's correct. I may not have been clear above, but what I meant is that this change won't break compatibility with users currently **_not providing_** a repartition topic name as it will create multiple repartition topics thus keep their topology the same. Does that make sense? Ack. Just wanted to make sure we are on the same page :)
Since timezone is now a string, we should probably check for `Strings.isNullOrEmpty()` instead of just null now. (or null/empty check, I'll leave that up to personal preference :) )
I think I would consider taking settings out. We try to extract node.name from it as far as I understand, which I don't think is ever going to be set on a transport client. Maybe we can just live without that part of the thread name and remove some complexity. This may very well come from the times where node client was widely used, hence node.name made sense in the past, but it doesn't anymore.
Could store `entry.getKey()` in a local variable since it is used several times
you can fold this into the previous `if` block, so it reads: ``` if (in.readBoolean()) { this.nodeDecisions = Collections.unmodifiableMap( in.readMap(StreamInput::readString, NodeAllocationResult::new)); } else { this.nodeDecisions = null; } ```
unnecessary type in constructor, can use `new HashMap<>()`
Maybe this one too, I'm not sure.
Fine by me.
I think maybe just "return Math.log(doc.popularity) \* 100;", you don't need the "<idOrCode>" bit.
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
I'd suggest moving this static method after the non-static methods.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
We should read the metadata inside the while loop since it could change.
nit: add `final` (same below)
Just wondering if this test is good. Seems like a "RoundRobinAssigner" might compute the exact same assignment. Some more "randomness" would be good IMHO. (Not a must though.)
I just noticed this isn't even being used by OperationDelay.
nit: remove the redundant line. Same as below.
nit: could use Utils.mkSet
`asList` -> `Collections.singletonList`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
redundant type arguments `<ProducerRecord<byte[], byte[]`
typo: byteArrray -> byteArray
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should be done in reset()
nit: could use Utils.mkSet
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
Just wondering if this test is good. Seems like a "RoundRobinAssigner" might compute the exact same assignment. Some more "randomness" would be good IMHO. (Not a must though.)
Fails checkstyle, needs to be final
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
I'd suggest moving this static method after the non-static methods.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
We should read the metadata inside the while loop since it could change.
nit: add `final` (same below)
Just wondering if this test is good. Seems like a "RoundRobinAssigner" might compute the exact same assignment. Some more "randomness" would be good IMHO. (Not a must though.)
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We don't want to be converting from int to string in the benchmark code.
You have some unmerged lines here
Hmm, I'd just generate the randoms during set-up and add them to an array.
This test is highly overlapping with `testOldBrokerAbortTransaction`, could be good to refactor out a common flow.
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We don't want to be converting from int to string in the benchmark code.
You have some unmerged lines here
Hmm, I'd just generate the randoms during set-up and add them to an array.
This test is highly overlapping with `testOldBrokerAbortTransaction`, could be good to refactor out a common flow.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
nit: missing a space after the first comma
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
recommended; ditto below.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
It should be robust in case of some missing fields.
ditto here and others below
You have some unmerged lines here
Btw, we should take the chance and make `version` and `commitId` final. Something like: ```java private static final String version; private static final String commitId; static { Properties props = new Properties(); try (InputStream resourceStream = AppInfoParser.class.getResourceAsStream("/kafka/kafka-version.properties")) { props.load(resourceStream); } catch (Exception e) { log.warn("Error while loading kafka-version.properties :" + e.getMessage()); } version = props.getProperty("version", "unknown").trim(); commitId = props.getProperty("commitId", "unknown").trim(); } ```
Let's use try with resources here and the other test so that the file is closed after it's used.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Btw, we should take the chance and make `version` and `commitId` final. Something like: ```java private static final String version; private static final String commitId; static { Properties props = new Properties(); try (InputStream resourceStream = AppInfoParser.class.getResourceAsStream("/kafka/kafka-version.properties")) { props.load(resourceStream); } catch (Exception e) { log.warn("Error while loading kafka-version.properties :" + e.getMessage()); } version = props.getProperty("version", "unknown").trim(); commitId = props.getProperty("commitId", "unknown").trim(); } ```
Let's use try with resources here and the other test so that the file is closed after it's used.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
nit: unneeded parenthesis
Since this query is a pure wrapper, I'm wondering if you should delegate calls to setBoost/getBoost (and then ignore the boost in equals/hashCode)
It seems like we're duplicating some of the logic contained in `Plugins` into this class by tracking class alias names and pre-computing plugin type based on them. Did you consider a `Herder` method that only accepted the name of the plugin, and took on the responsibility of deducing the plugin type itself? ```java List<ConfigKeyInfo> connectorPluginConfig(String pluginName); ``` In `AbstractHerder`, we could do something like this: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { Object plugin = Plugins.newPlugin(pluginName); PluginType pluginType = PluginType.from(plugin.class); List<ConfigKeyInfo> results = new ArrayList<>(); ConfigDef configDefs; switch (pluginType) { case SINK: case SOURCE: configDefs = ((Connector) plugin).config(); break; case CONVERTER: configDefs = ((Converter) plugin).config(); break; // ... Rest of switch statement follows same pattern, and rest of the method remains unchanged } ``` And in `Plugins` we could do this: ```java public Object newPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends Object> klass = pluginClass(delegatingLoader, classOrAlias, Object.class); return newPlugin(klass); } ``` Or alternatively, we could introduce a common interface for plugins that expose a `ConfigDef`: ```java interface DefinedConfigPlugin { ConfigDef config(); } ``` Which could really simplify some of the `AbstractHerder` logic: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { DefinedConfigPlugin plugin = Plugins.newDefinedConfigPlugin(pluginName); ConfigDef configDefs = plugin.config(); // No switch statement on plugin type necessary // ... Rest of the method remains unchanged } ``` And the change to `Plugins` would be lightweight as well: ```java public DefinedConfigPlugin newDefinedConfigPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends DefinedConfigPlugin> klass = pluginClass(delegatingLoader, classOrAlias, DefinedConfigPlugin.class); return newPlugin(klass); } ``` Worth noting that if we want to differentiate to users between "this plugin is not on the worker" and "we don't expose config information for this type of plugin", we'd have to make a few further tweaks.
Thanks for the clarification, makes sense.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
nit: Starting a message with lower case feels a little unusual.
Since these string literals are now relevant elsewhere, we should make them reusable constants. Perhaps they should be enums? I realize now that perhaps the class names should have also been enums but ð¤·.
How about just throwing `NullPointerException` here? If that causes other issue, could you add some useful exception message, such as, `Should not add null Throwable to CompositeException`? So that people can quickly figure out it's an application bug instead of an RxJava bug.
I thought it was unintentional. Never mind. See this style for the first time :)
we should escape expectedWarningHeaders, or alternatively unescape when we read.
why did you remove this? What if we have multiple pattern that match multiple snapshots? we now add these multiple times. For example: `foo*,*bar` will match the snapshot `foobar` twice.
Would it be a lot easier to do the following? ``` Map<String, Object> prefixedOriginals = connectorConfig.originalsWithPrefix(prefix); Map<String, Object> clientConfigs = configDef.parse(prefixedOriginals); ``` This does check a few more things (dependencies are set and validators are run), so maybe that's not really want we want to do here.
This leads to resolving the snapshot name on the repository for each entry in the list, which is very wasteful (We query the list of snapshots n times and thus have n separate network requests on S3/GCE etc.). This method should be rewritten so that we query the snapshot names on the repository once and then get all the snapshotInfo elements for the entries that we requested in a subsequent step.
Maybe simpler just to do it the oldschool way. ``` final Map<String, SnapshotId> allSnapshotIds = new HashMap<>(); for (SnapshotInfo snapshotInfo : snapshotsService.currentSnapshots(repository)) { SnapshotId snapshotId = snapshotInfo.snapshotId(); allSnapshotIds.put(snapshotId.getName(), snapshotId); } for (SnapshotId snapshotId : snapshotsService.snapshotIds(repository)) { allSnapshotIds.put(snapshotId.getName(), snapshotId); } ```
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
we should totally not have this method, one more reason to not implement the interface.
The sentence "Note that the order of the tags..." is not applicable because there is no set in this case. It's just the order of the varargs.
This exception is no longer possible since the constructor is taking `ObjectName`.
We typically avoid the `get` prefix in Kafka, so `objectName` seems fine.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
OK sorry, I had missed the dependency resolution issue. Then I suggest to keep your current solution for potentially revisit when all aggs are refactored and we have a better picture.
I was wondering wherer the bucketsPaths passed get used here, but they might only be necessary in other impls of PipelineAggregatorFactory I guess. I also found the order in which the super class reads something from the stream, then calls this method to create the actual implementation and then reads some more a bit hard to follow and a bit tricky. Maybe there are ways of simplifying this, but unfortunaltely I don't have a good suggestion at this point. Maybe the whole readFrom/doReadFrom separation in the abstract class and the implementations could be merged, which would mean some duplication in code but would be easier to understand and maintain? Just a suggestion though.
I now saw that in the consumer tests you use `Duration.ofSeconds(1).toMillis()` and `Duration.ofMillis(999).toNanos()`. This makes it already clearer. I think a variable with a meaningful name for the lower bound would make it even clearer.
nit: missing a space after the first comma
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
`PrintForEachAction<>` to remove warning. Also in the `print` method
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Ok, then for the profile settings you only read the publish_port and publish_host instead of the other settings. I see the difference now. Before it seemd like you wanted to read exactly the same settings, then I wondered why that part couldn't be shared.
can we get away with passing `null` instead of `TrustSelfSignedStrategy`? I'd prefer to have the certificates we trust only stored in the truststore
I've been wanting a portfile for a few weeks now for other testing things. It'll really make BWC tests more clean to have this, I think.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Don't get me wrong - I like the loop above - I just don't think is sufficient to prove to ourselves that we recreated the problem.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Ok, then for the profile settings you only read the publish_port and publish_host instead of the other settings. I see the difference now. Before it seemd like you wanted to read exactly the same settings, then I wondered why that part couldn't be shared.
can we get away with passing `null` instead of `TrustSelfSignedStrategy`? I'd prefer to have the certificates we trust only stored in the truststore
I've been wanting a portfile for a few weeks now for other testing things. It'll really make BWC tests more clean to have this, I think.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Don't get me wrong - I like the loop above - I just don't think is sufficient to prove to ourselves that we recreated the problem.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Ok, then for the profile settings you only read the publish_port and publish_host instead of the other settings. I see the difference now. Before it seemd like you wanted to read exactly the same settings, then I wondered why that part couldn't be shared.
can we get away with passing `null` instead of `TrustSelfSignedStrategy`? I'd prefer to have the certificates we trust only stored in the truststore
I've been wanting a portfile for a few weeks now for other testing things. It'll really make BWC tests more clean to have this, I think.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Don't get me wrong - I like the loop above - I just don't think is sufficient to prove to ourselves that we recreated the problem.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Ok, then for the profile settings you only read the publish_port and publish_host instead of the other settings. I see the difference now. Before it seemd like you wanted to read exactly the same settings, then I wondered why that part couldn't be shared.
can we get away with passing `null` instead of `TrustSelfSignedStrategy`? I'd prefer to have the certificates we trust only stored in the truststore
I've been wanting a portfile for a few weeks now for other testing things. It'll really make BWC tests more clean to have this, I think.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Don't get me wrong - I like the loop above - I just don't think is sufficient to prove to ourselves that we recreated the problem.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
@cmccabe I think you missed this change.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
nit: remove the redundant line. Same as below.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
@cmccabe I think you missed this change.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
nit: remove the redundant line. Same as below.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
> toArray() returns an Object[] depends on which toArray method you use. Just move to the one that accept an array as argument. Or iterator is fine too.
Could you have the score scripts as separate scripts rather than repurposing the existing ones? I think its important that we continue testing scripts that don't use score as well as scripts that do.
ditto here and others below
I'm not sure about this, it is a usage error.
Yeah, exactly, and I think usage should really be reserved for incompatible or invalid arguments, for example. This is more a state thing, so now I think I'm convincing myself that configuration is apt.
To be clear, I don't think we should change this to an I/O error. I think I'd be okay with a configuration error though.
Maybe we can replace calls of this helper with the new Endpoint class? Might get a tad bit longer in the end, so I'm fine either way.
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
same for tests below as well
I don't have a better suggestion, but targetTopicPartitionsUpstream is a kinda confusing name.
Nit - there is a stream::toArray(Directory[]::new))
This variable needs to be `final` says checkstyle.
```suggestion }, "The number of active tasks returned in the allotted time was not one."); ```
Up to you but I find it more intuitive to collect all the explicit write indices (i.e. flag is true) regardless of size if that is empty we check if `referenceIndexMetaDatas` is of size 1 and if the first value has ` null` for the flag, if so we set `writeIndices` to referenceIndexMetaDatas and be happy.
I think this assertion should be in `getAnyNodeExcept()` - it's ok to return an empty list here.
How can we be sure that `partNums` is not empty? If empty, `next()` would throw.
Guess we can keep it, but this helper doesn't seem to be doing much for us anymore.
something like `inferredInternalTopics.containsAll(specifiedInternalTopics)` might be easier to understand here
I like the extra-detailed error messages, thank you.
you can just do the conversion to unmodifiable map one time in the constructor. it looks like at the moment this is only accessed in tests anyway.
I think key-pairs of strings as list is brittle. But we inherited that.
It was removed from the other versions of `group` but not from here.
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
bit-nitpick :) ``` // modulo 2 operation if ((keyValue.length & 1) != 0) ``` most definitely optimized out by JIT because the divisor is known (`2`). Is it too hard to read? Sometimes it's good to train ppl who read the code by example. Can't be more nitpicking than that and if you want to keep uniformity with other versions of `getTags` elsewhere never mind. Not 100% sure either, leaving here to ask what you think in general for such optimizations that are JIT optimizable too.
ah, right. nah, that's fine. just when reviewing I had the thought that if we guaranteed non-`null`/non-empty in the constructor, this wouldn't be necessary. i realized that it was actually intentional, but easy to miss when reviewing here and not getting the same highlighting as an IDE
might want to rename `workerId` so it doesn't shadow the member field. something like `workerIdOpt` could work
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
to me it seems like we can't possibly know what the constraints of all reporters would be and they don't provide an interface for validation, so it should be up to them to figure out how to substitute. but i've also asked some other folks to maybe chime in here who may have better context on how we've handled this elsewhere.
I know the naming thing has bit us in the past, is this same approach used elsewhere and/or how was it decided on? Specifically, metric name constraints really shouldn't be JMX specific if that is the case here, despite the fact that the metrics is so obviously JMX-inspired. I can easily find https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/metrics/KafkaMetricsGroup.scala#L46 but nothing else. Have we not had the same problems because metrics w/ topic names in them already have constraints on the naming? If I am remembering correctly, I think maybe both @gwenshap and @junrao were involved in some discussions, I think `-` vs `_` was a problem at some point? Maybe one of them could chime in here.
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
no need to use `this.` outside the constructor. Here and below
nit: braces unneeded
nit: braces unneeded
Is the `myCommittedToken == null` check unnecessary here since it can never be the case when there are extensions? I think we make sure of this since we only call `identifyExtensions()` when there is a token.
This line is failing checkstyle.
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
no need to use `this.` outside the constructor. Here and below
nit: braces unneeded
nit: braces unneeded
Is the `myCommittedToken == null` check unnecessary here since it can never be the case when there are extensions? I think we make sure of this since we only call `identifyExtensions()` when there is a token.
This line is failing checkstyle.
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
no need to use `this.` outside the constructor. Here and below
nit: braces unneeded
nit: braces unneeded
Is the `myCommittedToken == null` check unnecessary here since it can never be the case when there are extensions? I think we make sure of this since we only call `identifyExtensions()` when there is a token.
This line is failing checkstyle.
nit: one too many line break? :)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
Please put it into an assert if you keep it. Iâd remove it.
I wonder if we need this at all. The blocking call to the client executes it anyway. The issue was that there was no testing. I think this entire transport action can use a ml threadpool instead
Even if the number of sub aggregation is expected to be small, I'm not too happy with the use of `ListIterator.add` which is linear on array lists.
Checkstyle is unhappy with this.
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
To avoid the interesting indentation: ``` msg = "<class 'admin_views.models.Question'> is not registered in the admin." with self.assertRaisesMessage(Http404, msg): ```
I don't think it's important for now
see above - I think you should add it though
IMO this is useless since it will throw an NPE anyway the check is obsolet
why an empty string? might as well use assertRaises at that point.
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
```suggestion Question.objects.create(question='Not a question.') ```
To avoid the interesting indentation: ``` msg = "<class 'admin_views.models.Question'> is not registered in the admin." with self.assertRaisesMessage(Http404, msg): ```
see above - I think you should add it though
`.get(self.live_server_url + reverse('admin:admin_views_question_add'))`
IMO this is useless since it will throw an NPE anyway the check is obsolet
I think this test isn't working as expected -- it's resolving to `RedirectView`, same with `test_inline_urls` -- probably the result of the resolve should be checked.
why an empty string? might as well use assertRaises at that point.
No need to use `get_user_model()` (don't think any of the other tests do that?), I think.
Does it need to be a separate test case from the one above? I don't see the distinction.
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`requireNonNull` seems not to be necessary
We can remove `requireNonNull` here, because `getter.keySerde()` would already throw a `ConfigException` if the default serde is null.
We should probably assume that people won't be using request throttling immediately since it was just introduced. But the same can probably be said for transactions.
Also, 5ms seems a bit extreme. Maybe this could be 20ms or so and we could use the minimum of this and the configured retry backoff so that users can adjust it lower if they need to.
Yeah, I have no doubt the performance is better. It's just that it seems like a lot of excess traffic and is going to be amplified by the number of transactional producers. It may be fine in the common case if the write markers are pretty quick, but if there is any kind of delay, then I'd be concerned about the brokers being overwhelmed with these requests (though maybe it's not as bad with request throttling). I'd rather err on the safe side for now since users can manually adjust the backoff. For the 0.11.0.1 release, we can provide a better solution. Most users will probably hold off until then anyway.
nit: new Integer(1) => Interger.valueOf()
I think this should be four different tests. One for each of the methods you are testing. I probably said this before, but it is much nicer if you can just read the test names to understand what should/shouldn't be happening
I stand by what i said, but I'll leave it up to you. It isn't a deal breaker for me!
This only needs to be set when we first create the `OffsetCommitRequestTopic`, right? So it can be set inside the `getOrDefault` block.
Ditto on removing these before/after methods.
If we don't cache the fields, we should remove the fields.clear() at the end.
add `fail()` in next line to make sure we hit the timeout and throw an `AssertionError`
nit: `/** ... */` -> `/* */`
We usually avoid the get prefix in cases like this
nit: add `final`
that will be hard to debug if it's false - which one misses? (holds for the one above as well).
We use `assumeFalse(Constants.JRE_IS_MINIMUM_JAVA9);` elsewhere, I don't think this is right since the version string no longer has the leading `1.`.
It's super minor, but I think we usually don't include punctuation at the end of exception messages (the `.`)
let's keep as is, with the assertion message I think it's ok. I wonder if we should have an assertion at the end of this method to say something like "if we have an active primary shard that's not relocating, then the replication tracker is in primary mode".
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
You have some unmerged lines here
same for tests below as well
We can use `assertThrows` for this kind of pattern: ```java RecordDeserializationException rde = assertThrows(RecordDeserializationException.class, () -> consumer.poll(Duration.ZERO)); assertEquals(invalidRecordOffset, rde.offset()); assertEquals(tp0, rde.partition()); ```
Might be simpler to use the mock deserializer only for values.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
It may also be useful to assert that the current consumer position is equal to `rde.offset`.
nit: one too many line break? :)
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Perhaps open a separate pr for the change to this method? This adds additional validation outside concrete index to data stream lookup.
In case of LOCAL_SHARDS/RESTORE, we could again call activatePrimary here.
Note that in case of peer recovery with a retry, we could end up with a higher gcp in the globalcheckpointtracker than what we're setting here.
wondering if we need recoveryState.isPeerRecovery() to simplify these lines.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
Both `GZipInputStream` and `SnappyInputStream` read the header in the constructor, so it would make sense to me to remain consistent in that respect.
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
> can be cancelled just because primary relocation completed before shard was activated by the master node yes. I'm aware of that - I'm thinking that with seq# fast recovery it wouldn't matter much as a ready shard will quickly re-recover. However, seeing how the new code looks like with the cancelRecoveriesForShard + shardRouting.isPeerRecovery changes, I think it became much simpler. I'm good. We can see how things develop later on and potentially move some logic to the master (which will simplify this class) or not.
we lose some concurrency control here where we only cancel the recovery if it's not done. I'm wondering if we should use `cancelRecoveriesForShard` and if it returns true, we then remove the shard. Also - In all cases where the the source of recovery changes due to a primary failure, the master cancels the allocation and changes the allocation id, meaning we don't get here. I wonder if we should also catch the case where a primary relocates on the master and not have to worry about all of this here. I think it will be simpler all in all
isn't this what peer recovery means? should we just check currentRoutingEntry? at this point we know it has to be the same allocationId, which will means it's safe.
I think your IDE is adding extra braces. (I know this is a bit annoying between Apache Kafka & Confluent projects since they use different styling. iirc default IntelliJ styling works for Kafka if you are using IntelliJ)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
base -> based progress -> progressed
You don't need to specify any symbolic name for a group since you have only one.
and -> a
and -> a
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
thanks for checking, that is fine then
we may have a small problem here, when toXContent is called on an object deserialized from a previous version that didn't send the _id .
if it prints out null it may be ok, if it gives NPE we need a null check, that's what I meant.
It's not super-important, but it probably makes sense to set -1 as the default for `ProducerId` in `InitProducerIdResponse`. Same for `ProducerEpoch` But maybe keep the explicit assignment as well since that makes it very clear...
This could be: ```java try (BufferedReader br = Files.newBufferedReader(Paths.get(args[0]))) { ... } ```
Whoops yeah, I only looked at the version for `Files` rather than `Files.newBufferedReader`, sorry
Do we gain anything by passing a reader into `parse`? It seems like it'd be easier for testing if you pre-read the file into a String or a list of lines and then passed it into parse. Are we concerned about the memory of reading `jvm.options` up front? (It would also let us separate errors reading the file from errors parsing the file from a feedback perspective)
It would also allow us not to have to make `parse` throw a checked `IOException`
nit: add a size? There are a few cases in here where we could do this.
Sorry for that -- You are of course right. `final` only for iterator loops...
Can `LogManager.getRootLogger().getLevel()` be `null`? With other loggers you return the effective level if that's the case.
What are your thoughts regarding returning the same `"No such logger"` value? It might be more informative to JMX users
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
what's the difference between TermsLookup and TermsLookupBuilder? I am thinking if we can just make TermsLookup Writeable etc. and avoid adding a new class that holds the same info.
No, you are right, I didn't realize the need for api users before going through the whole changes.
this curly bracket should be on the previous line
Hmm, doc says `The order defaults to desc when sorting on the _score, and defaults to asc when sorting on anything else.`, so maybe having the default in the enum is missleading.
I see, so parser always sets both "order" and "mode", regardless of whether they are set by the user. But what if we only go through the java api, use a plain builder and set "reverse = false". Translated to json this should give us "mode = MIN", but only if not explicitely set by the user otherwise, no? Sorry, haven't got a good solution myself so far either.
Maybe you could put the validation removed from toCContent here. (point.size > 0)
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
doesn't matter that much, I thought -1 didn't make sense :)
s/payload is/payloads are
We should break anything we need to to make the Java API clean, easy to use, and less trappy. Given this is only going into 3.0 we should take this opportunity.
It's super minor, but I think we usually don't include punctuation at the end of exception messages (the `.`)
I don't think raising en exception to save a few lines of code here is a good idea, please change this back to how it was before.
By that I mean a switch or something similar to what SuggestUtils#resolveDistance() does.
oh nevermind I thought it was a parsing method, but this is the simple Enum.valueOf
I think we should only log.warn here. I can imagine that at some point AWS may support this in China and I would not block users for this. May be we should not control that at all and let the user specify whatever he wants. I mean that if this plugin is used with other S3 compatible platform, we can't do those checks.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
Should we actually control this? I know, I wrote that code as well at the begining but the more I think about it, the more I think it's not that useful to block... May be only log.warn with "[{}] signer might not be supported"...
max timeDifferenceMs later than -> at most ...
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
The parameters can be `final`.
typo: an -> a, concat -> concatenated
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
nevermind I was confused... all is good
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
This seems like it's a kind of weird restriction. I guess it'd be odd to use the same name for an internal topic and another, though if you know its going to be prefixed it might not be great to not be able to use that same name.
... as discussed f2f: Add to the TODO to collect errors and return only when all requests are done, I'd do the actual implementation in a separate PR though
The parameters can be `final`.
typo: an -> a, concat -> concatenated
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
nevermind I was confused... all is good
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
This seems like it's a kind of weird restriction. I guess it'd be odd to use the same name for an internal topic and another, though if you know its going to be prefixed it might not be great to not be able to use that same name.
... as discussed f2f: Add to the TODO to collect errors and return only when all requests are done, I'd do the actual implementation in a separate PR though
we're in Java8 now... I think you can do: `(key,value,context) -> { ... }`
we end up supporting both `$stashedKey` and `foo${stashedKey}bar` ? we may want to move to the latter once all the clients runners implement this feature, to have a single way to get stashed values.
maybe ${stashedKey} alone should return an object then? Does that complicate things? Calling toString makes sense when the stashed thing is part of a string, otherwise returning the object sounds better.
maybe just `esVersion()`
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
should probably remove the `get` prefix and use `optionValue` since that is the convention followed in the Kafka codebase. Lots of other occurrences like this.
I also feel that we can collapse the layered interfaces a bit further after we've changed this, since the original motivation of having it is just to "stitch" the global stores and local stores together when exposing as `KafkaStreams#stores`. We can consider that in a separate, cleanup PR afterwards.
I can work on the follow-on change. WrappingStoreProvider -> WrappingStateStoreProvider GlobalStoreProvider -> GlobalStateStoreProvider QueryableStoreProvider is left as is.
With this change, just Global and Wrapping StateStoreProviders exist? IIUC, most of the `xxxStore` classes are just accessing the `Wrapping..` store provider? Makes me wonder, if we should just use the `QueryableStoreProvider` everywhere and cull the interface.. Anyway, I am not familiar enough with this part of the code. So I leave it to you..
Probably for another PR since it's unrelated but I wonder if `scriptable`, `formattable` and `timezoneAware` should be properties of the Builder object rather than/ as well as the parser so the builder can ensure an IllegalArgumentException is thrown if e.g. an unscriptable agg has the script method called on it? /cc @jpountz
so what about the other settings you can set on the Item like source filtering? I think we should expose all of them here though.
nit: missing empty line
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
Maybe an `assert` for unit tests (are `asserts` common in Kafka code base?). As `WrapperSerde` is private, nobody else can use it -- so no need to check for `null` IMHO.
Ups ð thanks
This is logic that I think should go into ReplicatedOperation.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
Might be simpler to use the mock deserializer only for values.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
nit. I think there is `.` missing `since 3.0[.] Use`
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
The variable name `phand` is non-descriptive
You have some unmerged lines here
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
The variable name `phand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
typo: ot -> to
The variable name `shand` is non-descriptive
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
happens in other tests too.
maybe also test a nested conditional setup? (So have conditional and then another conditional in the matched or unmatched list)
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
redundant type arguments `<ProducerRecord<byte[], byte[]`
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
happens in other tests too.
maybe also test a nested conditional setup? (So have conditional and then another conditional in the matched or unmatched list)
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
redundant type arguments `<ProducerRecord<byte[], byte[]`
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Can we also clear the temp `charBytes` array, something on the lines of: ``` final byte[] charBytes = CharArrays.toUtf8Bytes(password); try { return builder.startObject() .field("password").utf8Value(charBytes, 0, charBytes.length) .endObject(); } finally { Arrays.fill(charBytes, '\u0000'); } ```
I also need to go back and do this for the PutUserRequest
this should be done by just reading username password from the Credentials
No. You should not shadow the original explicitly provided password.
no need to implement/override this method if no validation is required
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was not aware of the restriction on JSON object keys, and that seems like a fine standard to follow. I can't imagine it being too useful.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
please set default to True
Is there similar behavior in the map parsing? I see a similar comma consume call being ignored. Consider the following test: ``` SchemaAndValue schemaAndValue = Values.parseString("{foo:bar baz:quux}"); assertEquals(Type.STRING, schemaAndValue.schema().type()); assertEquals("{foo:bar baz:quux}", schemaAndValue.value()); ```
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Can we also clear the temp `charBytes` array, something on the lines of: ``` final byte[] charBytes = CharArrays.toUtf8Bytes(password); try { return builder.startObject() .field("password").utf8Value(charBytes, 0, charBytes.length) .endObject(); } finally { Arrays.fill(charBytes, '\u0000'); } ```
I also need to go back and do this for the PutUserRequest
this should be done by just reading username password from the Credentials
No. You should not shadow the original explicitly provided password.
no need to implement/override this method if no validation is required
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
ok, potentially reduces allocations for the user, thanks
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
if we fail to start do we close the started ones
@guozhangwang Yes, keeping the reference is fine. I was concerned by the check itself because we were calling `generation()` twice in the previous implementation thus we could get two different instances. ``` generation() != Generation.NO_GENERATION && !protocolName.equals(generation().protocolName) ``` I haven't thought about the error-log but it is also a good point.
@dajac just to clarify, are you concerning that the `generation()` may change between the check and the error-log? If yes maybe we do not need to synchronize the whole function, instead we just get a reference of the returned `generation()` call and use that in the error-log, since the generation object is immutable.
I think you can remove `isSSLPropertyPresent` here, it's always true as it's checked above.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
We should log an error that prints out what the two configs actually are
I guess it could be renamed to isFalse() / isTrue() now
Ah nevermind, I see where we use it :-/
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
I think you use it indirectly through `parser. isBooleanValueLenient`.
I don't believe this is only kept for BWC. You use this to parse `_source` above.
@guozhangwang Yes, keeping the reference is fine. I was concerned by the check itself because we were calling `generation()` twice in the previous implementation thus we could get two different instances. ``` generation() != Generation.NO_GENERATION && !protocolName.equals(generation().protocolName) ``` I haven't thought about the error-log but it is also a good point.
@dajac just to clarify, are you concerning that the `generation()` may change between the check and the error-log? If yes maybe we do not need to synchronize the whole function, instead we just get a reference of the returned `generation()` call and use that in the error-log, since the generation object is immutable.
I think you can remove `isSSLPropertyPresent` here, it's always true as it's checked above.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
We should log an error that prints out what the two configs actually are
I guess it could be renamed to isFalse() / isTrue() now
Ah nevermind, I see where we use it :-/
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
I think you use it indirectly through `parser. isBooleanValueLenient`.
I don't believe this is only kept for BWC. You use this to parse `_source` above.
I mean to say that I think you can just call `Strings#toString`.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
The variable name `shand` is non-descriptive
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I just noticed this isn't even being used by OperationDelay.
Ah, okay. Thanks.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
`< Callback >` this explicit type is not necessary.
redundant type arguments `<ProducerRecord<byte[], byte[]`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Nit: add a space between `if` and `(`
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
did you plan to add here the list of nodes or something? looks like there is a missing argument.
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
I don't think it's important for now
Same with this, we are actually testing the deprecated method here, so we can justify the suppression.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
Ah yes, I was thinking about ReadOnlyWindowStore exposed in IQ only. All good.
Idk, the current defaults make sense to me. If a user has a custom store and wants to use the new `backwardFetchAll` with both longs and Instants, all they'd have to do is override the long-based `backwardFetchAll` method (they have to implement the long version no matter what, since this is what gets used internally to Streams). If we just throw UnsupportedOperationException directly from the default implementation of the Instant-based `backwardFetchAll`, then they would have to override that as well in their custom store. So we should just let the Instant default to the long method so users only have to implement one method instead of two (plus they would have to do the Instant validation themselves, etc)
Wearing my performance paranoid hat here: unlike the StreamsBuilder's `Materialized / Consumed / etc` constructs which is only used once, this is actually on the very critical path of the processing of each record, and on average the forward call itself can be triggered many times per record. So I'm a bit concerning about the new `To` object per call to the timestamp setters here. Could we do some benchmarking say with the simple benchmark code and watch the GC metrics to analyze its impact? If it shows non-neglectable overhead I'd suggest we re-consider its API to, for example, adding overloaded `forward(k, v, timestamp)` instead.
If users specify the wrong processor node it will cause NPE, which is a bit hard to reason. Better check null on `child` and throw an informative error message before calling forward.
same for tests below as well
looks like we could extract: ``` setCurrentNode(child); child.process(key, value); ``` into a method and use in all three places
yes, it seems to be not what this test is checking on. I think we can drop it here.
I think you also need the following test (here and in the other `*Windows`): ``` assertThat(DEPRECATED_OLD_24_HR_GRACE_PERIOD, is(Duration.ofDays(1).toMillis())); ``` Otherwise we will not notice if `DEPRECATED_OLD_24_HR_GRACE_PERIOD` is changed by mistake.
Alternatively, you could use `24 * 60 * 60 * 1000L` instead of `DEPRECATED_OLD_24_HR_GRACE_PERIOD` in the tests.
```suggestion assertEquals(0L, JoinWindows.of(ofMillis(DEPRECATED_OLD_24_HR_GRACE_PERIOD)).gracePeriodMs()); assertEquals(0L, JoinWindows.of(ofMillis(DEPRECATED_OLD_24_HR_GRACE_PERIOD + 1L)).gracePeriodMs()); ```
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Nit: add a space between `if` and `(`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
Note that this is different than setting a single property as it adds the inputs to the list.
We use `== False` throughout the codebase instead of `!` because the former is easier to spot visually.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Nit: add a space between `if` and `(`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
Note that this is different than setting a single property as it adds the inputs to the list.
We use `== False` throughout the codebase instead of `!` because the former is easier to spot visually.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
I would prefer not to use `ExtraPropertiesExtension`. Let's add our own extension instead. We would need to go trough build scripts now, but having that extra namespace would make it clear when reading the build script where these are coming from, and there are fewer chances to clash with something in the build script ( thinking about users of build-tools here).
Nit: add a space between `if` and `(`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Expected value here should be a list of longs.
With the type promotion changes I think you'll need to pass in both the original value and the projected value to this method and this assertion will have to change to something like `assertEquals(expectedProjected, projected)`.
You can reduce this code a lot by using `SchemaBuilder.type(readerType)` to handle all these cases instead of using `SchemaBuilder.int8()`, `SchemaBuilder.int16()`, etc.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
I would prefer not to use `ExtraPropertiesExtension`. Let's add our own extension instead. We would need to go trough build scripts now, but having that extra namespace would make it clear when reading the build script where these are coming from, and there are fewer chances to clash with something in the build script ( thinking about users of build-tools here).
Nit: add a space between `if` and `(`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Expected value here should be a list of longs.
With the type promotion changes I think you'll need to pass in both the original value and the projected value to this method and this assertion will have to change to something like `assertEquals(expectedProjected, projected)`.
You can reduce this code a lot by using `SchemaBuilder.type(readerType)` to handle all these cases instead of using `SchemaBuilder.int8()`, `SchemaBuilder.int16()`, etc.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
If these aren't expected to change at runtime, I'd suggest initializing the `HashMap` in the static block as a temporary variable , then wrapping it to create an unmodifiable map which is then used for the constant here: ```java Map<String, File> pluginJars = new HashMap<>(); try { pluginJars.put(..., ...); // More of the same } finally { PLUGIN_JARS = Collections.unmodifiableMap(pluginJars); } ```
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`<byte[]>` this explicit type is unnecessary
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
If these aren't expected to change at runtime, I'd suggest initializing the `HashMap` in the static block as a temporary variable , then wrapping it to create an unmodifiable map which is then used for the constant here: ```java Map<String, File> pluginJars = new HashMap<>(); try { pluginJars.put(..., ...); // More of the same } finally { PLUGIN_JARS = Collections.unmodifiableMap(pluginJars); } ```
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
redundant type arguments `<ProducerRecord<byte[], byte[]`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
Could we replace this with something like the following? ``` assertEquals(topics, requestWithNames.data().topics().map(DeleteTopicState::name).collect(toList)); ``` It is a bit easier to read and `assertEquals` gives the differences between all the expected and the existing topics when it fails.
Instead of adding these plugins as we go, we can get the `values()` from `loaded` at the end of this method.
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
something is wrong in this sentence :)
This could move to `ListOffsetResponse` as a helper, and maybe name as `singletonListOffsetTopicResponse`
Would be better to describe what `cases` are referring to.
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
I see that we need it from another package, I think it's ok.
How does the volume of data relate to the slowness of the search api in the remote cluster? We are using scan search which is pretty fast and doesn't do deep pagination, and e.g. socket timeout set to 10 seconds doesn't mean that the whole response has to come back in 10 seconds, the request only times out if no data comes back for 10 seconds at any point of the request execution.
I hope I'm not splitting hairs, but there's also a typo in the field (deault is missing and 'f'). (This PR resulted from a question I asked here; thanks for all the awesome work you invest there!)
good call on the typo. I did see the issue that originated this change, thanks for the heads up ;) Just trying to understand if yours is a special case that needs a custom timeout (which could be set), or whether the default timeout really has to be increased that much.
We did used to do this but we've moved away from it. So you'll see examples in the code when we had this but it is no longer the preferred way.
can we reduce visibility? eg. pkg-private
Ah ok fair enough -- thanks!
Yeah, builders are nice for the reasons you mention. However, since it wasn't discussed in KIP-222, I think keeping it package private for now might be better.
The first two of these fields are unused. I think that's right, and we should remove them and also `ec2Bucket`, by generating the key and token and then passing them into the bucket's constructor.
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
Sure, I was referring to future coding errors that will be revealed only during runtime. The current use is fine. I'm fine with NPE.
I'm not sure we want `match` to be `contains` in some cases. If we want this we should make a new construct.
+1 from my side as well
+1 looks redundant to me
this means the mutable ShardRouting will have their hashes re-calculated every time . Can you double check the impact this have on a huge routing nodes and the balancer (your favorite code :)).
is this somewhere on a todo? I'm afraid we'll loose it
These non-immutable classes :(
Not sure about this -- why not add two generics to the store, one for "wrapped" and one for "root" and keep this method that return the root type? I would also rename `inner()` -> `root()`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
+1 lets get rid of it! If we don't use it there is no need for the complexity!
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
`/`, `:`, `\`, `|`, `<`, `>`, `"`, `?` and `*` are already always stripped.
You have some unmerged lines here
Ah nevermind, I see where we use it :-/
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
I think you use it indirectly through `parser. isBooleanValueLenient`.
I don't believe this is only kept for BWC. You use this to parse `_source` above.
I think it is more idiomatic to statically import the `instanceOf`.
If you want to test the multi-write behavior you could make a testing aggregation here that needs to be rewritten twice. I'm not sure how important that is to you, but it ought to be possible.
I think we can check also randomly on a shard that relocates _to_ the local node
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
same 1+ randomInt
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
Same here - more randomization would be nice
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I think it is more idiomatic to statically import the `instanceOf`.
If you want to test the multi-write behavior you could make a testing aggregation here that needs to be rewritten twice. I'm not sure how important that is to you, but it ought to be possible.
I think we can check also randomly on a shard that relocates _to_ the local node
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
same 1+ randomInt
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
Same here - more randomization would be nice
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
similarly, equals uses the hash while hashCode doesn't
It feels wrong that hashCode is using writtenBy while equals isn't
no worries as soon as you rebase you won't need to take care of boost and _name, it's done automatically.
you can use the util method printBoostAndQueryName here now (once you rebased)
we need a consolidation of all the score mode / type we have at some point, not here though
I was having the same question in another query I was looking at. I think we made sure in constructors that the two builders are never null, but I was also wondering if if doesn't hurt having extra checks, in case e.g. some later change makes it possible to sneak in null query builders somehow. On the other hand, test should cover this. Sorry, undecided here, that's just what I had in mind in similar situation.
I think filter and query can never be null here? not sure whether we should validate this here.
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
nit: could use Utils.mkSet
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
We prefer adding the `set` prefix. ```suggestion public void setContents(Object contents) { ``` Also in this particular case I think we should also make a semantic change and type `contents` with `String`. This does mean that groovy will resolve GStrings sooner, but looking at the uses of this task that is ok and I would prefer the stronger typing, it's one of the reasons we convert in the first place. We can always _lather_ add a version that takes `Supplier<String>` if we need it to be more dynamic.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
```suggestion public void setFile(File file) { this.file = file; } public void setFile(String file) { this.file = getProject().file(file); } ``` Along the same lines as above to avoid the use of Object.
I would prefer we use something like `Files.write` where we can be specific about the encoding. `FileWriter` will rely on the default encoding, something we generally try to avoid.
This check is not necessary, Gradle doesn't allow for it unless the task is marked `@Optional`
Note that this is different than setting a single property as it adds the inputs to the list.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
We should use a try-with-resources syntax with this.
I think using `nextLine` might be easier to read, and since we need all the lines in memory to perform the de-duplication anyhow, I would consider doing it in one step. Using java streams and a set as the Groovy implementation did to take care of the de-duplication would make this concise and easy to understand: ``` files.getFiles().stream() .flatMap(Files.readLines(null, StandardCharsets.UTF_8).stream()) .collect(Collectors.toSet()) .forEach( line -> { // write each line to target }) ``` You will probably have to collect to a different set implementation to preserve order but this is the general idea. Writing a test will make that obvious.
This _nearly_ feels worthy of abstraction over the various sets of credentials, and I think that'll definitely be worth doing when the ECS-style credentials are added. Optional now, but worth thinking about.
Just wanted to say I really like the way this unit test is written! With the right usage of mocks we would avoid having any time-dependent flakiness.
Yes, end users would only ever read this object, hence the lack of a friendly `Builder`. I think it's OK to leave as-is.
I don't think we should have this constructor on the client side, as there's no way to sensibly add the missing values (and no sensible reason why the user would need to).
Should be `this.detectors = Collections.unmodifiableList(detectors)`. (This is probably a bug in X-Pack core too.)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
nit: The mention of join group comes out of nowhere
nit: remove `which is`
Also add `@params topics`
Fails checkstyle, needs to be final
nit: maybe drop "serializable"? Reads a little redundant.
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
and -> a
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
I was going to ask why we're using the `test` prefix for a benchmark, but then I realized that many of the kafka benchmarks do that and I somehow didn't notice. :) Given that, it seems fine to leave it like this for now.
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
Nice, thanks for the update. Looks good
recommended; ditto below.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
missing t at the end of the method name
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We should mention somewhere that users should prefer this new assignor for newer clusters.
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We should mention somewhere that users should prefer this new assignor for newer clusters.
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We should mention somewhere that users should prefer this new assignor for newer clusters.
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
same for tests below as well
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
nit: could use Utils.mkSet
I'm thinking whether it makes more sense to let `MockProcessor` encapsulate a delegate `MockApiProcessor` so that we could also use existing tests to verify the correctness of the migration.
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
> The JVM chooses the heap size ergonomically when the heap size is not specified. Do we have the ability to see what it would choose? If running on a small machine, for instance, we'd still want to disable Netty's pooled allocator if the JVM is going to automatically choose a 400mb heap
Would it be possible to return what the default JVM heap is here instead of null? Seems like we still may want to make changes to JVM options for an unset heap. Either that, or since we explicitly set it in our `jvm.options`, emit a warning or error that no heap has been specified (someone must have removed the option)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
> The JVM chooses the heap size ergonomically when the heap size is not specified. Do we have the ability to see what it would choose? If running on a small machine, for instance, we'd still want to disable Netty's pooled allocator if the JVM is going to automatically choose a 400mb heap
Would it be possible to return what the default JVM heap is here instead of null? Seems like we still may want to make changes to JVM options for an unset heap. Either that, or since we explicitly set it in our `jvm.options`, emit a warning or error that no heap has been specified (someone must have removed the option)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
We should mention somewhere that users should prefer this new assignor for newer clusters.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
"this until it is" doesn't quite parse.
Even if you are in 2.4+, if you want to switch from EAGER to a different COOPERATIVE assignor that new assignor still need to support both in order for a simple rolling bounce path. I think it worth mentioning this as well (maybe better in web docs than here in java docs, just wanted to bring this up).
Better be `cooperative-sticky`? `cooperative` is too general I think.
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Maybe we could name the context (and the class) something more descriptive for it's purpose? While the rest api is for executing a script, I think this context is a generic test context? Perhaps it could be "painless_test" (and PainlessTestScript) or something like that? I like having "test" in there because it is clear this is not for production uses, but to test painless code. It would also be more clear for when we do support other contexts in the execute api.
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
You are throwing away the stack trace here. Just have this method throw Exception, and the tests that call it as well.
The factory is what holds onto the params, so that they can be passed to the constructor. Think of the factory as the signature for the constructor. It's not boilerplate; it is actually needed based on current uses of scripts throughout the system. Also note that the factory signature is what allows the script instance to have arbitrary objects passed in. If `ScriptService.compile` were to return an instance directly, instead of a factory, we would need some way to pass in this information in a generic way, which would probably mean duck typing through a String->Object map and then require casts. With the factory, we get static type checking of the arguments a script needs to be constructed.
I think you can use `RestClient.SyncResponseListener` here instead
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Maybe we could name the context (and the class) something more descriptive for it's purpose? While the rest api is for executing a script, I think this context is a generic test context? Perhaps it could be "painless_test" (and PainlessTestScript) or something like that? I like having "test" in there because it is clear this is not for production uses, but to test painless code. It would also be more clear for when we do support other contexts in the execute api.
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
You are throwing away the stack trace here. Just have this method throw Exception, and the tests that call it as well.
The factory is what holds onto the params, so that they can be passed to the constructor. Think of the factory as the signature for the constructor. It's not boilerplate; it is actually needed based on current uses of scripts throughout the system. Also note that the factory signature is what allows the script instance to have arbitrary objects passed in. If `ScriptService.compile` were to return an instance directly, instead of a factory, we would need some way to pass in this information in a generic way, which would probably mean duck typing through a String->Object map and then require casts. With the factory, we get static type checking of the arguments a script needs to be constructed.
I think you can use `RestClient.SyncResponseListener` here instead
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Maybe we could name the context (and the class) something more descriptive for it's purpose? While the rest api is for executing a script, I think this context is a generic test context? Perhaps it could be "painless_test" (and PainlessTestScript) or something like that? I like having "test" in there because it is clear this is not for production uses, but to test painless code. It would also be more clear for when we do support other contexts in the execute api.
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
You are throwing away the stack trace here. Just have this method throw Exception, and the tests that call it as well.
The factory is what holds onto the params, so that they can be passed to the constructor. Think of the factory as the signature for the constructor. It's not boilerplate; it is actually needed based on current uses of scripts throughout the system. Also note that the factory signature is what allows the script instance to have arbitrary objects passed in. If `ScriptService.compile` were to return an instance directly, instead of a factory, we would need some way to pass in this information in a generic way, which would probably mean duck typing through a String->Object map and then require casts. With the factory, we get static type checking of the arguments a script needs to be constructed.
I think you can use `RestClient.SyncResponseListener` here instead
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Maybe we could name the context (and the class) something more descriptive for it's purpose? While the rest api is for executing a script, I think this context is a generic test context? Perhaps it could be "painless_test" (and PainlessTestScript) or something like that? I like having "test" in there because it is clear this is not for production uses, but to test painless code. It would also be more clear for when we do support other contexts in the execute api.
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
You are throwing away the stack trace here. Just have this method throw Exception, and the tests that call it as well.
The factory is what holds onto the params, so that they can be passed to the constructor. Think of the factory as the signature for the constructor. It's not boilerplate; it is actually needed based on current uses of scripts throughout the system. Also note that the factory signature is what allows the script instance to have arbitrary objects passed in. If `ScriptService.compile` were to return an instance directly, instead of a factory, we would need some way to pass in this information in a generic way, which would probably mean duck typing through a String->Object map and then require casts. With the factory, we get static type checking of the arguments a script needs to be constructed.
I think you can use `RestClient.SyncResponseListener` here instead
nit: one too many line break? :)
Please fix identation.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
nit: could use Utils.mkSet
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should be done in reset()
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
True there's nothing concrete. Google Java Style Guide mentions a logical order but nothing specific. There are some old Sun conventions: http://www.oracle.com/technetwork/java/codeconventions-141855.html and then, if you look at Intelij's rules, under Code Style -> Java -> Arrangement you get a feel of some other conventions. But beyond guidelines and given the absence of clear consensus my point is that, besides static initializer blocks, I'd expect member fields, constructors, methods in that rough order.
nit: Seems that this is not the right place for this method. It's now between static and non-static field members. It's used in the constructor, but still, it should probably be placed lower in the class.
Do we want a `ConnectException` here instead? Not sure.
Sure, I was referring to future coding errors that will be revealed only during runtime. The current use is fine. I'm fine with NPE.
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
Oh, I just noticed. Then `synchronized` is not needed anymore.
It was removed from the other versions of `group` but not from here.
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
bit-nitpick :) ``` // modulo 2 operation if ((keyValue.length & 1) != 0) ``` most definitely optimized out by JIT because the divisor is known (`2`). Is it too hard to read? Sometimes it's good to train ppl who read the code by example. Can't be more nitpicking than that and if you want to keep uniformity with other versions of `getTags` elsewhere never mind. Not 100% sure either, leaving here to ask what you think in general for such optimizations that are JIT optimizable too.
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
I know the naming thing has bit us in the past, is this same approach used elsewhere and/or how was it decided on? Specifically, metric name constraints really shouldn't be JMX specific if that is the case here, despite the fact that the metrics is so obviously JMX-inspired. I can easily find https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/metrics/KafkaMetricsGroup.scala#L46 but nothing else. Have we not had the same problems because metrics w/ topic names in them already have constraints on the naming? If I am remembering correctly, I think maybe both @gwenshap and @junrao were involved in some discussions, I think `-` vs `_` was a problem at some point? Maybe one of them could chime in here.
to me it seems like we can't possibly know what the constraints of all reporters would be and they don't provide an interface for validation, so it should be up to them to figure out how to substitute. but i've also asked some other folks to maybe chime in here who may have better context on how we've handled this elsewhere.
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Oh, I just noticed. Then `synchronized` is not needed anymore.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
super nit: I tend to like validation to be first
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
bit-nitpick :) ``` // modulo 2 operation if ((keyValue.length & 1) != 0) ``` most definitely optimized out by JIT because the divisor is known (`2`). Is it too hard to read? Sometimes it's good to train ppl who read the code by example. Can't be more nitpicking than that and if you want to keep uniformity with other versions of `getTags` elsewhere never mind. Not 100% sure either, leaving here to ask what you think in general for such optimizations that are JIT optimizable too.
I know the naming thing has bit us in the past, is this same approach used elsewhere and/or how was it decided on? Specifically, metric name constraints really shouldn't be JMX specific if that is the case here, despite the fact that the metrics is so obviously JMX-inspired. I can easily find https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/metrics/KafkaMetricsGroup.scala#L46 but nothing else. Have we not had the same problems because metrics w/ topic names in them already have constraints on the naming? If I am remembering correctly, I think maybe both @gwenshap and @junrao were involved in some discussions, I think `-` vs `_` was a problem at some point? Maybe one of them could chime in here.
to me it seems like we can't possibly know what the constraints of all reporters would be and they don't provide an interface for validation, so it should be up to them to figure out how to substitute. but i've also asked some other folks to maybe chime in here who may have better context on how we've handled this elsewhere.
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
Do we need the if/else? Since this is a unit test, it seems OK to just assert that the first element is the rate and the second is the total.
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
Nit: the methods of the `ConnectorStatusListener` and `TaskStatusListener` classes are in very different orders. It would help readability to have them in the same order. IMO, the order of the `TaskStatusListener` methods is nice because it follows the lifecycle.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Oh, I just noticed. Then `synchronized` is not needed anymore.
It was removed from the other versions of `group` but not from here.
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Oh, I just noticed. Then `synchronized` is not needed anymore.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
bit-nitpick :) ``` // modulo 2 operation if ((keyValue.length & 1) != 0) ``` most definitely optimized out by JIT because the divisor is known (`2`). Is it too hard to read? Sometimes it's good to train ppl who read the code by example. Can't be more nitpicking than that and if you want to keep uniformity with other versions of `getTags` elsewhere never mind. Not 100% sure either, leaving here to ask what you think in general for such optimizations that are JIT optimizable too.
super nit: I tend to like validation to be first
I know the naming thing has bit us in the past, is this same approach used elsewhere and/or how was it decided on? Specifically, metric name constraints really shouldn't be JMX specific if that is the case here, despite the fact that the metrics is so obviously JMX-inspired. I can easily find https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/metrics/KafkaMetricsGroup.scala#L46 but nothing else. Have we not had the same problems because metrics w/ topic names in them already have constraints on the naming? If I am remembering correctly, I think maybe both @gwenshap and @junrao were involved in some discussions, I think `-` vs `_` was a problem at some point? Maybe one of them could chime in here.
to me it seems like we can't possibly know what the constraints of all reporters would be and they don't provide an interface for validation, so it should be up to them to figure out how to substitute. but i've also asked some other folks to maybe chime in here who may have better context on how we've handled this elsewhere.
We did the dot to _ conversion for Yammer metric mostly because reporters like Graphite typically use dot to represent hierarchy and quite a few people are using the existing Graphite reporter that may be confused with dot. Since Kafka metric is new, we could just let individual reporter deal with this issue, instead of changing the metric name directly.
To be realistic, the second parameter should be `Collections.singleton(topic)` rather than `emptySet`.
Same here about multi-line toString methods
Here again I think we should use `builder.timeField` to handle this
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Can you make this non-pretty, it's always weird when you log things and then end up being multi-line
ditto here and others below
same for tests below as well
For human readable-ness, an additional field should be added, we shouldn't replace the field with a human readable version. You should be able to do ```java builder.timeField("modified_millis", "modified", modifiedDate); ``` (replacing the field names with the fields we want to use) and then you don't have to check the human readable flag yourself
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
We should limit this suppression to the method for which we really need it instead of the whole class
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Thanks for the clarification, makes sense.
nit: unneeded parenthesis
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
Since this query is a pure wrapper, I'm wondering if you should delegate calls to setBoost/getBoost (and then ignore the boost in equals/hashCode)
nit: remove empty line
I think we ditch the before/after methods as I previously recommended.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
nit: Starting a message with lower case feels a little unusual.
It seems like we're duplicating some of the logic contained in `Plugins` into this class by tracking class alias names and pre-computing plugin type based on them. Did you consider a `Herder` method that only accepted the name of the plugin, and took on the responsibility of deducing the plugin type itself? ```java List<ConfigKeyInfo> connectorPluginConfig(String pluginName); ``` In `AbstractHerder`, we could do something like this: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { Object plugin = Plugins.newPlugin(pluginName); PluginType pluginType = PluginType.from(plugin.class); List<ConfigKeyInfo> results = new ArrayList<>(); ConfigDef configDefs; switch (pluginType) { case SINK: case SOURCE: configDefs = ((Connector) plugin).config(); break; case CONVERTER: configDefs = ((Converter) plugin).config(); break; // ... Rest of switch statement follows same pattern, and rest of the method remains unchanged } ``` And in `Plugins` we could do this: ```java public Object newPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends Object> klass = pluginClass(delegatingLoader, classOrAlias, Object.class); return newPlugin(klass); } ``` Or alternatively, we could introduce a common interface for plugins that expose a `ConfigDef`: ```java interface DefinedConfigPlugin { ConfigDef config(); } ``` Which could really simplify some of the `AbstractHerder` logic: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { DefinedConfigPlugin plugin = Plugins.newDefinedConfigPlugin(pluginName); ConfigDef configDefs = plugin.config(); // No switch statement on plugin type necessary // ... Rest of the method remains unchanged } ``` And the change to `Plugins` would be lightweight as well: ```java public DefinedConfigPlugin newDefinedConfigPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends DefinedConfigPlugin> klass = pluginClass(delegatingLoader, classOrAlias, DefinedConfigPlugin.class); return newPlugin(klass); } ``` Worth noting that if we want to differentiate to users between "this plugin is not on the worker" and "we don't expose config information for this type of plugin", we'd have to make a few further tweaks.
Since these string literals are now relevant elsewhere, we should make them reusable constants. Perhaps they should be enums? I realize now that perhaps the class names should have also been enums but ð¤·.
You could just do `selector.poll(100)` instead of `poll(0) + sleep(100)`. `poll()` returns when an operation is ready, so we are not waiting unnecessarily.
The parameters should be the other way round (expected is `conns` and actual is the metric value).
Same as before, parameters of `assertEquals` should be the other way round.
Sorry, missed this earlier: We are creating a new `selector` in `checkAuthentiationFailed`, so we should ensure that the previous selector is closed. You could call `selector.close()` just before calling `checkAuthenticationFailed` here and also a couple of lines below.
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
Looks good. I like the additional checking that you're doing here.
same 1+ randomInt
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
Looks good. I like the additional checking that you're doing here.
I think there is a bug here. What is `\\`? I guess Windows? You need to take caution for different filesystems.
I think we should fix our datastrucuture first and don't make Path trie super complicated and flexible. This should be fixed first before we make this change here.
or maybe give the return value a variable and name it accordingly
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
do we need this logic? we know what we will send it
I see but I wonder if we should remove this method and simply accept Object and add a Fuzziness constructor that accepts Object instead
yes my reasoning is that a compile error makes you think about validation rather then forgetting because there's a default empty impl that does no validation. I tend to prefer an empty validate in all queries that don't need to validate, although that's verbose. Plus that is what we do with ActionRequest as well.
thanks, let's say I prefer to be verbose now so we don't forget. Once we are done we can remove if that makes sense :)
nit: can you break this into multiple lines so its easier to track w/ `writeTo`
can we remove an "elasticsearch_" prefix if it exists, I think it will be cleaner? down the road, we can also remove the specific ElasticsearchIllegalArgumentException and such, it was added historically to get the correct status code, but now we also identify IlleglaArgumentException and return the correct status code, so the need for those became irrelevant.
I guess we just prefer primitive types over objects :)
I don't mean to block this PR specifically, these are just things that are popping up the more I review similar PRs
after is now minimum_age
sorry I think I am mistaken here, looking deeper, I think we might need to remove execution from the builder in master instead given that we do nothing with it. Will do that.
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
check `source != null` not necessary. In doubt add an assertion.
+1 to what @mjsax said. The `source` should never be null. So you should change the `StreamThreadStateStoreProviderTest`. It just needs to have the topic name extracted to a field on line 73. And then that same topic name used on line 189 in `new TopicPartition(...)`
I'd also consider extracting: `source.getTimestampExtractor() != null ? ...` into a local as the line is quite long and it will make the code a bit easier to read.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It would be good to have some context as to where the filter appeared. I would at least word it a little differently: `"Missing [type] setting for anonymous char filter: " + charFilterName`
It looks to me like it duplicates the logic of creating a XContentBuilder in a given type and then write the filtered source as map. Could it be something like this? ``` ... Object value = source.filter(fetchSourceContext); try { if (nestedHit) { value = getNestedSource((Map<String, Object>) value, hitContext); } final int initialCapacity = Math.min(1024, source.internalSourceRef().length()); // deal with null here try (BytesStreamOutput streamOutput = new BytesStreamOutput(initialCapacity)) { XContentBuilder builder = new XContentBuilder(source.sourceContentType().xContent(), streamOutput); builder.value(value); hitContext.hit().sourceRef(builder.bytes()); } ... ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Change "param required" to "parameters are required"
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Nit: the methods of the `ConnectorStatusListener` and `TaskStatusListener` classes are in very different orders. It would help readability to have them in the same order. IMO, the order of the `TaskStatusListener` methods is nice because it follows the lifecycle.
oh seems like you also removed some ParseFieldMatcher usages, nice :)
It is in.
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
ditto here and others below
deprecated names match too. match should always return true, or rather throw an exception in strict mode if you use a deprecated name. I think it should be an assert. We had the same discussion with Colin in IndicesQueriesRegistry I think :)
the fact that the parse field matcher matches is a requirement, I think it should be an assert instead. It's really a our bug if it doesn't and we should catch it differently compared to "no function found"
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It looks ok to me
i.e., add `fail` after this line
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
rewrite test as above using `assertThrows()`.
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
I think it's always a single node cluster, but I'm good to keep it like this.
aws_ip_ranges -> aws_service_ip_ranges
same 1+ randomInt
good catch! that means we are not properly testing this case either given that we didn't catch it.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
I think we can check also randomly on a shard that relocates _to_ the local node
I mean random number of replicas with random combination of non-active states
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
Same here - more randomization would be nice
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
Sure, good plan.
I think we cannot (yet) do this with auth tokens received externally because they need to be passed to the test suite as well as this fixture, so we've had to settle on just using the same (long) string in both places. It would indeed be nicer if there were no magic strings in the fixture at all. For deterministic testing, maybe you can pass a seed in from Gradle somehow? Or just hard-code them, it's not that important. I'd rather they weren't synthesised as they are now.
On deeper thought, this seems unduly lenient: it should only return credentials for the role that `GET /latest/meta-data/iam/security-credentials/` returned, and should return 404 otherwise. Also I think `credentialResponseFunction` can be inlined, it's only used in one place. Also also we could prevent cheating slightly more by inventing random credentials when the service starts up, rather than synthesising them from the role name.
I presume, by the way, that passing `null` for the region here is ok. I haven't tried it.
... and this doesn't need to know it either.
Nit: this could just be `logger.debug("using endpoint [{}]", endpoint);`.
Would it help to actually list the method that was used, in case somebody thought they were using basic? ```suggestion log.trace("Request credentials used {} authentication, but only {} supported; ignoring", BASIC, method); ```
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
Isn't it true that most of the time this method will get only supported `Callback` implementations? In those cases, we'll never need the `unsupportedCallbacks`. I originally thought it might be worth making this more efficient, but I don't think it's worth it since the default constructor for `ArrayList` is pretty efficient in recent JVMs (with lazy allocation of the underlying array when the first element is added to the list).
a misspell? SQLFuncMixn -> SQLFuncMixin
Use the `msg = ` format to avoid awkward indentation.
We like to include trailing comma on the last item in a dict so if more items are added later, we don't have to modify this line again.
Since we are adding `fenced` to the RegisterBrokerRecord, do we also need to add a `fenced` field to the BrokerRegistrationRequest RPC? Or is it the case that only the controller will set the fenced state of this record
Nit: space between the cast operator and the target.
Ah, okay. Then I'm good with it as-is; we can consider redirects separately (if ever).
The assert message should be `https` not `http`!
I remember some of the metrics were lazily registered, i.e. they would only be registered if the corresponding action is called for the first time. Have we refactored it to always register all metrics up starting the task / process-node etc? Otherwise waiting for the stream state to transit to RUNNING may not guarantee all metrics should be already registered.
Thanks for double checking this! Then it lgtm.
Not sure it makes a difference but before it looks like we got `form=None` in the context.
ditto here and others below
same for tests below as well
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
I wonder how long this would work ;)
Ah, okay. Then I'm good with it as-is; we can consider redirects separately (if ever).
Nit: space between the cast operator and the target.
I think this could be done with `computeIfAbsent` like in "finishSnapshot" above
nit: I guess you could use `computeIfAbsent` here as well
Could you please add some line breaks? This and some of the other verifications are too long.
Hmm, that's annoying.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
Do we need quotaType? It seems that it's unrelated to metric tags.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
```suggestion * <p>A {@code retryBackoffMs} that is negative or zero will result in no delays between retries. ```
nit: maybe drop "serializable"? Reads a little redundant.
nit: The mention of join group comes out of nowhere
Also add `@params topics`
The KIP has the following method and is missing in the PR. `void updateRemotePartitionDeleteMetadata(RemotePartitionDeleteMetadata remotePartitionDeleteMetadata)`
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
this `readStringProperty`? it is not parsing script code, it is an ingest-node config reader
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
Hmm. I feel the `final` would be worth capitalizing the var name.
I think we can.
While you are there, can we fix this one? it is " Running at : " + miniKdc.getHost() + ":" + - miniKdc.getPort()
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
The KIP has the following method and is missing in the PR. `void updateRemotePartitionDeleteMetadata(RemotePartitionDeleteMetadata remotePartitionDeleteMetadata)`
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: probably checkstyle won't catch this, but if you format the block, there's an extra tab that you can remove here too.
same for tests below as well
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I think using `nextLine` might be easier to read, and since we need all the lines in memory to perform the de-duplication anyhow, I would consider doing it in one step. Using java streams and a set as the Groovy implementation did to take care of the de-duplication would make this concise and easy to understand: ``` files.getFiles().stream() .flatMap(Files.readLines(null, StandardCharsets.UTF_8).stream()) .collect(Collectors.toSet()) .forEach( line -> { // write each line to target }) ``` You will probably have to collect to a different set implementation to preserve order but this is the general idea. Writing a test will make that obvious.
none from what I can see, but I'm not sure it's worth holding up the PR for it.
Just out of curiosity, how does this differ from the following? ``` assertTrue(streams.close(10, TimeUnit.SECONDS)); ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
and -> a
base -> based progress -> progressed
and -> a
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Thanks for the explanation. Make sense.
I have a similar concern here for when entry.getValue is not a Map
thinking if those `synchronized` code blocks are needed, if you always check for `null` first, as context is never set to `null` again...
@spinscale I think it is needed if it is expected that another thread might be updating the context at the same time (ie. synchronization is protecting the hash map copy rather than the null check)
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
base -> based progress -> progressed
and -> a
and -> a
same for tests below as well
Perhaps say that the repartitioning will happen automatically, i.e., user doesn't need to do anything.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You have some unmerged lines here
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
These tests will now, right? Because of the empty on_failure processors? I think we should expect an exception here instead.
nit: extra newline
I feel like `pattern bank` is an internal naming convention, and externally we just call it `patterns`. not sure it matters here though, since one can only assume we are talking about the same thing.
nice! I like this. super helpful for keeping track
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: `null` -> {@code null}`
Nit `.` at the end
nit: both lines missing . at end
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You have some unmerged lines here
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You have some unmerged lines here
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
```dict_get``` makes codes even shorter
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Use ```extract_attributes``` instead. The order of video_id, account_id, ... may change.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
```dict_get``` makes codes even shorter
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Use ```extract_attributes``` instead. The order of video_id, account_id, ... may change.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: add `final`
Why not just use System.getProperty("tests.seed") ? is this an intellij auto-complete thing? I see this anti-pattern quite often and i wonder why its done.
ReflectiveOperationException can be used instead of both of these
can we just change this to System.getProperty("tests.seed") != null? Then that method can be removed.
I think we can get rid of the ResolvedHostname abstraction - what am I missing? ``` diff --git a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java index 61bf1cc..3d3495e 100644 --- a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java @@ -242,40 +242,36 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]"); } // create tasks to submit to the executor service; we will wait up to resolveTimeout for these tasks to complete - final List<Callable<ResolvedHostname>> callables = + final List<Callable<TransportAddress[]>> callables = hosts.stream().map(hn -> lookup(hn, transportService, limitPortCounts)).collect(Collectors.toList()); - final List<Future<ResolvedHostname>> futures = + final List<Future<TransportAddress[]>> futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS); final List<DiscoveryNode> discoveryNodes = new ArrayList<>(); // ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the // hostname with the corresponding task by iterating together final Iterator<String> it = hosts.iterator(); - for (final Future<ResolvedHostname> future : futures) { + for (final Future<TransportAddress[]> future : futures) { final String hostname = it.next(); - if (!future.isCancelled()) { + if (future.isCancelled()) { + logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); + } else { + assert future.isDone(); // guaranteed by the invokeAll try { - final ResolvedHostname resolvedHostname = future.get(); - if (resolvedHostname.isSuccess()) { - logger.trace("resolved host [{}] to {}", hostname, resolvedHostname.addresses()); - for (final TransportAddress address : resolvedHostname.addresses()) { - discoveryNodes.add( - new DiscoveryNode( - idGenerator.get(), - address, - emptyMap(), - emptySet(), - Version.CURRENT.minimumCompatibilityVersion())); - } - } else { - final String message = "failed to resolve host [" + hostname + "]"; - logger.warn(message, resolvedHostname.failure()); + final TransportAddress[] addresses = future.get(); + logger.trace("resolved host [{}] to {}", hostname, addresses); + for (final TransportAddress address : addresses) { + discoveryNodes.add( + new DiscoveryNode( + idGenerator.get(), + address, + emptyMap(), + emptySet(), + Version.CURRENT.minimumCompatibilityVersion())); } } catch (final ExecutionException e) { final String message = "failed to resolve host [" + hostname + "]"; logger.warn(message, e); } - } else { - logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); } } return discoveryNodes; @@ -289,17 +285,11 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { * @param limitPortCounts the port count limit * @return a callable that can be used to submit to an executor service */ - private static Callable<ResolvedHostname> lookup( + private static Callable<TransportAddress[]> lookup( final String host, final TransportService transportService, final int limitPortCounts) { - return () -> { - try { - return ResolvedHostname.success(transportService.addressesFromString(host, limitPortCounts)); - } catch (final UnknownHostException e) { - return ResolvedHostname.failure(e); - } - }; + return () -> transportService.addressesFromString(host, limitPortCounts); } @Override ```
isn't enough to have another waitForEvents to make sure that the previous event was successfully published? I really think we shouldn't have this time based solution. 10s makes me shudder :)
I wonder whether we should use `unicastConnectExecutor` for this and keep it contained (and throttled).
Actually plugins can implement `Closeable` and they will be closed when the node shuts down.
You might want to have a superclass here just so common stuff is obvious like `source` and (sometimes) `read`.
That used to be like one character in the antlr syntax....
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
could we make this test somehow operations based rather than time based. The Problem with time-based tests is that you have a very very hard time to get anywhere near reproducability. I know this is multithreaded anyways so it won't really reproduces but we can nicely randomize the num ops per thread which make it a bit nicer :)
you should use the `awaitBusy` method here which doesn't have a fixed sleep but increase the sleep interval in quadratic steps...
what about `assertEquals("consumer record size is not zero", 0, records.count());`? It can also be applied in a few other places
I think assertThat(throwables.get(0).getMessage(), containsString(...)) might be a bit better, especially if we don't specify an error message ourselves. Same for assertThat(throwables.get(0), instanceOf(...)).
nit: extra newline
maybe we could randomize the names of the 2 settings we have in this test
10000000L seems arbitrary, maybe `Long.MAX_VALUE` would better reflect what you are trying to achieve here? Or maybe we can make `-1` to work as `unlimited` or check for `unlimited` string constant.
maybe 7 indices with 50 docs is a bit too much (= slow test), let's reduce randomness to 3 indices, each max 2 shards, and 10 docs.
`ConsumerRecords` -> `ConsumerRecords<byte[], byte[]>`
I think this check does not add much (I would skip it)
could we make this test somehow operations based rather than time based. The Problem with time-based tests is that you have a very very hard time to get anywhere near reproducability. I know this is multithreaded anyways so it won't really reproduces but we can nicely randomize the num ops per thread which make it a bit nicer :)
you should use the `awaitBusy` method here which doesn't have a fixed sleep but increase the sleep interval in quadratic steps...
what about `assertEquals("consumer record size is not zero", 0, records.count());`? It can also be applied in a few other places
I think assertThat(throwables.get(0).getMessage(), containsString(...)) might be a bit better, especially if we don't specify an error message ourselves. Same for assertThat(throwables.get(0), instanceOf(...)).
nit: extra newline
maybe we could randomize the names of the 2 settings we have in this test
10000000L seems arbitrary, maybe `Long.MAX_VALUE` would better reflect what you are trying to achieve here? Or maybe we can make `-1` to work as `unlimited` or check for `unlimited` string constant.
maybe 7 indices with 50 docs is a bit too much (= slow test), let's reduce randomness to 3 indices, each max 2 shards, and 10 docs.
`ConsumerRecords` -> `ConsumerRecords<byte[], byte[]>`
I think this check does not add much (I would skip it)
It looks ok to me
Nit: why not use `boolean`
ah I see it has problems with `null` got it
same for tests below as well
don't drink and code ð» (same line twice)
How are dependencies for test plugins handled here? If someone wants to expand these tests to include a test plugin that requires some library that isn't available in the classpath for compilation during these tests, what (if anything) would they have to change in order to make things work? It seems unlikely enough that this would be needed any time soon so proactively making changes to support that seems unwarranted, but it'd probably be useful to at least note that the test plugins here are a little fragile if there's any current limitation on what dependencies they can rely on.
Nit: I personally dislike being shouted at by exception messages ```suggestion throw new IOException("Could not delete old class file"); ```
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
Since these string literals are now relevant elsewhere, we should make them reusable constants. Perhaps they should be enums? I realize now that perhaps the class names should have also been enums but ð¤·.
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
this logic belongs in transportWriteAction
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
just do sth like: ``` if image.get('publisher'): new_result['image'] = { 'publisher': image['publisher'], 'sku': image['sku'], 'offer': image['offer'], 'version': image['version'] } else: new_result['image'] = { 'id': image.get('id') } ```
if i am correct, that image reference may contain 'id' instead of sku/publisher/version/offer
Ahh okay, that makes sense, I missed that
This seems weird since `retries` is an iterator for TimeValue, what is this going to print? the log message makes it seem like it's expecting a plain number for the number of retries
nit: could use Utils.mkSet
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
Could we replace this with something like the following? ``` assertEquals(topics, requestWithNames.data().topics().map(DeleteTopicState::name).collect(toList)); ``` It is a bit easier to read and `assertEquals` gives the differences between all the expected and the existing topics when it fails.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
typo: byteArrray -> byteArray
redundant type arguments `<ProducerRecord<byte[], byte[]`
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
typo: byteArrray -> byteArray
redundant type arguments `<ProducerRecord<byte[], byte[]`
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
typo: byteArrray -> byteArray
redundant type arguments `<ProducerRecord<byte[], byte[]`
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
redundant type arguments `<ProducerRecord<byte[], byte[]`
typo: byteArrray -> byteArray
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
`< Callback >` this explicit type is not necessary.
redundant type arguments `<ProducerRecord<byte[], byte[]`
`asList` -> `Collections.singletonList`
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
Nit: you can remove `value =`
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
typo: byteArrray -> byteArray
`asList` -> `Collections.singletonList`
redundant type arguments `<ProducerRecord<byte[], byte[]`
All these methods can have package protected visibility.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
`< Callback >` this explicit type is not necessary.
`<byte[]>` this explicit type is unnecessary
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
```suggestion (Support from Virtual machine hardware version 14, Guest OS Windows 10 64 bit, Windows Server 2016). version_added: 2.8' ```
This should be in the "assigned in `configure`" section of fields.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
This class is surprisingly similar to org.apache.zookeeper.Login, have we copied from the same source? ;-)
Nit: I think this import is unused now.
Checked with Jun and this is fine.
Good point, but it could be clearer. This implementation can be used in production, but the `PropertyFileLoginModule` that also ships with this reference implementation should NOT be used in production.
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
There's now a `Utils.mkProperties` method you can use (in conjunction with `mkMap`) to set these at the declaration site instead of setting them (redundantly) before every test. Then you won't need the `@Before` at all.
This cleanup seems a bit awkward. It assumes that tests will initialize the driver but not close it, which seems like a strange abdication of responsibility. I think it would be cleaner and clearer to get rid of the driver field entirely. Tests that need the driver already initialize it; they can declare it as a local variable as well. Then, they clearly need to close it as well. Since `TopologyTestDriver` is `AutoCloseable`, one option is to declare the driver in try-with-resources style: ```java @Test public void myTest() { try (final TopologyTestDriver driver) { // the test code } } ```
I don't think we need these prevTasks and standbyTasks for this test. You can just pass `Collections.emptySet()` to the `Subscription`
As mentioned in the KIP discussion thread: it seem unnecessary complex for user, to specify all those value. The only parameter that is mandatory is the window size. If people call `KGroupedStream#windowBy` all other parameters also optional; they should be optional when reading a topic, too.
The iterator should return exactly one record. This, we should add an `Assert.assertFalse(it.hasNext());` after the `if`
this will annoy the forbidden API after rebase + squash. Heads up
kk. was referring to both the maps and the lists later onâ¦ > On 28 Aug 2015, at 20:40, Jason Tedor notifications@github.com wrote: > > In core/src/main/java/org/elasticsearch/action/admin/indices/recovery/TransportRecoveryAction.java: > > > - for (int i = 0; i < shardsResponses.length(); i++) { > > - Object shardResponse = shardsResponses.get(i); > > - if (shardResponse == null) { > > - // simply ignore non active shards > > - } else if (shardResponse instanceof BroadcastShardOperationFailedException) { > > - failedShards++; > > - if (shardFailures == null) { > > - shardFailures = new ArrayList<>(); > > - @Override > > - protected RecoveryResponse newResponse(RecoveryRequest request, int totalShards, int successfulShards, int failedShards, List<RecoveryState> responses, List<ShardOperationFailedException> shardFailures) { > > - Map<String, List<RecoveryState>> shardResponses = Maps.newHashMap(); > > @bleskes Are you referring to Maps? That hasn't been forbidden yet (but it will be soon). > > â > Reply to this email directly or view it on GitHub.
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
Looks good. I like the additional checking that you're doing here.
```suggestion (Support from Virtual machine hardware version 14, Guest OS Windows 10 64 bit, Windows Server 2016). version_added: 2.8' ```
This should be in the "assigned in `configure`" section of fields.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
This class is surprisingly similar to org.apache.zookeeper.Login, have we copied from the same source? ;-)
Nit: I think this import is unused now.
Checked with Jun and this is fine.
Good point, but it could be clearer. This implementation can be used in production, but the `PropertyFileLoginModule` that also ships with this reference implementation should NOT be used in production.
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
base -> based progress -> progressed
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
base -> based progress -> progressed
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Yes, that may work. It just that it would be good to avoid duplicating the same code in two places.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
The variable name `shand` is non-descriptive
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Yes, that may work. It just that it would be good to avoid duplicating the same code in two places.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
we do this kind of parsing in several places maybe a util can help at some point? not sure just an idea
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
I think we should provide some context on the exception here.
one assert per member is better then you see what's not null :0
I think we cannot just pass in `null` and rely on default serde types from configs, since users are not expecting the repartition to happen here from the DSL, and they thought they have provided enough serde informations on places they "think" a repartition will happen. So observing a `ClassCastException` at a place they are not expected would be a bad experience. As of now, without serde inheritance we may have to "restrict" the optimization, to only apply to cases where two or more repartition nodes are direct children of the common key-changing parent node. Moving forward we can consider the options @bbejeck provided, and personally I think serde inheritance would be a good place to start.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Not saying you need to change this or anything, but just want to point out that once everyone is on cooperative this state change actually indicates the _end_ of a rebalance.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Indentation doesn't look right here.
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
The variable name `shand` is non-descriptive
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Looks like this should be Nullable
The `e` argument should be `@NonNull`.
Either I'm missing something or ``` ObservableCache<Integer> source = (ObservableCache<Integer>)new ObservableCache<Integer>(Observable.range(0, 1000), 16); ``` can just be ``` ObservableCache<Integer> source = new ObservableCache<Integer>(Observable.range(0, 1000), 16); ```
I don't know how often this class is created, but maybe it makes sense to store a reference to the logger for later use if this class is instantiated more often.
recommend sticking with T, U, V (or A, B, C for higher-kinded) type parameters
nit: {@link KafkaClientSupplier}
Thanks! Will push this shortly.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
oh boy I was hoping we would not need this sort of stuff, but I guess we do? I mean the instanceof as well as the cast to double array
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
Looks like this should be Nullable
The `e` argument should be `@NonNull`.
Either I'm missing something or ``` ObservableCache<Integer> source = (ObservableCache<Integer>)new ObservableCache<Integer>(Observable.range(0, 1000), 16); ``` can just be ``` ObservableCache<Integer> source = new ObservableCache<Integer>(Observable.range(0, 1000), 16); ```
I don't know how often this class is created, but maybe it makes sense to store a reference to the logger for later use if this class is instantiated more often.
recommend sticking with T, U, V (or A, B, C for higher-kinded) type parameters
nit: {@link KafkaClientSupplier}
Thanks! Will push this shortly.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
oh boy I was hoping we would not need this sort of stuff, but I guess we do? I mean the instanceof as well as the cast to double array
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
`use {@link #toStream()} followed by {@link KStream#to(String)} and {@link StreamsBuilder#table(String)} to read back as a {@code KTable}` ?? same below
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
if not needed +1 on removing
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
We should do this check first
same for tests below as well
Ah nevermind, I see where we use it :-/
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
I think you use it indirectly through `parser. isBooleanValueLenient`.
I don't believe this is only kept for BWC. You use this to parse `_source` above.
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
FYI when you accept the suggested changes using GitHub UI, it preserves the authorship of the patch.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
Ah, my bad. This doesn't work on fixtures.
When you don't refer to the fixture return value, it's better to inject it via `usefixtures` so that there's no unused argument in the function. Also, the name is misleading. It's being injected into the test functions and it looks like the returned object is an instance of `BaseFactCollector` while in fact, it's a dict. You could improve this as follows: ```suggestion @pytest.mark.usefixtures('fake_now') def date_facts(monkeypatch): """Return a predictable instance of collected date facts.""" ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
Tests for `formset_factory()` and `formset_factory()` are missing.
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
FYI when you accept the suggested changes using GitHub UI, it preserves the authorship of the patch.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
Ah, my bad. This doesn't work on fixtures.
When you don't refer to the fixture return value, it's better to inject it via `usefixtures` so that there's no unused argument in the function. Also, the name is misleading. It's being injected into the test functions and it looks like the returned object is an instance of `BaseFactCollector` while in fact, it's a dict. You could improve this as follows: ```suggestion @pytest.mark.usefixtures('fake_now') def date_facts(monkeypatch): """Return a predictable instance of collected date facts.""" ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
Tests for `formset_factory()` and `formset_factory()` are missing.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
Nit: can be `final`
Nit: both parameters can be `final`
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
use `try-catch` instead of `expected` annotation -- not a single line test.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Use a similar logging to what we do for robust signals? See `django.dispatch.dispatcher.Signal.send_robust` and ``` try: response = receiver(signal=self, sender=sender, **named) except Exception as err: logger.error( "Error calling %s in Signal.send_robust() (%s)", receiver.__qualname__, err, exc_info=err, ) ``` Something like ```suggestion logger.error("Error calling {func.__qualname__} on_commit() ({e}).", exc_info=True) ```
nit: There is an extra space before `+`.
using `assertThat` is nicer as it gives better failure messages. `assertThat(sourceNode.getTimestampExtractor(), instanceOf(MockTimestaampExtractor))` in other places, too
typo: kStreamhould... -> kStreamShould In fact i'd probably rename these methods to begin with should, i.e., `shouldAddTimestampExtractorToStreamWithOffsetResetPerSource` etc
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
it is preferable to have descriptive test names, i.e., `emptyIteratorAlwaysReturnsFalse` `emptyIteratorPeekNextKeyShouldThrowNoSuchElementException` etc
This line is failing checkstyle.
Should we close the task first before re-initialize it to another StreamTask? Ditto below.
Nit: you can call `Thread.enumerate` directly. Also, it would be good to assert that `threadCount` is < than `threads.length`.
could be named as `processingMode`
can you add spaces? `new KeyManager[] { km }, new TrustManager[] { tm }`
indentation is off after other changes
`msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}"` could be used here instead of `var: messages`, no need to use `set_fact`.
Not sure how the lazy loading of variables, the example would be simpler to just have the one task instead of 2 in the examples. ``` - name: Get 2 messages off a queue debug: msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}" ```
CI failure due to missing conditional when calling main: ```python if __name__ == '__main__': main() ```
It seems `AMQPConnectionError` could be used instead of `Exception`.
still: https://github.com/ansible/ansible/pull/44070#discussion_r212981844 https://github.com/ansible/ansible/pull/44070#discussion_r213508181
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
remove "completes"? It's a Single :)
I _think_ you could just pull the `PositionLengthAttribute` and if it has a value greater than 1 on any token, it is a graph.
> Ok this doesn't work because the standard synonym token filter also sets the position length attribute Arrrrgh, you are right. Here's maybe another idea: why not always treat things as if they were a graph,since a single linear chain of tokens really is just a graph. And then, when the graph enumerates to just one path, it should naturally "become" what already happens today? I.e. don't break out any special treatment for "graph" vs "not graph".
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
remove "completes"? It's a Single :)
I _think_ you could just pull the `PositionLengthAttribute` and if it has a value greater than 1 on any token, it is a graph.
> Ok this doesn't work because the standard synonym token filter also sets the position length attribute Arrrrgh, you are right. Here's maybe another idea: why not always treat things as if they were a graph,since a single linear chain of tokens really is just a graph. And then, when the graph enumerates to just one path, it should naturally "become" what already happens today? I.e. don't break out any special treatment for "graph" vs "not graph".
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
remove "completes"? It's a Single :)
I _think_ you could just pull the `PositionLengthAttribute` and if it has a value greater than 1 on any token, it is a graph.
> Ok this doesn't work because the standard synonym token filter also sets the position length attribute Arrrrgh, you are right. Here's maybe another idea: why not always treat things as if they were a graph,since a single linear chain of tokens really is just a graph. And then, when the graph enumerates to just one path, it should naturally "become" what already happens today? I.e. don't break out any special treatment for "graph" vs "not graph".
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
`UUID of the virtual machine`? needs to mention host, i guess
```suggestion - The name of content library to manage. ```
VM or VirtualMachine
```suggestion - The content library description. ```
```suggestion - content library id for which details needs to be fetched. ```
The vmware modules only support Python 2.7 because of pyvmomi.
Tests for `formset_factory()` and `formset_factory()` are missing.
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Same question here as earlier about the `Locale`
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Same question here as earlier about the `Locale`
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Same question here as earlier about the `Locale`
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
Update return type to `L` (if we introduce `L`)
nit: merge both lines: `byte[] payload = new byte[primitiveSize == null ? dis.readInt() : primitiveSize];`
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
Same question here as earlier about the `Locale`
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
createMetadataTopic() is no longer used.
It seems that we need to automatically create metadata topic in RLMM implementation, not just in tests.
`consumerProps` and `producerProps` are of type `Map`, therefore the `.toString()` is probably not readable. So you'd need to convert these into a comma-separated list sth like `K1=V1,K2=V2,...Kn=Vn`.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Same question here as earlier about the `Locale`
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
spaces around '='
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
this `readStringProperty`? it is not parsing script code, it is an ingest-node config reader
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
lower cased now...
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
It may also be useful to assert that the current consumer position is equal to `rde.offset`.
We can use `assertThrows` for this kind of pattern: ```java RecordDeserializationException rde = assertThrows(RecordDeserializationException.class, () -> consumer.poll(Duration.ZERO)); assertEquals(invalidRecordOffset, rde.offset()); assertEquals(tp0, rde.partition()); ```
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
Might be simpler to use the mock deserializer only for values.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Was just thinking about how long a. transaction might possibly be open. 1 minute SGTM
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: fix indention (we usually use 4 spaces, not 8)
nit: remove empty line
nit: add `final`
nit: add `final`
nit: add `final`
you don't have to assert on anything if an exception is expected
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: remove empty line
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
nit: fix indention (we usually use 4 spaces, not 8)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
nit: add `final`
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
and randomly append '/' at the end
ditto here and others below
s/y ou/you Also I think upfront is one word.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
Wildcard imports should be caught by checkstyle, and should fail the build. In any case, please replace with non-wildcard imports.
Any reason you change to import all classes under `java.util`? I think we should import what we used in this class only.
I know we're violating this a few places (due to the initial code import), but I think we want to avoid converting to `*` imports.
`log` not used
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
Seems we're missing the second purpose.
Since log.error(.. ex) will print the stack trace already, may be we can save re-throwing the exception again. EDIT: if we want to stop the whole process by throwing the exception, we can then save log.error().
```suggestion public HighAvailabilityTaskAssignor(final Map<ID, ClientState> clientStates, final Set<TaskId> allTasks, final Set<TaskId> statefulTasks, final AssignmentConfigs configs) { ```
You are an exemplary boy scout!
Could we add some java doc to this assign to briefly mention about the algorithm used in the assignor? Thanks.
I feel like the summary here should be a bit more descriptive. Perhaps "There are enough master-eligible instances to form a quorum."
This test checks essentially the same thing as the previous unit tests? To check more in this test, we could as well verify that indexShard has the right term (i.e. that the cluster state update was properly applied to IndexShard).
This should be paginated
do we need busy waiting here? and we should probably wait on the node to join the cluster and have no relocation pending.
I think we can check also randomly on a shard that relocates _to_ the local node
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
same 1+ randomInt
I feel like the summary here should be a bit more descriptive. Perhaps "There are enough master-eligible instances to form a quorum."
This test checks essentially the same thing as the previous unit tests? To check more in this test, we could as well verify that indexShard has the right term (i.e. that the cluster state update was properly applied to IndexShard).
This should be paginated
do we need busy waiting here? and we should probably wait on the node to join the cluster and have no relocation pending.
I think we can check also randomly on a shard that relocates _to_ the local node
Same here, we need j<= numReplicas, which also makes me wonder if we want to validate in shardCanBeDeleted that the total number of shards in the routing table is what we expect it to be (we now only check for no shards at all)
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
I mean random number of replicas with random combination of non-active states
Same here - more randomization would be nice
same 1+ randomInt
That's a good point too. But what I wanted to highlight is to be explicit and return the exact collection, that being `Collections.emptyList()` or `new ArrayList()` (the former should be fine as you noted), instead of returning what's stored in `result` (whose declaration is good to be close to the use as much as possible). That's to guard against `result` being used earlier by code in the future. Improbable, but also doesn't hurt and it's a good practice IMO.
`result` is unused in this code block. To be future proof, I'd suggest being explicit by returning an empty list here, and declare `result` right above the block that is being used at.
```suggestion return Collections.emptyList(); ```
nit: plural (`Reflections`) seems more appropriate because it refers to the library/class.
Now that we have separate `Plugins::sinkConnectors` and `Plugins::sourceConnectors` methods, we can abstract this a little, which should improve readability a bit and make it easier to extend for other plugin types in the future: ```suggestion static final List<Class<? extends SinkConnector>> SINK_CONNECTOR_EXCLUDES = Arrays.asList( VerifiableSinkConnector.class, MockSinkConnector.class ); static final List<Class<? extends SourceConnector>> SOURCE_CONNECTOR_EXCLUDES = Arrays.asList( VerifiableSourceConnector.class, MockSourceConnector.class, SchemaSourceConnector.class ); @SuppressWarnings({"unchecked", "rawtypes"}) static final List<Class<? extends Transformation<?>>> TRANSFORM_EXCLUDES = Collections.singletonList( (Class) PredicatedTransformation.class ); public ConnectorPluginsResource(Herder herder) { this.herder = herder; this.connectorPlugins = new ArrayList<>(); // TODO: improve once plugins are allowed to be added/removed during runtime. addConnectorPlugins(herder.plugins().sinkConnectors(), SINK_CONNECTOR_EXCLUDES); addConnectorPlugins(herder.plugins().sourceConnectors(), SOURCE_CONNECTOR_EXCLUDES); addConnectorPlugins(herder.plugins().transformations(), TRANSFORM_EXCLUDES); addConnectorPlugins(herder.plugins().predicates(), Collections.emptySet()); addConnectorPlugins(herder.plugins().converters(), Collections.emptySet()); addConnectorPlugins(herder.plugins().headerConverters(), Collections.emptySet()); } private <T> void addConnectorPlugins(Collection<PluginDesc<T>> plugins, Collection<Class<? extends T>> excludes) { plugins.stream() .filter(p -> !excludes.contains(p.pluginClass())) .map(ConnectorPluginInfo::new) .forEach(connectorPlugins::add); ```
It seems like we're duplicating some of the logic contained in `Plugins` into this class by tracking class alias names and pre-computing plugin type based on them. Did you consider a `Herder` method that only accepted the name of the plugin, and took on the responsibility of deducing the plugin type itself? ```java List<ConfigKeyInfo> connectorPluginConfig(String pluginName); ``` In `AbstractHerder`, we could do something like this: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { Object plugin = Plugins.newPlugin(pluginName); PluginType pluginType = PluginType.from(plugin.class); List<ConfigKeyInfo> results = new ArrayList<>(); ConfigDef configDefs; switch (pluginType) { case SINK: case SOURCE: configDefs = ((Connector) plugin).config(); break; case CONVERTER: configDefs = ((Converter) plugin).config(); break; // ... Rest of switch statement follows same pattern, and rest of the method remains unchanged } ``` And in `Plugins` we could do this: ```java public Object newPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends Object> klass = pluginClass(delegatingLoader, classOrAlias, Object.class); return newPlugin(klass); } ``` Or alternatively, we could introduce a common interface for plugins that expose a `ConfigDef`: ```java interface DefinedConfigPlugin { ConfigDef config(); } ``` Which could really simplify some of the `AbstractHerder` logic: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { DefinedConfigPlugin plugin = Plugins.newDefinedConfigPlugin(pluginName); ConfigDef configDefs = plugin.config(); // No switch statement on plugin type necessary // ... Rest of the method remains unchanged } ``` And the change to `Plugins` would be lightweight as well: ```java public DefinedConfigPlugin newDefinedConfigPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends DefinedConfigPlugin> klass = pluginClass(delegatingLoader, classOrAlias, DefinedConfigPlugin.class); return newPlugin(klass); } ``` Worth noting that if we want to differentiate to users between "this plugin is not on the worker" and "we don't expose config information for this type of plugin", we'd have to make a few further tweaks.
I think we can clean up the http/transport/gatway settings here
do not work.
Good catch, thanks for cleaning this up!
I think we can simplify this and make sure we have 1 shard, no replicas.
BTW, instead of the above to wait for the nodes to come up, could something like this be done? ``` client().admin().cluster().health(Requests.clusterHealthRequest().waitForNodes(Integer.toString(3))).actionGet(); ```
I get that, I was just wondering why those default templates bother here
could use 1. `UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey()` 2. `IndexMetaData.INDEX_NUMBER_OF_SHARDS.getKey()` 3. `IndexMetaData.INDEX_NUMBER_OF_REPLICAS.getKey()`
A simple change to the message can make this assertion fit on one line: ``` diff diff --git a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java index 5ccb541..ca172f8 100644 --- a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java +++ b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java @@ -54,8 +54,7 @@ public class CheckpointsIT extends ESIntegTestCase { IndicesStatsResponse stats = client().admin().indices().prepareStats("test").clear().get(); for (ShardStats shardStats : stats.getShards()) { if (shardStats.getSeqNoStats() == null) { - assertFalse("didn't get seq no stats for a primary " + shardStats.getShardRouting(), - shardStats.getShardRouting().primary()); + assertFalse("no seq_no stats for primary " + shardStats.getShardRouting(), shardStats.getShardRouting().primary()); continue; } logger.debug("seq_no stats for {}: {}", shardStats.getShardRouting(), ```
Do we need to prefix these with `msg.`? Also, it might be nice to control the message format when message keys and values are to be included. I know that's more code, but it could be made to be similar to the other option.
Is there any way to put this into methods on the `ProcessingContext`, like `toString(boolean includeRecord)`? That way, its `toString()` method could really just be `toString(false)`. Not only is it a bit more testable, the logic of this reporter is more readable and focused on writing to the log.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
It'd be nice to know that some more things we expect to work do - stuff like the current time, all the listed methods. Most of the the stuff you need to fake out scoring is in the IndexLookupTests so that is cool.
I think we prefer not to use underscores as part of method names, camel case is better
I think these should get taken care of by `uninstallService`? Or is the point here that we want to assert exit code 0 when uninstalling it in these tests
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Why do we need this? The public ctor is used for new types, when intializing all the metadata fields. But in that case, there is nothing shared so no need to initialize the join fieldtype (it should not be used unless/until _parent is set on the new type, in which case it will be parsed and the protected ctor will be used).
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This is a little hard to read. A vanilla `if` statement may be better: ``` if (connectorName != null) { assertTrue(context.startsWith("[" + connectorName)); } ```
@rhauch I don't believe that's the effect the code here has. In the method call: ```java assertEquals( connectorName != null, connectorName != null ? context.startsWith("[" + connectorName) : false ); ``` if `connectorName` is null, then both arguments are guaranteed to evaluate to `false`. I think your intent may have been something like this: ```java assertEquals( connectorName != null, context.startsWith("[" + connectorName) ); ``` which would probably be acceptable, but may also benefit from a `message` that clarifies the expected behavior, possible something like `"Context should begin with connector name if and only if connector is non-null"`
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
You can also do this more concisely as `topicsByName.keySet().removeAll(existingTopicNames)`.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
Do we actually have to mock `generation()` and `rawConfig()` for this test? Looking at `connector()`, it looks like it only relies on the snapshot.
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I don't think we need to mock `generation()` in this test.
same for tests below as well
Actually, ignore this, the rest actions are actually just forwarding to the transport actions
Is there similar behavior in the map parsing? I see a similar comma consume call being ignored. Consider the following test: ``` SchemaAndValue schemaAndValue = Values.parseString("{foo:bar baz:quux}"); assertEquals(Type.STRING, schemaAndValue.schema().type()); assertEquals("{foo:bar baz:quux}", schemaAndValue.value()); ```
I was not aware of the restriction on JSON object keys, and that seems like a fine standard to follow. I can't imagine it being too useful.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Why do we need this? The public ctor is used for new types, when intializing all the metadata fields. But in that case, there is nothing shared so no need to initialize the join fieldtype (it should not be used unless/until _parent is set on the new type, in which case it will be parsed and the protected ctor will be used).
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This is a little hard to read. A vanilla `if` statement may be better: ``` if (connectorName != null) { assertTrue(context.startsWith("[" + connectorName)); } ```
@rhauch I don't believe that's the effect the code here has. In the method call: ```java assertEquals( connectorName != null, connectorName != null ? context.startsWith("[" + connectorName) : false ); ``` if `connectorName` is null, then both arguments are guaranteed to evaluate to `false`. I think your intent may have been something like this: ```java assertEquals( connectorName != null, context.startsWith("[" + connectorName) ); ``` which would probably be acceptable, but may also benefit from a `message` that clarifies the expected behavior, possible something like `"Context should begin with connector name if and only if connector is non-null"`
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
You can also do this more concisely as `topicsByName.keySet().removeAll(existingTopicNames)`.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
Please remove empty line.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
```suggestion except (AttributeError, KeyError): ```
OK, I see what you're doing here :+1:, I think there is slightly better way. Just suggestions, your call. Just removing these is not perfect. Ideally, omitting say `associations` in module args would behave same as writing explicit `associations: {}`. But currently explicit `associations: {}` won't match what's left after you remove empty values from API, causing unnecessary request and changed=True. - Args side can be normalized for you if you make attributes & associations first-class options, or suboptions, defaulting to `{}`. - Note that only recently manageiq master started sending empty values; nulls were omitted before. Not sure that's relevant â do you get Nones or empty hashes here? Anyway :+1: to normalizing API results in one direction or another â don't *rely* on getting empty values. - A pattern that works & reads nicely is defining a normalizing function and applying it on both sides of comparison. `if normalize(current) == normalized(desired)`. - IMHO, splitting logic between `has_field` and here is harder to follow, and it could be simple enough to inline, perhaps something like this: ``` current_properties = dynamic_resource_definition.get('properties', {}) current_name = dynamic_resource_definition.get('name') if (current_name == name and current_properties.get('attributes', {}) == properties.get('attributes', {}) and current_properties.get('associations', {}) == properties.get('associations', {}): ```
I think this validation can be dropped too. it's only `name` which is required=True. (plus we wouldn't even reach this function without finding a definition by name)
The properties' key-value and default/required can be defined in the spec.
Since `children`, `properties` and other's are defined as module args, the key will be present in `params` and initialized to is a default value. Hence the `if` check here and above is not required. `self.children = module.params['children']` is sufficient
`PyOpenSSL>= 0.15` seems only required for `SelfSignedCertificate`, with other providers older PyOpenSSL versions should work fine: this information could be added here.
nit: one too many line break? :)
we can use ElasticsearchAssertions.assertThrows. Slightly cleaner code.
this is dangerous. I'm not sure we can rely on this. Also testing the exact amount tests generic Transport functionality. I don't think we should do it here. Just keep it simple.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same here. ElasticsearchAssertions.assertThrows wil help
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
we can use ElasticsearchAssertions.assertThrows. Slightly cleaner code.
this is dangerous. I'm not sure we can rely on this. Also testing the exact amount tests generic Transport functionality. I don't think we should do it here. Just keep it simple.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same here. ElasticsearchAssertions.assertThrows wil help
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It should be robust in case of some missing fields.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Indentation doesn't look right here.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Same suggestion here for `assertNotEquals`.
I see, ok
this may get confusing since the feature will be allowed `today`, where `today` is some time in the future that someone will read this. maybe we can reference the PR here, and use more past-tense terms like `previously`.
ditto here and others below
I think this check does not add much (I would skip it)
Can we make this 1 hour? If it times out it's nice to get thread dump
same for tests below as well
++ on adding this.
do we need a dedicated test for this? can't we randomize the number of nodes in the normal deletion tests? O.w. we will need to test this situation with both closed indices and open. It's a shame IMO
This test is highly overlapping with `testOldBrokerAbortTransaction`, could be good to refactor out a common flow.
When you use it with an instance of `PreBuiltAnalyzers`.
typo: optain -> obtain
the reason why I suggested to make it configurable is that we could pass in our own values in tests that's all... not a big deal
right, I had totally misunderstood how the test works
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
tokeinzer -> tokenizer
I don't think it's important for now
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
did you plan to add here the list of nodes or something? looks like there is a missing argument.
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
store not used
nit: add `final`
nit: add `final`
nit: add `final`
nit: add `final`
Same suggestion here for `assertNotEquals`.
I see, ok
this may get confusing since the feature will be allowed `today`, where `today` is some time in the future that someone will read this. maybe we can reference the PR here, and use more past-tense terms like `previously`.
ditto here and others below
I think this check does not add much (I would skip it)
Can we make this 1 hour? If it times out it's nice to get thread dump
same for tests below as well
++ on adding this.
do we need a dedicated test for this? can't we randomize the number of nodes in the normal deletion tests? O.w. we will need to test this situation with both closed indices and open. It's a shame IMO
This test is highly overlapping with `testOldBrokerAbortTransaction`, could be good to refactor out a common flow.
Not related to this change but we could write this: ``` java log("Installed plugins in " + environment.pluginsFile().toAbsolutePath() + ":"); if (plugins == null || plugins.length == 0) { log(" - No plugin detected"); } else { ``` It could help people to have a better understanding on plugins location. (IIRC I saw this request on the mailing list).
ditto here and others below
Nit: too many blank lines.
Could make this assertion a little stronger: ``` assertEquals(new TestElement(i, i), coll.find(elements.get(i))); ```
should this be `&&`? As it is, this loop could terminate even if we always return null and never non-null
oh sorry, I forgot this is the condition for staying in the loop. my mistake.
same for tests below as well
nit: can remove type arguments
```suggestion final StreamJoined<String, Integer, Integer> streamJoined = StreamJoined .with(Serdes.String(), Serdes.Integer(), Serdes.Integer()) .withStoreName("store") .withLoggingEnabled(Collections.emptyMap()); ```
the reason why I suggested to make it configurable is that we could pass in our own values in tests that's all... not a big deal
indicesDeleted doesn't check for indexUUIDs. We have a separate method for it in this class `cleanMismatchedIndexUUIDs` - in this spirit of bringing all deletion code together - I think it's good to make indicesDelete aware of UUID switches (mark old as deleted), move the `applyDeletedIndices` to be executed where `cleanMismatchedIndexUUIDs` is called now and then we can remove `cleanMismatchedIndexUUIDs` make all go through here.
ditto here and others below
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
indicesDeleted doesn't check for indexUUIDs. We have a separate method for it in this class `cleanMismatchedIndexUUIDs` - in this spirit of bringing all deletion code together - I think it's good to make indicesDelete aware of UUID switches (mark old as deleted), move the `applyDeletedIndices` to be executed where `cleanMismatchedIndexUUIDs` is called now and then we can remove `cleanMismatchedIndexUUIDs` make all go through here.
ditto here and others below
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
The current names are misleading, e.g. `RenderableForm` is not really a render-able form it's a mixin which makes the form render-able. I would rename these classes: - `Renderable` to `RenderableMixin`, - `RenderableForm` to `RenderableFormMixin`, - `RenderableError` to `RenderableErrorMixin`.
i.e., add `fail` after this line
Let's use `epoch` instead of `currentEpoch`. Since we are using `currentEpoch`, the `endOffsetForEpoch.offset` will equal the LEO. If you instead use `epoch` then the `endOffsetForEpoch.offset`. will be `4` which is less than the LEO (`5`).
I think these _could_ be: ``` __str__ = render __html__ = render ``` Avoiding +1 depth (and it's faster). Off the top of my head, the only reasons _not_ to would be: - `x.__str__` would report `<bound method X.render of ...>` instead of `<bound method X.__str__ of ...>` - you _could_ technically manually call `x.__str__(template_name='a')` but I mean, who's doing that? Discuss amongst yourselves whether to change it, I don't think it really matters much :)
Is there anyway of outputting the name(s) of the fields we couldn't load doc values for here? Probably useful for debugging
Thanks for cleaning up the code duplication.
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
nit: remove empty line
nit: we have assertions like this in many test cases. With a more direct api to update quorum state, we can move these assertions into that api.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
i.e., add `fail` after this line
Thanks for cleaning up the code duplication.
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: remove empty line
nit: add `final`
nit: add `final`
nit: we have assertions like this in many test cases. With a more direct api to update quorum state, we can move these assertions into that api.
nit: add `final`
nit: add `final`
nit: add `final`
nit: add `final`
nit: remove empty line
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You have some unmerged lines here
maybe also here `"foo"` -> `{@code foo}`
Space missing between `}` and `is`.
`while` seems to be missing
We didn't specify this in the KIP but I think `toStream()` and `toStream(mapper)` should also have overrides with`Named`
and -> a
and -> a
base -> based progress -> progressed
an -> a
This overload does not take `Materialized` parameter
Perhaps say that the repartitioning will happen automatically, i.e., user doesn't need to do anything.
I think it's worth looking into, but in the meantime this will already be an improvement.
Default not set in argspec.
don't use new_name. It should be from_name to maintain idempotency
As far as I can tell, the 'in_use' is never used.
TODO add Exception handling for login error
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
lib/ansible/modules/network/aos/aos_ip_pool.py:191:1: M511 - mutable default arg of type List There is only one caller of create_new_ip_pool() and it provides all three args, so subnets doesnt need to be keyword arg or optional.
should be `type='path'`
Ah, yes, I miss read the code. Nothing to change here.
Import only what you need and not `*`
I have a similar concern here for when entry.getValue is not a Map
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
ditto here and others below
same for tests below as well
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
should be `type='path'`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Ah, yes, I miss read the code. Nothing to change here.
As far as I can tell, the 'in_use' is never used.
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
should be `type='path'`
Ah, yes, I miss read the code. Nothing to change here.
As far as I can tell, the 'in_use' is never used.
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
should be `type='path'`
Ah, yes, I miss read the code. Nothing to change here.
As far as I can tell, the 'in_use' is never used.
ditto here and others below
same for tests below as well
nit: insert space `String... expected`
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
should be `type='path'`
Ah, yes, I miss read the code. Nothing to change here.
nit: one too many line break? :)
nit: we can throw illegal-state if the state() == RESTORING since it should never happen.
Oh duh, I thought this was StreamTask. In that case, why would we check for RESTORING at all? We don't check for RESTORING state anywhere else in StandbyTask AFAICT (maybe Guozhang thought this was StreamTask like I did? ð )
Why not just make `suspend` a no-op if the task is RESTORING? That seems more in line with how we handle things elsewhere
Just to clarify, I would support doing the former, ie don't check whether it's RESTORING here at all. But we should at least be consistent
Right, by "check for RESTORING" I meant "throw an exception if state is restoring". It seems odd to check for RESTORING during `suspend` but not in any other StandbyTask method. Either it can never be in RESTORING and we are completely sure of that, and shouldn't check for RESTORING, or we should always check whether it's RESTORING and not just during `suspend` (eg also in `postCommit`)
Similar here, maybe we could leverage `transitionTo` to help throw the exception.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
ditto here and others below
Could you please add some line breaks? This and some of the other verifications are too long.
nit: one too many line break? :)
nit: we can throw illegal-state if the state() == RESTORING since it should never happen.
Oh duh, I thought this was StreamTask. In that case, why would we check for RESTORING at all? We don't check for RESTORING state anywhere else in StandbyTask AFAICT (maybe Guozhang thought this was StreamTask like I did? ð )
Why not just make `suspend` a no-op if the task is RESTORING? That seems more in line with how we handle things elsewhere
Just to clarify, I would support doing the former, ie don't check whether it's RESTORING here at all. But we should at least be consistent
Right, by "check for RESTORING" I meant "throw an exception if state is restoring". It seems odd to check for RESTORING during `suspend` but not in any other StandbyTask method. Either it can never be in RESTORING and we are completely sure of that, and shouldn't check for RESTORING, or we should always check whether it's RESTORING and not just during `suspend` (eg also in `postCommit`)
Similar here, maybe we could leverage `transitionTo` to help throw the exception.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
ditto here and others below
Could you please add some line breaks? This and some of the other verifications are too long.
nit: one too many line break? :)
A metadata request has topics as the "scoped error" (one cannot request a metadata request for a given partition). So, it looks to me that we introduced a regression here. We should check if there are similar cases for other requests.
It includes the partition-level error. It seems to me it follows the docs. ` The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as more specifically scoped errors (such as topic or partition-level errors). `
Similar here, maybe we could leverage `transitionTo` to help throw the exception.
This needs to be protected by a `if (in.getVersion().onOrAfter(Version.V_1_3_0)) {`
ditto here and others below
Why is the order of these methods different than in `ConnectorStatusListener`? Also, the `TaskStatusListener` methods always forward the method to the delegate _last_, whereas the methods of the `ConnectorStatusListener` use a mixture. Let's make them consistent.
same for tests below as well
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
I would add an `assert this.context != null` here just to make sure
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
It should be robust in case of some missing fields.
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I have a similar concern here for when entry.getValue is not a Map
same for tests below as well
nit: one too many line break? :)
Typo: space after `uuid,`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I'm wondering if we should make this `info` or `warn` level. It doesn't seem like it would be very verbose, and it might be nice to see by default because it will have secondary effects later on when we try to start a new transaction, but get blocked. But I also don't feel strongly about it, so I leave it to your discretion.
Why do we need an atomic here? `close()` should be called single threaded only, right? And if I miss anything, we do we not need to use atomic to switch from "created" to "running" in `start()`.
Just realized, that the method does use `synchronized` keyword anyway... it's guarded against this already. Same for `start()`.
I just mean, why not inline that? I'm just imagining coming back to this code in a few months and wondering why we need to suspend a task before recycling, or why we call `prepareCommit` but don't then actually commit, etc
Nevermind, I see that's the pattern we follow everywhere else
Should we close the task first before re-initialize it to another StreamTask? Ditto below.
It will good to clear the requests and test when empty as well.
ditto here and others below
same for tests below as well
Unify "create task" code with `shouldThrowExceptionIfAnyExceptionsRaisedDuringCloseTopology` -- it's almost the same and both test cases can use the same topology structure.
I'm wondering if we should make this `info` or `warn` level. It doesn't seem like it would be very verbose, and it might be nice to see by default because it will have secondary effects later on when we try to start a new transaction, but get blocked. But I also don't feel strongly about it, so I leave it to your discretion.
Why do we need an atomic here? `close()` should be called single threaded only, right? And if I miss anything, we do we not need to use atomic to switch from "created" to "running" in `start()`.
Just realized, that the method does use `synchronized` keyword anyway... it's guarded against this already. Same for `start()`.
I just mean, why not inline that? I'm just imagining coming back to this code in a few months and wondering why we need to suspend a task before recycling, or why we call `prepareCommit` but don't then actually commit, etc
Nevermind, I see that's the pattern we follow everywhere else
Should we close the task first before re-initialize it to another StreamTask? Ditto below.
It will good to clear the requests and test when empty as well.
ditto here and others below
same for tests below as well
Unify "create task" code with `shouldThrowExceptionIfAnyExceptionsRaisedDuringCloseTopology` -- it's almost the same and both test cases can use the same topology structure.
Indentation doesn't look right here.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Indentation doesn't look right here.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: the more I see of this, the more I think that it's worth extending the `onDPKG` type of API to be able to produce values so reading trough the code is more consistent.
Could just use `false`
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
could use `assertFalse`
I am not sure what we have yet to decide here. What Christoph is suggesting makes sense, let's update the PR accordingly
As mentioned above, I'd opt for setting the fully constructed lookUp oject here in case it is valid.
Nit: can you put this and `runWithoutJava` next to each other
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
should we wrap the processing etc in `try{..}finally{..}` so we ensure that we do `streams.close()`? Also maybe close with a timeout? Same elsewhere
can you just leave the constant in this class? There isn't a need to put it in realm imo
++ on debug message
Should this be `debug` instead of `info`? It generates a lot of message like this during replication: ``` [2014-07-01 22:30:36,127][INFO ][index.store ] [Mimic] [test][1] create legacy output for segments_1 ```
Would `Long.toHexString(value)` work here? Not sure if it's exactly the same as the current code.
Seems like this might occur only in a programming error, which we could test for in a unit test.
Would `Integer.toHexString(value)` work here? Not sure if it's exactly the same as the current code.
Nit: use `java.nio.charset.StandardCharsets.UTF_8` here rather than `Charset.forName(...)`. The latter has to do a lookup every time.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It'd be better to not change these lines, because we don't intend to change the logic -- yet doing so adds risk and increases the size of this PR.
Like it or not, our style is to use ` == false` instead of `!`.
Oh, and _nit_ on the unnecessary brackets :)
We typically use `Locale.ROOT` rather than `ENGLISH` for case conversion.
@adityasrini Rather than doing the two String.toLowerCase(Locale.ENGLISH) which requires 2 changes, you should replace the new HashMap() with a new TreeMap(String.CASE_INSENSITIVE_ORDER).
@javanna Sorry my suggestion should have been to replace the `new HashSet()` with `new TreeSet(String.CASE_INSENSITIVE_ORDER)` at line 433 , and remove the 2x `toLowerCase(Locale.ENGLISH)` additions, obviously mentioning TreeMap was nonsense.
This was probably left by mistake.
I think we should fix our datastrucuture first and don't make Path trie super complicated and flexible. This should be fixed first before we make this change here.
or maybe give the return value a variable and name it accordingly
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
Is this step necessary given step 1 and 2? The election != Election.PREFERRED case is covered in step 1 and the other case seems covered by step 2.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Does this really need to be generic? We certainly don't care about any of that on the consumption side.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
I'm not certain this requirement is enough because if a source doesn't deliver the requested amount, it will keep the client hanging which may not request a new batch. There is also the problem if the first observable delivers less than requested, the missing amount is not replenished/considered by the second Observable and thus the client may starve. This is why `concat` uses the `SubscriptionArbiter` so that if an Observable didn't deliver enough, the next is requested for the missed amount. Similar measures might be required with this `AsyncOnSubscribe`.
guava has a `Iterables.elementsEqual()` - which works slightly different, maybe your implementation is a bit faster
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
lower cased now...
where is this method used? I can't find it
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
We don't need this field, this could be a local in `startClusters()`
and.. looking at the parsing logic this is indeed internal and we don't accept none from strings. Sorry for the noise.
@clintongormley mentioned that NONE doesn't have many external usages (we only use it for index auto creation) so we might want to drop the special naming and use `0`. I will keep the object reuse in parsing.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Sorry for that -- You are of course right. `final` only for iterator loops...
use `try-catch` instead of `expected` annotation -- not a single line test.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
We may be able to save all this hassle by defining alias group as a map of `target` to a list of `deprecated` configs? We defined this as a 2-dim array but we always convert it to lists...
Sorry for that -- You are of course right. `final` only for iterator loops...
use `try-catch` instead of `expected` annotation -- not a single line test.
This can be initialized here and be `final`
initialize the `KStream` here and make it `final`
use `try-catch` plus `fail()` for this line and remove annotation `@expected` -- right now, for example, a bug in `builder.stream` raising `NullPointerException` would not get detected. ``` try { stream.peek(null); fail("Should not allow null Action"); } catch (final NullPointerException e) { // expected } `@expected` should only be used in "single line test" for which it is clear that no exception can happen before the actual tested code.
add `final` twice
You should also compare `expectedValues`.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Sorry for that -- You are of course right. `final` only for iterator loops...
use `try-catch` instead of `expected` annotation -- not a single line test.
and.. looking at the parsing logic this is indeed internal and we don't accept none from strings. Sorry for the noise.
@clintongormley mentioned that NONE doesn't have many external usages (we only use it for index auto creation) so we might want to drop the special naming and use `0`. I will keep the object reuse in parsing.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Sorry for that -- You are of course right. `final` only for iterator loops...
use `try-catch` instead of `expected` annotation -- not a single line test.
This can be initialized here and be `final`
initialize the `KStream` here and make it `final`
use `try-catch` plus `fail()` for this line and remove annotation `@expected` -- right now, for example, a bug in `builder.stream` raising `NullPointerException` would not get detected. ``` try { stream.peek(null); fail("Should not allow null Action"); } catch (final NullPointerException e) { // expected } `@expected` should only be used in "single line test" for which it is clear that no exception can happen before the actual tested code.
You should also compare `expectedValues`.
Do we need to wrap with the LinkedHashMap? Could we just do `Collections.unmodifiableMap(metrics.metrics());`
Nice refactoring to put this code in a separate method!
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
nit: add `final` and put single parameter per line
Nit: please use single parameter per line formatting
Makes sense, we can do that later.
Probably not, and since sensor names are only used for internal bookkeeping there should be no compatibility issues with the change.
Why not organizing the thread-level sensors as cache-level sensors as well? I.e. `Map<String, Deque<String>> threadLevelSensors = new HashMap<>()` where the string key is just `threadName`, since we will only remove sensors for the whole thread at once.
Do we need to wrap with the LinkedHashMap? Could we just do `Collections.unmodifiableMap(metrics.metrics());`
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
nit: add `final` and put single parameter per line
Nit: please use single parameter per line formatting
This line is failing checkstyle. I think we need a space after the first semicolon.
Why not organizing the thread-level sensors as cache-level sensors as well? I.e. `Map<String, Deque<String>> threadLevelSensors = new HashMap<>()` where the string key is just `threadName`, since we will only remove sensors for the whole thread at once.
Makes sense, we can do that later.
Probably not, and since sensor names are only used for internal bookkeeping there should be no compatibility issues with the change.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`asList` -> `Collections.singletonList`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
Gotcha. Okay, two points: 1) It may be overkill, but you may want to consider separating the input (source, resource, etc.) files from the output (compiled class, JAR) files. It'd more closely mirror the build setup that's commonly used for Java projects and would probably make this code easier to modify in the future. 2) This bug initially surfaced with use of the `ServiceLoader` mechanism; it'd be great if we could have a test that verifies that the changes here fix how that works in isolated plugins.
I think we should do this in a `AccessController.doPrivileged` block since we need a special permission to modify threadgroup. It's good to respect that since we use this in reindex etc. as well
This exception is no longer possible since the constructor is taking `ObjectName`.
you should assign a new list instance (or clear the `abortBenchmarkNodeStatuses` list) to make sure we are not reading an instance that already has some status in the list.
Works for me. Maybe just have an interface called Cancellable - it seems CancellableTask is taken.
Thanks for pointing this out, missed that all other constructors delegate here, my mistake.
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
good catch! that means we are not properly testing this case either given that we didn't catch it.
makes sense to me as well now, sorry for the noise.
nit: one too many line break? :)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I'd suggest moving this static method after the non-static methods.
We should use try-with-resources here (for `DataInputStream`).
We should read the metadata inside the while loop since it could change.
same for here, not sure if the full Objects.equals needs to be called
I'm wondering if we need to use `Objects.equals` here which would be quite heavy-weight on the entire CockroachTasksInProgress... in this case, for example, all we care about is if there are new task entries whose executor is the local node id... in that case, maybe we can have a method on `CockroachTasksInProgress` such as `hasNewEntriesForExecutor(localNodeId)`
I think you want to use `notVisitedTasks` here instead of `runningTasks`
can you assign `event.state().nodes().masterNodeId()`
please return a Map instead no google guava stuff in public interfaces
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
It could be replaced with `if not res.get('skipped'):`
we really need something generic.... getting complex :-)
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
Builin -> Builtin (forgot a 't')
`e` is not used
Can you differentiate between the named route not being present in the rout table and other exceptions to avoid log spew in the normal situation in which the route does not exists for that route table.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
This should have the two arguments in separate strings in case the implementation that invokes the commands changes to exec commands in the future.
Yep, that's correct (the value should be double-quoted).
What happens if tmpdir consists of a path with spaces in it ? I expect Powershell to fail on this, an it should be quoted `...Directory -Path "%s" -Name...`
I don't think this can work because this is not an interactive step. So you cannot pass the key passphrase to `ssh-keygen` and the process will just stay stuck.
Would it be enough to check `form.fields`? This might make the test a bit easier to follow instead of having to parse the HTML to see what's expected..
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
You have some unmerged lines here
ditto here and others below
same for tests below as well
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
You have some unmerged lines here
ditto here and others below
same for tests below as well
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
You have some unmerged lines here
ditto here and others below
same for tests below as well
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
Similar to below. Maybe `testManualAssignmentChangeWithAutoOffsetCommitEnabled` is a more descriptive name.
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
For even distribution, it would be useful to verify 2 things. (1) The leaders are distributed evenly when all brokers are unfenced. (2) If any broker is fenced, the new leaders are still distributed evenly.
Nit: can you put this and `runWithoutJava` next to each other
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
Similar to below. Maybe `testManualAssignmentChangeWithAutoOffsetCommitEnabled` is a more descriptive name.
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
For even distribution, it would be useful to verify 2 things. (1) The leaders are distributed evenly when all brokers are unfenced. (2) If any broker is fenced, the new leaders are still distributed evenly.
Nit: can you put this and `runWithoutJava` next to each other
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
Similar to below. Maybe `testManualAssignmentChangeWithAutoOffsetCommitEnabled` is a more descriptive name.
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
For even distribution, it would be useful to verify 2 things. (1) The leaders are distributed evenly when all brokers are unfenced. (2) If any broker is fenced, the new leaders are still distributed evenly.
Nit: can you put this and `runWithoutJava` next to each other
We can use a separate ticket to centralize these helper functions into `org.apache.kafka.test.TestUtils`, would you mind filing a JIRA? Example functions like `getProducer/Consumer/StreamsConfig`, etc.
nit: typo in description
`topics created using through() method` -> `topics used in/by through() method`
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
You are right @hachikuji . For line 1597 to be true, I think the test needs to do another round of fetch. > // The high watermark advances to be larger than log.endOffsetForEpoch(3), to test the case 3 Line 1614 wants to fail because of an invalid offset and epoch based on the leader epoch cache. Not because it is greater than the high watermark. ``` assertThrows(IllegalArgumentException.class, () -> context.client.createSnapshot(invalidSnapshotId4.offset, invalidSnapshotId4.epoch)); ```
```suggestion @pytest.mark.parametrize( 'mocked_version', ( '', ' (devel 8a202cae3e) last updated 2021/01/11 10:24:38 (GMT +200)', ), ids=('plain', 'scm'), ) def test_ansible_version(capsys, monkeypatch, mocked_version): monkeypatch.setattr( 'ansible.cli.arguments.option_helpers._git_repo_info', lambda repo_path: mocked_version, ) ```
```suggestion from ansible.release import __version__ expected_version_line = 'ansible {ver!s}{scm_info!s}'.format(ver=__version__, scm_info=mocked_version) assert expected_version_line == version_lines[0], 'Incorrect ansible version line in "ansible --version" output' ```
maybe we could randomize the names of the 2 settings we have in this test
Nit: can you put this and `runWithoutJava` next to each other
For even distribution, it would be useful to verify 2 things. (1) The leaders are distributed evenly when all brokers are unfenced. (2) If any broker is fenced, the new leaders are still distributed evenly.
nit: typo in description
`topics created using through() method` -> `topics used in/by through() method`
Hmm, doesn't seem like this is correct. >version ['1', '0', '0-SNAPSHOT'] major_minor ['1', '0'] Extracting ['tar', 'xf', '/Users/ijuma/src/kafka/core/build/distributions/kafka_2.11-1.0.0-SNAPSHOT-site-docs.tgz', '--strip-components', '1'] Traceback (most recent call last): File "./release.py", line 235, in <module> command_stage_docs() File "./release.py", line 227, in command_stage_docs cmd('Extracting ', 'tar xf %s --strip-components 1' % docs_tar, cwd=os.path.join(kafka_site_repo_path, docs_version(version))) File "./release.py", line 108, in cmd output = subprocess.check_output(cmd, *args, stderr=subprocess.STDOUT, **kwargs) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 566, in check_output process = Popen(stdout=PIPE, *popenargs, **kwargs) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 710, in __init__ errread, errwrite) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 1335, in _execute_child raise child_exception OSError: [Errno 2] No such file or directory: '/Users/ijuma/src/kafka/../kafka-site/10'
Also, it seems like our convention for docs versions is quite bad. If we didn't want to use `.`, we could use something else like `_`.
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
Python 2.6 needs {0}, {1} - empty brackets in various other places too.
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Trivial fix, but it would be good to say 2.12 instead of 2.12.1 here so that we get the latest patch release. There's one other place in the file that also needs to be updated.
nit: missing . at end
You don't need to specify any symbolic name for a group since you have only one.
records to it, and reading all records from it, such that
It should be robust in case of some missing fields.
We didn't specify this in the KIP but I think `toStream()` and `toStream(mapper)` should also have overrides with`Named`
`KeyValueStore` -> `TimestampedKeyValueStore`
`get()` returns a `ValueAndTimestamp<Long>` -- not sure if we should add a `.value()` call to the right hand side or change the return type left hand side? Maybe easier to change to ``` Long aggForKey = localStore.get(key).value(); // ... ```
as above (more often below -- please fit all)
This overload does not take `Materialized` parameter
Because there is not `CogroupedKStream#reduce()` method this sentence is not useful and should be removed.
I'm sorry for flip-flopping on this, but thinking about this again (with the new model we introduced), I think it's simpler to call this just shardId , which must be set either at construction time (for things like refresh/bulk/flush actions) or when the request is resolved. Feels unnatural to call this resolvedShardId when it can be part of the constructor.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
What if we make `level` default to "info" or "debug" instead? That way if you call `log_response` on a non-error response you'd just get an info/debug log, instead of getting a confusing "module logger has no attribute None" error (or whatever the wording actually would be)
no blank line
I've proposed `self.fail(f'Unexpected logs found: {cm.output!r}')` to use the same message as in Python. With the current version `AssertNoLogsTest` tests will fail on Python 3.10+. We can adjust a message or skip new tests on Python 3.10+.
no blank line
response (no cap) unless you mean to write HttpResponse
I'm omit the intermediate extra variable in favor of: ``` getattr(logger, level)( message, *args, extra={...}, exc_info=exc_info, ) ```
Or in some cases (e.g. CSRF) it's because we want to log the response under a particular non-default logger. But even in those cases, we never want to double-log a response.
The variable name `phand` is non-descriptive
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
To me, this logic should really be in `IndicesQueriesRegistry` so we construct the registry with just the `Settings` object and then call a `registerQuery(ParseField, QueryParser<?>)` method which unpacks the `ParseField` and adds it to the registry map. That was the registry is dealing with how to internally structure the data and the internals can be easily changed later without affecting outside code.
Hmmm, I do see what you mean. Personally I would still prefer the register method in the registry but I think this is a personal preference thing rather than a substantial concern so I'm happy to yield on it :smile:
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I know that this is how it used to be but we add an explanation that this is called before the index is added to the cluster state? created is misleading.
and -> a
base -> based progress -> progressed
And if they are not used yet, we can probably remove them for now.
Does this factory need to extend key-value store factory? It seems a general in-memory factory, not specifically for key-value stores, right? And same for OffHeapFactory.
My minor concern is that KeyFactory and ValueFactory may be only specific to key-value stores, not not any general stores; for example for database stores you may have some functions like ``` withSchema() ``` that defines the data types for each column but not using "withKey / Value" any more. But since it is only for future improvements let's revisit this nested mechanism later.
and -> a
Perhaps say that the repartitioning will happen automatically, i.e., user doesn't need to do anything.
Thank you for pointing this out! I will have a look at this in the next days.
Yeah, the underlying store compares the serializer bytes lexicographically, it doesn't have any concept of "Integer" or any other type. And the really tricky thing is that it scans lexicographically, which means from left to right, whereas when we serialize things we usually do so from right to left. eg `2` in binary is `10` whereas 11 in binary is `1011` and 13 is `1101`. The problem here is that the serialized version of 2 is a different number of bytes than the serialized form of 11/13, so the lexicographical comparator is effectively comparing digits of a different magnitude.
i.e., add `fail` after this line
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
nit: remove empty line
nit: fix indention (we usually use 4 spaces, not 8)
nit: add `final`
We could also use `FileSystemUtils.isAccessibleDirectory(Path, ESLogger)` to make sure this dir is readable.
This can be only `Files.isDirectory(hunspellDir)` since `Files.isDirectory` returns false if the file doesn't exist.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
I have a similar concern here for when entry.getValue is not a Map
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
Space missing between `}` and `is`.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
maybe also here `"foo"` -> `{@code foo}`
Nit `{@code StateRestorerListener}`
ok, potentially reduces allocations for the user, thanks
Are you going to update the other two to remove unnecessary operations? That's all that's left and then I can merge the PR. Thanks!
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Changing the names of variables which is not necessary for this patch makes it harder to review, can we revert them? e.g. `total_seconds_since -> since`, or ``` for index, (seconds_per_chunk, chunk_name) in enumerate(TIMESINCE_CHUNKS): ``` -> ``` for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS): ```
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
So, looking at our existing list of modules, **api_url** is more popular than **server_url**. I guess we need to make sure we are making the right changes wrt. parameter naming. ``` [dag@moria ansible.git]$ grep -rl 'api_url' lib/ansible/modules | grep '\.py$' | wc -l 77 [dag@moria ansible.git]$ grep -rl 'server_url' lib/ansible/modules | grep '\.py$' | wc -l 21 ```
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
There is no need to add quotes here. Please remove them from all modules.
maybe also here `"foo"` -> `{@code foo}`
ok, potentially reduces allocations for the user, thanks
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
So, looking at our existing list of modules, **api_url** is more popular than **server_url**. I guess we need to make sure we are making the right changes wrt. parameter naming. ``` [dag@moria ansible.git]$ grep -rl 'api_url' lib/ansible/modules | grep '\.py$' | wc -l 77 [dag@moria ansible.git]$ grep -rl 'server_url' lib/ansible/modules | grep '\.py$' | wc -l 21 ```
There is no need to add quotes here. Please remove them from all modules.
maybe also here `"foo"` -> `{@code foo}`
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
ok, potentially reduces allocations for the user, thanks
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Space missing between `}` and `is`.
maybe also here `"foo"` -> `{@code foo}`
Nit: `.` missing at end of sentence
ok, potentially reduces allocations for the user, thanks
Nit `{@code StateRestorerListener}`
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
it is preferable to have descriptive test names, i.e., `emptyIteratorAlwaysReturnsFalse` `emptyIteratorPeekNextKeyShouldThrowNoSuchElementException` etc
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
nit: fix indention (we usually use 4 spaces, not 8)
nit: add `final`
nit: add `final`
nit: add `final`
nit: add `final`
nit: remove empty line
nit: remove empty line
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
It should be robust in case of some missing fields.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
I really like this class.
```suggestion * Metadata of a Kafka Streams client. ```
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Nit `{@code StateRestorerListener}`
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
As I suggested before, to not expose the node information, we should remove this function.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
nit: extra blank line ```suggestion ```
This is the only remaining point of discussion. I don't have a strong preference for any of them so I leave it up to you.
I have a small preference for `Future<Map<Integer, Future>>` because it seems more aligned to how we do it for other APIs but I don't feel strong about it.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
nit: extra blank line ```suggestion ```
I have a small preference for `Future<Map<Integer, Future>>` because it seems more aligned to how we do it for other APIs but I don't feel strong about it.
This is the only remaining point of discussion. I don't have a strong preference for any of them so I leave it up to you.
I'd suggest to use a more descriptive test name, e.g. in the form of `shouldDoXYZ`.
Can `LogManager.getRootLogger().getLevel()` be `null`? With other loggers you return the effective level if that's the case.
We may be able to save all this hassle by defining alias group as a map of `target` to a list of `deprecated` configs? We defined this as a 2-dim array but we always convert it to lists...
shall we flip this outer if? `if (fieldNamesMapper != null && fieldNamesMapper.enabled()) {` looks a bit nicer to me
ditto here and others below
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
s/`Strings.isNullOrEmpty(publicKey)||`/`Strings.isNullOrEmpty(publicKey) ||` (space missing)
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
same for tests below as well
You have some unmerged lines here
Looks good. I like the additional checking that you're doing here.
@bizybot can you open up a issue that describes this behavior of the object parser and label it with discuss? Then we can move this PR forward.
I am confused how this works when created is only within role mapping but we ignore role mapping
paused -> running
this state is missing from the KIP, it should be added
we just generally try to avoid the mess if the code isn't ready to be committed yet. it can always be held onto in a branch, wip pr, etc
same for tests below as well
ditto here and others below
alternatively just `actual.getNano() % 1000 == 0` - not sure if it is more readable to be honest, so feel free to ignore me :-)
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
you can use the util method printBoostAndQueryName here now (once you rebased)
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
Not introduced in this patch: "is non" => "as non"
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Ditto here: use `entrySet()`.
It should be robust in case of some missing fields.
nit: maybe iterate over `entrySet()` instead.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Not introduced in this patch: "is non" => "as non"
It's not a bid deal, but I found the naming here a bit confusing, since the `nonExistingSourceNode` is clearly added to the topology down on line 223, so it definitely exists. But I'm not sure what a better name would be...msybe `removedSourceNode`? Idk
can we not wrap a translog but rather just keep this test translog next to the normal one? keep it simple and readable :)
You have some unmerged lines here
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
I think it'd be clearer to simply inline these overloads and spell out all the parameters at the call sites. We only make three of these objects, so four overloads of the constructor seems excessive :) Also if `Bucket` were not `static` then you wouldn't need to pass `buckets` in.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
ditto here and others below
recommended; ditto below.
nit: add `final`
same for tests below as well
nit: add space `configEntry :` -- wondering why this is not detected by checkstyle...
nit: add `{ }` -- we use curly braces for all blocks nit: remove double space after `==`
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I have a similar concern here for when entry.getValue is not a Map
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
same for tests below as well
1: I'm definitely happy with this. I'm not sure why I didn't go for it myself. 2: Fine by me, I don't feel strongly.
It seems the `if shuffle` block is repeated twice, you can move it out of the conditional block
This bit of metadata should also be added to each dataset in the "both" case.
Please check test coverage carefully. I didn't spot a test for this change.
You can also drop the parentheses :wink:
It looks like both `__init__` method can be removed as they simply delegate to `AlterFooTogether.__init__`.
I feel like it should be `_delete_unique_sql`'s decision to do the bool casting. Maybe some backends will need access to the condition to appropriately delete it. Lets just pass `condition=condition` and let database backends do `if condition`.
Not something that you have to change but I think this could be simplified to ```python for obj_func in self.obj_func_mapping.values(): obj_func() ```
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
Getting an error about an index when creating a constraint is confusing unless you understand the implementation details.
you mean providing the size of the array I guess? cause I don't see a constructor that accepts an array in ArrayList.
I wonder if `profile` and `explain` should be forbidden too? Both have non-negligible impact on performance, and seem irrelevant to ranking as well.
creating two ArrayLists may not be the best thing to do. Lets do this instead: ``` List<String> splitList = new ArrayList<>(); Collections.addAll(splitList, oldVal.split(separator)); ```
can we use the index name first in the log, like `[{}] locking all shards, num_shards [{}], index, numShards`
Nit: why not use `boolean`
I would be using a `Set` in this circumstances.
It's good like it is , it's more civilized, otherwise it would indeed indeed violate the scope of this PR. I think I see the privilege code as new code where creative destruction is more loosely permitted. But I still think it would be nice to do this change in a follow-up. I am happy to pick it up if you wish.
Side note: we need to rename Reducer.FUNCTION to have a more explicit name.
nit: I think remove "next", since this is no longer a second step in the method
We can use a set here instead (it's sorted at the end anyhow). ``` final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds); // first, look at the snapshots in progress final List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, snapshotIds.stream().map(SnapshotId::getName).collect(Collectors.toList())); for (SnapshotsInProgress.Entry entry : entries) { snapshotSet.add(inProgressSnapshot(entry)); snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId()); } ```
Minor nitpick 3: You could put the two if-statements into a long one making this diff really small
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
Sorry, missed this earlier: We are creating a new `selector` in `checkAuthentiationFailed`, so we should ensure that the previous selector is closed. You could call `selector.close()` just before calling `checkAuthenticationFailed` here and also a couple of lines below.
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
Looks good. I like the additional checking that you're doing here.
`isServer` is not used
same 1+ randomInt
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
nit: one too many line break? :)
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
given that we have almost proper setters here that return void, do we really want to make them return this? no strong opinion, just thinking out loud
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
something like `inferredInternalTopics.containsAll(specifiedInternalTopics)` might be easier to understand here
nit: extra line
nit: extra line
Maybe merge all the groovy securing code into one place? It feels funky to have the default receiver whitelist here but method blacklist above.
Do we want to _require_ a user provided key ? If I understand correctly, it really only protects against rainbow table attack when used in this context, but with the salt and potentially hard coded default key it seems we should be covered.
@jkakavas - thanks for the thoughtful reply. I don't want to derail this PR and will open an issue for further discussion. EDIT: Issue logged: https://github.com/elastic/elasticsearch/issues/31692
Sorry, i don't think i was very clear. I meant the hashing algorithm here is an HMAC (a keyed hash). For the anonymization use case we could use a non keyed Hash to the same effect. The key doesn't provide much value unless you are verifying the hash's integrity. To avoid swapping implementations based on a key's existence, a hard coded key can be used, which effectively (but not technically) changes from a keyed hash to non keyed hash.
I think it would be valid to fallback to a generated salt if none is set (for other use cases), but it doesn't necessarily need to be part of this PR.
Do we want to default to random salts here ? If I understand the primary use case correctly it is to anonymize fields for analysis which would prefer the same input values to result to the same hash. (e.g. hash(jakelandis) always results in "adslkjv983d")
Search and executable, and execute look like they should delegate stuff to a single method. Orsomething.
This function returns true if there is a non-empty intersection between topicNames and partitionForHost. You could reverse the iteration: iterate topicNames (since it is a List) and lookup into partitionForHost (since it is a Set and likely has O(1) lookup time). The overall complexity would be reduced: O(m*n) -> O(m)
@mjsax Got it. Thanks for your response!
Are these methods the sam as in the class above? If so consider refactoring so we only have them once
the node where the shard should move to
I think we should use `writeAtomic` everywhere just to reduce the complexity.
nit: extra line
Great catch, thanks @showuon !
Hmm, I just noticed this... It applies to the other test, too. I can see some value in asserting that `range(null, null)` returns the same thing as `all()`, but I wonder if it would be better to validate that they both return the _right_ thing. It's just the fact that the underlying implementation delegates `all()` to `range(null, null)` that's making me think of it.
This would wait forever. Maybe we should do: ```suggestion TestUtils.waitForCondition(() -> stateStore.get(high) != null, "The store never finished populating"); ```
You might consider: ```suggestion try (final KeyValueIterator<String, String> scanIterator = forward ? stateStore.range(null, null) : stateStore.reverseRange(null, null)) { TestUtils.checkEquals(scanIterator, dataIterator); } ```
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
same for tests below as well
with vint we save a cast to byte I guess, that's it :)
do we do this in other places? I mean using read/WriteByte for enum ordinals? I think there's many many places where we have VInt instead
oh boy, I see that we were using VInt for writing and Byte for reading.... thanks for fixing...
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
can this be in try-with logic.... you are not closing this input stream at all
My understanding is that Jun is suggesting that we should set `checkHC` to true for the Java client if message format is 1.
I wonder if we should enable this only for new indices that we know are created with es 1.4
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
also use new `writeDoubleArray` here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if you do `extends ToXContentToBytes` instead of `implements ToXContent` you get that for free
ok I wasn't sure, perfect
Nit: rename to `shouldThrowOnInvalidTopicNames`
nit: you could just specify one `String` variable at the top of the method and set it accordingly if `topics` is `null` or not then have a single `return` statement. Just a personal preference though.
nit: add `final`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
i.e. defaults on the query params will get rid of this weirdness (although at least it is isolated here)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
also use new `writeDoubleArray` here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if you do `extends ToXContentToBytes` instead of `implements ToXContent` you get that for free
ok I wasn't sure, perfect
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
also use new `writeDoubleArray` here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if you do `extends ToXContentToBytes` instead of `implements ToXContent` you get that for free
ok I wasn't sure, perfect
This test seems to be overlapping with `shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound`. I don't think we need both to return `LeaderNotAvailable` unless they are evaluating different scenarios.
same for tests below as well
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Include class name here? This seems like it would be confusing if logged.
You have some unmerged lines here
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
also use new `writeDoubleArray` here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if you do `extends ToXContentToBytes` instead of `implements ToXContent` you get that for free
ok I wasn't sure, perfect
This test seems to be overlapping with `shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound`. I don't think we need both to return `LeaderNotAvailable` unless they are evaluating different scenarios.
same for tests below as well
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Include class name here? This seems like it would be confusing if logged.
You have some unmerged lines here
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This is because we are inheriting a Scala class, and moving forward we should remove this with the Java version `org.apache.kafka.copycat.util.ShutdownableThread` that can be moved into `o.a.k.common.utils`. We can leave it as is for now.
same for tests below as well
nit: add `final`
Can replace the three lines with: ``` assertEquals(Utils.mkSet("TLSv1.2"), Utils.mkSet(engine.getEnabledProtocols())); ```
req: Could you please rename `StreamsMetricsImpl metrics` to `StreamsMetricsImpl streamsMetrics` and then format the code like this ``` final StreamsMetricsImpl streamsMetrics = new StreamsMetricsImpl(metrics, "test", StreamsConfig.METRICS_LATEST); ```
It seems I also could approve it. I will read all code tomorrow and work with you to get this approved.
@jeffchao traditionally Kafka used key,value pairs in properties and pass it everywhere and each implementation takes look at this config and pulls their interested key,value pairs. Example, authorizer interface https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/security/auth/Authorizer.scala#L35 . The pluggable class when it gets instantiated a configure method will be called and all the key,value in server.properties will be passed and it will pick whats relevant to the class. We can do the same here instead of asking users append key,values into the a config which is hard to configure and hard to get it right.
Suggestion on above function addConfiguredSecurityProviders: 1. I think using following format for security.providers: security.providers=provider1_classname,provider2_generator_classname key1:val1 key2:val2,... 2. So when parsing above config, if there is no parameters following provider1_classname, then we can think provider1_classname is java Provider, then insert it; if there are key:value pair parameters following provider2_generator_classname, we can think provider2_generator_classname is SecurityProviderGenerator, then create "Map<String, ?> config" from key:value pair parameters, then call configure and getProvider of instance of SecurityProviderGenerator. This way we can handle all different scenarios in the future.
Should not `port` be an integer ? Note that the module accepts `None` value (no error encountered)
`sgr['dest_port_from']` is already a string no need to use `str` around.
adding the registraiton part into Config file doesn't look good to me. Generally speaking Config classes are only there to express the config members and validation around them but not to take any action. SecurityUtils.java would be a better place.
`ip_range=dict(default='0.0.0.0/0', type=lambda x: to_text(ip_network(to_text(x)))),` could be used in `argument_spec` instead of this method: * inner `to_text` required because `ip_network` requires unicode in input * outer `to_text` required because `module_utils` [doesn't handle parameter which aren't basic type](https://github.com/ansible/ansible/blob/83ec4184701f77d4de68d0c52946fd80a13fbe0a/lib/ansible/module_utils/basic.py#L504) (except `datetime`) (`to_text` comes from `from ansible.module_utils._text import to_text`)
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
You can also do this more concisely as `topicsByName.keySet().removeAll(existingTopicNames)`.
If it's possible to directly forward to `LoggingDeprecationHandler.INSTANCE` I'd rather do that because it would avoid duplicating the knowledge that the logger for `ParseField.class` goes to the deprecation log.
Not needed anymore.
Minor suggestion to make it clearer that we're not waiting for the write index not to exist: ```suggestion public static final String NAME = "check-not-write-index"; ```
can we open an issue/track it somewhere that these should be evaluated
This isn't a REST extension necessarily, right? It's also used by Kafka via JMX. I think mentioning `worker restarts` and `rest extension` might be confusing
@wicknicks would be useful to have some unit test for this class.
also, please make a note to make this configurable.
Is this the format required by the mbean stuff? It might be nice to return something more structured here.
Can `LogManager.getRootLogger().getLevel()` be `null`? With other loggers you return the effective level if that's the case.
Make it `public abstract class`
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
I think this should be: ``` ^(?:[-\\w]+[.])*[-\\w]+$ ``` - non-capturing groups (`(?:..)`) are more efficient - `\w` already includes `\d` and `_` - a `-` inside `[ ]` should appear first, otherwise it indicates a range (at least in pcre)
This should be: ``` ^(?:[-\\w]+[.])+$ ``` This assumes that (a) at least one level is required and (b) there is nothing after the group key (so it is anchored to the end of the string)
Ah yeah I suppose that might be ok, in this case it's user-defined input so that's pretty awkward but it beats breaking.
Yes, pass the value as a json string.
I think this should be a concurrentSet to be honest we remove stuff from this under locks and I don't like the runtime otherwise.
Can we move these up at the top of the class with the other object variable declarations? I think it is more readable than having them 300 lines down into the class.
this can be: ``` Java public static final Setting<List<URIPattern>> ALLOWED_URLS_SETTING = Setting.listSetting("repositories.url.allowed_urls",Collections.emptyList(), URIPattern::new, false, Setting.Scope.CLUSTER); ```
can this be: ``` Java public static final Setting<URL> URL = new Setting<>("url", "http:", URL::new, false, Setting.Scope.CLUSTER); ... URL url = ...; if (URL.exits(settings) == false && REPOSITORIES_URL.exists(settings) == false) { throw new RepositoryException(name.name(), "missing url"); } ```
Is this intentional? cc @enothereska
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
I think this should be: ``` ^(?:[-\\w]+[.])*[-\\w]+$ ``` - non-capturing groups (`(?:..)`) are more efficient - `\w` already includes `\d` and `_` - a `-` inside `[ ]` should appear first, otherwise it indicates a range (at least in pcre)
This should be: ``` ^(?:[-\\w]+[.])+$ ``` This assumes that (a) at least one level is required and (b) there is nothing after the group key (so it is anchored to the end of the string)
Ah yeah I suppose that might be ok, in this case it's user-defined input so that's pretty awkward but it beats breaking.
Yes, pass the value as a json string.
I think this should be a concurrentSet to be honest we remove stuff from this under locks and I don't like the runtime otherwise.
Can we move these up at the top of the class with the other object variable declarations? I think it is more readable than having them 300 lines down into the class.
this can be: ``` Java public static final Setting<List<URIPattern>> ALLOWED_URLS_SETTING = Setting.listSetting("repositories.url.allowed_urls",Collections.emptyList(), URIPattern::new, false, Setting.Scope.CLUSTER); ```
can this be: ``` Java public static final Setting<URL> URL = new Setting<>("url", "http:", URL::new, false, Setting.Scope.CLUSTER); ... URL url = ...; if (URL.exits(settings) == false && REPOSITORIES_URL.exists(settings) == false) { throw new RepositoryException(name.name(), "missing url"); } ```
Is this intentional? cc @enothereska
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
Nit: you can remove `value =`
Nit: unnecessary new line.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
I'm somewhat inclined to add the local id to the builder rather than making it constant. It makes the builder a bit more self-contained. On a similar note, it would be nice to push the other static config values into the builder as well.
redundant type arguments `<ProducerRecord<byte[], byte[]`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
I think we should call `deserializer.configure(...)` here
Can we actually include UUID type? It always 16 bytes.
It's better to avoid "double-brace initialization", which is actually declaring a new anonymous subclass of HashMap just to add some stuff to it in one statement. A little while back, I added this method for accomplishing the same thing more safely: `org.apache.kafka.common.utils.Utils#mkMap`, and the accompanying `org.apache.kafka.common.utils.Utils#mkEntry`.
nit: should be `<L extends List<Inner>>` to avoid warning about using a raw type
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
can be simplified to `@SuppressWarnings("unchecked")`
There a two independent configs for the list-type and inner-type, hence it might be better to handle both independently: ``` if (listClass == null) { String listTypePropertyName = isKey ? CommonClientConfigs.DEFAULT_LIST_KEY_DESERIALIZER_TYPE_CLASS : CommonClientConfigs.DEFAULT_LIST_VALUE_DESERIALIZER_TYPE_CLASS; listClass = (Class<List<Inner>>) configs.get(listTypePropertyName); if (listClass == null) { throw new ConfigException("Not able to determine the list class because it was neither passed via the constructor nor set in the config"); } } if (inner == null) { String innerDeserializerPropertyName = isKey ? CommonClientConfigs.DEFAULT_LIST_KEY_SERIALIZER_INNER_CLASS : CommonClientConfigs.DEFAULT_LIST_VALUE_SERIALIZER_INNER_CLASS; Class<Deserializer<Inner>> innerDeserializerClass = (Class<Deserializer<Inner>>) configs.get(innerDeserializerPropertyName); inner = Utils.newInstance(innerDeserializerClass); inner.configure(configs, isKey); } ```
Remove the last sentence, since the `reset` method is private, and looks like it's handle automatically.
```suggestion /** * Metadata of a task. */ ```
```suggestion /** * The value of {@link StreamsConfig#APPLICATION_SERVER_CONFIG} configured for the Streams * client. * * @return {@link HostInfo} corresponding to the Streams client */ ```
Yes, we could add `ignoredExtensions` and include that in the log in the server.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We should mention somewhere that users should prefer this new assignor for newer clusters.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
`asList` -> `Collections.singletonList`
Why not have the standard to string? A multiline return value is difficult to work with in a debugger...
mmm this is not 100% correct. although it makes little sense, you can still set boost and queryname on the result, which would end up modifying the prototype and all subsequent match_none queries read.
obscure error message... let's start by `"could not read alias fields filtering from xcontent. expected an object but found [" + parser.currentToken() + "] instead"`
Same here, I think the ctor should contain the mandatory arguments and those should be immutable later. Again, this means for parsing we need ConstructingObjectParser.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
We do expect RemoteStorageManager to have strong consistency on the data. We only relax the requirements on metadata consistency. So, it would be useful to make this clear.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Ah yes, thanks!
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
missing t at the end of the method name
It'd be more powerful to do an assertion on the complete set of returned plugins, since that will only require one test run to discover all differences between the expected plugins and the actual ones: ```suggestion Set<Class<?>> excludes = Stream.of(ConnectorPluginsResource.SINK_CONNECTOR_EXCLUDES, ConnectorPluginsResource.SOURCE_CONNECTOR_EXCLUDES) .flatMap(Collection::stream) .collect(Collectors.toSet()); Set<ConnectorPluginInfo> expectedConnectorPlugins = Stream.of(SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS) .flatMap(Collection::stream) .filter(p -> !excludes.contains(p.pluginClass())) .map(ConnectorPluginsResourceTest::newInfo) .collect(Collectors.toSet()); Set<ConnectorPluginInfo> actualConnectorPlugins = new HashSet<>(connectorPluginsResource.listConnectorPlugins(true)); assertEquals(expectedConnectorPlugins, actualConnectorPlugins); verify(herder, atLeastOnce()).plugins(); ``` (This assumes we split out `CONNECTOR_EXCLUDES`, but the same general strategy should apply even if we don't).
Also set the store name in this test.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
No need to define another attribute. The form class should be accessible as `self.TestForm`.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Ah yes, thanks!
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
missing t at the end of the method name
It'd be more powerful to do an assertion on the complete set of returned plugins, since that will only require one test run to discover all differences between the expected plugins and the actual ones: ```suggestion Set<Class<?>> excludes = Stream.of(ConnectorPluginsResource.SINK_CONNECTOR_EXCLUDES, ConnectorPluginsResource.SOURCE_CONNECTOR_EXCLUDES) .flatMap(Collection::stream) .collect(Collectors.toSet()); Set<ConnectorPluginInfo> expectedConnectorPlugins = Stream.of(SINK_CONNECTOR_PLUGINS, SOURCE_CONNECTOR_PLUGINS) .flatMap(Collection::stream) .filter(p -> !excludes.contains(p.pluginClass())) .map(ConnectorPluginsResourceTest::newInfo) .collect(Collectors.toSet()); Set<ConnectorPluginInfo> actualConnectorPlugins = new HashSet<>(connectorPluginsResource.listConnectorPlugins(true)); assertEquals(expectedConnectorPlugins, actualConnectorPlugins); verify(herder, atLeastOnce()).plugins(); ``` (This assumes we split out `CONNECTOR_EXCLUDES`, but the same general strategy should apply even if we don't).
Also set the store name in this test.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
No need to define another attribute. The form class should be accessible as `self.TestForm`.
maybe like this: ``` Java try { IOUtils.close(() -> processes.stream().map(s -> (Closeable)s::destroy).iterator()); } finally { processes.clear(); } ```
lets call `stdinReferences.clear()` after we closed all of them. I also think you should use `IOUtils.close(stdinReferences)` instead, it will close all references even if one close call throws an exception.
This should be done in reset()
Maybe: Include in the log the Connect key, value, and other details of records that resulted in errors and failures.
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Same question here about just using a static ConfigDef instead of a static method.
nit: add a size? There are a few cases in here where we could do this.
This is `ListDeserializer` hence, shouldn't we use `ConsumerConfig.LIST_KEY_DESERIALIZER_INNER_CLASS_CONFIG` ? The "SERDE" config should be used in Kafka Streams codebase only? (Same for value, and for both inner types in the next line).
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You have some unmerged lines here
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
"this until it is" doesn't quite parse.
`InternalProcessorContext` is already public interface but it's in `internals` package, so I figured it is okay? Anyways, this is not much blocking this PR, so feel free to merge it anyways and we can keep discussing here while you merge.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.
"with a read-only key"
with a read only key
two license headers? :)
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
"with a read-only key"
with a read only key
two license headers? :)
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
Same question here about just using a static ConfigDef instead of a static method.
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
nit: Seems that this is not the right place for this method. It's now between static and non-static field members. It's used in the constructor, but still, it should probably be placed lower in the class.
True there's nothing concrete. Google Java Style Guide mentions a logical order but nothing specific. There are some old Sun conventions: http://www.oracle.com/technetwork/java/codeconventions-141855.html and then, if you look at Intelij's rules, under Code Style -> Java -> Arrangement you get a feel of some other conventions. But beyond guidelines and given the absence of clear consensus my point is that, besides static initializer blocks, I'd expect member fields, constructors, methods in that rough order.
Sure, I was referring to future coding errors that will be revealed only during runtime. The current use is fine. I'm fine with NPE.
Do we want a `ConnectException` here instead? Not sure.
half the shards? please update
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
"with a read-only key"
with a read only key
two license headers? :)
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
"with a read-only key"
with a read only key
I really like this class.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
two license headers? :)
This looks good. Basically a JavaFx version of 'unsubscribeOn'. This is better because it allows executing immediately if already in the right thread.
This PR looks good. Once the build issue is resolved I will merge it. Thanks for contributing!
Whoops. I just merged it :-) I'll have to fix the build later.
nit: single parameter per line
ok, potentially reduces allocations for the user, thanks
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Can remove if initialize above
nit: extra blank line ```suggestion ```
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Same question here about just using a static ConfigDef instead of a static method.
Seems that this class is a bit redundant, i.e, we could just construct an `AssignedTasks` with the `logContext` and `"standby task"`
nit `Production exception handler` -> `{@code ProductionExceptionHandler}`
I think we probably should clean these up so they are more useful for users, but won't block merging this on that. I was thinking something more along the lines of: ``` UUIDDeserializer deserializes UUIDs in standard 36-byte hexidecimal string representation. ``` then followed by the encoding details, i.e. the stuff a user wants to know. Many users won't even think about the fact that what's going into the deserializer (or out of the serializer) is actually a `byte[]`.
I really like this class.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
nit: `pc` -> `oldProcessorContext` `apiPc` -> `newProessorContext` `ssc` -> `stateStoreContext` below `c` -> `context`
Nit: could just throw the exception directly here; doesn't appear to be much benefit to putting that in a separate `setup` method.
Cheating the compiler, woohoo!
Nit: reword to avoid "log" being ambiguous as verb or noun: "Writes errors and their context to application logs."
We should limit this suppression to the method for which we really need it instead of the whole class
add `final` twice
Can remove if initialize above
Remove double blank.
Can `LogManager.getRootLogger().getLevel()` be `null`? With other loggers you return the effective level if that's the case.
yea Im all for not exetnding that class. And Im also all for putting things that are primitive and easily validatable into the constructors. Optionals, i think im ok with setters but i think this also deserves a wider audience to discuss.
This is a question, not a change request: What is our philosophy regarding having setters vs. immutable request objects going forward for the HLRC? I've been under the impression we preferred immutable objects, but it doesn't seem to be consistent.
I am wondering would it be better to have this logic in `kafka.Kafka.main()` instead of in the exception? Also it seems that after calling shtudownSystem() the thread will continue to run in this case, which is different from the previous behavior, i.e. system.exit() does not return. If we do so we need to inspect all the cases where we call `System.exit()` and make sure all the threads will exit after we change it to throw the exception. By putting this logic in `kafka.Kafka.main()`, we can still call System.exit() in any of the Kafka thread after catching the `FatalExitError` exception and it is guaranteed the thread won't run anymore.
I think @becketqin was suggesting that we can add a method to `Kafka` that would cause the thread waiting on `KafkaServer.shutdownLatch` to resume and call `System.exit()` with the appropriate exit status.
I also wonder if we should only have `Task.java` and have different ctors and if you don't pass a parentID you are not a child task? and default parent id is 0 just like in linux etc.
If there are multiple FatalExitError thrown, do we want call `System.exit()` only once instead of creating a thread for each of them? Maybe we can just log the error and return.
This should only be done in close()
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
Cool. I think the fewer configs overall, the better. If we can get away with just the Serde configs then let's do so to keep the API surface area smaller for users ð
Have you thought about rearranging the parameters so that the operation is last? It's the only parameter that might be a lambda, and having it last would be more readable.
In this case everything is quite readable since all the things we're delegating to are super short method calls, I found the code that invokes this quite readable (but of course that's subjective)
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Strings.EMPTY_ARRAY could be used too (if you want)
Nit: "doens't" -> "doesn't"
seems redundant indeed
I'll leave this one
This multi-line `||` is super ugly to read without syntax highlighting (on github, for instance). How about: ``` java boolean same = local.isSame(remote); boolean hashAndLengthEqual = (local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length()); boolean consistent = same || hashAndLengthEqual; ```
Also, `.length()` should be compared before `hash()` in my opinion so it can short circuit without comparing the entire `BytesRef` if it can be avoided.
3 more indentation issues above
The reason should be more explicit about why this needed.
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
I see that we need it from another package, I think it's ok.
Strings.EMPTY_ARRAY could be used too (if you want)
Nit: "doens't" -> "doesn't"
seems redundant indeed
I'll leave this one
This multi-line `||` is super ugly to read without syntax highlighting (on github, for instance). How about: ``` java boolean same = local.isSame(remote); boolean hashAndLengthEqual = (local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length()); boolean consistent = same || hashAndLengthEqual; ```
Also, `.length()` should be compared before `hash()` in my opinion so it can short circuit without comparing the entire `BytesRef` if it can be avoided.
3 more indentation issues above
The reason should be more explicit about why this needed.
We should make this test be fore `<byte[], byte[]>` as then we have covered both key and value deserialization.
I see that we need it from another package, I think it's ok.
nit: `final` + next line and might as well do the previous while you are at it ;-)
nit: new lines are generally not recommended to break object type declaration with object name. For this specific line I think we can still make them in one line.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
Discussed offline with @ijuma. This actually isn't quite enough to fix the example he brought up earlier in all cases. For example, it still doesn't work if you construct `Config` with a `Set` for the entries. Given that we can't guarantee equality in this way generally, I'd probably suggest we just revert to using `Collections.unmodifiableCollection` like you had before.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
Sure, I was just wondering as this patterns appears now at least 3 times.
I think we should discuss such ideas in follow-up PRs. It's not clear to me that replacing duplicate code with more abstractions would be a win.
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
I wonder what will happen under parallel unit test environment like Jenkins, for `KafkaProducerTest`, `KafkaConsumerTest` and `KafkaStreamsTest`, won't the global counts be messed since AFAIK they are executed under a single JVM? cc @ijuma
We can call `selectKey()` instead which is like a syntax-sugar for such cases.
We should explain why the key ("temp") is hard-coded here.
I'd suggest to replace `5000` with `TimeUnit.SECONDS.toMillis(5)`. This is better than magic numbers.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
nit: why not `k2` ? Should we use `A`, `B`, `C`, `D` for the values to make it easier to understand the expected result? It's unclear which A is which below.
How about changing this to be only stoppable by ctrl-C? We are changing the rest of the examples as well in a manner to improve our quick start: https://github.com/apache/kafka/pull/3515
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
Do we need to check if it is null here? I think it is probably ok if it doesn't throw any exceptions? Obviously it would be better if we could check that `loginManger.release()` was only called on the first invocation, but i appreciate that involves further refactoring
nit: extra blank line ```suggestion ```
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
I wonder what will happen under parallel unit test environment like Jenkins, for `KafkaProducerTest`, `KafkaConsumerTest` and `KafkaStreamsTest`, won't the global counts be messed since AFAIK they are executed under a single JVM? cc @ijuma
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
Fails checkstyle, needs to be final
We can call `selectKey()` instead which is like a syntax-sugar for such cases.
nit: could use Utils.mkSet
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
I wonder what will happen under parallel unit test environment like Jenkins, for `KafkaProducerTest`, `KafkaConsumerTest` and `KafkaStreamsTest`, won't the global counts be messed since AFAIK they are executed under a single JVM? cc @ijuma
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
nit: extra blank line ```suggestion ```
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
Fails checkstyle, needs to be final
use `try-catch` plus `fail()` for this line and remove annotation `@expected` -- right now, for example, a bug in `builder.stream` raising `NullPointerException` would not get detected. ``` try { stream.peek(null); fail("Should not allow null Action"); } catch (final NullPointerException e) { // expected } `@expected` should only be used in "single line test" for which it is clear that no exception can happen before the actual tested code.
We can call `selectKey()` instead which is like a syntax-sugar for such cases.
only one parameter should be `null` -- otherwise it's unclear what this test actually does
We should explain why the key ("temp") is hard-coded here.
I'd suggest to replace `5000` with `TimeUnit.SECONDS.toMillis(5)`. This is better than magic numbers.
Naming this the same as the one in `WorkerTest` is causing failures in `WorkerTest` because the search for the connector by reflection finds both classes.
nit: why not `k2` ? Should we use `A`, `B`, `C`, `D` for the values to make it easier to understand the expected result? It's unclear which A is which below.
How about changing this to be only stoppable by ctrl-C? We are changing the rest of the examples as well in a manner to improve our quick start: https://github.com/apache/kafka/pull/3515
Line too long (also some lines above and further below)
There are two input streams in this test, and thus we should create a second `TestInputTopic` to pipe input via both.
braces please. for the rest of the method too. (I realize you just tweaked this to be a lambda but it would be good to fix this as two line single statement `if`s are dangerous and evil).
You know, we can add a checkstyle check for those....
maybe just `esVersion()`
While we're at it, we may as well use another `{}` substitution for the parameter and remove the unneeded `toString()`.
I know you just moved these lines around, but while you're doing that it probably would be worthwhile to combine these 2 statements into one. If the log is busy, these might not appear next to each other.
It would be good to have some context as to where the filter appeared. I would at least word it a little differently: `"Missing [type] setting for anonymous char filter: " + charFilterName`
Nit: `assertThat` take expected result as first parameter IIRC (otherwise error message on failing test is "reversed")
prop: Use `assertThat()` here and in the other overload of this method.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
nit: space after IOException
Wow, test inheritance made this a truly mysterious change... Managed to track it down, though.
I think this will be clearer if we say - "// precreate incoming indices and popluate them with the relevant types"
this curly bracket should be on the previous line
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
```suggestion * @return map from tasks with caught-up clients to the list of client candidates ``` or something similar to make it clear the map only contains tasks with caught-up clients
req: I think we want to introduce some `acceptableLag` config within which a task is considered caught-up, otherwise this is way too strict. ie the condition should be `lag <= acceptableLag`
req: rename to `tasksToPreviousClients` or something similar that works "previous" into it
```suggestion // If a task was previously assigned to a client that that is caught-up and still exists, give it back ```
req: drop the `!caughtUpClients.isEmpty()` check here, if it's in the map it should have at least 1 caught-up client
req: rename `clientHostingTask` -> `previousHostingClient` (or similar)
Couple notes: You probably shouldn't pop from module.params.... I usually consider that to be a "constant" value. It's the record of what the user specified in the playbook for the module to look at but not to change. If you do want to pop it, you don't need to do it as two steps. This should be equivalent to what the present code does: ``` python module.params['binding:vnic_type'] = module.params.pop('vnic_type', None) ```
Yes, that would be the way to do it. Also, just for clarity, those are not blockers for merging this PR. The question of behaviour change is the only thing holding this up.
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Search and executable, and execute look like they should delegate stuff to a single method. Orsomething.
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
Ah nevermind, I see where we use it :-/
same for tests below as well
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
You don't need to specify any symbolic name for a group since you have only one.
Couple notes: You probably shouldn't pop from module.params.... I usually consider that to be a "constant" value. It's the record of what the user specified in the playbook for the module to look at but not to change. If you do want to pop it, you don't need to do it as two steps. This should be equivalent to what the present code does: ``` python module.params['binding:vnic_type'] = module.params.pop('vnic_type', None) ```
Yes, that would be the way to do it. Also, just for clarity, those are not blockers for merging this PR. The question of behaviour change is the only thing holding this up.
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Search and executable, and execute look like they should delegate stuff to a single method. Orsomething.
Does this need to be public, or can we make it private to this class and force everyone to go through the String version of the `parseBooleanLenient`? (I did a cursory glance and didn't see usages, but it's possible I missed some)
Ah nevermind, I see where we use it :-/
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I have a similar concern here for when entry.getValue is not a Map
It should be robust in case of some missing fields.
There's some mixed spaces and tabs here, please remove the tabs and use spaces only.
and -> a
You don't need to specify any symbolic name for a group since you have only one.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
should we implement SearchContext.toString? This way it would also be easier to look at SearchContext objects when debugging
I think it is fine: we only build one search context per request per shard.
`wrappedStore()` should `return wrapped;` -- that's why I argue for renaming the variable.
Not sure about this -- why not add two generics to the store, one for "wrapped" and one for "root" and keep this method that return the root type? I would also rename `inner()` -> `root()`
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
I would add an `assert this.context != null` here just to make sure
nit: we have assertions like this in many test cases. With a more direct api to update quorum state, we can move these assertions into that api.
I would add an `assert this.context != null` here just to make sure
can you just leave the constant in this class? There isn't a need to put it in realm imo

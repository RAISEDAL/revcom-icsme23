Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
nit: one too many line break? :)
No tabs in python code.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
minor: unused import now that WINDOWS is a static import below
Nit: unnecessary new line.
This class is surprisingly similar to org.apache.zookeeper.Login, have we copied from the same source? ;-)
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
public access? I can see this being accessed by another package too (such as `rest.resources`)
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
I'd consider making this extend org.junit.rules.ExternalResource - it can then be used as a JUnit ClassRule or Rule. The benefits being that the JUnit framework takes care of startup and shutdown
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Maybe it's worth not including this constructor. It's only used in tests and it's generally a good idea to provide a message with the exception.
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
Another reason for having these classes in common (i.e. KAFKA-5265) is that they can potentially be used by the Authorizer interface when we move it to Java.
public access? I can see this being accessed by another package too (such as `rest.resources`)
Good idea to add this safety net.
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
Nit: unnecessary new line.
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: `{@code null}`
Nit: unnecessary new line.
nit: some extra newlines here.
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Maybe: Include in the log the Connect key, value, and other details of records that resulted in errors and failures.
Same question here about just using a static ConfigDef instead of a static method.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
In my dreams, merging would either throw an exception or return a new independent mapping so that we wouldn't need this validation phase :)
Going through itertools here ends up creating both a list and a generator so it's likely slower than just returning a list. If the list is very large and your goal is to reduce memory consumption, you can use a generator expresssion instead of a list comprehension on line 322: ``` python expanded_excludes = (self._pattern_to_pkgname(self.base, p) for p in self.base.conf.exclude) ``` However, for iteration over most data, lists are faster than other iterables so it is a time-space tradeoff.
to me these should be sets and required to be non-null
this can be collapsed into `assertTrue(foundTerms.add(bucket.getKeyAsNumber()))`
Why do we need both? Is it because there are so many things going on in this file? I don't understand why we wouldnt just need the CompiledAutomaton for the terms.intersect operation, why do we need a ByteRunAutomaton too? Having both seems silly anyway, but if we must do it, try to assign the ByteRunAutomaton from the CompiledAutomaton. The majority of the time it will be non-null: ``` /** * Matcher for quickly determining if a byte[] is accepted. * only valid for {@link AUTOMATON_TYPE#NORMAL}. */ public final ByteRunAutomaton runAutomaton; ```
Can we also assert that the state gets to `RUNNING` after the new thread has joined
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: no new paragraph required
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
Can remove if initialize above
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
Good point, but it could be clearer. This implementation can be used in production, but the `PropertyFileLoginModule` that also ships with this reference implementation should NOT be used in production.
extension name must not be empty
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
This would wait forever. Maybe we should do: ```suggestion TestUtils.waitForCondition(() -> stateStore.get(high) != null, "The store never finished populating"); ```
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
For this specific API, I suspect it is ever commonly used in PAPI, so I'm fine with not supporting it right away, also as a way to encourage users to change code sooner than later, if there's anyone.
I'm +1 on supporting the timestamps, even if it's not commonly used now, users will often look to tests for example usage (at least I do). I'm also +1 on removing `childIndex` for the same reason, but I don't have too strong an opinion on that.
I would omit this (not the test, just the sentence) and put examples into the web docs.
nit: no new paragraph required
nit: `{@code null}`
Can we simplify the param-doc? Mabye: "The MockProcessorContext allow a `Processor` to access those config during runtime?" It it required to lost all of those with the corresponding methods? nit `{@link StreamsConfig}`
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
remove the super call
remove the super call
Seems to fit in one line
I thought so, but wasn't excited with the grouping and it's not a long line anyways.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Existing issue, space should be after the colon.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Existing issue, space should be after the colon.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
Hmm, why did we do this? I thought we'd have a try/catch block.
I don't think we should make the patterns dir configurable? Outside the ES_HOME directory ES has insufficient permissions to read files. I think the patterns dir should always be `$ES_HOME/config/ingest/grok/patterns`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is it guaranteed that the contents of `errors` will only actually be compilation errors and not, e.g., warnings? Might be worth just using the return value of [call()](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.CompilationTask.html#call--) to determine if compilation succeeded.
Use `Collections.singletonMap` here and `Collections.singletonList`
This test is not really testing what we want to be testing here. The reason that it's not is because the cache key for a file named `".hidden_file"` is not `"hidden_file"`, but rather it is `""`. A file named `".hidden_file"` never would have been processed by the compilation engine because it doesn't have an extension. So this will ultimately throw, but not for the right reason.
same here as what i said below. You can use a `assertThat`
Include the exception in the log so there is an indication of what went wrong? Looks like it was previously included.
Note that this is different than setting a single property as it adds the inputs to the list.
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
I was referring to the fact that the setting netty uses are the result of a merge of multiple things: ``` // merge fallback settings with default settings with profile settings so we have complete settings with default values Settings mergedSettings = settingsBuilder() .put(fallbackSettings) .put(defaultSettings) .put(profileSettings) .build(); ``` If we can make that static and available we can now for sure they use the same thing, even if people change stuff.
guys take this offline if you want - let move here.
I think we should separate the two and push this as is. Your code refactoring has more changes than this functional change and on the security end I think we should be careful. let get this in and cleanup the stuff afterwards
ok...but client depends on the transport service anyway no? I think I don't get it
I don't know that we care about closing the handler. It probably does not matter too much, but there should not be any resources hanging around if we properly consume all the requests.
I think we should fix our datastrucuture first and don't make Path trie super complicated and flexible. This should be fixed first before we make this change here.
No need for this as the listener does not release anything.
same as above for non exception case
nit: a space before `else`.
I think it would be easier to read if we use the string representation to create these: http://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFilePermissions.html#fromString(java.lang.String)
That is much easier to read!
I call those "leftovers".
But `value` is coming from the system property and `setting` is come the settings object? He's ensuring that he takes it from one of the two, but not both.
Right, what I meant was, that `containsKey` value is only used if `value != null`, so why not get it only if `value != null`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
I fixed this one to use the constant before merging.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
Why is serviceName a property inside JaaS config? Could this be made one of the Kafka Sasl configuration properties instead? Presumably it is used only by Kafka code and hence doesn't belong in jaas.conf? IBM JDK Kerberos module throws an exception because it doesn't recognize this property.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Thanks for clarifying, @ijuma. Seems like we could verify the round-robin behavior without relying on specific number of IPs.
The test is verifying the round robin that _our_ code does, not the DNS server. We should ensure we still have that coverage in the meantime.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
a logger should always be private -- if classed extend `KTableSource` the should create their own logger with the corresponding "child" class name.
"This class is intended for a single thread use." - can we change this to a more aggressive "This class is NOT thread-safe"? I want to make sure there is no confusion in the future for any other devs using this class
nit: chain these c'tors to consolidate code. Makes it easy to do validation etc in case a need arise in future.
Is it necessary to call a public non-final method from a constructor? This can cause issues when somebody subclasses `IcuTokenizerFactory` as initialization order gets important. I'd opt for making `#getIcuConfig()` private which avoids the issue. Alternatives: Declare `#getIcuConfig()` or the class as `final`.
Nit: rename to `shouldThrowOnInvalidTopicNames`
We should limit this suppression to the method for which we really need it instead of the whole class
I'm thinking whether it makes more sense to let `MockProcessor` encapsulate a delegate `MockApiProcessor` so that we could also use existing tests to verify the correctness of the migration.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
This could be `ConfigException` instead. With the `ConnectException` hierarchy we get a little bit stuck because we can't have `ConnectException` be the base of all our exceptions and not redefine some. There are some from core Kafka that are fine if triggered from within the framework, and `ConfigException` falls under that category -- the biggest value aside from standardization that asking for `ConnectException`/`RetriableException` from connectors/tasks is that it is a signal for how to handle the exception, but the runtime code doesn't require that everything inherits from those (and in fact we handle other exceptions from connectors as well, we just would prefer that the connector think about how it wants the framework to handle possible errors).
It should now be possible to make up the `RoleArn` and `SecretAccessKey` using the seeded RNG rather than by concatenating strings like this. They can reasonably be different each call.
I really think this should a hard-coded value and not passed in from the environment. I don't think we gain much by accepting it from outside, and I envisage it being the sort of thing I have to look up each time I come across it. The `BUCKET_NAME`/`KEY`/`TOKEN` inputs are clearer (despite that the `KEY` and `TOKEN` used here could be generated internally if we could do so deterministically).
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
The official name is "Docker SDK for Python" ([docs](https://docker-py.readthedocs.io/en/stable/)).
you should specify 'docker python library'
You might also want to say which versions you support.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
nit: put `@Override` on its own line
Does this actually need to be public? It looks like the SchemaBuilder uses names anyway and expects resolution to work internally. Adding another Schema class seems like its going to get confusing.
This could be final.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I know this is only a test class, but returning `Collections.emptyMap()` would be the nicer thing to do here
nit: Capitalize `p`.
Update the above TODO with only admin client left.
Same for `addThroughputSensor`.
@rodesai I see your point here. However, the downside of not throwing is that we will also not notice the bad behavior in our tests like the soak tests. I personally prefer to improve tests instead of downgrading the reaction to bad behavior. Assume in future somebody makes a change that breaks the assumption of the non-shared metrics registry, we would find this bug immediately during development instead of during production. Another option that comes to my mind is to classify exceptions that originate from the metrics framework differently in the uncaught exception handler, but that would probably need some more work.
Nit: let's avoid moving all of these imports around. Our convention is to place the `java` and static imports at the end, and moving them unnecessarily just complicates maintenance.
Could we use ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG etc instead of hand-coded strings? It is less error-prone for possible future changes.
Ah, my bad. I think the variable I had in mind is actually called `Double.BYTES`. Not 100% sure it's defined for all possible primitive types, but I would hope so
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
That sounds good to me ð
I think we could leave this called `simpleString`. The convention seems to be not to call out the existence of the Validator explicitly in other calls. I see that this might cause some issues with overloading but I think they're surmountable.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
the reason why I suggested to make it configurable is that we could pass in our own values in tests that's all... not a big deal
Can change this to the new autoclose functionality in Java 7 now that the codebase is on it: ``` try (ZipFile zipFile = new ZipFile(pluginFile)) { // ... } catch (Exception e) { // ... } ``` Thereby dropping the entire `zipFile`-related code from within the `finally` block.
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
did you plan to add here the list of nodes or something? looks like there is a missing argument.
It *looks* to me like this will hit a `NullPointerException`.
Just to avoid allocating an empty list in the common case where we don't throw any exceptions.
Sounds good. I prefer it the way you suggest anyway. I'll change it.
Why not make it `final` and return an empty list? It seems better to avoid using `null` if possible
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Just to avoid allocating an empty list in the common case where we don't throw any exceptions.
Sounds good. I prefer it the way you suggest anyway. I'll change it.
Why not make it `final` and return an empty list? It seems better to avoid using `null` if possible
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
looks like this is not passed to Metrics object. we can use reporter instance at below line.
nit: new Integer(1) => Interger.valueOf()
using `assertThat` is nicer as it gives better failure messages. `assertThat(sourceNode.getTimestampExtractor(), instanceOf(MockTimestaampExtractor))` in other places, too
nit: There is an extra space before `+`.
typo: kStreamhould... -> kStreamShould In fact i'd probably rename these methods to begin with should, i.e., `shouldAddTimestampExtractorToStreamWithOffsetResetPerSource` etc
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
Please break this down into a couple of lines to make it easier to read. Also, the `distinct` call should be unnecessary for this bug, and only introduces extra work that distracts from the main problem.
Should be changing double quotes to single, if at all. I wouldn't really worry about it though.
Looks good, my mistake.
I'm not sure the usage of `settings.FORMAT_MODULE_PATH` is correct here. Now the `format_module_path` keyword argument is no longer used (thus the failing test, I think).
don't need the trailing comma
"new" -> "now"
Rather than filtering ourself, we could alternatively pass prefix as glob to newDirectoryStream, and it would follow filesystem rules.
Import them from compat module: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/common/_collections_compat.py#L37 ```python from ansible.module_utils.common import MutableMapping, MutableSequence ```
After some thinking: it does not make sense to have this `HAS_TOML` with fallback to `AnsibleTomlEncoder = None` because you're not going to use it anyway. Just check for `ImportError` where you import this plugin and that's it.
```python from functools import partial ```
This was probably discussed in the KIP, but obviously the downside is that users won't get any warning or hint that they should transition. But I guess we don't get a substantial benefit from removing `AdminClient`, so maybe we'll just never do it.
This is a breaking change, right? Same for the other `create` method in this class.
Not for `Streamable`. If you switch it to `Writeable` then yes. But that might make sense to wait for another PR? I don't know, I haven't been following this one very closely.
nit: new lines are generally not recommended to break object type declaration with object name. For this specific line I think we can still make them in one line.
should it be `final` ? seems to be a const semantics
ditto on the properties and the driver.
nit: `final` + next line and might as well do the previous while you are at it ;-)
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Just want to point out that this assumes all controllers are voters. It would be worth a follow-up to support controllers as observers as well.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
This name seems backwards.
I don't think we need a synchronized block here since `start()` is always called once at the very start
I see your point, but I do also not see the need for an internal state for which we need to avoid invalidation. Variables `numStandbyReplicas` and `numStandbyReplicas` are configs that can be stored as member fields of `ClientTagAwareStandbyTaskAssignor` or passed along to the methods that need them. Variables `tagKeyToTagValuesMapping`, `clientsPerTagValue`, `standbyTaskClientsByTaskLoad`, and `clientStates` can also be passed to the methods that need them. Avoiding state makes reasoning about code simpler and here it seems possible to avoid state. See `HighAvailabilityTaskAssignor`, it does not have any state.
s/assignments/oldAssignments, and name could be simplified as `toNewAssignment`
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
This name seems backwards.
I don't think we need a synchronized block here since `start()` is always called once at the very start
Not really against the style, just a nit of mine (My IDE recommends removing it). feel free to ignore.
nit: Could just to `new ArrayList<>();`
whenever referring to Connect as the framework (as opposed to the verb) I'd use `Connect`. Same as `Kafka cluster` and `Connect framework` a few words after. It's easy to miss that you are referring to the framework if it's not capitalized.
also can it be final
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
You might consider using `OptionalDouble`.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Nit: move these two static factory methods above the non-static member variables, so all static and non-static members are together.
We should mention somewhere that users should prefer this new assignor for newer clusters.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I have a similar concern here for when entry.getValue is not a Map
I have a similar concern here for when entry.getValue is not a Map
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
nit: put `@Override` on its own line
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
Just thinking about is once more: why do we need to make this interface public? We have `Named` as public method to use `NamedOperation` and other public control objects (`Consumed` etc) that implement it -- but I actually think, users don't need to know about this interface? \cc @fhussonnois @bbejeck @guozhangwang @vvcephei @ableegoldman
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
nit: put `@Override` on its own line
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
Just thinking about is once more: why do we need to make this interface public? We have `Named` as public method to use `NamedOperation` and other public control objects (`Consumed` etc) that implement it -- but I actually think, users don't need to know about this interface? \cc @fhussonnois @bbejeck @guozhangwang @vvcephei @ableegoldman
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: extra blank line ```suggestion ```
Can we actually include UUID type? It always 16 bytes.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
It's better to avoid "double-brace initialization", which is actually declaring a new anonymous subclass of HashMap just to add some stuff to it in one statement. A little while back, I added this method for accomplishing the same thing more safely: `org.apache.kafka.common.utils.Utils#mkMap`, and the accompanying `org.apache.kafka.common.utils.Utils#mkEntry`.
Yes, this should on an internal package (eg `common.internals`).
@gwenshap meant that `kafka.common.Topic.InternalTopics` should be removed in favour of the `INTERNAL_TOPICS` defined in this PR.
It would be good to have constants instead of hardcoding the fields in many places.
this four lines can just be one line: `Topics.validate(topicName)`
`Integer.toString` is a slightly more concise way of doing this.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Why do we need to do this? `log` is private and is not used
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
nit: could use Utils.mkSet
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
This is a breaking change, right? Same for the other `create` method in this class.
nit: no new paragraph required
I understand why. But other contributors might not (and I might forget why in the future and want to change it...). It's not obvious from the code and thus should be explained with a commend, IMHO.
Sounds good. Would be helpful for users to understand. The exception message should explain what they need to do to avoid the exception.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
This feels wrong that we have a "helper" that schedulers extend from. That implies that the `Scheduler` interface is wrong. /cc @headinthebox
It's not necessary to have `PENDING_VALUE`, `RUNNING_VALUE`, etc. since you can just call `PENDING.name()` to get the string `"PENDING"`
Oh, and a typo which I would like to make KNOWN (or UNKNOWN?! ... I would pick a pun over clarity any day :) )
public access? I can see this being accessed by another package too (such as `rest.resources`)
Just for reference: fixed via https://github.com/apache/kafka/pull/5588
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
nit: We use singular verbs in other functions (e.g. line 54 above), would be better to be consistent.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
probably not required to do a special logic for ConnectHeaders. The equals check using iterator below should probably be suffice.
nit: one too many line break? :)
No tabs in python code.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
this should be declared volatile (considering the double-checked locking below)
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
getters should not use get. i.e. use `networkDevice` here, etc.
this should be declared volatile (considering the double-checked locking below)
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
might be true now, probably not true long term. also probably depends on where this is used - in a transformation for a source connector, it's likely for the foreseeable future that the headers are empty; for a sink connector, anywhere people have started using headers it is very unlikely they are empty. the optimization is fine, i just watch for these things as they complicate the code and if they appear in the first version of code, usually aren't backed up by real data suggesting they are valuable.
I've seen this a few places -- `SchemaAndValue` already has `SchemaAndValue.NULL` field which does the same thing -- no need to repeat a bunch of times in a bunch of classes.
getters should not use get. i.e. use `networkDevice` here, etc.
this should be declared volatile (considering the double-checked locking below)
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
This could be final.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
Why do we need to do this? `log` is private and is not used
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
otherwise, if you want it for testing, it can be done once in the ctor
ditto here and others below
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
same question as above
same for tests below as well
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
set supports_check_mode=True after the check mode implementation
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
not sure why you moved all the code to _version ... why not keep here? seems like useless jump
`< Callback >` this explicit type is not necessary.
I'm about to change this in #22586 so that DeleteResponse/IndexResponse/UpdateResponse don't have to repeat all these checks. There will be a assertDocWriteResponse() method, and here we only have to check for UpdateResponse specific fields.
Good that we have a test case where the expected output is hardcoded instead of generated by the test (avoids issues where a bug in the construction of the string can cancel out a bug in the parsing code. :)
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: add `final` (same below)
nit: remove the redundant line. Same as below.
The test name is not self describing: what about `shouldAlllowToSpecifyRocksDBConfigSetterClassAsString`
`asList` -> `Collections.singletonList`
use `try-catch` instead of `expected` annotation -- not a single line test.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
This is `ListDeserializer` hence, shouldn't we use `ConsumerConfig.LIST_KEY_DESERIALIZER_INNER_CLASS_CONFIG` ? The "SERDE" config should be used in Kafka Streams codebase only? (Same for value, and for both inner types in the next line).
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
Cool. I think the fewer configs overall, the better. If we can get away with just the Serde configs then let's do so to keep the API surface area smaller for users ð
ok I understand better your intention now. I think it is still weird from a user perspective to have to pass in `null`, not loving the nullable arguments. That said it is not a huge deal, can leave as-is.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
thanks for adding this
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
same 1+ randomInt
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
same 1+ randomInt
Please could you assert that the content of the message is correct? (`expectThrows` returns the exception thrown, so you just need to assign it to a variable and check its message.)
ditto here and others below
this is not needed. createIndex automatically reroutes.
Hmm, we're using a raw type here and a few other places. This is discouraged (type checking is disabled in these cases). If we don't want to propagate the generics when we use the superclass, we should probably drop them.
same for tests below as well
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Wouldn't it be much easier to do the following: ``` public Connector createConnector(String listener, String name) { ... String hostname = ... int port = ... ... if (name == null || name.trim().isEmpty()) { name = String.format("%s_%s%d", PROTOCOL_HTTPS, hostname, port); } connector.setName(name); ... ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I don't think this is necessary. The SecurityFileChangeListener thread may not yet have started, but the watch services are already registered after `factory.configure(configs)`. The file change below should queue a change even if the thread hasn't started.
Yes, we should remove `sleep` in the tests and ensure they work without them.
rewrite test as above using `assertThrows()`.
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Wouldn't it be much easier to do the following: ``` public Connector createConnector(String listener, String name) { ... String hostname = ... int port = ... ... if (name == null || name.trim().isEmpty()) { name = String.format("%s_%s%d", PROTOCOL_HTTPS, hostname, port); } connector.setName(name); ... ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
same for tests below as well
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
i.e., add `fail` after this line
Should we remove this class? Currently they can only be 2 types of connectors, source or sink connectors. This seems to introduce a third implementation of the `abstract Connector` class, but testing seems sufficient without it.
use `try-catch` instead of `expected` annotation -- not a single line test.
req: Since we do not need to validate `valueTransformer`, could you please remove it from the `verify()`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I think you can initialize the capacity.
Doesn't hurt, I guess, but it might obfuscate the fact that all the parsed aggregations don't implement equals/hashCode. At a quick glance people might think all subclasses properly implement equals()...
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
I don't think it's important for now
This sucks.. I want to see how big of a deal it is to keep things as they were. Indeed snapshotting a commit will keep it's translog around but I'm not sure anymore it's worth this kind of wrapping layers. Maybe we should invest in faster clean up on those snapshotted commits. I'll reach out to discuss.
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
req: we'll never hit this, as `taskToCaughtUpClients` only contains tasks _with_ caught-up clients IIUC. Can we just construct `unassignedTasksWithoutCaughtUpClients` as the set `totalTasks - taskToCaughtUpClients.keySet`? We can do that in `assignTasksWithoutCaughtUpClients` and remove `unassignedTasksWithoutCaughtUpClients` from `assignTasksWithCaughtUpClients` entirely
req: drop the `!caughtUpClients.isEmpty()` check here, if it's in the map it should have at least 1 caught-up client
Fine with me -- it's just a "prop" after all. FWIW I generally find these functional-style methods harder to read, but for whatever reason in this case I was finding the original a bit hard to understand and thought this suggestion helped to "get to the point" faster. But of course it's always easier to read your own code than someone else's ð
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
req: I think we want to introduce some `acceptableLag` config within which a task is considered caught-up, otherwise this is way too strict. ie the condition should be `lag <= acceptableLag`
req: we'll never hit this, as `taskToCaughtUpClients` only contains tasks _with_ caught-up clients IIUC. Can we just construct `unassignedTasksWithoutCaughtUpClients` as the set `totalTasks - taskToCaughtUpClients.keySet`? We can do that in `assignTasksWithoutCaughtUpClients` and remove `unassignedTasksWithoutCaughtUpClients` from `assignTasksWithCaughtUpClients` entirely
req: drop the `!caughtUpClients.isEmpty()` check here, if it's in the map it should have at least 1 caught-up client
req: rename `clientHostingTask` -> `previousHostingClient` (or similar)
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
ditto here and others below
same for tests below as well
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
I think the assertion on 219 would pass even if the 1st mocked interaction never happened. Do we need something to tighten up the expected behaviour? Maybe something like: ```java verify(kafkaBasedLog, times(2)).send(any(), any(), any()); ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
Can be final
Nit: I know this was inherited from the existing code, but it would be nice to do something like `ByteArrayDeserializer.class.getName()` for serializers and deserializers.
Hmm. I feel the `final` would be worth capitalizing the var name.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
Ok, I'm convinced :) Thanks for clearing up my confusion.
nit: add a size? There are a few cases in here where we could do this.
Can be final
Nit: I know this was inherited from the existing code, but it would be nice to do something like `ByteArrayDeserializer.class.getName()` for serializers and deserializers.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
Not sure what the intent is here, to increment the number between each test, or between each instance of this integration test class within the JVM... It actually does the latter.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
nit: extra space before `anyObject`
nit: the `20` here means version 2.0, since we mistakenly made a compatible breaking change in 2.0 and this test is specifically for that. So let's just keep the suffix.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
nit: extra space before `anyObject`
nit: the `20` here means version 2.0, since we mistakenly made a compatible breaking change in 2.0 and this test is specifically for that. So let's just keep the suffix.
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
We should fail if the put replaced an existing entry? Or rather, not replace if the mapping already exists (ie where a 2 different whiteslists are whitelisting methods on the same class). But surely they can't be allowed to have different names in painless for the same java class (one would overwrite the other here).
nit: Starting a message with lower case feels a little unusual.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
We should fail if the put replaced an existing entry? Or rather, not replace if the mapping already exists (ie where a 2 different whiteslists are whitelisting methods on the same class). But surely they can't be allowed to have different names in painless for the same java class (one would overwrite the other here).
nit: Starting a message with lower case feels a little unusual.
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
The first two of these fields are unused. I think that's right, and we should remove them and also `ec2Bucket`, by generating the key and token and then passing them into the bucket's constructor.
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
Probably worth asserting that they return success. I've never seen them not do so but if they ever start then this test won't have many segments and will fail in strange ways to anyone trying to debug it.
Is this any quicker if you use bulks? I tend to do that out of habit.
Its a bit silly that an instance of this will return true for instanceof ImmutableTestCluster - its certainly not immutable. Not a big deal, probably.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
retainLatest() and this method have a lot in common. We could potentially refactor it, but not too concerned if its left as-is.
i think leaving as is should be fine atm, and tbh at least they are both close enough together to be easily modified together. if we think this is useful enough, i'd file a jira dependent on the jdk8 update so we can follow up.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
nit: list the members list here would help trouble shoot.
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
nit: list the members list here would help trouble shoot.
Typically, most users push logs to something like elastic/splunk and should be able to lookup the logs from the archive. I'm not too concerned about this since properties file based credentials store shouldn't typically be used in a production environment. So,I'm fine leaving the log statement in here. But let's see what the committers have to say fro this :).
do we really need that we matched it? Can't we do all all of this is a single log statement? We can include size of credentials map and authenticated boolean. This will help keep the old structure.
Let's use try with resources here and the other test so that the file is closed after it's used.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
it is preferable to have descriptive test names, i.e., `emptyIteratorAlwaysReturnsFalse` `emptyIteratorPeekNextKeyShouldThrowNoSuchElementException` etc
Nit: somehow I don't like `blah`. Otherwise LGTM
Are you planning to add this? It should be straightforward once you set a limit on the maximum size.
I see that you are actually printing the sink nodes. I'm wondering if this if condition is necessary since in line 85 this function will be skipped anyway.
There's a trailing comma issue
need a newline after the group before the underline, and a double newline after the underline
The second newline should be left for the caller, as it otherwise causes an extra line before 'Dependents' in the enriched RST
these 2 lines shouldn't be here
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Nit: I think you can leave out ESTestCase here.
I think you meant `get_ellipsized_page_range` here. Use `number` instead of `page_num` which matches the argument name used by `Paginator.get_page()`.
There is no need to provide a value for `max_pages_num` - I think it should be calculated automatically: ```python (self.on_each_side + self.on_ends) * 2 ``` Otherwise developers can provide values that are incompatible with each other...
In Python3, `super()` is enough.
That's right - you need to call them out explicitly.
It *looks* to me like this will hit a `NullPointerException`.
When you use it with an instance of `PreBuiltAnalyzers`.
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
ok...but client depends on the transport service anyway no? I think I don't get it
did you plan to add here the list of nodes or something? looks like there is a missing argument.
```suggestion elif databases[DEFAULT_DB_ALIAS] == {}: ```
I presume it was intentional to change this to `.update()` so that `self._settings` is modified? I expect that could just do this instead: ```python databases[DEFAULT_DB_ALIAS] = {'ENGINE': 'django.db.backends.dummy'}
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Is there a `Locale` that would work for lowercasing these that would work and not vary by the JVM config? I think based on the restricted characters, just using something like english should be ok.
nit: I don't spot any, but safer to avoid typos by just having constants for these
It is probably better to use nanoTime here so you don't get clock skew giving you weird numbers. Not like it matters a whole lot here though.
Nit: If we do fix up the above example of this it makes sense to fix this up too.
How about we reset the offsets between tests? I think that may be what you're suggesting. It would be cleaner not to accumulate metadata over time.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
Just a reminder, `ByteBuffer` again :)
It's not super-important, but it probably makes sense to set -1 as the default for `ProducerId` in `InitProducerIdResponse`. Same for `ProducerEpoch` But maybe keep the explicit assignment as well since that makes it very clear...
Let's use `Map` on the left side instead of `HashMap`
Is this method used anywhere? The only caller I can find is `DeleteGroupsResponseTest` and that also test the Errors is None. If we decide to keep it, we can remove `.code()` from both sides of the equals
I would say it's important _not_ to be able to create bogus requests. ;) We can introduce specific mechanisms for testing, but a public constructor for a request should do its own validation.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
That is right, since Kafka Streams processor topology traversal is Depth First, when we finished one child route we need to go back to the next child route, and hence resetting the the currNode.
I think it is important to keep different classes on the client-side so that we can have more type safety and potentially add some methods to only eg. avg in the future
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
super-nit: this should say `Check that this is a Decimal`, not `date`. repeated below for time and timestamp, but slightly less egregiously :)
Got it. May be we could have something like SchemaAndValueUtils to include such utils for it. Just didn't feel great seeing this method in the ConnectHeaders class.
Just a reminder, `ByteBuffer` again :)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
Nice, thanks for the update. Looks good
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
nit: remove the redundant line. Same as below.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I think we should provide some context on the exception here.
nit: add `final`
`UnknownTopicOrPartitionException` is the cause of the actual exception `e`, so we cannot just catch it here.
Might be better to add a catch-clause for this case instead? ``` try { ... } catch (final UnknownTopicOrPartitionException ignoreAndSwallow) { } catch (final InterruptedException | ExecutionException e) { throw new RuntimeException(e); } ```
nit: add `final`
I think we should provide some context on the exception here.
nit: add `final`
`UnknownTopicOrPartitionException` is the cause of the actual exception `e`, so we cannot just catch it here.
Might be better to add a catch-clause for this case instead? ``` try { ... } catch (final UnknownTopicOrPartitionException ignoreAndSwallow) { } catch (final InterruptedException | ExecutionException e) { throw new RuntimeException(e); } ```
nit: add `final`
I think it will be cleaner? not a biggy though
> Why do you think that? Does having a hard reference to an object guarantees all weak references to it are kept around? I was worried the GC might decide to remove a weak reference just because, in which case we will create another marker. Again - not saying this is wrong, but looking to learn.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Same concern regarding the leniency.
Same concern regarding the leniency.
I think it will be cleaner? not a biggy though
> Why do you think that? Does having a hard reference to an object guarantees all weak references to it are kept around? I was worried the GC might decide to remove a weak reference just because, in which case we will create another marker. Again - not saying this is wrong, but looking to learn.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
You could look at `GradleUnitTestCase` it does the same by pulling int the randomized runner only. What I was wondering about w.r.t order is that if it really makes sense to have it fixed. If all we are doing is going trough methods sequentially what advantage does it bring to have them in separate methods ? Maybe better error reporting ? Should we keep the randomized method order and make sure it actually works like that? I'm not saying we need to change it just looking to understand the implications.
seems dangerous to use the thread name to check ownership. might be safer to check reference equality on `Thread`
I am wondering if we should throw an `IllegalStateException` here, because it seems illegal to me to request a lock of a task directory in a state directory that does not exist.
add space after `=`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think it is not OK because of the lack of symetry of the equals method: although `new ClosestNestedParentFilter(parentAggregator).equals(parentFilter)` would return true, `parentFilter.equals(new ClosestNestedParentFilter(parentAggregator))` would return false, which means we might pollute the filter cache with a new filter that will never be reused every time this aggregation is used. So I think we need to fix the root issue, that is that parent aggregators should be fully constructed before constructing sub aggregators, before fixing this one.
I think we need a better fix for this: it's bad that we pass the parent aggregator in but it's not fully constructed yet. Additionally, I'm concerned that the equals method of `ClosestNestedParentFilter` is not symetric, this could lead to duplicates in the filter cache.
we need to remember to update this when we add the reverse_nested aggregator :)
I don't like it much when constructors have side-effects. Can we maybe move the API from ``` java new PidFile(path, true); ``` to something like ``` PidFile pidFile = PidFile.create(path, true); ``` to make it clear that there is something happening (since there is a verb)
inventory plugin, not module ... also we can use 'short form' for licenses now
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
I think we can check the beforePart == null out of the if(!..equals) and it will make it cleaner.
We need to close this thread pool at the end of the test
this seems to be called when `upgrader.needsUpgrading(shardId)` indicates true, so this is not needed. Do we want an assert `needsUgrading(shardId)` instead? if we want the log (which should be debug imho) it should be moved to the calling function. It's not visible now.
also, I think the opened channel needs to be closed at one point
should be cached thread pool, the default constructor does the right thing here
I'm fine as well, will make a reference to 10055 of this PR
It seems not possible in Java
Maybe an `assert` for unit tests (are `asserts` common in Kafka code base?). As `WrapperSerde` is private, nobody else can use it -- so no need to check for `null` IMHO.
ditto here and others below
Do we need to do this at this point? I guess so at it makes sense to have `sourceTopicNames` match what's in `nodeToSourceTopics`. I'm only asking as we never had this before and I'm curious as to why.
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
this _technically_ changes the public interface and would require a KIP if we're being pedantic about the process. I personally think we can go by without a KIP but we obviously need a committer to say what they think
I may be wrong, but my understanding was that 400 and above are errors for which error response is returned in `connection.getErrorStream`, while the code is currently reading response from the error stream for >= 300.
It should be robust in case of some missing fields.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
s/payload is/payloads are
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto on removing before/after.
ditto on (what I think is) the impossibility of this condition being false.
Ditto on removing these before/after methods.
ditto on removing before/after.
Ditto on removing before/after
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
ditto here and others below
I think we can now remove this condition as the client can not be null because we throw now `new ElasticsearchException("Unable to configure Azure compute service", e);` in the CTOR
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
same for tests below as well
It should be robust in case of some missing fields.
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
It'd be super nice to explain that we only need this because of `PreBuiltAnalyzers`.
Good catch, thanks for cleaning this up!
Well, it's not at the end of the file right? But if you'd prefer to keep it that's fine too, was just a "super nit" suggestion ð
super nit: extra blank line
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
While we should have the call to `super` above, do we really need this given that the default `available` implementation in GZIP is not very helpful? i.e., ``` super.available(); return inf.finished() ? 0 : 1; ```
nit: extra blank line ```suggestion ```
Do we really need to print `super.toString`? Ditto above.
We also need a test to validate that some extensions can be ignored (neither valid nor error).
Does this test ever encounter this exception? I don't think we will be able to backport this test to < 2.6 because the method won't exist at all, much less generate the exception that is being caught here. If anything, this generates a less informative NPE later in `put`, and hides the actual root cause.
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I would rather test this by calling the newFilter static method. In fact the check that we left there instead of relying on validate is there ony to protect other code paths from the outside (newFilter is public)
It should be robust in case of some missing fields.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
Can we remove `throws IOException` and write: ``` java try { if (!Files.exists(initialSettings.v2().pluginsFile())) { Files.createDirectories(initialSettings.v2().pluginsFile()); } } catch (IOException e) { displayHelp("Unable to create plugins dir: " + initialSettings.v2().pluginsFile()); System.exit(EXIT_CODE_ERROR); } ```
Maybe we can use `setIfExists`.
Wonder if there's any harm retaining the top-level error regardless of the version. Seems more consistent with how we handle the case of constructing from a `Struct`.
Same question here as earlier about the `Locale`
this name is not good. there is no *error* involved. I think you should maybe name it `generateFailureXContent` or somethign like this
extract to variable
```suggestion waitForCondition( this::checkForPartitionAssignment, CONNECTOR_SETUP_DURATION_MS, "Connector tasks were not assigned a partition each." ); ```
This cleanup seems a bit awkward. It assumes that tests will initialize the driver but not close it, which seems like a strange abdication of responsibility. I think it would be cleaner and clearer to get rid of the driver field entirely. Tests that need the driver already initialize it; they can declare it as a local variable as well. Then, they clearly need to close it as well. Since `TopologyTestDriver` is `AutoCloseable`, one option is to declare the driver in try-with-resources style: ```java @Test public void myTest() { try (final TopologyTestDriver driver) { // the test code } } ```
nit: remove empty line
ditto on removing before/after.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
maybe randomize the number of shards and their states? (unassigned/initializing/closed)
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
maybe call this pendingTasks or resolvedTasks? I got a bit confused by the valid notion - some of the tasks are marked as successful but are not valid :)
I see now that MoveAllocationCommand is not touched by the PR. I think moving to NamedWriteableRegistry is a good idea, but I'm fine with putting it out of scope for this PR
can we call this `explainOrThrowMissingRoutingNode` ? the docs can read something like "a utility method to handle the case where a disco node can not be found in the routing table. Typically this would mean it's not a data node"
Callers of this method can just do `allocation.routingTable().shardRoutingTable(shardId).primaryShard()` these days (if we add an overload for shardRoutingTable which takes a shardId). I don't think it's worth having this utility method. (I know it existed before - we have progressed since it was written :))
I mean random number of replicas with random combination of non-active states
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
makes sense - treat whatever I wrote as a draft that can be adjusted as more metrics are added
I think we can use `Class.isAssignableFrom` to see what type it is rather than catching the exception. See `ChannelBuilders.createPrincipalBuilder` for a similar use case.
well, i thought a method reference would work here for the hash map, but I tried it and it doesn't seem to work. ð¤
nit: It seems clearer to use `ConsumerPartitionAssignor.class` directly below.
Then the log message should state the reason (e.g., the class was not found) and that the named provider will not be used. However, it does seem strange that this is technically an invalid configuration, so why would we not just throw a ConfigException? Note around lines 723 how any configuration property whose value is a Class name will be invalid if a `ClassNotFoundException` is caught, and this leads to a `ConfigException`. Silently ignoring seems at best inconsistent but at worst a bad idea.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
nit: can we call it getParseFieldMatcher? now that we have an interface it should be easy to rename all the existing impls at the same time. If you feel like it should be a follow-up, I am fine with that.
typo `to to` (also missing `.` at the end of the sentence)
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
```suggestion /** * The value of {@link StreamsConfig#APPLICATION_SERVER_CONFIG} configured for the Streams * client. * * @return {@link HostInfo} corresponding to the Streams client */ ```
Existing issue, space should be after the colon.
It looks like `(' %s' % order).strip()` can simply be `order` now.
put the closing parenthesis on the next line
`%(expressions)s)` not `%(expression)s)`. You're missing the `s` at the end of `expressions`
I think these _could_ be: ``` __str__ = render __html__ = render ``` Avoiding +1 depth (and it's faster). Off the top of my head, the only reasons _not_ to would be: - `x.__str__` would report `<bound method X.render of ...>` instead of `<bound method X.__str__ of ...>` - you _could_ technically manually call `x.__str__(template_name='a')` but I mean, who's doing that? Discuss amongst yourselves whether to change it, I don't think it really matters much :)
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
This could be final.
Nit: you can remove `value =`
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
use `try-catch` instead of `expected` annotation -- not a single line test.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Wildcard imports should be caught by checkstyle, and should fail the build. In any case, please replace with non-wildcard imports.
We would like to avoid wildcard import in the code base.
thinking aloud: even though we are binding to a specific StateStoreProvider implementation here, it seems fine,since there are n't any other really in a topology
The purpose of this change was to highlight that the data structure is required to be concurrent. Of course if a method that existed in `ConcurrentMap` and not in `Map` was used, that would be a hard requirement. `putIfAbsent` used to be such a method but that's not the case after 1.8. In any case, the use of the more accurate interface is valid even if we don't explicitly use methods that don't exist in the parent. That's because the need for this implementation to be thread safe is a requirement here.
Since log.error(.. ex) will print the stack trace already, may be we can save re-throwing the exception again. EDIT: if we want to stop the whole process by throwing the exception, we can then save log.error().
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Maybe we could use a different value here.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
Can remove if initialize above
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
extension name must not be empty
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
nit: add `final` (same below)
This doesn't seem to be used.
Could we expose this like the following instead? ``` public KafkaFuture<ListOffsetResultInfo> partitionResult(TopicPartition partition); ``` Then we can keep the map internal.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
nit: add `final` (same below)
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
This doesn't seem to be used.
```suggestion /** * Metadata of a task. */ ```
You might consider using `OptionalDouble`.
Nit: go with single parameter per line.
@vahidhashemian, yes, that's what I mean.
Do we really want anything related to internal topics to be client side? This could change in brokers from version to version and the clients should still work. I understand that for now we have no way to get that information, but we will soon (KAFKA-3306). I imagine removing the client side list would be part of the cleanup once thats available. So whatever exists in the mean time should be private so we don't need a deprecation cycle.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
I think the result does not need to include anything here if we organize the top-level future as a map of members -> the corresponding futures of `Void`.
```suggestion /** * Metadata of a task. */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
Should this be abstract? It feels weird to use it without actually configuring any scripts. I think maybe in `StoredScriptsIT` just extend it and return `emptyMap` there. That seems like a special case of using this.
If you think lots of places will use the empty definition then I don't think it should be abstract. I thought only a few script would use the empty definition though.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
Can remove if initialize above
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
I think the result does not need to include anything here if we organize the top-level future as a map of members -> the corresponding futures of `Void`.
```suggestion /** * Metadata of a task. */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
It's different because the join and split actually do something and have a clear reason for being included. It also correctly handles versions like 3.4.1, which chopping off the end of the string doesn't. ``` >>> srv_version = '3.4.16' >>> srv_version[:-3] '3.4' >>> srv_version = '3.4.1' >>> srv_version[:-3] '3.' ```
I'm not sure what the purpose of the split and join currently are. Shouldn't this be splitting and joining on `.`? ```suggestion loose_srv_version = LooseVersion('.'.join(srv_version.split('.')[:2])) ```
Could we move these two functions to `org.apache.kafka.common.utils.Utils`? And we can then also remove the duplicate sort function in `DefaultPartitionGrouper`.
Is this requirement no longer true? The old logic doesn't match the error message, but you haven't replaced it with anything at all.
This logic tried to enforce a minimum version requirement, which the new code does not. Since it doesn't sound like you have added compatibility with older versions (or have any reason to), why not do something like: ``` min_version = '2.4' if loose_srv_version < LooseVersion(min_version): module.fail_json(msg='MongoDB {0] found, the minimum version supported by this module is {1}'.format(srv_version, min_version)) ```
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Can you use `== false` here...the `!` is almost hidden in all the other text around it...
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
Could you please add some line breaks? This and some of the other verifications are too long.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
does it need to be protected? Also maybe rename to something like collectValue ? I find it weird to call add against the script itself
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
you could rewrite this as ``` ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(config)); assertThat(e.getMessage, ... ); ```
++, it's a java 8 only idiom, which is not a problem for ingest, no backports
I think we shouldn't call the error handler if the error can be delivered or replaced on the normal path.
Maybe use `expectThrows(...)` instead? It is much cleaner and safer than try-catch blocks: ``` java ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(config)); assertThat(e.getMessage(), equalTo("[regex_file] regex file [does-not-exist.yaml] doesn't exist (has to exist at node startup)")); ```
can we remove this one, so it won't be called by mistake? I think only the benchmark calls it, in which case, the benchmark can call the one with the concurrencyLevel parameter using the available processors
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: move parameter to next line
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
can we factor the lentient handling part out in a single mehtod? ``` private Query rethrowUlessLentient(RuntimeException e) { if (settings.lenient()) { return null; } throw e; } ``` man I with we had support for annonymous functions here or macros even :)
nit: add `final`
There is no need to add quotes here. Please remove them from all modules.
So, looking at our existing list of modules, **api_url** is more popular than **server_url**. I guess we need to make sure we are making the right changes wrt. parameter naming. ``` [dag@moria ansible.git]$ grep -rl 'api_url' lib/ansible/modules | grep '\.py$' | wc -l 77 [dag@moria ansible.git]$ grep -rl 'server_url' lib/ansible/modules | grep '\.py$' | wc -l 21 ```
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
These look like leftovers.
Good idea to add this safety net.
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
nit: one too many line break? :)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
Originally this was just intended as a sanity check. However, thinking about it more, it might be better to change it to a much longer period, or even get rid of it entirely. It should not be needed since there is a task `durationMs`, of course. That might make sense as a separate PR, since we should change all the workloads.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Why are we generating the connect internal topic names here? if there's a rule for the topic naming convention it should be defined in one place which is `ReplicationPolicy`.
One issue with c. is that it works for new environments. If users already have MM2 running, it's using topics with the current names.
> Oh no, this lines replace the original props.putIfAbsent(DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG, "mm2-offsets." + sourceAndTarget.source() + ".internal");, etc. not Connect's internal topics. `DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG` is one of the connect's internal topics. ``` private static final String OFFSET_STORAGE_TOPIC_CONFIG_DOC = "The name of the Kafka topic where connector offsets are stored"; ``` My point is users already can control these types of topics using the `DistributedConfig` so there's no point in controlling them again using the separator. The main issue I think we need to fix first is preventing is the replication of these topics.
> only when MM2 is running in standalone mode. They are created in any mode if there is no value for DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG > If the user is running MM2 in connect mode, the user is responsible for configuring DistributedConfig.OFFSET_STORAGE_TOPIC_CONFIG, DistributedConfig.CONFIG_TOPIC_CONFIG, etc. It is what you are meaning. Right? Small clarification, users can use `DistributedConfig` with any mode (even standalone) to override the name of these topics. And they always had the power to do so, even before KIP-690, and if this new topic name didn't match the `isInternalTopic` policy, it would replicate. The PR's approach is trying to control the Connect topics that MM2 needs to set up using the separator; this is where I am not sure it's a minor fix or something that requires a KIP that follows KIP-690. My suggestion, is to introduce the minor fix first and propose another KIP if you believe that Connect internal topics created by MM2 Workers should to be controlled by the separator as well.
We did not have this check before, why is it needed? Also checks here are only applied when running in "driver" mode.
This idiom is used across a bunch of the tests, which is fine, but it's also a pretty generic bit of logic. I wonder if it would be better to move it to TestUtils. In fact, there are already a couple of utilities there for comparing iterators, and I bet there are also Hamcrest matchers that compare iterators. I'm fine with this as-is, if you prefer it; I just wondered if you knew about those other options.
I like the use of `Optional`. I think, you could make it even simpler: ``` final Sensor sensor = Optional.ofNullable(metrics.getSensor(fullSensorName)).orElseGet(() -> { final Sensor newSensor = metrics.sensor(fullSensorName, recordingLevel, parents); threadLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName); return newSensor; }); ``` Please use the correct indentation. We use 4 spaces. Same applies to the changes below.
The number of elements is not always 1. Each created thread-level sensor is added to this queue, e.g., `processLatencySensor`, `pollRecordsSensor`, etc. Check out the callers of `threadLevelSensor()`. Each queue contains all thread-level sensors for one single stream thread.
Probably not, and since sensor names are only used for internal bookkeeping there should be no compatibility issues with the change.
Why not organizing the thread-level sensors as cache-level sensors as well? I.e. `Map<String, Deque<String>> threadLevelSensors = new HashMap<>()` where the string key is just `threadName`, since we will only remove sensors for the whole thread at once.
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
You might consider: ```suggestion try (final KeyValueIterator<String, String> scanIterator = forward ? stateStore.range(null, null) : stateStore.reverseRange(null, null)) { TestUtils.checkEquals(scanIterator, dataIterator); } ```
Do you think it would be clearer if we don't rely on the defaults, but just explicitly include both branches? Oh, also, this isn't an immutable builder, so you can just do: ```suggestion if (cachingEnabled) { stateStoreConfig.withCachingEnabled(); } else { stateStoreConfig.withCachingDisabled(); } if (loggingEnabled) { stateStoreConfig.withLoggingEnabled(new HashMap()); } else { stateStoreConfig.withLoggingDisabled(); } ```
should we put `kafka` and `numThread` directly into `props` and reduce number of parameters here (would also simplify all the "passing through" code.
Log the **node** versions? Can also be done directly in the loop where you are adding the nodes :-)
This is no longer used, could be removed
we throw the exception and thus take care of the interrupt. We don't need to set it...
this is not needed. createIndex automatically reroutes.
OMG `== false`! ð±
same for tests below as well
ditto here and others below
You should be able to collapse this to `IOUtils.close(this.current, uncomittedTranslogs)`
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Ah! I misread this as turning `logAll` *on* instead of *off*. Now I get it :)
you are perfectly right Christoph, let's merge the two and keep the existing class.
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
I think it's always a single node cluster, but I'm good to keep it like this.
look into `StreamInput#readMap`
Nit: add `final` to both parameters -- please follow a "one parameter per line" formatting.
why do you need `CopyOnWriteHashMap` here? you don't really edit the map, you only replace it.
sounds great thanks
we can use Writeable here instead of Streamable so fields can become final and default constructor can go away
Nit: `final` and formatting
Nit: add `final` to both parameters -- please follow a "one parameter per line" formatting.
why do you need `CopyOnWriteHashMap` here? you don't really edit the map, you only replace it.
sounds great thanks
we can use Writeable here instead of Streamable so fields can become final and default constructor can go away
Nit: `final` and formatting
I think it's always a single node cluster, but I'm good to keep it like this.
Same minor nitpick about whether or not we need to check for an empty group ID.
We should add doc string that "for properties user specify both with and without the prefix, the one with the prefix will be used, only for BOOTSTRAP_SERVERS_CONFIG it will ignore the prefixed one but always try to use the non-prefixed one, since currently KS is only supporting to read / write from the same Kafka cluster", etc.
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
@rajinisivaram The login callback handler class isn't getting its #configure(Map<String, ?>, String, List<AppConfigurationEntry>) invoked. Perhaps it might be better to treat the login callback handler class the same way the client and server callback handler classes are treated, which is to create/configure them in SaslChannelBuilder? Note that the login callback handler class is potentially used both on the client side **and** on the server side (it is used on the broker when the mechanism is the inter-broker protocol).
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
We should read the metadata inside the while loop since it could change.
nit: could use Utils.mkSet
nit: add a size? There are a few cases in here where we could do this.
The other constructor calls the parameter `sampledStat`. We should be consistent.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
I think we should call `deserializer.configure(...)` here
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
nit: could use Utils.mkSet
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
This should be done in reset()
ditto here and others below
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
nit: one too many line break? :)
same for tests below as well
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
maybe just : ``` final ShardRecoveryContext shardContext = ongoingRecoveries.computeIfAbsent(shard, s -> new ShardRecoveryContext()); return shardContext.addNewRecovery(() -> createRecoverySourceHandler(request, shard, shardContext)); ```
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Adding the exception is fine, but you can just throw it directly: ``` throw new OffsetOutOfRangeException(...)` ``` Not need to assign it to variable first :)
variable exception unnecessary
Let's stop this on shutdown.
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
not sure this suppress warnings is needed
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Adding the exception is fine, but you can just throw it directly: ``` throw new OffsetOutOfRangeException(...)` ``` Not need to assign it to variable first :)
variable exception unnecessary
Let's stop this on shutdown.
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
You could submit a minor follow-up if you like.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
You might consider using `OptionalDouble`.
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
nit: could use Utils.mkSet
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
Do we want to consider using a configuration for this and other spots where we have hard-coded values? With KIP-276 merged users can specify different timeouts per consumer type.
Nit: -> `messagePrefix + "It shouldn't be null.")` (remove space -- this allows to hand is an empty prefix without getting an undesired whitespace (ie, `""`, if prefix is not desired). Similar below.
`doWork` is just one iteration. `ShutdownableThread` has the loop. I'm ok with the change, but we probably will need to copy over some of the shutdown logic.
Was just thinking about how long a. transaction might possibly be open. 1 minute SGTM
nit: move `windowBy()` to it's own line -- also `count()` (similar below)
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It should be robust in case of some missing fields.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
@rajinisivaram I think @guozhangwang has observed unnecessary empty stub files cluttering the code base in the past, and is suggesting that as a pattern to avoid. Correct me if I'm wrong, but the way this logic is structured, it looks like like very little extra effort to add a default properties file as soon as non-empty defaults are needed (add the file, and switch to `self.prop_file = self.render(...)` Since this is such a minor edit, having an empty stub file in place doesn't really buy much. As for rendering missing templates as empty strings in ducktape - I don't think this is the right approach, since it would hide error conditions and potentially cause confusing behavior. For example, if the user's intention is to use a nonempty template file, but the location is wrong, he or she should receive an error (easy to diagnose) than potentially start up the service with different settings than intended (harder to diagnose).
As mentioned above, to avoid empty dummy files, we can just do something like this for now: ``` self.prop_file = "" self.security_config = SecurityConfig(security_protocol, self.prop_file) self.security_protocol = self.security_config.security_protocol self.prop_file += str(self.security_config) ```
```suggestion self.parser.add_argument("--no-fail-on-errors", action="store_true", default=False, dest='dont_fail_on_errors', ``` A common pattern in CLI args is yup use "no".
unrelated, but maybe worth creating helper method that returns `Optional<GracefulShutdown>` to avoid these null checks throughout
Got it. For future readers the function is `maybeCompleteShutdown`.
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
nit: line too long
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
if it's not important, maybe a safer default is nicer :) I'm fine leaving as is for now. We can revisit after the bootstrapping.
can we use package private methods and have unit tests for this.. an integration seems like an overkill.
If we rewrite to use "absolute position" instead of delta, we can remove this.
Should probably also be explicit that you need to replace it with a custom analyzer using `standard` tokenizer and `html_strip` char_filter, plus `lowercase` filter and any other filters you have been using.
The change makes sense to me. I don't think anything would stop the auto-commits from going through. Even if there was such a mechanism, it seems better to explicitly disable it.
Nice, thanks for the update. Looks good
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
I think it would make sense to style this test (and `shouldInstantiateFromListOfClassTypes` below) more like `shouldInstantiateAssignors` now, ie where we actually validate the assignors that are returned (eg `assertTrue(assignors.get(0) instanceof StickyAssignor)`). Previously this test was just making sure that we adaptor would work and we wouldn't throw an exception when constructing the consumer, that's why it's like this
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
This particular test doesn't make sense any more, since there is no "old" assignor type now that PartitionAssignor is removed
Ah, yeah, you'd need to do something more like what actually happens in the actual KafkaConsumer/`getAssignorInstances` code. eg ``` @Test @SuppressWarnings("unchecked") public void shouldInstantiateAssignorClass() { Object classTypes = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances((List<String>) classTypes, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); } ```
It's super awkward, obviously, but since this is what happens when we process the configs in the real code we should try to replicate that in the test
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
perfect thanks. sorry for the confusion.
we can just call `terminate(threadPool)` here
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
`name()` -> `wrapped.name()`
same here as what i said below. You can use a `assertThat`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
Just a thought: maybe instead of referring to the Delimiter in Aggregations we can have an own constant in Suggest and either declare the same symbol there or delegate to InternalAggregation.TYPED_KEYS_DELIMITER? The delimiter doesn't need to be the same in aggs and suggestions, only the parsing part needs to refer to it (although its good to have the same like we do now I think)
as I said above, that makes sense, I adjusted it on our branch that way.
@original-brownbear I understand that part, but IMHO it's best if we stick to some basic guidelines for our tests/benchmarks. To reduce the GC impact how about we decrease the cache size to 5, and the number of records to insert 25 or so? Or just create an array inline with the keys and declare as a private variable? Either way, we should be able to do the work in the `setUp` method.
Sorry for being late on this. Populating static variables from a non-static method is generally not a good practice since it's generally not thread-safe. Given how JMH works, it's fine for those fields to be non-static right? Also, it seems more realistic since the data is isolated per run.
maybe rename this to `setUp` and put the loop populating the array in this method
I dont' think this is possible? `getFields()` never returns null
Should we have tests for the `DistributedConfig` class? Again, much of the logic should be the same, but the tests would each be simpler if using a `ConfigDef.Validator`.
Can we fold this into `writeTo` and add a boolean to the signature (maybe `includeRequestHeaders`)? It seems like it just requires adding a if/else block
Nit: `active.size()-1` -> `active.size() - 1`
Ah yes, thanks!
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
getters should not use get. i.e. use `networkDevice` here, etc.
nit: Starting a message with lower case feels a little unusual.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Each unit test should test one thing, so break this into separate tests for the different test conditions.
Please use string interpolation. There are a few other places like that.
Would `isUnknown` be clearer? I find that boolean methods without any prefix feel a bit ambiguous when reading them.
Hmm, we should probably specify that we can change the output of this String (i.e. parsing may break). I would have preferred if we didn't expose this as a public method and had a utility for it.
same for tests below as well
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
This would no longer raise `ValueError` but `PageNotAnInteger` or `EmptyPage`. I think this PR needs some more consideration and tests.
nit: one too many line break? :)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
It would probably be helpful to include the old constructor. At least I can imagine users having test cases where they construct SinkRecords directly and it would be nice not to break those unnecessarily.
I think `kafkaOffset` was incorrectly changed to `Long`. We'll always have a Kafka offset, so it should be `long`. Also, the current version breaks compatibility since the old signature constructor is no longer available.
We need to keep this public method and deprecate. Perhaps throw an exception if multiple group ids were specified and retain existing behaviour for single group id.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
It would probably be helpful to include the old constructor. At least I can imagine users having test cases where they construct SinkRecords directly and it would be nice not to break those unnecessarily.
I think `kafkaOffset` was incorrectly changed to `Long`. We'll always have a Kafka offset, so it should be `long`. Also, the current version breaks compatibility since the old signature constructor is no longer available.
We need to keep this public method and deprecate. Perhaps throw an exception if multiple group ids were specified and retain existing behaviour for single group id.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
Please remove empty line.
Here you should test if the stream thread has the name of the stream thread that was removed before.
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
Closing does not need `keyfile`. (Tested it with the module, works fine without `keyfile` option.)
Ah, I misread that. Totally makes sense :)
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
```suggestion - Path of the authentication file. Default is ``${XDG_RUNTIME_DIR}/containers/auth.json`` ```
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
Closing does not need `keyfile`. (Tested it with the module, works fine without `keyfile` option.)
Ah, I misread that. Totally makes sense :)
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
```suggestion - Path of the authentication file. Default is ``${XDG_RUNTIME_DIR}/containers/auth.json`` ```
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
I'd also consider removing this one too if we are not using it.
`Integer.toString` is a slightly more concise way of doing this.
I'd suggest to use a more descriptive test name, e.g. in the form of `shouldDoXYZ`.
It would be better to do the assertion in the test rather than here. It will make the test clearer.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
`Integer.toString` is a slightly more concise way of doing this.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: add `final` (same below)
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
I fixed this one to use the constant before merging.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
I fixed this one to use the constant before merging.
nit: add `final` (same below)
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
nit: move parameter to it's own line (same below)
There is a built-in for this `Function.identity()`
nit: could use Utils.mkSet
We really need a docstring here. `ConsumerRecordTimestampExtractor` enables event-time processing, which is a crucial functionality for stream processing. Also, the name `ConsumerRecordTimestampExtractor` (which IMHO we should keep) does not hint at "hey, if you use me, then you'll get event-time processing in return". Idea: > Retrieves built-in timestamps from Kafka messages (introduced in [KIP-32: Add timestamps to Kafka message](https://cwiki.apache.org/confluence/display/KAFKA/KIP-32+-+Add+timestamps+to+Kafka+message)), thus providing event-time processing semantics. > > Here, "built-in" refers to the fact that compatible Kafka producer clients automatically and transparently embed such timestamps into messages they sent to Kafka, which can then be retrieved via this timestamp extractor; i.e. these built-in timestamps are different from other timestamps that the user may have included in the _payload_ of the Kafka message. However, I remember that KIP-32 actually defines: > (From KIP-32) > Add the following two configurations to the broker > - message.timestamp.type - This topic level configuration defines the type of timestamp in the messages of a topic. The valid values are _CreateTime_ or _LogAppendTime_. The docstring idea above only covers CreateTime semantics (= producer-time), not LogAppendTime (= broker-time). So we may need to correct the docstring idea.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
Nit: could just throw the exception directly here; doesn't appear to be much benefit to putting that in a separate `setup` method.
Cheating the compiler, woohoo!
public access? I can see this being accessed by another package too (such as `rest.resources`)
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
@guozhangwang i'm not sure why we would want to enforce caching? Perhaps the custom store is already an in memory store? Why would we cache that? Perhaps there is some other reason why they don't want caching for a given store.
@duy @jeyhunkarimov Got it. So I think the question is whether we want to partially solve the "not be able to have finer-grained caching" problem here or just keep it as is and wait for a more focused shot later in another ticket. I think we can argue that it is OK to be "soft" and potentially change it later when we have another mechanism for fine-grained caching. My concern, though, is that by opening the pandora box of allowing users to do caching like this we are not long complicating the internal implementation (which, as we talked, is OK as long as this tech debt can be simplified later), but also about exposing the internal classes like CachingXXStores to public user interfaces, and this box is hard to be closed later. Anyways, my take is that eventually the finer-grained caching support should be added, but not by exposing the CachingXXStores to users.
Synced with @dguy offline on caching, the current semantics "only dedup on forwarding if it is the default CachingXXStore with wrapper RocksDB" looks OK to me. I think we need to re-consider the unification of caching with dedupping after this since now with user customizable stores this caching mechanism is narrowed to default state store suppliers only.
ok - i see what you are saying. That probably feeds into another issue, though. I know we don't support it now, but the global caching on/off switch is probably too coarse grained. I think we should be able to decide on a per store basis if we want it to be cached or not. I think this has already been asked for by at least a couple of people.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
I fixed this one to use the constant before merging.
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
nit: add `final` (same below)
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Unnecessary `new String[] {}`, can just use the string as varargs for `Arrays.asList`. Same pattern is used in multiple places in this class.
nit: could use Utils.mkSet
I fixed this one to use the constant before merging.
nit: add `final` (same below)
```suggestion public void shouldInstantiateAssignor() { ```
This could be final.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I fixed this one to use the constant before merging.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
This could be final.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I fixed this one to use the constant before merging.
Same as before, `new Integer[]{}' not required for `Arrays.asList`.
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
Ditto on removing before/after
ditto on removing before/after.
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
Do we actually need two fields? From looking at the code, it wasn't clear to me.
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Yeah but I expect the value for this config to come from a class implementing the interface so in this case `DefaultReplicationPolicy`.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
There's no need for reflection here - writing out all the fields, in a sensible order, is much preferred.
Generally multi-line output from `toString()` is a bit of a pain to work with. +1 for using the system's line separator, and I think `System.lineSeparator()` works too as we're in Java 8 here, but a one-line output would be better.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ```
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
nit : missing new line
"with a read-only key"
with a read only key
Pls use caps :) (see your `ErrorReporter` above).
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
```suggestion /** * Metadata of a stream thread. */ ```
Should this be retriable? Same question for `FetchSessionIdNotFoundException`.
`Indicate[s] that Kafka Streams is in state {@link org.apache.kafka.streams.KafkaStreams.State#CREATED CREATED} and thus state stores cannot be queries yet.`
```suggestion * Metadata of a Kafka Streams client. ```
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
Pls use caps :) (see your `ErrorReporter` above).
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
typo `to to` (also missing `.` at the end of the sentence)
Maybe an `assert` for unit tests (are `asserts` common in Kafka code base?). As `WrapperSerde` is private, nobody else can use it -- so no need to check for `null` IMHO.
We should log an error that prints out what the two configs actually are
While I understand why passing `Plugin` here is safe, after thinking about it a bit, I think I prefer replacing the `Plugin plugin` with `String source` to give the flexibility to choose whether this logic should be applied on the Plugin itself (using `onModule` or `processModules`) or on a different `PreProcessModule` (that latter feels more natural to me)
I think we want to test index level blocks too here
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
deprecated names match too. match should always return true, or rather throw an exception in strict mode if you use a deprecated name. I think it should be an assert. We had the same discussion with Colin in IndicesQueriesRegistry I think :)
the fact that the parse field matcher matches is a requirement, I think it should be an assert instead. It's really a our bug if it doesn't and we should catch it differently compared to "no function found"
I think we want to test index level blocks too here
rewrite test as above using `assertThrows()`.
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
we can randomly use a different cluster? or maybe downsize the global cluster to 1 node for this test? I also wonder if we should consider to run tests with one node as well? the minNode=2 was only convenience...
ditto on the properties and the driver.
ditto on the properties and the driver.
Ditto on the properties and the driver.
nit: should we inline these? The variable names are barely shorter than the method names.
nit: one too many line break? :)
same here. I think we should throw an exception when running into an error. No need to accumulate things and return them
Recently, we prefer to use `assertThat()` instead of `assertEquals()`.
Should this else clause be returned to what it was before the original refactoring PR? https://github.com/elastic/elasticsearch/pull/32068/files#diff-c94184ea4ef180f10817aa2bbd41a8edL119
Could also purge the local state before tests, just in case.
This can be `Files.notExist(...)`
This could be deleteIfExists
nit: extra line
we could pass a glob with regex:xxx to newDirectoryStream if we want
This method can be public, static, and take a String instead of a Path, which would allow us to unit test it. It will require moving the logging up one level higher though, but still nice to be able to unit test.
typo: an -> a, concat -> concatenated
Well, maybe I should have pointed them _all_ out the first time.
Same thing here with the `connectorProps` vs the `config`.
Also set the store name in this test.
I would name the method `passwd_check`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
nit: can we make this debug level? Otherwise it will make this test a little spammy.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
All methods only used once should be explicitly inlined.
`fatal=False` will print error wen failed. Instead it should be optional and not print any error.
confuses the shit out of me everytime :)
Should this else clause be returned to what it was before the original refactoring PR? https://github.com/elastic/elasticsearch/pull/32068/files#diff-c94184ea4ef180f10817aa2bbd41a8edL119
nit: use assertThat(...) with isNull() as matcher instead? I think in general that is the preferred way of writing test assertions.
That's just a mistake. Initially I had separate priorities for `ADD_PARTITIONS` and `ADD_OFFSETS`, but forgot to adjust the `END_TXN` priority after combining them.
Let's make this an `UncheckedIOException` too.
can this be ``` if (pluginClass.getName().equals(plugin)) { luceneVersion = pluginProps.getProperty("lucene"); break; } logger.debug("skipping [{}]", pluginUrl); ``` I think taht is more clear
Same as before, parameters of `assertEquals` should be the other way round.
Maybe we should remove the `Collections.synchronizedList` wrapper(s).
we do this kind of parsing in several places maybe a util can help at some point? not sure just an idea
this will not work, right? cause the default is `9300-9400`, which is good, since we want to try another port on the second instance we start on the same machine.
one assert per member is better then you see what's not null :0
should we move the `configureSocketChannel` call into the try block as well here? seems cleaner
Same as before, parameters of `assertEquals` should be the other way round.
here I'd do the same as above an pass in an some kind of BytesReference factory that can produce new BytesReferences and return a `CompositeBytesReference` instead the `int` to signal how much has been read. We can figure out how to do SSL and stuff afterwards this is too hard to do in one step
I think here we can go with an ordinary `BytesReference` and use it's efficient iterator `BytesRefIterator iterator()` the returned `BytesRef` is just a pointer into the underlying `byte[]` that you can wrap in with `ByteBuffer#wrap` and do your accounting what is left for writing in this method. so there is no need to use a `NetworkBytesReference`
Not sure about this. `SslTransportLayer#hasBytesBuffered` returns true if there is any data in `netReadBuffer`. If more data is needed to unwrap and no data arrives from the client, I think the handling of `keysWithBytesBuffered` results in a tight polling loop with timeout=0.
Nit: somehow I don't like `blah`. Otherwise LGTM
Rather than filtering ourself, we could alternatively pass prefix as glob to newDirectoryStream, and it would follow filesystem rules.
Nitpick, how about: ``` java public static File tempDirectory(Path parent, String prefix) { final File file; prefix = prefix == null ? "kafka-" : prefix; try { file = parent == null ? Files.createTempDirectory(prefix).toFile() : Files.createTempDirectory(parent, prefix).toFile(); } catch (IOException e) { throw new RuntimeException("Failed to create temporary directory", e); } file.deleteOnExit(); Runtime.getRuntime().addShutdownHook(new Thread() { @Override public void run() { Utils.delete(file); } }); return file; } ```
I would add a flush(), since we expect people to see those bytes and we want to be independent of the filesystem impl (what if it uses buffering, thats its choice)
could be shorted using `com.google.common.io.Files.write`
This is not longer correct - more like "Creates a new QueryBuilder from the query represented by the xcontent in the parser." or something.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
```suggestion * Any object created with {@code new} in {@link RocksDBConfigSetter#setConfig setConfig()} and that inherits ```
Typo: > Similar[ly], you can ... with [a] custom ...
This is not longer correct - more like "Creates a new QueryBuilder from the query represented by the xcontent in the parser." or something.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
```suggestion * Any object created with {@code new} in {@link RocksDBConfigSetter#setConfig setConfig()} and that inherits ```
Typo: > Similar[ly], you can ... with [a] custom ...
Checkstyle is unhappy with this.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It seems to me this check should be moved to ```ApiMessageTypeGenerator``` as it is a generated code from json.
> it doesn't seem particularly beneficial It seems to me the benefit is the error happens from runtime/test_runtime to build time (generate message code).
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
I would include the non-null constraint in the sentence, eg "Returns a non-null resource pattern on which this action is being performed".
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
It would be good to have constants instead of hardcoding the fields in many places.
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
Don't put a newline in the middle of a work, put the newline before the work actually starts. There are a few examples of that in the module.
I would include the non-null constraint in the sentence, eg "Returns a non-null resource pattern on which this action is being performed".
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
Note: We never use the double underscore private convention. We just use the single underscore private convention.
nit: probably worth to create constants with meaningful name to use them instead of `true/false`, something like: ``` java @Test public void withSubscribingTwice() { performTestUsingWithSubscribingTwice(DONT_DISPOSE_EAGERLY); } ```
When you do `iri.decode(encoding)` you are getting unicode, so effectively you sometime have unicode, sometime bytes. If the caller needs bytes, it can encode in whatever encoding it desires .
It would be good to have constants instead of hardcoding the fields in many places.
I did not check this in detail but if `UCharacter.getPropertyValueEnum()` returns values > `UScript.CODE_LIMIT`, then it would break your code that populates the `breakers` array below. In that case I would add an explicit check and throw an exception.
Ok, then it's fine.
Actually this line is not the actual problem, but this one is: ``` java final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT]; ``` together with ``` java breakers[code] = parseRules(resourcePath, env); ``` If `code` is greater than `UScript.CODE_LIMIT` then this will result in an `ArrayIndexOutOfBoundsException`. But I do not know whether it is possible that this condition occurs in practice.
shall we make some of these protected? sounds quite wrong to be using this exception without providing a status. Would be nice to remove some of these variants but I guess they are needed by EsSecurityException.
This whole loop reads fairly low-level. If config files can be considered small, we could just read them much more concisely with the Stream API (untested): ``` java String rules = Files.readAllLines(path) .stream() .filter((v) -> v.startsWith("#") == false) .collect(Collectors.joining("\n")); ``` All the low-level stuff is gone. But this relies on Java 8 features and will only work on master.
should this be `BAD_REQUEST` instead? If we cannot handle the request, it's not that there's an internal server error, but that the request is unexpected.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
ok...but client depends on the transport service anyway no? I think I don't get it
if the api is really internal, I think we can simplify this. Do we need to use a client here? Can we instead use the transport service directly? In that case we wouldn't need the RefreshAction, and the RefreshRequestBuilder. Otherwise the api ends up being exposed anyways, no matter if we say it's internal, but it doesn't have a corresponding REST handler, which makes things inconsistent.
I did not check this in detail but if `UCharacter.getPropertyValueEnum()` returns values > `UScript.CODE_LIMIT`, then it would break your code that populates the `breakers` array below. In that case I would add an explicit check and throw an exception.
Ok, then it's fine.
Actually this line is not the actual problem, but this one is: ``` java final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT]; ``` together with ``` java breakers[code] = parseRules(resourcePath, env); ``` If `code` is greater than `UScript.CODE_LIMIT` then this will result in an `ArrayIndexOutOfBoundsException`. But I do not know whether it is possible that this condition occurs in practice.
shall we make some of these protected? sounds quite wrong to be using this exception without providing a status. Would be nice to remove some of these variants but I guess they are needed by EsSecurityException.
This whole loop reads fairly low-level. If config files can be considered small, we could just read them much more concisely with the Stream API (untested): ``` java String rules = Files.readAllLines(path) .stream() .filter((v) -> v.startsWith("#") == false) .collect(Collectors.joining("\n")); ``` All the low-level stuff is gone. But this relies on Java 8 features and will only work on master.
what is this provider doing here? We can't do this in our production code this will take hours for decouple again We either pass a client or not but not yet another indirection.
This seems to be redundant from above (or already the merged test...) -- restore-consumer and adminclient would be missing though.
add check for restore-consumer and admitclient
I think, we should use three different values to make sure that the different prefixes overwrite the configs for the corresponding clients. Looking into the test below, they seem to be redundant with this one? We can also remove this test and keep the other three (that would avoid redundancy, too)
as above -- add check for two missing clients
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
As I suggested before, to not expose the node information, we should remove this function.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I've seen alternative solutions floating around that use a configurable source here. Basically, the configuration passed to configure() is consulted to find the "source cluster", rather than looking at the topic name. That approach lets you return an actual source here, which obviates the new canTrackSource() method etc.
thanks a lot! should we have a test that leverages this extension point for score functions? I thought we had one already but not sure anymore
recommended; ditto below.
Thanks. Not a blocker.
If these aren't expected to change at runtime, I'd suggest initializing the `HashMap` in the static block as a temporary variable , then wrapping it to create an unmodifiable map which is then used for the constant here: ```java Map<String, File> pluginJars = new HashMap<>(); try { pluginJars.put(..., ...); // More of the same } finally { PLUGIN_JARS = Collections.unmodifiableMap(pluginJars); } ```
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
I believe this will inject non-determinism ... notifications will be capable of interleaving and being out of order. I think we need to combine this with `ScheduledObserver` which maintains a queue and event loop for handling each notification sequentially on the given scheduler.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
I really like this class.
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
Thanks for the explanation, and thanks for fixing the synchronization. As an optimization, I think we should use something like `ConcurrentMap` here rather than synchronized blocks, so that we can minimize the amount of time threads spend waiting. This will be a bit more tricky to use, but more scalable. I guess when I thought about KIP-511, I thought of it in terms of metrics and perhaps occasional samples of connections (similar to how we do request sampling by logging a few selected requests). I don't see why we'd ever need a full snapshot of all existing connections. The snapshot would probably be out of date by the time it had been returned, since new connections are closed and opened all the time. Reading the KIP more carefully, I see that KIP-511 does specify a metric which essentially requires each connection to register itself. Considering we don't even have a way to visualize or graph this metric, I'm not sure this belongs in JMX. I have to think about this more...
I don't think it's necessary to keep a central registry of all this information for all connections. We really just need the metrics, most of which can just be simple counters. If we need more information about a connection, we can look at the request context of that connection. But it doesn't have to be stored here.
We also need to explain a bit why we add a type converter at this layer of the store hierarchy.
Nit: unnecessary new line.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
ah right, `lastUpdateMs` will make sure that bucket would be full on the first `record()`.
Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.
```suggestion import org.apache.kafka.common.MetricName; import org.apache.kafka.common.metrics.Metrics; import org.apache.kafka.common.metrics.Sensor; import org.apache.kafka.common.metrics.stats.CumulativeSum; import java.util.Map; ```
I really like this class.
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
This should be the same unit as the unit in `Rate`, right? If so, I think someone could create Rate as: ```new Rate(TimeUnit.MILLISECONDS, new TokenBucket())``` Or ```new Rate(new TokenBucket(TimeUnit.MILLISECONDS))```
I also think it's better to start with burst size credits. We would normally create the sensor on the first byte/request/etc. and before that, the <user,client> is idle which means they were "accumulating credits".
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
nit: than -> that
hopefully the `System.nanoTime` goes away once you merge master in.
nit: shall we rather initialize to empty and replace this with an empty check? I see that empty is currently not an option anyways.
and -> a
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: add a size? There are a few cases in here where we could do this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: add a size? There are a few cases in here where we could do this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: add a size? There are a few cases in here where we could do this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: add a size? There are a few cases in here where we could do this.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can initialize to `new HashMap<>()` here as is done with `invalidExtensions` below.
nit: `This` -> `{@code MockProcessorContext}` "this" , "here" etc is bad style IMHO
Is this an oversight? `DEFAULT_KEEPALIVE_SETTING.get(settings)`
There's still a usage as `applicationId + "-" + topic` in the `SinkNodeFactory` subclass. The structure of that class is now a bit odd as the `applicationId` is passed as a parameter, but it's a non-static so it captures the parent reference and actually uses it for at least one other member of the parent class (`internalTopicNames`). I'm fine committing as is if this is consistent with trunk since then a clean up could easily be cherry picked if that was desired. But it looks like this patch and what's on trunk differ significantly. This method name doesn't even seem to exist on trunk? Are you sure you want to diverge so wildly? It's going to make any more backports/cherrypicks really annoying...
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Is this an oversight? `DEFAULT_KEEPALIVE_SETTING.get(settings)`
There's still a usage as `applicationId + "-" + topic` in the `SinkNodeFactory` subclass. The structure of that class is now a bit odd as the `applicationId` is passed as a parameter, but it's a non-static so it captures the parent reference and actually uses it for at least one other member of the parent class (`internalTopicNames`). I'm fine committing as is if this is consistent with trunk since then a clean up could easily be cherry picked if that was desired. But it looks like this patch and what's on trunk differ significantly. This method name doesn't even seem to exist on trunk? Are you sure you want to diverge so wildly? It's going to make any more backports/cherrypicks really annoying...
This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`}` and `else if` should be on the same line
Nit: The default constructor `AtomicBoolean#<init>()` can be used.
Why is this `volatile`? It doesn't look necessary to me.
This also seems like the kind of leniency that we'd want to remove in the future.
But yeah, keep it now.
I have a small preference for `Future<Map<Integer, Future>>` because it seems more aligned to how we do it for other APIs but I don't feel strong about it.
This is the only remaining point of discussion. I don't have a strong preference for any of them so I leave it up to you.
This name seems backwards.
same here, s/subscriptions/newSubscriptions and `toOldSubscription`
Can remove if initialize above
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
```suggestion version_added: '2.8' ```
```suggestion - The RAID level of the pool. type: str ```
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ok, potentially reduces allocations for the user, thanks
Why do you remove this check? A `TimeWindow` should not allow this case.
I reordered the method from "few parameter" to "more parameters" to make it easier to navigate within the file.
Because there is not `CogroupedKStream#reduce()` method this sentence is not useful and should be removed.
as above (more often below -- please fit all)
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: remove `this` (not required)
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
You can remove `: {}` as we are not passing any args anymore, that is, we are calling the second method instead of the first: `public void warn(String format, Object arg);` `public void warn(String msg, Throwable t);`
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Code convention nitpick: there should be a space before the colon.
Oh, good to know that they've changed the behaviour since 1.6.0 to make this work (i.e. if the last parameter is unused and it's a Throwable, then it's interpreted as a Throwable instead of a parameter).
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
This is a little annoying, but you do that the Throwable is also a parameter. As far as I can see, there is no overload that takes a Throwable _and_ parameters. I assume that's why Anna did it like this. However, I didn't test to see if slf4j does a runtime check on the arguments to look for a Throwable (it would surprise me if it did).
Maybe use log parameters instead? ``` java log.warn("Error executing interceptor onSend callback for topic: {}, partition: {}", record.topic(), record.partition(), t); ```
nit: What do you think about sprinkling a bit of docstrings in this interface while we're rewriting it? I like the original description of `An MBean that allows the user to dynamically alter log4j levels at runtime.`
@wicknicks would be useful to have some unit test for this class.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
```suggestion * <p>A {@code retryBackoffMs} that is negative or zero will result in no delays between retries. ```
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Better name as "setCurrentNodeInProcessorContext"? And then in java docs mention that it returns the processor context with current node set.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
same here as what i said below. You can use a `assertThat`
nit: make the keys a `Set<String>` and then do `assertThat(keys, equalTo(Utils.mkSet("2","3")`
I do not think we should log here. This is on the reload of a file and not an update to the ciphers settings
nit: remove (was tested already)
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
The map is not used.
Same as before, parameters of `assertEquals` should be the other way round.
clarify the error message specifying what needs to be non null? the inner query...also remove empty, doesnt make sense here
request1 and request 2 are not used.
We may need to call sender.run() one more time to ensure the message is not reenqueued. The reqenqueued message won't be sent out again in the same sender.run().
Nit: spacing between `while` and `(`.
Nit: spacing between `!` and `value`.
I see. Do not bother then :) At lease we are not introduce a regression to make perf worse :)
It's unusual to hold a reference to an abstract class like this. I believe the intent is to be able to transparently handle either `KeyValueSegments` or (I'm guessing) `KeyValueTimestampSegments`. The full expression would be to have a `Segments` interface implemented by `AbstractSegments`, which is then extended by your two implementations. Then this line would reference `Segments<S>`. It's fine to collapse this into just the abstract class (although questionable in the presence of package-protected fields). But to maintain transparency, I'd name the abstract class `Segments` instead of `AbstractSegments`. That way, to an outsider class (like this one), you're still just interacting with the interface (i.e., the public interface of the class), rather than specifically an abstract class. Adhering to this pattern leaves the door open in the future to extract `Segments` into a full interface without having to change any outside code (which is what I meant by maintain transparency).
My idea was to make the BulkRequestSource hold what it has to hold (the failed items), be able to retrieve them and act accordingly from processBulkIndexRequest, rather than have logic to deal with failures within the BulkRequestSource itself. Exposing different getters might help as well, that's another option. I tend to think that extracting the "processing" part would make things cleaner but I may be wrong.
Nit: spacing between `while` and `(`.
Nit: spacing between `!` and `value`.
I see. Do not bother then :) At lease we are not introduce a regression to make perf worse :)
It's unusual to hold a reference to an abstract class like this. I believe the intent is to be able to transparently handle either `KeyValueSegments` or (I'm guessing) `KeyValueTimestampSegments`. The full expression would be to have a `Segments` interface implemented by `AbstractSegments`, which is then extended by your two implementations. Then this line would reference `Segments<S>`. It's fine to collapse this into just the abstract class (although questionable in the presence of package-protected fields). But to maintain transparency, I'd name the abstract class `Segments` instead of `AbstractSegments`. That way, to an outsider class (like this one), you're still just interacting with the interface (i.e., the public interface of the class), rather than specifically an abstract class. Adhering to this pattern leaves the door open in the future to extract `Segments` into a full interface without having to change any outside code (which is what I meant by maintain transparency).
My idea was to make the BulkRequestSource hold what it has to hold (the failed items), be able to retrieve them and act accordingly from processBulkIndexRequest, rather than have logic to deal with failures within the BulkRequestSource itself. Exposing different getters might help as well, that's another option. I tend to think that extracting the "processing" part would make things cleaner but I may be wrong.
what is this provider doing here? We can't do this in our production code this will take hours for decouple again We either pass a client or not but not yet another indirection.
can we factor the lentient handling part out in a single mehtod? ``` private Query rethrowUlessLentient(RuntimeException e) { if (settings.lenient()) { return null; } throw e; } ``` man I with we had support for annonymous functions here or macros even :)
There is history around the azure plugin so I won't take this as an example. > Unless you have other thoughts I will go ahead and have a simple private method inside the BlobStore that returns the Storage instance. Code inside the Blobstore is responsible for not caching the instance. :+1: Let's do that and not block this PR. This is something we can still revisit later on.
I understand why you did that but I find that the two storageAccess() just adds extra unnecessary noise. I think we could instead have a simple private `safeClient()` method that returns the `Storage` client to use, and later do things like: ` SocketAccess.doPrivilegedIOException(() -> safeClient().get(bucketName));` I find this easier to read and to understand where the stack is cut for access control.
Since the account settings are supplied by user, I would feels better if we used URI to build this string. This way we will have at least some basic validation of the things that go into this URL.
But I wouldn't be afraid to just use a full if/else block, either. ```suggestion final WindowBytesStoreSupplier storeSupplier; if (inOrderIterator) { storeSupplier = new InOrderMemoryWindowStoreSupplier("InOrder", 50000L, 10L, false); } else { storeSupplier = Stores.inMemoryWindowStore("Reverse", ofMillis(50000), ofMillis(10), false); } ```
This is how I typically break up ternaries. ```suggestion final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier("InOrder", 50000L, 10L, false) : Stores.inMemoryWindowStore("Reverse", ofMillis(50000), ofMillis(10), false); ```
The original intent of the test was to ensure, we don't write into non-exiting topics, ie, create a topic out of nowhere -- but with the new abstraction that cannot happen anyway I guess.
This must be `OUTPUT_TOPIC_2`
Same as above mentioned, the validation didn't get handled in new API.
same for tests below as well
method name changes
It should be robust in case of some missing fields.
nit. I think there is `.` missing `since 3.0[.] Use`
You don't need to specify any symbolic name for a group since you have only one.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
same for tests below as well
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
nit: remove `this` (not required)
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
Code convention nitpick: there should be a space before the colon.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
Yes. The user can use the config two ways: ``` // as string props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, "my.fully.qualified.package.MyInnerSerde"); // or as class props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, my.fully.qualified.package.MyInnerSerde.class); // or short (it the class is imported) props.put(DEFAULT_LIST_KEY_SERDE_TYPE_CLASS, MyInnerSerde.class); ``` Both should be supported and the code need to be able to handle both cases. Hence, we should get is as `Object` and use `instanceof` to check the type.
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
nit: remove `this` (not required)
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
nit: could use Utils.mkSet
Code convention nitpick: there should be a space before the colon.
i know it was motivated by findbugs, but this was probably a good refactoring anyway :) `RestServer.httpRequest` to *make* an http request has always been a bit awkward
Actually I think it works: http://www.slf4j.org/faq.html#paramException.
Even though this one should work, exact double comparisons tend to scare me a bit: should we use `null` instead of `-1` for non-existing x-axis units? (and store it in a Double)
Side note: we need to rename Reducer.FUNCTION to have a more explicit name.
I know it was already the case, but can we make this allocationFound parmater actually count the number of allocation found (i.e. all shards with an allocation id, matching or not) Later we can refactor this maybe and remove it completely but for now let's keep it consistent.
The indentation is off here and the rest of the way through this test.
no need for iteration here, you can get the node directly by calling `state.getNodes().get(shardRouting.currentNodeId())` (which will return `null` if no node found)
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
I mean to close `node` and safe the conditional... but it's Releasable so you can use `Releasables.close()`
ditto here and others below
I think this constructor can go away
That's certainly a funky corner case, right? Its a broken plugin that does that.
The logging brackets are off here: `[{} to [{}]]`.
`ConsumerRecords` -> `ConsumerRecords<byte[], byte[]>`
We could use a "for each" loop here, something like: ``` for (Class<? extends Connector> connector : connectorClasses) { connectCluster.configureConnector(connector.getSimpleName(), mm2Config.connectorBaseConfig( new SourceAndTarget(primary, backup), connector)); } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Actually the constructor of all such description classes can just be default package-private since they are only used by KafkaAdminClient, and hence can just be private APIs, and we do not need to deprecate-overload any more.
new ArrayList<String>() => new ArrayList<>()
I'd keep it as member field. Having to declare the type in every test case to which you use it is be a bit annoying. Also, if you reuse this variable in consecutively in the same test case, the fact that in the first occurrence you have to specify the type but in the next ones it's already declared, breaks a symmetry in assignments that's otherwise good. Finally, having it `final` is not all that useful.
This method is usually called `setUp()`.
This isn't your name
can we make `"security.manager.enabled"` a constant please
nit: one too many line break? :)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
I mean to close `node` and safe the conditional... but it's Releasable so you can use `Releasables.close()`
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
I did notice that you renamed the method in a subsequent commit which covers the "name should also ideally indicate the difference" part. :)
Maybe this should be a class docstring :thinking:
Hmm, I don't think this is right. We still need to build Scala 2.12 separately since it requires Java 8.
I think what you have here works fine. Thanks @umesh9794 for your PR.
Instead of pulling the value out with a regex, what do you think of `streamsString.contains("appId")`. Although what you have works as well.
I did notice that you renamed the method in a subsequent commit which covers the "name should also ideally indicate the difference" part. :)
Hmm, I don't think this is right. We still need to build Scala 2.12 separately since it requires Java 8.
I also think we can add a method that checks for precision to simplify this! please
need to update `./gradlew uploadArchivesAll` at line no: 644
maybe `Objects.equal` could make it easier to read
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
you don't need this. Junit gives you a new instance of the test class for every test method
I'd suggest to use a more descriptive test name, e.g. in the form of `shouldDoXYZ`.
This should be done in reset()
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
nit: Starting a message with lower case feels a little unusual.
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
What about inlining `transformations` and having something like: ``` when(plugins.transformations()).thenReturn(Collections.singleton(transformationPluginDesc())); ```
I think this behavior should be shown in the examples since it is tricky to explain.
`WindowStore` is public API -- we need a KIP if we want to deprecate something. Thus, this is not a `MINOR` PR.
```suggestion - Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key ```
Use URL instead of Url. ```suggestion - The URL of the Gitlab server, with protocol (i.e. http or https). ```
There is no need to add quotes here. Please remove them from all modules.
We are using options in an inconsistent way here compared to other APIs. A good example to follow would be: ``` public ListOffsetsResult listOffsets(Map<TopicPartition, OffsetSpec> topicPartitionOffsets, ListOffsetsOptions options) ``` Options here are additional options that apply to the request. Data for the request comes from the first argument. We could do something similar for listConsumerGroupOffsets.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
We are using options in an inconsistent way here compared to other APIs. A good example to follow would be: ``` public ListOffsetsResult listOffsets(Map<TopicPartition, OffsetSpec> topicPartitionOffsets, ListOffsetsOptions options) ``` Options here are additional options that apply to the request. Data for the request comes from the first argument. We could do something similar for listConsumerGroupOffsets.
This is a breaking change in a public API since it removes the default constructor. In any case, don't really want this in the constructor, we should add methods for whatever we need. Actually looking at the rest of the changes in this class, we are repurposing an existing public API by changing all of its methods, we need to completely rethink this change.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
I see. `MaterializedInternals` must be `public` and cannot enlarge the scope if `Materialized` constructor is `protected`... What about adding a public static method `MaterializedInternals#fromMaterialized(Materialized)` that calls the copy constructor? This way, we could make it protected IMHO.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
this is a personal preference, I like to avoid overriding the setup and teardown methods of estestcase and use separate one
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I've move all of this into the EXAMPLES block
There is a `requirements:` than should be used for this, see other modules for examples
I don't think we can do this. Also, I would only mention it, when we start to deprecate an API.
This isn't valid yaml ` : `
I reordered the method from "few parameter" to "more parameters" to make it easier to navigate within the file.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I like this cleanup, but I think we still need the `null` check. Since it's possible for the value to be `null`, we should probably be defensive about it. Or were you thinking that we should just let the `NullPointerException` occur and kill the connector? Something in the middle of these two cases might be to log a warning so hopefully the connector developer can fix their code. (The only reason we even need to validate this is due to the `SinkTaskContext.offset(Map<TopicPartition, Long> offsets)` variant, the single partition variant with `long` obviously doesn't have the same issue.)
We use line lengths up to 119 characters when it helps readability. I wouldn't reformat this line when it doesn't have any other changes.
can we check the commit id in the stats and make sure it's the same? alternatively, can we maybe find the segments info for the right commit and create a stats object there? You're right about the synced flush not caring, but I'm worried that we get false scary warn message. I want to avoid that.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
Please add trailing comma.
Nit: you can call `Thread.enumerate` directly. Also, it would be good to assert that `threadCount` is < than `threads.length`.
This can be single-lined.
This can be single-lined.
I think these are too internal, I would rather check that `MultiValueDict` is pickleable: ```python pickle.loads(pickle.dumps(...)) ```
nit: new line
This can be single-lined.
I think these are too internal, I would rather check that `MultiValueDict` is pickleable: ```python pickle.loads(pickle.dumps(...)) ```
`< Callback >` this explicit type is not necessary.
and here too ;)
typo: byteArrray -> byteArray
I'm not certain this requirement is enough because if a source doesn't deliver the requested amount, it will keep the client hanging which may not request a new batch. There is also the problem if the first observable delivers less than requested, the missing amount is not replenished/considered by the second Observable and thus the client may starve. This is why `concat` uses the `SubscriptionArbiter` so that if an Observable didn't deliver enough, the next is requested for the missed amount. Similar measures might be required with this `AsyncOnSubscribe`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Because `Named#name` is not `final`, it is not guaranteed that `EMPTY` will have an `null` name (one might call `#empty()` and modify it) -- seems to be a potential source of bugs. Can we instead remove `EMPTY` and return `new NamedInternal()` in `empty()` each time? It's not on the critical code path, so should be fine.
There is a built-in for this `Function.identity()`
req: move this to `StreamsPartitionAssignor`, where we'll be building and passing the `Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients` map around
Actually, WDYT about adding this class in the "add configs" PR and then rebasing this PR on top of that? Then I could do the same (since I need this class in my next PR as well)
Asking because neither a `List<T>` nor a `Deserializer<T>` need a `Comparator`.
In the previous version, we didn't delay the onCompleted event.
"this until it is" doesn't quite parse.
can we invert this and say `if (suggestStats != null)`
I'm not certain this requirement is enough because if a source doesn't deliver the requested amount, it will keep the client hanging which may not request a new batch. There is also the problem if the first observable delivers less than requested, the missing amount is not replenished/considered by the second Observable and thus the client may starve. This is why `concat` uses the `SubscriptionArbiter` so that if an Observable didn't deliver enough, the next is requested for the missed amount. Similar measures might be required with this `AsyncOnSubscribe`.
this file can go back to 140 chars as well...
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
```suggestion /** * Metadata of a task. */ ```
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
You might consider using `OptionalDouble`.
We should limit this suppression to the method for which we really need it instead of the whole class
I fell like a functional interface here doesn't really buy us anything comparing to a simple if statement with two calls.
Both `GZipInputStream` and `SnappyInputStream` read the header in the constructor, so it would make sense to me to remain consistent in that respect.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
@hachikuji asked you to change the name originally: ```text hachikuji 5 days ago Contributor nit: the name is a little awkward. How about hasRemaining to match ByteBuffer? ``` :)
Sorry for the confusion. I thought `hasRemaining` made sense initially, but then I realized that the name should be more suggestive of its usage. I'd prefer something like `ensureNoneRemaining`, but it's not a dealbreaker for me.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
Nit: add `Cannot be {@code null}.` (maybe somewhere else, too)
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
ditto here and others below
same for tests below as well
You have some unmerged lines here
You don't need to specify any symbolic name for a group since you have only one.
I realize that the "streams-file-input" topic is used for multiple purposes in the upcoming quickstart/demo instructions. In this case, feel free to keep the input topic name as is.
"over text files": This is confusing because we're not using text files anywhere. What about the following: > Implements the WordCount program that computes a simple word occurrence histogram from an input text. > Assumes the input text is read from the Kafka topic "streams-lines-of-text", where the values of messages represent lines of text.
ditto on removing before/after.
Ok, I'm convinced :) Thanks for clearing up my confusion.
I see. But even though the number gets incremented after each test method, the string `inputTopic` is already fixed when the class is constructed, so it won't automatically get incremented. I think you need to make this a method to achieve the effect you intended.
ditto here and others below
same for tests below as well
Nit: add `Cannot be {@code null}.` (maybe somewhere else, too)
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
ditto here and others below
You have some unmerged lines here
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
As soon as external JSON names are stable we should use the same names inside for variable names I think. Can be done in a separate PR though.
I think this should be moved to QueryCreationContext and exposed here through it temporarily
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
rewrite test as above using `assertThrows()`.
nit: not a big deal here, but for unit tests I think given the very low overhead it is better to separate out each of the cases into their own test as it can help make it more quickly obvious if issues are with a specific case or if it affects multiple cases.
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
this is great
This seems to be safely handling unsubscribe by doing it in the right thread so 'unsubscribeOn' is not needed.
This is a hard override (via index.mapping.date.round_ceil setting, which default to true) to disallow rounding up. Not sure if this actuall set to false, seems undesired to me.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
this is great
This seems to be safely handling unsubscribe by doing it in the right thread so 'unsubscribeOn' is not needed.
This is a hard override (via index.mapping.date.round_ceil setting, which default to true) to disallow rounding up. Not sure if this actuall set to false, seems undesired to me.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
There is a built-in for this `Function.identity()`
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
Nit: ```suggestion * executed exactly once. If {@code maxRetries} is set to {@code n}, the callable will be executed at ```
Nit: since we require a non-null `Duration`, we should state that here: ```suggestion * @param timeoutDuration timeout duration; may not be null ```
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
Nit: unnecessary new line.
If it is no more an integration test, this should be removed.
Why do you need to prepare `KafkaStreams` for testing? Only classes that are mocked and that are either `final` or have static methods need to be prepared.
use `try-catch` instead of `expected` annotation -- not a single line test.
IMHO we should consider changing to ` @Parameterized.Parameters(name = "caching enabled = {0}")` which prints the whether caching is enabled or not vs. just the index of the parameter.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
same for tests below as well
`retry < this.numberOfRetries` is implied here due to the outer check.
I also wonder if we should log `TRACE`/`DEBUG` issues for this.
same for tests below as well
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
ditto here and others below
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
nit: one too many line break? :)
ditto here and others below
You have some unmerged lines here
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It should be robust in case of some missing fields.
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
lib/ansible/modules/network/aos/aos_ip_pool.py:191:1: M511 - mutable default arg of type List There is only one caller of create_new_ip_pool() and it provides all three args, so subnets doesnt need to be keyword arg or optional.
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I think it might be nice to move this in `TcpHeader`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
`To query state stores, it's required to first start Kafka Streams via {@link KafkaStreams#start()}. You can retry to query the state after the state transitioned to ...`
Nit: will this ever be null? Would be nice to know in an the implementation if it can assume it's never null. Also, need a description of the method.
typo `to to` (also missing `.` at the end of the sentence)
This style of setters is not AK convention.
nit: in kafka we normally don't use `get`/`set` prefixes
inventory plugin, not module ... also we can use 'short form' for licenses now
That would be ```suggestion version_added: '2.8' authors: ```
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
Please change this to 2017â2018, as the copyright should normally cover all years of artwork/code creation/updates.
Here you go https://smallbusiness.chron.com/year-copyright-statement-mean-62027.html
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
We don't need to make this change, do we? Let's try to minimize the changes to the existing code.
ditto here and others below
same for tests below as well
maybe rename this to `setUp` and put the loop populating the array in this method
This is no longer used, could be removed
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Do we really need a before and after? These are run completely sequentially, so the "before" of one test is the "after" of the previous. I'm just thinking of what the old output used to look like (a single line per test in most cases with "OK") compared to what we are moving to here (many lines per test, if I understand correctly).
Is this really necessary? Seems like it will produce a lot of noise.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
What is the reason for reordering all these parameters? This breaks `blame` attribution for these lines & doesn't improve the code.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
makes sense to me as well now, sorry for the noise.
Worth wrapping all these long fail_json calls at the comma before exception - otherwise it goes off the side at PR (I know there are lots of lines that are already too long but let's not add more)
This is used for both producer and consumer, so we'd better name it `props` not `consumerProps`.
Instead of `new MetricName("batch-size-avg", "producer-metrics", "", tags)`, I think we should use `metrics.metricName("batch-size-avg", "producer-metrics")`, right? The doc says `Please create MetricName by method {@link org.apache.kafka.common.metrics.Metrics#metricName(String, String, String, Map)}`. Same for other MetricName instantiation.
good catch! that means we are not properly testing this case either given that we didn't catch it.
makes sense to me as well now, sorry for the noise.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
We should use try-with-resources here (for `DataInputStream`).
This covariance stuff is insane.
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
Oh no! The build failed because of tabs! You can catch these sorts of things with `gradle core:precommit` which is much faster than `gradle core:check` because it doesn't run all the tests. I'll run the tests before pushing but for something like this it ought to be safe for you not to run them.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
The producer in the `WorkerSourceTask` automatically resends records, but if the producer fails to resend the [WorkerSourceTask enqueues the unsent records in `toSend`](https://github.com/apache/kafka/blob/08e8facdc9fce3a9195f5f646b49f55ffa043c73/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java#L343-L348) and send them again. It is true that this happens after each call to `poll()`, but if the send fails then `toSend` is non-null and upon the next iteration of the loop it will not call `poll()` and will then try resending whatever is in `toSend`. This will continue to happen as long as `toSend` is not null. However, in the current PR, even though this might happen, the loop may still ask for the source partitions and offsets and will synchronously commit them using the `offsetWriter`. So it is possible that a record with a particular offset `o1`, for a source partition `p1` fails to send and is retried, but then a connector then sets a later offset `o2` for the same partition and the connector commits offset `o2`. If the connector were to fail at exactly that point (which is possible), the `o2` offset may have been committed without the `o1` record being written. I understand that in your particular use case, you probably would only set the offsets for a particular partition if records were not written recently, but that doesn't change the fact that the `WorkerSourceTask` might be attempting to resend the previous records for quite some time. What if your new block of code were only performed if `sendRecords()` succeeded? I think there are a couple of issues with that as well. First, the offset writer is called synchronously, whereas other calls to commit offsets are sent a separate commit thread that calls multiple tasks. Now there are multiple threads committing offsets with potential race conditions and concurrency issues. Second, it still is a complicated API, and will developers truly understand when and how they use `getSourcePartitionAndOffset()`? Can I call it to read the last offset committed for a particular source partition? The worker doesn't ever set the offsets there. The WorkerSourceTask has a single, ordered pipeline for all records that each have their offsets. I still believe the best and most reliable and deterministic way to solve this is to use that same pipeline.
probably `new ThreadPool(Settings.EMPTY)` :) I wonder if the helper could hide the creation of the thread pool even, maybe not, but we will see that later. As you pointed out it may be that the helper is not needed at all.
got it thank you.
I may have forgotten, but what has changed here compared to the startFlush method? We don't call daemonThreadFactory as we dropped the name and settings requirement for logging right? I wonder if we should still call that and just provide the standard "bulk_processor" prefix.
I think I would consider taking settings out. We try to extract node.name from it as far as I understand, which I don't think is ever going to be set on a transport client. Maybe we can just live without that part of the thread name and remove some complexity. This may very well come from the times where node client was widely used, hence node.name made sense in the past, but it doesn't anymore.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
Could we collapse the code path for having a queryable store name or not into the same function? For example: ``` filter(.. /*nothing*/) calls filter(.. (String) null); filter(.. "storeName") calls filter(.. storeSupplier); // if storeName is not null, otherwise pass null as well filter(.. supplier) do the actual impl, which checks if supplier is null or not ```
nit: line too long
Nit: rename to `shouldThrowOnInvalidTopicNames`
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
typo: byteArrray -> byteArray
Nit: rename to `shouldThrowOnInvalidTopicNames`
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
typo: byteArrray -> byteArray
Since this doesn't change functionality, we probably don't want to change this just to update to modern syntax. The more changes we make like this, the harder it is to backport other fixes that might overlap with this diff, and ideally we backport fixes aggressively (and in fact, this could be an example where we might want to backport to a version that supports jdk7).
As mentioned in the KIP discussion thread: it seem unnecessary complex for user, to specify all those value. The only parameter that is mandatory is the window size. If people call `KGroupedStream#windowBy` all other parameters also optional; they should be optional when reading a topic, too.
I think we can fail the shard on _any_ failure here. failAndRemoveShard already does logging under WARN
`indexMetaData.getIndex()` -> NullpointerException!
Ah, yes, the magic is hardcoded here.
Well, that not how unit testing works :)
"with a read-only key"
with a read only key
nit: single parameter per line
Yes, we could add `ignoredExtensions` and include that in the log in the server.
I actually meant an error (http 400)? Messages can be ignored. This is just an invalid configuration.
Yes I think so.
ignoring the status here makes sense to me, but I wonder if we are 100% sure that the status returned by `ElasticsearchException#status` (which looks at cause etc.) will always be the same as what we got back (either as status code or within response body).
fillResponse can throw an already closed exception. We should make sure we deal with exceptions here correctly
Maybe warp the listener using ActionListener#wrap which does the write things and will simplify the code here too.
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
nit: one too many line break? :)
It should be robust in case of some missing fields.
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
ditto here and others below
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this: ``` private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) { final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get(); assertThrows(NoSuchElementException.class, iterator::peekNextKey); } ``` and then two public tests ``` @Test public void shouldThrowIfNoPeekNextKeyRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } @Test public void shouldThrowIfNoPeekNextKeyReverseRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } ``` Admittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
remove try-catch and replace with: ``` final StreamsException s = assertThrows(StreamsException.class, () -> testDriver.pipeInput(consumerRecord)); ``` assert afterwards and don't re-throw.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this: ``` private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) { final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get(); assertThrows(NoSuchElementException.class, iterator::peekNextKey); } ``` and then two public tests ``` @Test public void shouldThrowIfNoPeekNextKeyRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } @Test public void shouldThrowIfNoPeekNextKeyReverseRange() { final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics())); shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}))); } ``` Admittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
could these three methods somehow be in the base test class, at least partially? what I am looking for is avoiding copy pasting when writing new tests, and possibly not forgetting to cover important scenarios.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
nit: one too many line break? :)
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
To be consistent with KAFKA-2388, this should probably be: ``` java void subscribe(Pattern pattern, ConsumerRebalanceListener listener); ```
The indentation is off here.
In fact, it should probably say something like `Remove the plugin specified by {@code pluginName}.`
`pluginName` should still be wrapped in a code block (`{@code}`).
Let's drop the uppercase on `Terminal`.
This is the default.
Same minor nitpick about whether or not we need to check for an empty group ID.
This is also the default, I think.
Map.Entry<String, String> to avoid the check below
ditto here and others below
this could be: `assertThat(serializer.serialize(topic, null), nullValue())`
this one, too
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
This is the default.
The serialization package is open to everyone (it's public API and at the lowest layer). So I don't think we should worry about that. It's not like we're avoiding a dependency here, we are just hiding it via a string based config (that still requires the default constructor to be present).
We can pass the serializers in the constructor and it's a bit more concise.
This is also the default, I think.
We don't usually assert on exception messages as it makes tests a bit brittle. This applies to a few other tests too.
we can maybe use similar technique as we do in `QueryParsingException` and also report the location
As far as I can (brief check only) they are always null, but it wasn't part of the API to change properties that are not part of the json being parsed. Not a big deal..
You could make it the same with an `else if` instead of `else`: ``` } else if (theAnalyzer != null) { builder.searchAnalyzer(theAnalyzer); } ```
Strictly speaking this is different than the previous code - if none of index analyzer , search analyzer and theAnalyzer is set, we reset the indexAnalyzer and searchAnalyzer on the builder to null. We didn't use to do it...
if we only use all names to put things in the map we lose all the deprecation warnings that we might have etc. we should rather keep track of the original ParseField and call ParseFieldMatcher#match.
nit: one too many line break? :)
Prefer an anonymous Func1, for example, ``` java public <R> Observable<R> mergeMapIterable(final Func1<? super T, ? extends Iterable<? extends R>> collectionSelector) { return flatMap(new Func1<T, Observable<? extends R>>() { @Override public Observable<? extends R> call(T t1) { return Observable.from(collectionSelector.call(t1)); } }); } public <U, R> Observable<R> mergeMapIterable( final Func1<? super T, ? extends Iterable<? extends U>> collectionSelector, Func2<? super T, ? super U, ? extends R> resultSelector) { return mergeMap(new Func1<T, Observable<? extends U>>() { @Override public Observable<? extends U> call(T t1) { return Observable.from(collectionSelector.call(t1)); } }, resultSelector); } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could be `contentType = scriptMetadata.getOptions().getOrDefault(Script.CONTENT_TYPE_OPTION, DEFAULT_CONTENT_TYPE);` And then you can remove the null check below
as above: avoid `/` Update to ``` log.warn("Unable to read '{}{}{}'. Using default inputValues list", "resources", File.seperator, fileName); ```
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Not related to this PR but I think that we should check if what we are trying to remove is not part of the BLACKLIST. Someone could potentially provide a plugin which contains his own `bin/elasticsearch` script, which looks scary to me.
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
as above: avoid `/` Update to ``` log.warn("Unable to read '{}{}{}'. Using default inputValues list", "resources", File.seperator, fileName); ```
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I'm doubting if we should introduce generics for the BatchingTask and batchingKey. I'm fine with keeping as is if you don't like the generic version.
`name()` -> `wrapped.name()`
What is the reason for having `assertDoesNotThrow` here and below? The test will fail if an exception is thrown, so seems like unnecessary noise.
I just thought about this. I think `endOffset` should be actual endOffset, ie, `11` for this test -- we pass in the `offsetLimit` as 5 in `StateRestorer` below.
I think this way of triggering the exception is not only complicated but it even might be a source of flakiness. Could we have some more straightforward? I think the original solution (overriding getResponse) was better than this.
Okay, I see later that we catch the overflow exception and that we skip adjusting; I need to think about this.
```suggestion module.exit_json(changed=True,**camel_dict_to_snake_dict(res))) ```
I'm not convinced we should ignore failures. These tasks still occupy queue capacity, and there is no guarantee they failed quickly, a thread can be executing for awhile before failing.
I'm not convinced in th soundness of the bookkeeping here. I think that `totalNanos` can include the total task time for more than `tasksPerWindow` tasks.
You can achieve this same result output with `module.exit_json(changed=True,**camel_dict_to_snake_dict(execution))` which can be imported from `ansible.module_utils.ec2`. That will automatically cover if AWS ever starts returning additional keys from this API and is generally easier to maintain.
The variable name `phand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
at this point you don't need the restClient variable anymore
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
`app_configs` is initialized as an empty dict, so this line should be unnecessary :thinking:
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
oh seems like you also removed some ParseFieldMatcher usages, nice :)
I think the norm is to use `apps` instead of `app_registry` to designate `Apps()` instances around the codebase.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
Are you going to update the other two to remove unnecessary operations? That's all that's left and then I can merge the PR. Thanks!
I think the message needs to be updated.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Can we keep the refs to these internal clients
Do you think we could have something like: ``` java bulkRetry = Retry.on(EsRejectedExecutionException.class).policy(BackoffPolicy.wrap(backoffPolicy, task::countBulkRetry)); ``` I find it easier to know what's going on on bulk retries.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
nit: We use singular verbs in other functions (e.g. line 54 above), would be better to be consistent.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
nit: one too many line break? :)
given that we also filter responses by creating a new response filter chain and filtered action listener, this inner class is not just a request filter chain... can we maybe merge the two at this point? Seems like in the end we either filters nothing or both (request and response) anyway...
Correct me if I am wrong but these filters have to be executed in a serial fashion one after another, right? So you can make this async if you need to on top of the blocking loop? I would like to see an example where this is used to understand the rational please :)
can we just have this variant not the one that takes a String.
Can we keep the refs to these internal clients
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
nit: The method signature for StatAndConfig has MetricConfig parameter first and MetricName second. This one has the reverse order.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The message doesn't seem to match the condition above.
you can just do the conversion to unmodifiable map one time in the constructor. it looks like at the moment this is only accessed in tests anyway.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
sorry I didn't see that you created a copy (I missed the "new HashMap" part)
(and also the fact that it will be lost on serialization, etc.)
We discussed this on Slack and concluded that this is an unimportant special case in which it's painful to check the authorization correctly but, moreover, we can just ignore the auth checks on this API without losing anything significant. Arguably this could just use a `nonAuthPath`. I think get this special case out of the way first and then neaten up the rest and move it into `Bucket`.
I suspect it's now neater to turn this logic around - find the appropriate `Bucket` using `request.getParam("bucket")` and let the `Bucket` check the authorisation, look up the handler, and do the necessary.
you could extract this in a private method to share some code with the scritp execution below.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: missing a space after the first comma
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
nit: missing a space after the first comma
should we apply a try-catch patter instead of annotation? It's not a single line test? (same below)
ditto here and others below
My rationale is mainly around typos :) In the past I have some experience spending much time on troubleshooting a typo caused issue, since these issues are usually not well exposed in the exception messages, e.g. if you had a `stream-record-cach-metrics` in one of the lines it would be hard to find out..
same for tests below as well
You don't need to specify any symbolic name for a group since you have only one.
We need to cast indeed, but I want to give the compiler opportunities to find errors, which is never possible when one starts definiting methods whose generic parameter is only used in the return value. By the way I'm thinking that we could make casts more safe by making category a class instead of a string, and this class would be the base class of the object that the namedwriteables can deserialize
This is probably just my style bias, but I wonder if it would be easier (and more readable) to use static factories for atomic vs non-atomic ControllerResult. Something like: ```java ControllerResult.newAtomicResult(records, response) // and ControllerResult.newResult(records, response) ``` Boolean flags as such a pain and easy to mess up. I actually think it might be nice if there are no public constructors for ControllerResult and we use factories for everything. However, this would be a bigger change, so I'm fine if we defer it (if we even decide we need it).
nit: add `{ }` to then block (we always use `{}` for all blocks.)
I don't think you need @Before here, the parent method already has it.
@bbejeck That is a good question! Originally I thought it is okay to always calling `hasNext` inside `next()`, as long as we make sure `hasNext` implementation is idempotent, i.e. calling it multiple times before `next()` does not have side effect is sufficient. But by making it idempotent we could have the corner case you mentioned. For example: ``` t0: call `hasNext()` -> store is still open -> call `makeNext` -> `next` field is set. t1: store is closed. t2: call `next()` -> call `hasNext()` again ``` Without this check, at `t3` we would still return the `next` field.
Sorry for my denseness... Why are these "not re-assigned"? They're part of a data structure called "assigned tasks", which seems to imply that they are assigned.
nit: keep fields with the same access level together
`maxWrnHeaderSize` -> `maxWarningHeaderSize`
I'm not too keen on these variance changes unless you can show that there is an inference problem with lambdas under 8 without them.
would be nice to allow to configure it to a percentage of the heap size
nit: extra line
If the intention is for this to be immutable then you should wrap the `new TreeMap` with `Collections.unmodifiableSortedMap()`, because otherwise a caller can modify it via the getter.
Similar to above, `new TreeMap` should be wrapped with `Collections.unmodifiableSortedMap()`.
makes sense to me as well now, sorry for the noise.
It might get written out correctly via toXContent, but I doubt it works when only going through the java api.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
Suggestion: We already say "Kafka Streams API", "DSL", and "Processor API". That's already a lot of "APIs" even though it's all about the same thing. I wouldn't label interactive queries to be yet another API. I'd just say: > ... to access the content via interactive queries:
In general this would be better as a unmodifiable map. I am not a fan of doing it this way. We should be able to challenge with more than a single scheme
Consistency: Here we say > with [a] custom "auto.offset.reset" strategy and below we say > Enum used to define auto offset reset policy when creating {@link KStream} or {@link KTable}. The AK docs say neither "strategy" or "policy", it's just a config like any other. Hence I'd suggest to change the above consistently to sth like: > with [a] custom {@code auto.offset.reset} configuration and > Sets the {@code auto.offset.reset} configuration when creating {@link KStream} or {@link KTable}.
Typo: > Similar[ly], you can ... with [a] custom ...
This is still missing in the KIP wiki page.
Refer to the `processing.guarantee` config here.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
`scheduler` does not appear in parameter list of this method...
`scheduler` has no effect here...
should we use a native trove collection here from String to long
Refer to the `processing.guarantee` config here.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
`scheduler` does not appear in parameter list of this method...
`scheduler` has no effect here...
should we use a native trove collection here from String to long
`Note when the windowed serde class is used, one needs...`
This selector is never used since we create a Selector a couple of lines below using `createSelector`. We should remove these three lines and the `logContext` created at the start of this test.
doesn't matter that much, I thought -1 didn't make sense :)
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
boost will be gone once you rebase, same for queryName
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Please remove empty line.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Could surround this call with new lines as you did for the others? Makes the calls under test more visible.
No, this does not give your any safety.
No, this does not make any sense.
Great catch! Do we have a test for this bug? We should include this fix in 0.11.0.1.
This data construction seems better to be put in the `AlterConfigsResponse` constructor.
Yea, my suggestion would be to reuse the existing constructor as the construction of the `AlterConfigsResponseData` seems non trivial for a caller to do, compared with passing a map of errors.
nit: missing a space after the first comma
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
Was just thinking about how long a. transaction might possibly be open. 1 minute SGTM
nit. I think there is `.` missing `since 3.0[.] Use`
ditto here and others below
Might be simpler to use the mock deserializer only for values.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
ditto here and others below
You have some unmerged lines here
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
add a private constructor so it is not possible to instantiate it. Maybe even make it final, although it is redundant with the private constructor.
This class looks pretty complicated, can you please cover it with tests? https://codecov.io/gh/ReactiveX/RxJava/src/4f2eecee404238b49c4ac0f2f074ed6d63938231/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
can we pass in the supplier here too? No need to provide the whole parser.
No need for the newline here
possibly use a `SimpleFileVisitor` here to not override all methods
you can reduce this code by using only the `nio` classes instead of moving forth and back between NIO and `File`, see `java.nio.files.Files` for things like moving `Path`
`FileAlreadyExistsException` is an `IOException` and this `IOException` block does the same thing as doing nothing -- `return CONTINUE;`.
Yes, but replace `FileAlreadyExistsException` with `IOException` to maintain the same functionality. Sorry for saying it so confusingly before.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
You don't need to specify any symbolic name for a group since you have only one.
Indentation doesn't look right here.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
```suggestion public void shouldInstantiateAssignor() { ```
nit: could use Utils.mkSet
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
nit: remove the redundant line. Same as below.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
Nit: you can remove `value =`
`asList` -> `Collections.singletonList`
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
Can this lead to user code change? ( as you changed the tests above )
This would be less mysterious if this method were inlined into `updateLimitOffsets`. Right now, it's not terribly clear why it's ok to set the "last update offset time" in a method that doesn't update the offsets.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
nit: one too many line break? :)
Can this lead to user code change? ( as you changed the tests above )
This would be less mysterious if this method were inlined into `updateLimitOffsets`. Right now, it's not terribly clear why it's ok to set the "last update offset time" in a method that doesn't update the offsets.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
nit: one too many line break? :)
We can use `<>` in the right-hand side. Also, we can just pass the serializers in the constructor to make the example simpler.
Nit: space missing after `for`.
Use diamond (`<>`).
ditto here and others below
Using generic types instead of raw types for collections is preferable (we can fix elsewhere in the file too) ```suggestion List<?> items = (List<?>) value; ```
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
nit: I think formatting corrects this (at least on intellij). Can be fixed below too ```suggestion for (Object item : items) { ```
nit: Starting a message with lower case feels a little unusual.
`instanceof` checks for `null` too. I wonder if it's better to combine these two cases to say that we expect a list with at least one value (meaning a non-empty list).
perfect thanks. sorry for the confusion.
maybe not appropriate here, but we can do this with one underlying read of metadata via Files.readAttributes (you then have isRegularFile() and size() available from BasicFileAttributes)
This has to use the new settings API.
I think it'd be nice to have an assertion on the text of one description just so we can look at it.
It would make sense to refactor this into `private Settings newNodeEnvSettings()` since every test requires it, in case it ever has to be changed in the future.
> and re-using the `KGroupedStream` results in an `InvalidToplogyException` when building the topology I thought, if there is no user topic-name, old code would create multiple repartition topics? And re-using `KGroupedStream` only throughs if there is a user topic-name (and this restriction is lifted with this PR)
> That's correct. I may not have been clear above, but what I meant is that this change won't break compatibility with users currently **_not providing_** a repartition topic name as it will create multiple repartition topics thus keep their topology the same. Does that make sense? Ack. Just wanted to make sure we are on the same page :)
Since timezone is now a string, we should probably check for `Strings.isNullOrEmpty()` instead of just null now. (or null/empty check, I'll leave that up to personal preference :) )
I think I would consider taking settings out. We try to extract node.name from it as far as I understand, which I don't think is ever going to be set on a transport client. Maybe we can just live without that part of the thread name and remove some complexity. This may very well come from the times where node client was widely used, hence node.name made sense in the past, but it doesn't anymore.
Could store `entry.getKey()` in a local variable since it is used several times
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
I'd suggest moving this static method after the non-static methods.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
I just noticed this isn't even being used by OperationDelay.
nit: remove the redundant line. Same as below.
nit: could use Utils.mkSet
`asList` -> `Collections.singletonList`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
yeah, I was thinking we could validate the input with a regexp first, but maybe it's easier/safer to reimplement the parsing logic
I'd suggest moving this static method after the non-static methods.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
we should do this `assertTrue` thing for the CooperativeStickyAssignor as well
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I'm not sure it is ever good for this to be a global default. Haven't we learned that it causes nasty issues in places like event loops? It seems only appropriate for separate threads, like the IO or NewThread schedulers.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
recommended; ditto below.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Indentation doesn't look right here.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
nit: one too many line break? :)
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Btw, we should take the chance and make `version` and `commitId` final. Something like: ```java private static final String version; private static final String commitId; static { Properties props = new Properties(); try (InputStream resourceStream = AppInfoParser.class.getResourceAsStream("/kafka/kafka-version.properties")) { props.load(resourceStream); } catch (Exception e) { log.warn("Error while loading kafka-version.properties :" + e.getMessage()); } version = props.getProperty("version", "unknown").trim(); commitId = props.getProperty("commitId", "unknown").trim(); } ```
Let's use try with resources here and the other test so that the file is closed after it's used.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Btw, we should take the chance and make `version` and `commitId` final. Something like: ```java private static final String version; private static final String commitId; static { Properties props = new Properties(); try (InputStream resourceStream = AppInfoParser.class.getResourceAsStream("/kafka/kafka-version.properties")) { props.load(resourceStream); } catch (Exception e) { log.warn("Error while loading kafka-version.properties :" + e.getMessage()); } version = props.getProperty("version", "unknown").trim(); commitId = props.getProperty("commitId", "unknown").trim(); } ```
Let's use try with resources here and the other test so that the file is closed after it's used.
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Perhaps we should not change the return type here unless we decide to make the more extensive `LinkedHashSet` change across all APIs (and corresponding KIP).
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
nit: unneeded parenthesis
Since this query is a pure wrapper, I'm wondering if you should delegate calls to setBoost/getBoost (and then ignore the boost in equals/hashCode)
It seems like we're duplicating some of the logic contained in `Plugins` into this class by tracking class alias names and pre-computing plugin type based on them. Did you consider a `Herder` method that only accepted the name of the plugin, and took on the responsibility of deducing the plugin type itself? ```java List<ConfigKeyInfo> connectorPluginConfig(String pluginName); ``` In `AbstractHerder`, we could do something like this: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { Object plugin = Plugins.newPlugin(pluginName); PluginType pluginType = PluginType.from(plugin.class); List<ConfigKeyInfo> results = new ArrayList<>(); ConfigDef configDefs; switch (pluginType) { case SINK: case SOURCE: configDefs = ((Connector) plugin).config(); break; case CONVERTER: configDefs = ((Converter) plugin).config(); break; // ... Rest of switch statement follows same pattern, and rest of the method remains unchanged } ``` And in `Plugins` we could do this: ```java public Object newPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends Object> klass = pluginClass(delegatingLoader, classOrAlias, Object.class); return newPlugin(klass); } ``` Or alternatively, we could introduce a common interface for plugins that expose a `ConfigDef`: ```java interface DefinedConfigPlugin { ConfigDef config(); } ``` Which could really simplify some of the `AbstractHerder` logic: ```java @Override public List<ConfigKeyInfo> connectorPluginConfig(String pluginName) { try { DefinedConfigPlugin plugin = Plugins.newDefinedConfigPlugin(pluginName); ConfigDef configDefs = plugin.config(); // No switch statement on plugin type necessary // ... Rest of the method remains unchanged } ``` And the change to `Plugins` would be lightweight as well: ```java public DefinedConfigPlugin newDefinedConfigPlugin(String classOrAlias) throws ClassNotFoundException { Class<? extends DefinedConfigPlugin> klass = pluginClass(delegatingLoader, classOrAlias, DefinedConfigPlugin.class); return newPlugin(klass); } ``` Worth noting that if we want to differentiate to users between "this plugin is not on the worker" and "we don't expose config information for this type of plugin", we'd have to make a few further tweaks.
How about just throwing `NullPointerException` here? If that causes other issue, could you add some useful exception message, such as, `Should not add null Throwable to CompositeException`? So that people can quickly figure out it's an application bug instead of an RxJava bug.
I thought it was unintentional. Never mind. See this style for the first time :)
we should escape expectedWarningHeaders, or alternatively unescape when we read.
why did you remove this? What if we have multiple pattern that match multiple snapshots? we now add these multiple times. For example: `foo*,*bar` will match the snapshot `foobar` twice.
Would it be a lot easier to do the following? ``` Map<String, Object> prefixedOriginals = connectorConfig.originalsWithPrefix(prefix); Map<String, Object> clientConfigs = configDef.parse(prefixedOriginals); ``` This does check a few more things (dependencies are set and validators are run), so maybe that's not really want we want to do here.
This exception is no longer possible since the constructor is taking `ObjectName`.
We typically avoid the `get` prefix in Kafka, so `objectName` seems fine.
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
OK sorry, I had missed the dependency resolution issue. Then I suggest to keep your current solution for potentially revisit when all aggs are refactored and we have a better picture.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
Checkstyle is unhappy with this.
Can you make this a full `if` statement, it's really easy to miss the `return` while reading in this format
Checkstyle is unhappy with this.
Strings.EMPTY_ARRAY could be used too (if you want)
Checkstyle is unhappy with this.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
Did you mean: ```suggestion setBrokerId(3). setBrokerEpoch(100). ```
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
> toArray() returns an Object[] depends on which toArray method you use. Just move to the one that accept an array as argument. Or iterator is fine too.
Could you have the score scripts as separate scripts rather than repurposing the existing ones? I think its important that we continue testing scripts that don't use score as well as scripts that do.
ditto here and others below
I'm not sure about this, it is a usage error.
Yeah, exactly, and I think usage should really be reserved for incompatible or invalid arguments, for example. This is more a state thing, so now I think I'm convincing myself that configuration is apt.
I don't have a better suggestion, but targetTopicPartitionsUpstream is a kinda confusing name.
Nit - there is a stream::toArray(Directory[]::new))
This variable needs to be `final` says checkstyle.
```suggestion }, "The number of active tasks returned in the allotted time was not one."); ```
Up to you but I find it more intuitive to collect all the explicit write indices (i.e. flag is true) regardless of size if that is empty we check if `referenceIndexMetaDatas` is of size 1 and if the first value has ` null` for the flag, if so we set `writeIndices` to referenceIndexMetaDatas and be happy.
you can just do the conversion to unmodifiable map one time in the constructor. it looks like at the moment this is only accessed in tests anyway.
I think key-pairs of strings as list is brittle. But we inherited that.
It was removed from the other versions of `group` but not from here.
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
bit-nitpick :) ``` // modulo 2 operation if ((keyValue.length & 1) != 0) ``` most definitely optimized out by JIT because the divisor is known (`2`). Is it too hard to read? Sometimes it's good to train ppl who read the code by example. Can't be more nitpicking than that and if you want to keep uniformity with other versions of `getTags` elsewhere never mind. Not 100% sure either, leaving here to ask what you think in general for such optimizations that are JIT optimizable too.
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
Ah I see, thanks!
Does that mean that `XXXOrDefault` have to be covariant as well :-( ``` public T singleOrDefault(T defaultValue) ```
This covariance stuff is insane.
and remove the below null check
otherwise I would be happy to just return in the else block and remove the instanceof check in the while loop below
nit: one too many line break? :)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Please put it into an assert if you keep it. Iâd remove it.
I wonder if we need this at all. The blocking call to the client executes it anyway. The issue was that there was no testing. I think this entire transport action can use a ml threadpool instead
Even if the number of sub aggregation is expected to be small, I'm not too happy with the use of `ListIterator.add` which is linear on array lists.
Checkstyle is unhappy with this.
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
unused import now, no? https://github.com/elastic/elasticsearch/pull/16432/files#diff-208398fdbe888b55ad36dd4f161fdf48L22
```suggestion Question.objects.create(question='Not a question.') ```
To avoid the interesting indentation: ``` msg = "<class 'admin_views.models.Question'> is not registered in the admin." with self.assertRaisesMessage(Http404, msg): ```
see above - I think you should add it though
`.get(self.live_server_url + reverse('admin:admin_views_question_add'))`
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
`requireNonNull` seems not to be necessary
We can remove `requireNonNull` here, because `getter.keySerde()` would already throw a `ConfigException` if the default serde is null.
We should probably assume that people won't be using request throttling immediately since it was just introduced. But the same can probably be said for transactions.
Also, 5ms seems a bit extreme. Maybe this could be 20ms or so and we could use the minimum of this and the configured retry backoff so that users can adjust it lower if they need to.
Yeah, I have no doubt the performance is better. It's just that it seems like a lot of excess traffic and is going to be amplified by the number of transactional producers. It may be fine in the common case if the write markers are pretty quick, but if there is any kind of delay, then I'd be concerned about the brokers being overwhelmed with these requests (though maybe it's not as bad with request throttling). I'd rather err on the safe side for now since users can manually adjust the backoff. For the 0.11.0.1 release, we can provide a better solution. Most users will probably hold off until then anyway.
If we don't cache the fields, we should remove the fields.clear() at the end.
add `fail()` in next line to make sure we hit the timeout and throw an `AssertionError`
nit: `/** ... */` -> `/* */`
We usually avoid the get prefix in cases like this
nit: add `final`
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
We can use `assertThrows` for this kind of pattern: ```java RecordDeserializationException rde = assertThrows(RecordDeserializationException.class, () -> consumer.poll(Duration.ZERO)); assertEquals(invalidRecordOffset, rde.offset()); assertEquals(tp0, rde.partition()); ```
Might be simpler to use the mock deserializer only for values.
Do we need `invalidData`? Seems like we can just do this: ``` if (i == recordIndex) { throw new SerializationException(); } else { i++; return super.deserialize(topic, data); } ```
ditto here and others below
same for tests below as well
nit: one too many line break? :)
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
In current design (KIP-19), expiration of a batch in the accumulator is to avoid holding the batch forever in the accumulator when the partitions has no leader. If the batch can be drained, that means it can still make progress. In that case, we probably don't want to expire that batch.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Perhaps open a separate pr for the change to this method? This adds additional validation outside concrete index to data stream lookup.
In case of LOCAL_SHARDS/RESTORE, we could again call activatePrimary here.
Note that in case of peer recovery with a retry, we could end up with a higher gcp in the globalcheckpointtracker than what we're setting here.
wondering if we need recoveryState.isPeerRecovery() to simplify these lines.
Can you please elaborate why we no longer read the header during construction? It seems to me that `checkHC` could be a constructor parameter and then we could keep it as a private and final variable and less changes would be required. But maybe I am missing something. Note that public and mutable variables are generally avoided in Java.
I think your IDE is adding extra braces. (I know this is a bit annoying between Apache Kafka & Confluent projects since they use different styling. iirc default IntelliJ styling works for Kafka if you are using IntelliJ)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
This could be: ```java try (BufferedReader br = Files.newBufferedReader(Paths.get(args[0]))) { ... } ```
Whoops yeah, I only looked at the version for `Files` rather than `Files.newBufferedReader`, sorry
Do we gain anything by passing a reader into `parse`? It seems like it'd be easier for testing if you pre-read the file into a String or a list of lines and then passed it into parse. Are we concerned about the memory of reading `jvm.options` up front? (It would also let us separate errors reading the file from errors parsing the file from a feedback perspective)
It would also allow us not to have to make `parse` throw a checked `IOException`
nit: add a size? There are a few cases in here where we could do this.
what's the difference between TermsLookup and TermsLookupBuilder? I am thinking if we can just make TermsLookup Writeable etc. and avoid adding a new class that holds the same info.
No, you are right, I didn't realize the need for api users before going through the whole changes.
this curly bracket should be on the previous line
Hmm, doc says `The order defaults to desc when sorting on the _score, and defaults to asc when sorting on anything else.`, so maybe having the default in the enum is missleading.
I see, so parser always sets both "order" and "mode", regardless of whether they are set by the user. But what if we only go through the java api, use a plain builder and set "reverse = false". Translated to json this should give us "mode = MIN", but only if not explicitely set by the user otherwise, no? Sorry, haven't got a good solution myself so far either.
It's super minor, but I think we usually don't include punctuation at the end of exception messages (the `.`)
I don't think raising en exception to save a few lines of code here is a good idea, please change this back to how it was before.
By that I mean a switch or something similar to what SuggestUtils#resolveDistance() does.
oh nevermind I thought it was a parsing method, but this is the simple Enum.valueOf
I think we should only log.warn here. I can imagine that at some point AWS may support this in China and I would not block users for this. May be we should not control that at all and let the user specify whatever he wants. I mean that if this plugin is used with other S3 compatible platform, we can't do those checks.
The parameters can be `final`.
typo: an -> a, concat -> concatenated
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
The parameters can be `final`.
typo: an -> a, concat -> concatenated
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
we're in Java8 now... I think you can do: `(key,value,context) -> { ... }`
we end up supporting both `$stashedKey` and `foo${stashedKey}bar` ? we may want to move to the latter once all the clients runners implement this feature, to have a single way to get stashed values.
maybe ${stashedKey} alone should return an object then? Does that complicate things? Calling toString makes sense when the stashed thing is part of a string, otherwise returning the object sounds better.
maybe just `esVersion()`
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
I also feel that we can collapse the layered interfaces a bit further after we've changed this, since the original motivation of having it is just to "stitch" the global stores and local stores together when exposing as `KafkaStreams#stores`. We can consider that in a separate, cleanup PR afterwards.
I can work on the follow-on change. WrappingStoreProvider -> WrappingStateStoreProvider GlobalStoreProvider -> GlobalStateStoreProvider QueryableStoreProvider is left as is.
With this change, just Global and Wrapping StateStoreProviders exist? IIUC, most of the `xxxStore` classes are just accessing the `Wrapping..` store provider? Makes me wonder, if we should just use the `QueryableStoreProvider` everywhere and cull the interface.. Anyway, I am not familiar enough with this part of the code. So I leave it to you..
Probably for another PR since it's unrelated but I wonder if `scriptable`, `formattable` and `timezoneAware` should be properties of the Builder object rather than/ as well as the parser so the builder can ensure an IllegalArgumentException is thrown if e.g. an unscriptable agg has the script method called on it? /cc @jpountz
so what about the other settings you can set on the Item like source filtering? I think we should expose all of them here though.
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
nit. I think there is `.` missing `since 3.0[.] Use`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
happens in other tests too.
I just noticed this isn't even being used by OperationDelay.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
happens in other tests too.
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
nit: indent not aligned, as @mjsax mentioned above.
Indentation doesn't look right here.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Can we also clear the temp `charBytes` array, something on the lines of: ``` final byte[] charBytes = CharArrays.toUtf8Bytes(password); try { return builder.startObject() .field("password").utf8Value(charBytes, 0, charBytes.length) .endObject(); } finally { Arrays.fill(charBytes, '\u0000'); } ```
I also need to go back and do this for the PutUserRequest
this should be done by just reading username password from the Credentials
No. You should not shadow the original explicitly provided password.
no need to implement/override this method if no validation is required
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was not aware of the restriction on JSON object keys, and that seems like a fine standard to follow. I can't imagine it being too useful.
Can we also clear the temp `charBytes` array, something on the lines of: ``` final byte[] charBytes = CharArrays.toUtf8Bytes(password); try { return builder.startObject() .field("password").utf8Value(charBytes, 0, charBytes.length) .endObject(); } finally { Arrays.fill(charBytes, '\u0000'); } ```
I also need to go back and do this for the PutUserRequest
this should be done by just reading username password from the Credentials
No. You should not shadow the original explicitly provided password.
no need to implement/override this method if no validation is required
nit: one too many line break? :)
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
@guozhangwang Yes, keeping the reference is fine. I was concerned by the check itself because we were calling `generation()` twice in the previous implementation thus we could get two different instances. ``` generation() != Generation.NO_GENERATION && !protocolName.equals(generation().protocolName) ``` I haven't thought about the error-log but it is also a good point.
@dajac just to clarify, are you concerning that the `generation()` may change between the check and the error-log? If yes maybe we do not need to synchronize the whole function, instead we just get a reference of the returned `generation()` call and use that in the error-log, since the generation object is immutable.
I think you can remove `isSSLPropertyPresent` here, it's always true as it's checked above.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
We should log an error that prints out what the two configs actually are
@guozhangwang Yes, keeping the reference is fine. I was concerned by the check itself because we were calling `generation()` twice in the previous implementation thus we could get two different instances. ``` generation() != Generation.NO_GENERATION && !protocolName.equals(generation().protocolName) ``` I haven't thought about the error-log but it is also a good point.
@dajac just to clarify, are you concerning that the `generation()` may change between the check and the error-log? If yes maybe we do not need to synchronize the whole function, instead we just get a reference of the returned `generation()` call and use that in the error-log, since the generation object is immutable.
I think you can remove `isSSLPropertyPresent` here, it's always true as it's checked above.
Consider `value.isEmpty()` instead of `value.equals("")`. Also, would it be safer to do to avoid potential incosistencies (same for above): ``` return !(value.isEmpty() || isExplicitFalse(value)); ```
We should log an error that prints out what the two configs actually are
I mean to say that I think you can just call `Strings#toString`.
same for tests below as well
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
It should be robust in case of some missing fields.
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I mean to say that I think you can just call `Strings#toString`.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
I just noticed this isn't even being used by OperationDelay.
Ah, okay. Thanks.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Nit: add a space between `if` and `(`
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Same with this, we are actually testing the deprecated method here, so we can justify the suppression.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
Ah yes, I was thinking about ReadOnlyWindowStore exposed in IQ only. All good.
Idk, the current defaults make sense to me. If a user has a custom store and wants to use the new `backwardFetchAll` with both longs and Instants, all they'd have to do is override the long-based `backwardFetchAll` method (they have to implement the long version no matter what, since this is what gets used internally to Streams). If we just throw UnsupportedOperationException directly from the default implementation of the Instant-based `backwardFetchAll`, then they would have to override that as well in their custom store. So we should just let the Instant default to the long method so users only have to implement one method instead of two (plus they would have to do the Instant validation themselves, etc)
I think you also need the following test (here and in the other `*Windows`): ``` assertThat(DEPRECATED_OLD_24_HR_GRACE_PERIOD, is(Duration.ofDays(1).toMillis())); ``` Otherwise we will not notice if `DEPRECATED_OLD_24_HR_GRACE_PERIOD` is changed by mistake.
Alternatively, you could use `24 * 60 * 60 * 1000L` instead of `DEPRECATED_OLD_24_HR_GRACE_PERIOD` in the tests.
```suggestion assertEquals(0L, JoinWindows.of(ofMillis(DEPRECATED_OLD_24_HR_GRACE_PERIOD)).gracePeriodMs()); assertEquals(0L, JoinWindows.of(ofMillis(DEPRECATED_OLD_24_HR_GRACE_PERIOD + 1L)).gracePeriodMs()); ```
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Nit: add a space between `if` and `(`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
Nit: add a space between `if` and `(`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
The method was not named as a setter in groovy so this could be DSL-like. ie, usage looks like (notice the lack of equals sign): ``` noticeTask { licensesDir 'foo' } ```
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
I would prefer not to use `ExtraPropertiesExtension`. Let's add our own extension instead. We would need to go trough build scripts now, but having that extra namespace would make it clear when reading the build script where these are coming from, and there are fewer chances to clash with something in the build script ( thinking about users of build-tools here).
Nit: add a space between `if` and `(`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
I don't think that this is the right place for this. Since #13086, we already do duplicate settings validation in the `XContentSettingsLoader` and the `PropertiesSettingsLoader`, and this kind of check should sit right along side those checks (rather than having these checks spread out). If we do add this check to `XContentSettingsLoader`, this pushes the check as far down as it can go, and enables us to fail as early as possible. As a bonanza, we can give an error message that includes the line number that the failure occurred on. This is as user-friendly as we can get here. I didn't realize that you had opened this pull request, but I already opened #17310 that does exactly this.
I would prefer not to use `ExtraPropertiesExtension`. Let's add our own extension instead. We would need to go trough build scripts now, but having that extra namespace would make it clear when reading the build script where these are coming from, and there are fewer chances to clash with something in the build script ( thinking about users of build-tools here).
Nit: add a space between `if` and `(`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`<byte[]>` this explicit type is unnecessary
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
redundant type arguments `<ProducerRecord<byte[], byte[]`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
Instead of adding these plugins as we go, we can get the `values()` from `loaded` at the end of this method.
This logic is not exactly the most straightforward. What about something like this? ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { Versioned versioned; if (pluginImpl != null) { versioned = (Versioned) pluginImpl; } else { versioned = (Versioned) pluginKlass.newInstance(); } return versioned.version(); } return "undefined"; ``` or ``` if (pluginKlass.isAssignableFrom(Versioned.class)) { if (pluginImpl == null) { pluginImpl = pluginKlass.newInstance(); } return ((Versioned) pluginImpl).version(); } return "undefined"; ```
something is wrong in this sentence :)
This could move to `ListOffsetResponse` as a helper, and maybe name as `singletonListOffsetTopicResponse`
Would be better to describe what `cases` are referring to.
How does the volume of data relate to the slowness of the search api in the remote cluster? We are using scan search which is pretty fast and doesn't do deep pagination, and e.g. socket timeout set to 10 seconds doesn't mean that the whole response has to come back in 10 seconds, the request only times out if no data comes back for 10 seconds at any point of the request execution.
I hope I'm not splitting hairs, but there's also a typo in the field (deault is missing and 'f'). (This PR resulted from a question I asked here; thanks for all the awesome work you invest there!)
good call on the typo. I did see the issue that originated this change, thanks for the heads up ;) Just trying to understand if yours is a special case that needs a custom timeout (which could be set), or whether the default timeout really has to be increased that much.
We did used to do this but we've moved away from it. So you'll see examples in the code when we had this but it is no longer the preferred way.
can we reduce visibility? eg. pkg-private
I'm not sure we want `match` to be `contains` in some cases. If we want this we should make a new construct.
+1 from my side as well
+1 looks redundant to me
this means the mutable ShardRouting will have their hashes re-calculated every time . Can you double check the impact this have on a huge routing nodes and the balancer (your favorite code :)).
is this somewhere on a todo? I'm afraid we'll loose it
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
`/`, `:`, `\`, `|`, `<`, `>`, `"`, `?` and `*` are already always stripped.
I think it is more idiomatic to statically import the `instanceOf`.
If you want to test the multi-write behavior you could make a testing aggregation here that needs to be rewritten twice. I'm not sure how important that is to you, but it ought to be possible.
I think we can check also randomly on a shard that relocates _to_ the local node
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
same 1+ randomInt
I think it is more idiomatic to statically import the `instanceOf`.
If you want to test the multi-write behavior you could make a testing aggregation here that needs to be rewritten twice. I'm not sure how important that is to you, but it ought to be possible.
I think we can check also randomly on a shard that relocates _to_ the local node
Maybe `Producer epoch...`. Also, not sure the exception message adds anything given what's already logged. Maybe we should remove that.
same 1+ randomInt
similarly, equals uses the hash while hashCode doesn't
It feels wrong that hashCode is using writtenBy while equals isn't
no worries as soon as you rebase you won't need to take care of boost and _name, it's done automatically.
you can use the util method printBoostAndQueryName here now (once you rebased)
we need a consolidation of all the score mode / type we have at some point, not here though
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`assertThrows` is what we use for some time now, and it's available to the branches that this PR will be backported. (same below)
nit: could use Utils.mkSet
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
We prefer adding the `set` prefix. ```suggestion public void setContents(Object contents) { ``` Also in this particular case I think we should also make a semantic change and type `contents` with `String`. This does mean that groovy will resolve GStrings sooner, but looking at the uses of this task that is ok and I would prefer the stronger typing, it's one of the reasons we convert in the first place. We can always _lather_ add a version that takes `Supplier<String>` if we need it to be more dynamic.
no need for a constant here, you can use `StandardCharsets.UTF_8`.
For java, there needs to be setters/getters, as the annotation will not automatically create them as it does in groovy. The annotations then go on the getters/settings.
```suggestion public void setFile(File file) { this.file = file; } public void setFile(String file) { this.file = getProject().file(file); } ``` Along the same lines as above to avoid the use of Object.
I would prefer we use something like `Files.write` where we can be specific about the encoding. `FileWriter` will rely on the default encoding, something we generally try to avoid.
This _nearly_ feels worthy of abstraction over the various sets of credentials, and I think that'll definitely be worth doing when the ECS-style credentials are added. Optional now, but worth thinking about.
Just wanted to say I really like the way this unit test is written! With the right usage of mocks we would avoid having any time-dependent flakiness.
Yes, end users would only ever read this object, hence the lack of a friendly `Builder`. I think it's OK to leave as-is.
I don't think we should have this constructor on the client side, as there's no way to sensibly add the missing values (and no sensible reason why the user would need to).
Should be `this.detectors = Collections.unmodifiableList(detectors)`. (This is probably a bug in X-Pack core too.)
I think putting a `@JsonValue` annotation here should fix the capitalization issue, seems like it uses `name()` by default for `enums`.
nit: The mention of join group comes out of nowhere
nit: remove `which is`
Also add `@params topics`
Fails checkstyle, needs to be final
The identity function could pass this test, but wouldn't have the behavior we need in the BasicAuthSecurityRestExtension. I wonder if there's a way to confirm that the mockConfiguration has been evaluated prior to calling `get()` on the returned supplier.
I was going to ask why we're using the `test` prefix for a benchmark, but then I realized that many of the kafka benchmarks do that and I somehow didn't notice. :) Given that, it seems fine to leave it like this for now.
Ah, I was suggesting to just replicate the `shouldInstantiateAssignor` and `shouldInstantiateListOfAssignors` tests exactly, but with the `classTypes` being eg `StickyAssignor.class` instead of `StickyAssignor.class.getName()`. For example ``` classNames = Collections.singletonList(StickyAssignor.class); List<ConsumerPartitionAssignor> assignors = getAssignorInstances(classNames, Collections.emptyMap()); assertTrue(assignors.get(0) instanceof StickyAssignor); ```
Nice, thanks for the update. Looks good
recommended; ditto below.
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
Can we also rename `StreamsGraphNode` to `GraphNode`? The `Streams` prefix is a bit confusing, IMO, because `StreamSourceNode` and `StreamsGraphNode` seem really similar although they are quite different.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
nit: could use Utils.mkSet
I'm thinking whether it makes more sense to let `MockProcessor` encapsulate a delegate `MockApiProcessor` so that we could also use existing tests to verify the correctness of the migration.
Would it be possible to extract test code in this class and `RocksDBRangeIteratorTest` that actually tests code in class `RocksDbIterator` to a test class `RocksDbIteratorTest`. I think that would make the code more maintainable.
```suggestion public void shouldInstantiateAssignor() { ```
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
> The JVM chooses the heap size ergonomically when the heap size is not specified. Do we have the ability to see what it would choose? If running on a small machine, for instance, we'd still want to disable Netty's pooled allocator if the JVM is going to automatically choose a 400mb heap
Would it be possible to return what the default JVM heap is here instead of null? Seems like we still may want to make changes to JVM options for an unset heap. Either that, or since we explicitly set it in our `jvm.options`, emit a warning or error that no heap has been specified (someone must have removed the option)
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Perhaps an exception would be better than an empty set since this would be unintentional? Otherwise the check itself is unnecessary since the following code would do the same thing.
> The JVM chooses the heap size ergonomically when the heap size is not specified. Do we have the ability to see what it would choose? If running on a small machine, for instance, we'd still want to disable Netty's pooled allocator if the JVM is going to automatically choose a 400mb heap
Would it be possible to return what the default JVM heap is here instead of null? Seems like we still may want to make changes to JVM options for an unset heap. Either that, or since we explicitly set it in our `jvm.options`, emit a warning or error that no heap has been specified (someone must have removed the option)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Nit: go with single parameter per line.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
@rajinisivaram @stanislavkozlovski LGTM with the possible exception of maybe adding support for retrieving/logging any ignored extensions? I'll defer to your preference on this.
Yes, we could add `ignoredExtensions` and include that in the log in the server.
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
oh right sorry I keep missing that.
This would have deserved a `// <1>`
> Makes sense? It does not make sense. Having try/catch like this means the test doesn't really know what it is testing.
And how about activating ordinary sniffing instead , maybe with a very high resniff interval or something like that? I do see why replacing the hosts is not ideal, but I think that not doing it complicates things in our production code, which is even worse.
maybe: ``` Java for (int i = 0; i < params.length; i++) { paramsMap.put(params[i++], params[i}); } ```
nit: one too many line break? :)
Please fix identation.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
nit: could use Utils.mkSet
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
This should be done in reset()
Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that? Replay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
Oh, I just noticed. Then `synchronized` is not needed anymore.
It was removed from the other versions of `group` but not from here.
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Oh, I just noticed. Then `synchronized` is not needed anymore.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
super nit: I tend to like validation to be first
Do we need the if/else? Since this is a unit test, it seems OK to just assert that the first element is the rate and the second is the total.
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
Nit: the methods of the `ConnectorStatusListener` and `TaskStatusListener` classes are in very different orders. It would help readability to have them in the same order. IMO, the order of the `TaskStatusListener` methods is nice because it follows the lifecycle.
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
Oh, I just noticed. Then `synchronized` is not needed anymore.
empty line needed
I think key-pairs of strings as list is brittle. But we inherited that.
Oh, I just noticed. Then `synchronized` is not needed anymore.
Allow me to begin by saying that I admit and like the simplicity of this pattern. Still, if this method is frequently used, and if the `gets` >> `creates` (are expected to be way more), then an alternative would be: ```java private final ConcurrentMap<String, MetricGroup> groupsByName = new ConcurrentHashMap<>(); ... public MetricGroup group(String groupName, boolean includeWorkerId, String... tagKeyValues) { MetricGroup group = groupsByName.get(groupName); if (group == null) { Map<String, String> tags = tags(includeWorkerId ? workerId : null, tagKeyValues); group = new MetricGroup(groupName, tags); groupsByName.putIfAbsent(groupName, group); } return group; } ``` which is almost identical in terms of code. This pattern might waste a few objects on initialization, but otherwise it relieves the map from global synchronization on `gets`. If both `gets` and `creates` are expected to be just a few it doesn't worth it probably. Can't say because the use of `group` in this PR is not demonstrated.
Yeah, there's some didactic aspect to a few lines that are just a bit harder to read of course. (for instance if it was `var` instead of `2` things would be different). But I was on the edge too. Fine with leaving it.
To be realistic, the second parameter should be `Collections.singleton(topic)` rather than `emptySet`.
Same here about multi-line toString methods
Here again I think we should use `builder.timeField` to handle this
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Thanks for the clarification, makes sense.
nit: unneeded parenthesis
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
Since this query is a pure wrapper, I'm wondering if you should delegate calls to setBoost/getBoost (and then ignore the boost in equals/hashCode)
nit: remove empty line
You could just do `selector.poll(100)` instead of `poll(0) + sleep(100)`. `poll()` returns when an operation is ready, so we are not waiting unnecessarily.
The parameters should be the other way round (expected is `conns` and actual is the metric value).
Same as before, parameters of `assertEquals` should be the other way round.
Sorry, missed this earlier: We are creating a new `selector` in `checkAuthentiationFailed`, so we should ensure that the previous selector is closed. You could call `selector.close()` just before calling `checkAuthenticationFailed` here and also a couple of lines below.
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
If using `ConfigDef.Validator`, all of these lines would go away, and we actually don't need mocks of any kind.
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
Looks good. I like the additional checking that you're doing here.
I think there is a bug here. What is `\\`? I guess Windows? You need to take caution for different filesystems.
I see but I wonder if we should remove this method and simply accept Object and add a Fuzziness constructor that accepts Object instead
yes my reasoning is that a compile error makes you think about validation rather then forgetting because there's a default empty impl that does no validation. I tend to prefer an empty validate in all queries that don't need to validate, although that's verbose. Plus that is what we do with ActionRequest as well.
thanks, let's say I prefer to be verbose now so we don't forget. Once we are done we can remove if that makes sense :)
nit: can you break this into multiple lines so its easier to track w/ `writeTo`
can we remove an "elasticsearch_" prefix if it exists, I think it will be cleaner? down the road, we can also remove the specific ElasticsearchIllegalArgumentException and such, it was added historically to get the correct status code, but now we also identify IlleglaArgumentException and return the correct status code, so the need for those became irrelevant.
check `source != null` not necessary. In doubt add an assertion.
+1 to what @mjsax said. The `source` should never be null. So you should change the `StreamThreadStateStoreProviderTest`. It just needs to have the topic name extracted to a field on line 73. And then that same topic name used on line 189 in `new TopicPartition(...)`
I'd also consider extracting: `source.getTimestampExtractor() != null ? ...` into a local as the line is quite long and it will make the code a bit easier to read.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
good point.... we should be able to get rid of it.
alright let's maybe make it a TODO then, just so we know the plan is to make it go away
maybe add the type that is found in the error message with fieldType.typeName()
This seems overly complicated. An easier structure to follow would be something like this: ```java String expectedType = "KafkaController"; Set<String> expectedMetricNames = Utils.mkSet( "ActiveControllerCount", "GlobalTopicCount", "GlobalPartitionCount", "OfflinePartitionsCount", "PreferredReplicaImbalanceCount" ); MetricsRegistry registry = new MetricsRegistry(); try (QuorumControllerMetrics quorumControllerMetrics = new QuorumControllerMetrics(registry)) { assertMetricsCreated(registry, expectedMetricNames); } assertMetricsRemoved(registry, expectedMetricNames); ```
This is going to be modified and accessed on potentially different threads, right? If so, we should add the `volatile` modifier here.
ditto here and others below
deprecated names match too. match should always return true, or rather throw an exception in strict mode if you use a deprecated name. I think it should be an assert. We had the same discussion with Colin in IndicesQueriesRegistry I think :)
the fact that the parse field matcher matches is a requirement, I think it should be an assert instead. It's really a our bug if it doesn't and we should catch it differently compared to "no function found"
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It looks ok to me
i.e., add `fail` after this line
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
rewrite test as above using `assertThrows()`.
I think it's always a single node cluster, but I'm good to keep it like this.
aws_ip_ranges -> aws_service_ip_ranges
same 1+ randomInt
good catch! that means we are not properly testing this case either given that we didn't catch it.
Sorry for the noise, realized all constructors are delegated to the `TermsQueryBuilder(String fieldName, Iterable values)` constructor, so all good.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Sure, good plan.
I think we cannot (yet) do this with auth tokens received externally because they need to be passed to the test suite as well as this fixture, so we've had to settle on just using the same (long) string in both places. It would indeed be nicer if there were no magic strings in the fixture at all. For deterministic testing, maybe you can pass a seed in from Gradle somehow? Or just hard-code them, it's not that important. I'd rather they weren't synthesised as they are now.
On deeper thought, this seems unduly lenient: it should only return credentials for the role that `GET /latest/meta-data/iam/security-credentials/` returned, and should return 404 otherwise. Also I think `credentialResponseFunction` can be inlined, it's only used in one place. Also also we could prevent cheating slightly more by inventing random credentials when the service starts up, rather than synthesising them from the role name.
I presume, by the way, that passing `null` for the region here is ok. I haven't tried it.
... and this doesn't need to know it either.
a misspell? SQLFuncMixn -> SQLFuncMixin
Use the `msg = ` format to avoid awkward indentation.
We like to include trailing comma on the last item in a dict so if more items are added later, we don't have to modify this line again.
Since we are adding `fenced` to the RegisterBrokerRecord, do we also need to add a `fenced` field to the BrokerRegistrationRequest RPC? Or is it the case that only the controller will set the fenced state of this record
Nit: space between the cast operator and the target.
ditto here and others below
same for tests below as well
nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
I wonder how long this would work ;)
Hmm, that's annoying.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I really like the fact that we are separating Resources from ResourcePatterns! Great job.
Do we need quotaType? It seems that it's unrelated to metric tags.
How about: ```suggestion * <p>The task will be executed at least once. No retries will be performed * if {@code timeoutDuration} is 0 or negative, or if {@code timeoutDuration} is less than {@code retryBackoffMs}. ```
typo: byteArrray -> byteArray
`<byte[]>` this explicit type is unnecessary
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
`< Callback >` this explicit type is not necessary.
How about ``` for (byte b : payload) { assertNotEquals(0, b); } ```
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
> fail if the annotation was unnecessary Yeah, that is very important. It would be nice to be able to annotate at the exception level. Much cleaner if not for those nasty problems. I still think we shouldn't allow the annotation on classes at all and should force them to make a static method call if they want to swallow. But I'm not so against it that I'd block this whole PR over it.
Yeah. I just don't like it! I'll live with it and maybe think of a way to make it less painful later.
I think allowing this on a whole class is too broad. Is there a use case I'm not thinking of? I just figure it'd almost always be better to have it on a method or constructor.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
nit: probably checkstyle won't catch this, but if you format the block, there's an extra tab that you can remove here too.
same for tests below as well
To make it more rigid: we can pass a valid end point string, and then check that the field is still `null` below.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
and -> a
Thanks for the explanation. Make sense.
I have a similar concern here for when entry.getValue is not a Map
thinking if those `synchronized` code blocks are needed, if you always check for `null` first, as context is never set to `null` again...
@spinscale I think it is needed if it is expected that another thread might be updating the context at the same time (ie. synchronization is protecting the hash map copy rather than the null check)
I think @talevy is talking about the `value` and not `path`. I think it is ok to add a null key.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
These tests will now, right? Because of the empty on_failure processors? I think we should expect an exception here instead.
nit: extra newline
I feel like `pattern bank` is an internal naming convention, and externally we just call it `patterns`. not sure it matters here though, since one can only assume we are talking about the same thing.
nice! I like this. super helpful for keeping track
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
```dict_get``` makes codes even shorter
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Use ```extract_attributes``` instead. The order of video_id, account_id, ... may change.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
```dict_get``` makes codes even shorter
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Use ```extract_attributes``` instead. The order of video_id, account_id, ... may change.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
nit: add `final`
Why not just use System.getProperty("tests.seed") ? is this an intellij auto-complete thing? I see this anti-pattern quite often and i wonder why its done.
ReflectiveOperationException can be used instead of both of these
can we just change this to System.getProperty("tests.seed") != null? Then that method can be removed.
I think we can get rid of the ResolvedHostname abstraction - what am I missing? ``` diff --git a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java index 61bf1cc..3d3495e 100644 --- a/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java +++ b/core/src/main/java/org/elasticsearch/discovery/zen/UnicastZenPing.java @@ -242,40 +242,36 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]"); } // create tasks to submit to the executor service; we will wait up to resolveTimeout for these tasks to complete - final List<Callable<ResolvedHostname>> callables = + final List<Callable<TransportAddress[]>> callables = hosts.stream().map(hn -> lookup(hn, transportService, limitPortCounts)).collect(Collectors.toList()); - final List<Future<ResolvedHostname>> futures = + final List<Future<TransportAddress[]>> futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS); final List<DiscoveryNode> discoveryNodes = new ArrayList<>(); // ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the // hostname with the corresponding task by iterating together final Iterator<String> it = hosts.iterator(); - for (final Future<ResolvedHostname> future : futures) { + for (final Future<TransportAddress[]> future : futures) { final String hostname = it.next(); - if (!future.isCancelled()) { + if (future.isCancelled()) { + logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); + } else { + assert future.isDone(); // guaranteed by the invokeAll try { - final ResolvedHostname resolvedHostname = future.get(); - if (resolvedHostname.isSuccess()) { - logger.trace("resolved host [{}] to {}", hostname, resolvedHostname.addresses()); - for (final TransportAddress address : resolvedHostname.addresses()) { - discoveryNodes.add( - new DiscoveryNode( - idGenerator.get(), - address, - emptyMap(), - emptySet(), - Version.CURRENT.minimumCompatibilityVersion())); - } - } else { - final String message = "failed to resolve host [" + hostname + "]"; - logger.warn(message, resolvedHostname.failure()); + final TransportAddress[] addresses = future.get(); + logger.trace("resolved host [{}] to {}", hostname, addresses); + for (final TransportAddress address : addresses) { + discoveryNodes.add( + new DiscoveryNode( + idGenerator.get(), + address, + emptyMap(), + emptySet(), + Version.CURRENT.minimumCompatibilityVersion())); } } catch (final ExecutionException e) { final String message = "failed to resolve host [" + hostname + "]"; logger.warn(message, e); } - } else { - logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname); } } return discoveryNodes; @@ -289,17 +285,11 @@ public class UnicastZenPing extends AbstractComponent implements ZenPing { * @param limitPortCounts the port count limit * @return a callable that can be used to submit to an executor service */ - private static Callable<ResolvedHostname> lookup( + private static Callable<TransportAddress[]> lookup( final String host, final TransportService transportService, final int limitPortCounts) { - return () -> { - try { - return ResolvedHostname.success(transportService.addressesFromString(host, limitPortCounts)); - } catch (final UnknownHostException e) { - return ResolvedHostname.failure(e); - } - }; + return () -> transportService.addressesFromString(host, limitPortCounts); } @Override ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
could we make this test somehow operations based rather than time based. The Problem with time-based tests is that you have a very very hard time to get anywhere near reproducability. I know this is multithreaded anyways so it won't really reproduces but we can nicely randomize the num ops per thread which make it a bit nicer :)
you should use the `awaitBusy` method here which doesn't have a fixed sleep but increase the sleep interval in quadratic steps...
what about `assertEquals("consumer record size is not zero", 0, records.count());`? It can also be applied in a few other places
I think assertThat(throwables.get(0).getMessage(), containsString(...)) might be a bit better, especially if we don't specify an error message ourselves. Same for assertThat(throwables.get(0), instanceOf(...)).
nit: extra newline
could we make this test somehow operations based rather than time based. The Problem with time-based tests is that you have a very very hard time to get anywhere near reproducability. I know this is multithreaded anyways so it won't really reproduces but we can nicely randomize the num ops per thread which make it a bit nicer :)
you should use the `awaitBusy` method here which doesn't have a fixed sleep but increase the sleep interval in quadratic steps...
what about `assertEquals("consumer record size is not zero", 0, records.count());`? It can also be applied in a few other places
I think assertThat(throwables.get(0).getMessage(), containsString(...)) might be a bit better, especially if we don't specify an error message ourselves. Same for assertThat(throwables.get(0), instanceOf(...)).
nit: extra newline
It looks ok to me
Nit: why not use `boolean`
ah I see it has problems with `null` got it
same for tests below as well
don't drink and code ð» (same line twice)
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
this logic belongs in transportWriteAction
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: could use Utils.mkSet
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
Could we replace this with something like the following? ``` assertEquals(topics, requestWithNames.data().topics().map(DeleteTopicState::name).collect(toList)); ``` It is a bit easier to read and `assertEquals` gives the differences between all the expected and the existing topics when it fails.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
`asList` -> `Collections.singletonList`
Could we fail the test right here? It doesn't seem like there is much benefit to returning the missing metrics from the method. That would let us simplify this a little. Instead of this: ```java Set<String> missingMetrics = getMissingMetricNames(expectedMetricNames, expectedGroup, expectedType); assertEquals(Collections.emptySet(), missingMetrics, "Expected metrics did not exist"); ``` we could have: ```java assertRegisteredMetrics(expectedMetricNames, expectedGroup, expectedType); ``` We could probably also drop `expectedGroup` since we only have `kafka.controller`.
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
nit: When this assert failed, we'll see the error messages: `Expected metrics did not exist` ==> expected: `emptySet`, but was: `missingMetrics` I think we should change the error messages, ex: `Expect no missing metrics` ==> expected: `emptySet`, but was: `missingMetrics`
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
redundant type arguments `<ProducerRecord<byte[], byte[]`
Why do we have `Args` here? The `toString` is used in the JUnit test display and hence why it doesn't include anything besides the parameters before this change.
typo: byteArrray -> byteArray
nit: we could split this lone line by different key, value by new line to make it clear. ex: ``` String[] args = new String[] { "--topic", "Hello-Kafka", "--num-records", "5", .... }; ``` Same as below.
nit: remove the redundant line. Same as below.
`< Callback >` this explicit type is not necessary.
Yeah, it's relatively new but it's the clear path forward especially with JUnit 5 coming with built-in support for the same.
typo: byteArrray -> byteArray
`asList` -> `Collections.singletonList`
redundant type arguments `<ProducerRecord<byte[], byte[]`
All these methods can have package protected visibility.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
```suggestion (Support from Virtual machine hardware version 14, Guest OS Windows 10 64 bit, Windows Server 2016). version_added: 2.8' ```
This should be in the "assigned in `configure`" section of fields.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
There's now a `Utils.mkProperties` method you can use (in conjunction with `mkMap`) to set these at the declaration site instead of setting them (redundantly) before every test. Then you won't need the `@Before` at all.
This cleanup seems a bit awkward. It assumes that tests will initialize the driver but not close it, which seems like a strange abdication of responsibility. I think it would be cleaner and clearer to get rid of the driver field entirely. Tests that need the driver already initialize it; they can declare it as a local variable as well. Then, they clearly need to close it as well. Since `TopologyTestDriver` is `AutoCloseable`, one option is to declare the driver in try-with-resources style: ```java @Test public void myTest() { try (final TopologyTestDriver driver) { // the test code } } ```
I don't think we need these prevTasks and standbyTasks for this test. You can just pass `Collections.emptySet()` to the `Subscription`
As mentioned in the KIP discussion thread: it seem unnecessary complex for user, to specify all those value. The only parameter that is mandatory is the window size. If people call `KGroupedStream#windowBy` all other parameters also optional; they should be optional when reading a topic, too.
The iterator should return exactly one record. This, we should add an `Assert.assertFalse(it.hasNext());` after the `if`
```suggestion (Support from Virtual machine hardware version 14, Guest OS Windows 10 64 bit, Windows Server 2016). version_added: 2.8' ```
This should be in the "assigned in `configure`" section of fields.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
These should be `<pre>` rather than `<code>`. The latter is more for phrases, not blocks, and loses all indentation and line breaks within a block of code. Then you can get rid of the `<br>` tags.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
same for tests below as well
base -> based progress -> progressed
```suggestion * If the return value of {@link ValueTransformer#transform(Object) ValueTransformer#transform()} is {@code null}, no ``` Please also fix this on the original method
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Yes, that may work. It just that it would be good to avoid duplicating the same code in two places.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `phand` is non-descriptive
Yes, that may work. It just that it would be good to avoid duplicating the same code in two places.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `phand` is non-descriptive
we do this kind of parsing in several places maybe a util can help at some point? not sure just an idea
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
I think we should provide some context on the exception here.
one assert per member is better then you see what's not null :0
I think we cannot just pass in `null` and rely on default serde types from configs, since users are not expecting the repartition to happen here from the DSL, and they thought they have provided enough serde informations on places they "think" a repartition will happen. So observing a `ClassCastException` at a place they are not expected would be a bad experience. As of now, without serde inheritance we may have to "restrict" the optimization, to only apply to cases where two or more repartition nodes are direct children of the common key-changing parent node. Moving forward we can consider the options @bbejeck provided, and personally I think serde inheritance would be a good place to start.
Indentation doesn't look right here.
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
Looks like this should be Nullable
The `e` argument should be `@NonNull`.
Either I'm missing something or ``` ObservableCache<Integer> source = (ObservableCache<Integer>)new ObservableCache<Integer>(Observable.range(0, 1000), 16); ``` can just be ``` ObservableCache<Integer> source = new ObservableCache<Integer>(Observable.range(0, 1000), 16); ```
I don't know how often this class is created, but maybe it makes sense to store a reference to the logger for later use if this class is instantiated more often.
recommend sticking with T, U, V (or A, B, C for higher-kinded) type parameters
Looks like this should be Nullable
The `e` argument should be `@NonNull`.
Either I'm missing something or ``` ObservableCache<Integer> source = (ObservableCache<Integer>)new ObservableCache<Integer>(Observable.range(0, 1000), 16); ``` can just be ``` ObservableCache<Integer> source = new ObservableCache<Integer>(Observable.range(0, 1000), 16); ```
I don't know how often this class is created, but maybe it makes sense to store a reference to the logger for later use if this class is instantiated more often.
recommend sticking with T, U, V (or A, B, C for higher-kinded) type parameters
`use {@link #toStream()} followed by {@link KStream#to(String)} and {@link StreamsBuilder#table(String)} to read back as a {@code KTable}` ?? same below
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
if not needed +1 on removing
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
We should do this check first
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
FYI when you accept the suggested changes using GitHub UI, it preserves the authorship of the patch.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
Ah, my bad. This doesn't work on fixtures.
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
FYI when you accept the suggested changes using GitHub UI, it preserves the authorship of the patch.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
Ah, my bad. This doesn't work on fixtures.
nit: could use Utils.mkSet
```suggestion public void shouldInstantiateAssignor() { ```
Nit: you can remove `value =`
Did you mean: ```suggestion setBrokerId(2). setBrokerEpoch(100). ```
I know. It's just that we already use a mocking framework and we could use something like: `EasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();` if we also defined `factory` to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Use a similar logging to what we do for robust signals? See `django.dispatch.dispatcher.Signal.send_robust` and ``` try: response = receiver(signal=self, sender=sender, **named) except Exception as err: logger.error( "Error calling %s in Signal.send_robust() (%s)", receiver.__qualname__, err, exc_info=err, ) ``` Something like ```suggestion logger.error("Error calling {func.__qualname__} on_commit() ({e}).", exc_info=True) ```
nit: There is an extra space before `+`.
using `assertThat` is nicer as it gives better failure messages. `assertThat(sourceNode.getTimestampExtractor(), instanceOf(MockTimestaampExtractor))` in other places, too
typo: kStreamhould... -> kStreamShould In fact i'd probably rename these methods to begin with should, i.e., `shouldAddTimestampExtractorToStreamWithOffsetResetPerSource` etc
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
can you add spaces? `new KeyManager[] { km }, new TrustManager[] { tm }`
indentation is off after other changes
`msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}"` could be used here instead of `var: messages`, no need to use `set_fact`.
Not sure how the lazy loading of variables, the example would be simpler to just have the one task instead of 2 in the examples. ``` - name: Get 2 messages off a queue debug: msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}" ```
CI failure due to missing conditional when calling main: ```python if __name__ == '__main__': main() ```
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
Nit: missing `.`
recommended; ditto below.
must be param prefixes now
Nit: ```suggestion log.warn("Executing {} only once, since retryBackoffMs={} is larger than total timeoutMs={}", descriptionStr, retryBackoffMs, timeoutMs); ```
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
If you (also) specify your GitHub nick, you will be informed in case bugs/issues/PRs are filed against this plugin. The syntax is ```suggestion - Stefan HeitmÃ¼ller (@morph027) <stefan.heitmueller@gmx.com> ```
```suggestion - Scott Buchanan (@scottsb) - Andrew Zenk (@azenk) - Sam Doran (@samdoran) ```
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
`UUID of the virtual machine`? needs to mention host, i guess
```suggestion - The name of content library to manage. ```
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
Update return type to `L` (if we introduce `L`)
nit: merge both lines: `byte[] payload = new byte[primitiveSize == null ? dis.readInt() : primitiveSize];`
Update return type to `L` (if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: remove `this` (not required)
`Constructor<List<T>>` (or `Constructor<L>` if we introduce `L`)
Update return type to `L` (if we introduce `L`)
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
I would recommend using `RealmSettings.getRealmSettings` instead. It slightly reduces your reliance on the underlying realm config model.
spaces around '='
maybe I am missing something, but `.getSourceAndMetadata()` returns a mutable Map? here is an example: https://github.com/elastic/elasticsearch/pull/18193/files#diff-4e27382bea1f95bce321ce30c5315e98R42
this `readStringProperty`? it is not parsing script code, it is an ingest-node config reader
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: instead of `new HashSet<>(Collections.singletonList(tp0))`, you can use `Collections.singleton(tp0)`
Worked fine when I tried it locally: ```java assertEquals(Collections.singleton(tp0), records.partitions()); ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
you don't have to assert on anything if an exception is expected
same for tests below as well
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: remove empty line
nit: one too many line break? :)
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
It should be robust in case of some missing fields.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Wildcard imports should be caught by checkstyle, and should fail the build. In any case, please replace with non-wildcard imports.
Any reason you change to import all classes under `java.util`? I think we should import what we used in this class only.
I know we're violating this a few places (due to the initial code import), but I think we want to avoid converting to `*` imports.
`log` not used
Sure, no problem. It's a slim and harmless chance, that's why I mentioned.
I feel like the summary here should be a bit more descriptive. Perhaps "There are enough master-eligible instances to form a quorum."
This test checks essentially the same thing as the previous unit tests? To check more in this test, we could as well verify that indexShard has the right term (i.e. that the cluster state update was properly applied to IndexShard).
This should be paginated
do we need busy waiting here? and we should probably wait on the node to join the cluster and have no relocation pending.
I think we can check also randomly on a shard that relocates _to_ the local node
I feel like the summary here should be a bit more descriptive. Perhaps "There are enough master-eligible instances to form a quorum."
This test checks essentially the same thing as the previous unit tests? To check more in this test, we could as well verify that indexShard has the right term (i.e. that the cluster state update was properly applied to IndexShard).
This should be paginated
do we need busy waiting here? and we should probably wait on the node to join the cluster and have no relocation pending.
I think we can check also randomly on a shard that relocates _to_ the local node
That's a good point too. But what I wanted to highlight is to be explicit and return the exact collection, that being `Collections.emptyList()` or `new ArrayList()` (the former should be fine as you noted), instead of returning what's stored in `result` (whose declaration is good to be close to the use as much as possible). That's to guard against `result` being used earlier by code in the future. Improbable, but also doesn't hurt and it's a good practice IMO.
`result` is unused in this code block. To be future proof, I'd suggest being explicit by returning an empty list here, and declare `result` right above the block that is being used at.
```suggestion return Collections.emptyList(); ```
nit: plural (`Reflections`) seems more appropriate because it refers to the library/class.
Now that we have separate `Plugins::sinkConnectors` and `Plugins::sourceConnectors` methods, we can abstract this a little, which should improve readability a bit and make it easier to extend for other plugin types in the future: ```suggestion static final List<Class<? extends SinkConnector>> SINK_CONNECTOR_EXCLUDES = Arrays.asList( VerifiableSinkConnector.class, MockSinkConnector.class ); static final List<Class<? extends SourceConnector>> SOURCE_CONNECTOR_EXCLUDES = Arrays.asList( VerifiableSourceConnector.class, MockSourceConnector.class, SchemaSourceConnector.class ); @SuppressWarnings({"unchecked", "rawtypes"}) static final List<Class<? extends Transformation<?>>> TRANSFORM_EXCLUDES = Collections.singletonList( (Class) PredicatedTransformation.class ); public ConnectorPluginsResource(Herder herder) { this.herder = herder; this.connectorPlugins = new ArrayList<>(); // TODO: improve once plugins are allowed to be added/removed during runtime. addConnectorPlugins(herder.plugins().sinkConnectors(), SINK_CONNECTOR_EXCLUDES); addConnectorPlugins(herder.plugins().sourceConnectors(), SOURCE_CONNECTOR_EXCLUDES); addConnectorPlugins(herder.plugins().transformations(), TRANSFORM_EXCLUDES); addConnectorPlugins(herder.plugins().predicates(), Collections.emptySet()); addConnectorPlugins(herder.plugins().converters(), Collections.emptySet()); addConnectorPlugins(herder.plugins().headerConverters(), Collections.emptySet()); } private <T> void addConnectorPlugins(Collection<PluginDesc<T>> plugins, Collection<Class<? extends T>> excludes) { plugins.stream() .filter(p -> !excludes.contains(p.pluginClass())) .map(ConnectorPluginInfo::new) .forEach(connectorPlugins::add); ```
BTW, instead of the above to wait for the nodes to come up, could something like this be done? ``` client().admin().cluster().health(Requests.clusterHealthRequest().waitForNodes(Integer.toString(3))).actionGet(); ```
I get that, I was just wondering why those default templates bother here
could use 1. `UnassignedInfo.INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.getKey()` 2. `IndexMetaData.INDEX_NUMBER_OF_SHARDS.getKey()` 3. `IndexMetaData.INDEX_NUMBER_OF_REPLICAS.getKey()`
A simple change to the message can make this assertion fit on one line: ``` diff diff --git a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java index 5ccb541..ca172f8 100644 --- a/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java +++ b/core/src/test/java/org/elasticsearch/index/seqno/CheckpointsIT.java @@ -54,8 +54,7 @@ public class CheckpointsIT extends ESIntegTestCase { IndicesStatsResponse stats = client().admin().indices().prepareStats("test").clear().get(); for (ShardStats shardStats : stats.getShards()) { if (shardStats.getSeqNoStats() == null) { - assertFalse("didn't get seq no stats for a primary " + shardStats.getShardRouting(), - shardStats.getShardRouting().primary()); + assertFalse("no seq_no stats for primary " + shardStats.getShardRouting(), shardStats.getShardRouting().primary()); continue; } logger.debug("seq_no stats for {}: {}", shardStats.getShardRouting(), ```
Do we need to prefix these with `msg.`? Also, it might be nice to control the message format when message keys and values are to be included. I know that's more code, but it could be made to be similar to the other option.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Why do we need this? The public ctor is used for new types, when intializing all the metadata fields. But in that case, there is nothing shared so no need to initialize the join fieldtype (it should not be used unless/until _parent is set on the new type, in which case it will be parsed and the protected ctor will be used).
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
Do we actually have to mock `generation()` and `rawConfig()` for this test? Looking at `connector()`, it looks like it only relies on the snapshot.
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Why do we need this? The public ctor is used for new types, when intializing all the metadata fields. But in that case, there is nothing shared so no need to initialize the join fieldtype (it should not be used unless/until _parent is set on the new type, in which case it will be parsed and the protected ctor will be used).
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
It seems that the checkstyle failed but all unit tests have passed. I can modify the code slightly to fix the checkstyle failure before merging it.
Please remove empty line.
IMO, this string should give details when the condition is not met, like `stream thread has not been added`. Same applies to the other wait conditions.
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
```suggestion except (AttributeError, KeyError): ```
nit: one too many line break? :)
we can use ElasticsearchAssertions.assertThrows. Slightly cleaner code.
this is dangerous. I'm not sure we can rely on this. Also testing the exact amount tests generic Transport functionality. I don't think we should do it here. Just keep it simple.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
we can use ElasticsearchAssertions.assertThrows. Slightly cleaner code.
this is dangerous. I'm not sure we can rely on this. Also testing the exact amount tests generic Transport functionality. I don't think we should do it here. Just keep it simple.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Indentation doesn't look right here.
Indentation doesn't look right here.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
Same suggestion here for `assertNotEquals`.
I see, ok
this may get confusing since the feature will be allowed `today`, where `today` is some time in the future that someone will read this. maybe we can reference the PR here, and use more past-tense terms like `previously`.
ditto here and others below
I think this check does not add much (I would skip it)
When you use it with an instance of `PreBuiltAnalyzers`.
typo: optain -> obtain
the reason why I suggested to make it configurable is that we could pass in our own values in tests that's all... not a big deal
right, I had totally misunderstood how the test works
I think that what confuses me here is that we call performRequest and performRequestAsync here, why do we mock the rest client then? Wouldn't it be better to test that RestHighLevelClient subclasses can use performRequestAndParseEntity and performRequestAsyncAndParseEntity (which are private at the moment)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
same for tests below as well
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Same suggestion here for `assertNotEquals`.
I see, ok
this may get confusing since the feature will be allowed `today`, where `today` is some time in the future that someone will read this. maybe we can reference the PR here, and use more past-tense terms like `previously`.
ditto here and others below
I think this check does not add much (I would skip it)
Not related to this change but we could write this: ``` java log("Installed plugins in " + environment.pluginsFile().toAbsolutePath() + ":"); if (plugins == null || plugins.length == 0) { log(" - No plugin detected"); } else { ``` It could help people to have a better understanding on plugins location. (IIRC I saw this request on the mailing list).
ditto here and others below
Nit: too many blank lines.
Could make this assertion a little stronger: ``` assertEquals(new TestElement(i, i), coll.find(elements.get(i))); ```
should this be `&&`? As it is, this loop could terminate even if we always return null and never non-null
indicesDeleted doesn't check for indexUUIDs. We have a separate method for it in this class `cleanMismatchedIndexUUIDs` - in this spirit of bringing all deletion code together - I think it's good to make indicesDelete aware of UUID switches (mark old as deleted), move the `applyDeletedIndices` to be executed where `cleanMismatchedIndexUUIDs` is called now and then we can remove `cleanMismatchedIndexUUIDs` make all go through here.
ditto here and others below
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
indicesDeleted doesn't check for indexUUIDs. We have a separate method for it in this class `cleanMismatchedIndexUUIDs` - in this spirit of bringing all deletion code together - I think it's good to make indicesDelete aware of UUID switches (mark old as deleted), move the `applyDeletedIndices` to be executed where `cleanMismatchedIndexUUIDs` is called now and then we can remove `cleanMismatchedIndexUUIDs` make all go through here.
ditto here and others below
all I want here is a mechanism that always works. I think if we rely on a backgroud task our system is broken and we have to fix it.
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
The current names are misleading, e.g. `RenderableForm` is not really a render-able form it's a mixin which makes the form render-able. I would rename these classes: - `Renderable` to `RenderableMixin`, - `RenderableForm` to `RenderableFormMixin`, - `RenderableError` to `RenderableErrorMixin`.
i.e., add `fail` after this line
Let's use `epoch` instead of `currentEpoch`. Since we are using `currentEpoch`, the `endOffsetForEpoch.offset` will equal the LEO. If you instead use `epoch` then the `endOffsetForEpoch.offset`. will be `4` which is less than the LEO (`5`).
I think these _could_ be: ``` __str__ = render __html__ = render ``` Avoiding +1 depth (and it's faster). Off the top of my head, the only reasons _not_ to would be: - `x.__str__` would report `<bound method X.render of ...>` instead of `<bound method X.__str__ of ...>` - you _could_ technically manually call `x.__str__(template_name='a')` but I mean, who's doing that? Discuss amongst yourselves whether to change it, I don't think it really matters much :)
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
i.e., add `fail` after this line
Thanks for cleaning up the code duplication.
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: add `final`
nit: add `final`
nit: add `final`
nit: add `final`
nit: remove empty line
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
maybe also here `"foo"` -> `{@code foo}`
Space missing between `}` and `is`.
`while` seems to be missing
We didn't specify this in the KIP but I think `toStream()` and `toStream(mapper)` should also have overrides with`Named`
and -> a
I think it's worth looking into, but in the meantime this will already be an improvement.
Default not set in argspec.
don't use new_name. It should be from_name to maintain idempotency
As far as I can tell, the 'in_use' is never used.
TODO add Exception handling for login error
I have a similar concern here for when entry.getValue is not a Map
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
ditto here and others below
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
ditto here and others below
same for tests below as well
This will fail if the playbook task uses `delegate_to`. Consider instead of accepting the file contents instead of a source file name
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
same for tests below as well
nit: insert space `String... expected`
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
nit: one too many line break? :)
nit: we can throw illegal-state if the state() == RESTORING since it should never happen.
Oh duh, I thought this was StreamTask. In that case, why would we check for RESTORING at all? We don't check for RESTORING state anywhere else in StandbyTask AFAICT (maybe Guozhang thought this was StreamTask like I did? ð )
Why not just make `suspend` a no-op if the task is RESTORING? That seems more in line with how we handle things elsewhere
Just to clarify, I would support doing the former, ie don't check whether it's RESTORING here at all. But we should at least be consistent
nit: one too many line break? :)
nit: we can throw illegal-state if the state() == RESTORING since it should never happen.
Oh duh, I thought this was StreamTask. In that case, why would we check for RESTORING at all? We don't check for RESTORING state anywhere else in StandbyTask AFAICT (maybe Guozhang thought this was StreamTask like I did? ð )
Why not just make `suspend` a no-op if the task is RESTORING? That seems more in line with how we handle things elsewhere
Just to clarify, I would support doing the former, ie don't check whether it's RESTORING here at all. But we should at least be consistent
nit: one too many line break? :)
A metadata request has topics as the "scoped error" (one cannot request a metadata request for a given partition). So, it looks to me that we introduced a regression here. We should check if there are similar cases for other requests.
It includes the partition-level error. It seems to me it follows the docs. ` The number of each type of error in the response, including {@link Errors#NONE} and top-level errors as well as more specifically scoped errors (such as topic or partition-level errors). `
Similar here, maybe we could leverage `transitionTo` to help throw the exception.
This needs to be protected by a `if (in.getVersion().onOrAfter(Version.V_1_3_0)) {`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
The variable name `shand` is non-descriptive
The variable name `shand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `phand` is non-descriptive
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
nit: one too many line break? :)
Typo: space after `uuid,`
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
ditto here and others below
I'm wondering if we should make this `info` or `warn` level. It doesn't seem like it would be very verbose, and it might be nice to see by default because it will have secondary effects later on when we try to start a new transaction, but get blocked. But I also don't feel strongly about it, so I leave it to your discretion.
Why do we need an atomic here? `close()` should be called single threaded only, right? And if I miss anything, we do we not need to use atomic to switch from "created" to "running" in `start()`.
Just realized, that the method does use `synchronized` keyword anyway... it's guarded against this already. Same for `start()`.
I just mean, why not inline that? I'm just imagining coming back to this code in a few months and wondering why we need to suspend a task before recycling, or why we call `prepareCommit` but don't then actually commit, etc
Nevermind, I see that's the pattern we follow everywhere else
I'm wondering if we should make this `info` or `warn` level. It doesn't seem like it would be very verbose, and it might be nice to see by default because it will have secondary effects later on when we try to start a new transaction, but get blocked. But I also don't feel strongly about it, so I leave it to your discretion.
Why do we need an atomic here? `close()` should be called single threaded only, right? And if I miss anything, we do we not need to use atomic to switch from "created" to "running" in `start()`.
Just realized, that the method does use `synchronized` keyword anyway... it's guarded against this already. Same for `start()`.
I just mean, why not inline that? I'm just imagining coming back to this code in a few months and wondering why we need to suspend a task before recycling, or why we call `prepareCommit` but don't then actually commit, etc
Nevermind, I see that's the pattern we follow everywhere else
Indentation doesn't look right here.
The variable name `phand` is non-descriptive
The variable name `shand` is non-descriptive
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
Indentation doesn't look right here.
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
The variable name `shand` is non-descriptive
The variable name `phand` is non-descriptive
nit: the more I see of this, the more I think that it's worth extending the `onDPKG` type of API to be able to produce values so reading trough the code is more consistent.
Could just use `false`
This is not introduced in this PR: we can try to get the record collector in the constructor and cache it instead of trying to access it every time. I checked all the access patterns of this field and they should not be modified dynamically.
could use `assertFalse`
I am not sure what we have yet to decide here. What Christoph is suggesting makes sense, let's update the PR accordingly
can you just leave the constant in this class? There isn't a need to put it in realm imo
++ on debug message
Should this be `debug` instead of `info`? It generates a lot of message like this during replication: ``` [2014-07-01 22:30:36,127][INFO ][index.store ] [Mimic] [test][1] create legacy output for segments_1 ```
Would `Long.toHexString(value)` work here? Not sure if it's exactly the same as the current code.
Seems like this might occur only in a programming error, which we could test for in a unit test.
Like it or not, our style is to use ` == false` instead of `!`.
Oh, and _nit_ on the unnecessary brackets :)
We typically use `Locale.ROOT` rather than `ENGLISH` for case conversion.
@adityasrini Rather than doing the two String.toLowerCase(Locale.ENGLISH) which requires 2 changes, you should replace the new HashMap() with a new TreeMap(String.CASE_INSENSITIVE_ORDER).
@javanna Sorry my suggestion should have been to replace the `new HashSet()` with `new TreeSet(String.CASE_INSENSITIVE_ORDER)` at line 433 , and remove the 2x `toLowerCase(Locale.ENGLISH)` additions, obviously mentioning TreeMap was nonsense.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Does this really need to be generic? We certainly don't care about any of that on the consumption side.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
Ideally we'd not wrap the exception if there are no retries, so I guess it just depends on how hard it is to make that work.
I think there's an edge case where `timeoutMs` is positive but small enough that the condition on line 77 is not met but the while loop on line 85 is not satisfied because the end time has already passed. In this edge case, we might not call the callable function (even once). One option is to change the while loop to be a do-while loop so that we always go through one loop. Another option is to compute the remaining time before line 77 and not update it before the while loop. Either would work, but one of the options may require fewer duplicated lines.
I don't think it's necessary to warn in this case. Maybe debug, but not warn. If callers are concerned, they can check the parameters before calling the method.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
nit: one too many line break? :)
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
ditto here and others below
It should be robust in case of some missing fields.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
`int` is what you want here, not `Integer`, right? It looks like we don't want or need this to ever be null. Should we throw an exception if latencyMs is set to a non-positive number? It's not clear what that would mean, or who it would be useful to. A millisecond is a relatively large amount of network latency. I suppose we can add a nanoseconds field later, though, if that becomes an issue.
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
We may be able to save all this hassle by defining alias group as a map of `target` to a list of `deprecated` configs? We defined this as a 2-dim array but we always convert it to lists...
Sorry for that -- You are of course right. `final` only for iterator loops...
use `try-catch` instead of `expected` annotation -- not a single line test.
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
That makes sense. I got confused by the fact that `AbortTransactionResult` takes a `Map` in its constructor. In this case, `all()` seems fine. Thanks for the clarification.
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Hm, kind of annoying that we have to return Properties here, but (as far as I know) there is no way to make an immutable Properties
nit: could use Utils.mkSet
getters should not use get. i.e. use `networkDevice` here, etc.
we don't typically use "get" in our getters, right? so this should just be `latencyMs`
Sorry for that -- You are of course right. `final` only for iterator loops...
Do we need to wrap with the LinkedHashMap? Could we just do `Collections.unmodifiableMap(metrics.metrics());`
Nice refactoring to put this code in a separate method!
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Do we need to wrap with the LinkedHashMap? Could we just do `Collections.unmodifiableMap(metrics.metrics());`
Can this be made polymorphic instead of actually checking the `PASSWORD` type here? e.g., could we simply always do `newConfig.put(key, entry.getValue().toString())` since `Password.toString()` always hides the value (in contrast to the `value()` method? I don't see a use atm, but keeping this generalizable seems potentially valuable. wouldn't block on this, but it doesn't seem great to have to bake details of the config type into code in the `AbstractHerder` that otherwise doesn't care about it.
I think we should keep the `Collections.sort(keys)` part to keep the reproducibility between different jvms if we can.
Ah - I see the other side of it. Up on line 925 I thought you were building a LinkedHashMap from a HashMap rather than casting. Up where you call `parser.mapOrdered`. Anyway, `mapOrdered` should make this reproduceable like the `Collections.sort` was trying to do.
nit: add `final` and put single parameter per line
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
`asList` -> `Collections.singletonList`
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I think we should do this in a `AccessController.doPrivileged` block since we need a special permission to modify threadgroup. It's good to respect that since we use this in reindex etc. as well
This exception is no longer possible since the constructor is taking `ObjectName`.
you should assign a new list instance (or clear the `abortBenchmarkNodeStatuses` list) to make sure we are not reading an instance that already has some status in the list.
Works for me. Maybe just have an interface called Cancellable - it seems CancellableTask is taken.
Thanks for pointing this out, missed that all other constructors delegate here, my mistake.
nit: one too many line break? :)
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
ditto here and others below
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I'd suggest moving this static method after the non-static methods.
We should use try-with-resources here (for `DataInputStream`).
We should read the metadata inside the while loop since it could change.
same for here, not sure if the full Objects.equals needs to be called
I'm wondering if we need to use `Objects.equals` here which would be quite heavy-weight on the entire CockroachTasksInProgress... in this case, for example, all we care about is if there are new task entries whose executor is the local node id... in that case, maybe we can have a method on `CockroachTasksInProgress` such as `hasNewEntriesForExecutor(localNodeId)`
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
It could be replaced with `if not res.get('skipped'):`
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
You don't need to specify any symbolic name for a group since you have only one.
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
This should have the two arguments in separate strings in case the implementation that invokes the commands changes to exec commands in the future.
Yep, that's correct (the value should be double-quoted).
What happens if tmpdir consists of a path with spaces in it ? I expect Powershell to fail on this, an it should be quoted `...Directory -Path "%s" -Name...`
I don't think this can work because this is not an interactive step. So you cannot pass the key passphrase to `ssh-keygen` and the process will just stay stuck.
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
nit: one too many line break? :)
It might be worth mentioning in the upgrade notes the fact that we now invoke revocation logic in `unsubscribe` and `close`.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
No tabs in python code.
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
nit: typo in description
do you have indentation at 2 chars only for this method? We use 4 chars in our codebase. I'd appreciate if you could change that.
nit: extra newline
Worth putting the different mapping as first in the List as a second test? `(EsIndex("diff"...), EsIndex("same"..), EsIndex("one"))`
maybe we could randomize the names of the 2 settings we have in this test
nit: typo in description
`topics created using through() method` -> `topics used in/by through() method`
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
You are right @hachikuji . For line 1597 to be true, I think the test needs to do another round of fetch. > // The high watermark advances to be larger than log.endOffsetForEpoch(3), to test the case 3 Line 1614 wants to fail because of an invalid offset and epoch based on the leader epoch cache. Not because it is greater than the high watermark. ``` assertThrows(IllegalArgumentException.class, () -> context.client.createSnapshot(invalidSnapshotId4.offset, invalidSnapshotId4.epoch)); ```
nit: typo in description
`topics created using through() method` -> `topics used in/by through() method`
Hmm, doesn't seem like this is correct. >version ['1', '0', '0-SNAPSHOT'] major_minor ['1', '0'] Extracting ['tar', 'xf', '/Users/ijuma/src/kafka/core/build/distributions/kafka_2.11-1.0.0-SNAPSHOT-site-docs.tgz', '--strip-components', '1'] Traceback (most recent call last): File "./release.py", line 235, in <module> command_stage_docs() File "./release.py", line 227, in command_stage_docs cmd('Extracting ', 'tar xf %s --strip-components 1' % docs_tar, cwd=os.path.join(kafka_site_repo_path, docs_version(version))) File "./release.py", line 108, in cmd output = subprocess.check_output(cmd, *args, stderr=subprocess.STDOUT, **kwargs) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 566, in check_output process = Popen(stdout=PIPE, *popenargs, **kwargs) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 710, in __init__ errread, errwrite) File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 1335, in _execute_child raise child_exception OSError: [Errno 2] No such file or directory: '/Users/ijuma/src/kafka/../kafka-site/10'
Also, it seems like our convention for docs versions is quite bad. If we didn't want to use `.`, we could use something else like `_`.
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
nit: missing . at end
You don't need to specify any symbolic name for a group since you have only one.
records to it, and reading all records from it, such that
It should be robust in case of some missing fields.
We didn't specify this in the KIP but I think `toStream()` and `toStream(mapper)` should also have overrides with`Named`
I'm sorry for flip-flopping on this, but thinking about this again (with the new model we introduced), I think it's simpler to call this just shardId , which must be set either at construction time (for things like refresh/bulk/flush actions) or when the request is resolved. Feels unnatural to call this resolvedShardId when it can be part of the constructor.
Forget the two interfaces idea. Just renaming the methods'd be good enough for me.
It'd be more helpful to me if these notes were on the method if we're going to mix them together like this. Another option would be to have two interfaces implemented by one class. I'm not sure that helps at all.
What if we make `level` default to "info" or "debug" instead? That way if you call `log_response` on a non-error response you'd just get an info/debug log, instead of getting a confusing "module logger has no attribute None" error (or whatever the wording actually would be)
no blank line
The variable name `phand` is non-descriptive
The indentation is messed up here, it should be 4 instead of 2 spaces. You may want to get a better editor - a modern editor should take care of indentation automatically.
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I know that this is how it used to be but we add an explanation that this is called before the index is added to the cluster state? created is misleading.
and -> a
base -> based progress -> progressed
Thank you for pointing this out! I will have a look at this in the next days.
Yeah, the underlying store compares the serializer bytes lexicographically, it doesn't have any concept of "Integer" or any other type. And the really tricky thing is that it scans lexicographically, which means from left to right, whereas when we serialize things we usually do so from right to left. eg `2` in binary is `10` whereas 11 in binary is `1011` and 13 is `1101`. The problem here is that the serialized version of 2 is a different number of bytes than the serialized form of 11/13, so the lexicographical comparator is effectively comparing digits of a different magnitude.
i.e., add `fail` after this line
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
We could also use `FileSystemUtils.isAccessibleDirectory(Path, ESLogger)` to make sure this dir is readable.
This can be only `Files.isDirectory(hunspellDir)` since `Files.isDirectory` returns false if the file doesn't exist.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
Space missing between `}` and `is`.
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Changing the names of variables which is not necessary for this patch makes it harder to review, can we revert them? e.g. `total_seconds_since -> since`, or ``` for index, (seconds_per_chunk, chunk_name) in enumerate(TIMESINCE_CHUNKS): ``` -> ``` for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS): ```
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
In fact, it seems to be standardized already in *lib/ansible/module_utils/api.py* as **api_url**. cc @bcoca
But grace and retention are two different things. In fact, I just had another conversation about this issue, and it seem we need to fix this by allowing people to specify a retention time IMHO. Not sure if we need to add a `Materialized` parameter or add `Joined#withRetention()` that we use to specify serdes etc.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
I don't think this is `@since` anything.
Since we have a Jira ticket that is even referenced here, I would prefer to remove the ToDo from the code.
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
it is preferable to have descriptive test names, i.e., `emptyIteratorAlwaysReturnsFalse` `emptyIteratorPeekNextKeyShouldThrowNoSuchElementException` etc
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
You don't need to specify any symbolic name for a group since you have only one.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
same for tests below as well
nit: fix indention (we usually use 4 spaces, not 8)
nit: add `final`
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
You don't need to specify any symbolic name for a group since you have only one.
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
I really like this class.
```suggestion * Metadata of a Kafka Streams client. ```
I would expect this to be `UTF-8` with a dash. That's the format in https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html
That's a good idea. Note: Kafka does not use this JUnit functionality yet (i.e. no use of ExternalResource, ClassRule, Rule as far as I can tell). @ijuma: Would it ok for us to introduce this? There's no additional dependency etc., it's just using a new JUnit feature that was introduced in 4.7 (we're on 4.12).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
As I suggested before, to not expose the node information, we should remove this function.
I'd suggest only keep `partitionsToOffsetAndMetadata` here.
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
Where is this function used? I'd suggest we only keep one function, i.e. ``` public Map<TopicPartition, KafkaFuture< ConsumerGroupDescription >> DescribeConsumerGroupsResult#values() ```
The user is trying to access a partition that was not requested. I think we could raise `IllegalArgumentException` directly to the user.
nit: extra blank line ```suggestion ```
I have a small preference for `Future<Map<Integer, Future>>` because it seems more aligned to how we do it for other APIs but I don't feel strong about it.
ditto here and others below
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
s/`Strings.isNullOrEmpty(publicKey)||`/`Strings.isNullOrEmpty(publicKey) ||` (space missing)
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
same for tests below as well
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
The second one, implement toString with the utility. On May 8, 2016 9:28 PM, "Johnny Lim" notifications@github.com wrote: > In core/src/main/java/org/elasticsearch/action/get/GetResponse.java > https://github.com/elastic/elasticsearch/pull/18102#discussion_r62442944 > : > > > @@ -168,4 +169,17 @@ public void writeTo(StreamOutput out) throws IOException { > > super.writeTo(out); > > getResult.writeTo(out); > > } > > + > > - @Override > > - public String toString() { > > - try { > > @nik9000 https://github.com/nik9000 Are you suggesting not implementing > SearchResponse.toString() but using Strings.toString() in application > code, or implementing SearchResponse.toString() via using > Strings.toString()? > > â > You are receiving this because you were mentioned. > Reply to this email directly or view it on GitHub > https://github.com/elastic/elasticsearch/pull/18102/files/c5f0c73b8b0f9c57500656081005aa64e28f509b#r62442944
I think this is the same as `Strings.toString(this)`? Otherwise I think this looks fine.
I mean to say that I think you can just call `Strings#toString`.
It's better to use variable names with context so for example `check1` could be `keystoreCheck`, etc.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Looks good. I like the additional checking that you're doing here.
@bizybot can you open up a issue that describes this behavior of the object parser and label it with discuss? Then we can move this PR forward.
I am confused how this works when created is only within role mapping but we ignore role mapping
paused -> running
this state is missing from the KIP, it should be added
you can use the util method printBoostAndQueryName here now (once you rebased)
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
Not introduced in this patch: "is non" => "as non"
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Not introduced in this patch: "is non" => "as non"
It's not a bid deal, but I found the naming here a bit confusing, since the `nonExistingSourceNode` is clearly added to the topology down on line 223, so it definitely exists. But I'm not sure what a better name would be...msybe `removedSourceNode`? Idk
can we not wrap a translog but rather just keep this test translog next to the normal one? keep it simple and readable :)
You have some unmerged lines here
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
I think it'd be clearer to simply inline these overloads and spell out all the parameters at the call sites. We only make three of these objects, so four overloads of the constructor seems excessive :) Also if `Bucket` were not `static` then you wouldn't need to pass `buckets` in.
@jasontedor Thanks. I think `:` is a reserved char on Windows and if used in logging.yml but no node name is configured then it might fail the creation of the log file. But I don't think there's something we can do.
This for loop is pretty similar to one in the `resolveConfigVariables(...)` method. Can we extract to a static helper method? I think it would also help make things a bit more clear, too.
ditto here and others below
recommended; ditto below.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
ditto here and others below
same for tests below as well
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
To simplify this, you could also just do `return assignmentSnapshot != null ? assignmentSnapshot.connectors().size() : 0.0;`
ditto here and others below
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
1: I'm definitely happy with this. I'm not sure why I didn't go for it myself. 2: Fine by me, I don't feel strongly.
It seems the `if shuffle` block is repeated twice, you can move it out of the conditional block
This bit of metadata should also be added to each dataset in the "both" case.
Please check test coverage carefully. I didn't spot a test for this change.
You can also drop the parentheses :wink:
you mean providing the size of the array I guess? cause I don't see a constructor that accepts an array in ArrayList.
I wonder if `profile` and `explain` should be forbidden too? Both have non-negligible impact on performance, and seem irrelevant to ranking as well.
creating two ArrayLists may not be the best thing to do. Lets do this instead: ``` List<String> splitList = new ArrayList<>(); Collections.addAll(splitList, oldVal.split(separator)); ```
can we use the index name first in the log, like `[{}] locking all shards, num_shards [{}], index, numShards`
Nit: why not use `boolean`
Minor nitpick 3: You could put the two if-statements into a long one making this diff really small
We tend to use different `node` value when multiple connections are created by a test. You could just replace `node` here with "1" and a couple of lines below with "2".
Sorry, missed this earlier: We are creating a new `selector` in `checkAuthentiationFailed`, so we should ensure that the previous selector is closed. You could call `selector.close()` just before calling `checkAuthenticationFailed` here and also a couple of lines below.
How about putting the `server.stop()` and `server = null` in a finally block? Also, `CloseableHttpResponse` is `AutoCloseable`, so we could actually use a try-with-resources here: ```suggestion server = new RestServer(workerConfig); try { server.initializeServer(); server.initializeResources(herder); HttpRequest request = new HttpGet("/connectors"); try (CloseableHttpClient httpClient = HttpClients.createMinimal()) { HttpHost httpHost = new HttpHost(server.advertisedUrl().getHost(), server.advertisedUrl().getPort()); try (CloseableHttpResponse response = httpClient.execute(httpHost, request)) { Assert.assertEquals(200, response.getStatusLine().getStatusCode()); if (!headerConfig.isEmpty()) { expectedHeaders.forEach((k, v) -> Assert.assertEquals(response.getFirstHeader(k).getValue(), v)); } else { Assert.assertNull(response.getFirstHeader("X-Frame-Options")); } } } } finally { server.stop(); server = null; } ```
The advantage of using `ConfigDef.validator` on the `response.http.headers.config` config key is that this constructor call would throw an exception if any invalid value is used, and much sooner, too.
nit: one too many line break? :)
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
given that we have almost proper setters here that return void, do we really want to make them return this? no strong opinion, just thinking out loud
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
something like `inferredInternalTopics.containsAll(specifiedInternalTopics)` might be easier to understand here
nit: extra line
nit: extra line
Maybe merge all the groovy securing code into one place? It feels funky to have the default receiver whitelist here but method blacklist above.
Do we want to _require_ a user provided key ? If I understand correctly, it really only protects against rainbow table attack when used in this context, but with the salt and potentially hard coded default key it seems we should be covered.
This function returns true if there is a non-empty intersection between topicNames and partitionForHost. You could reverse the iteration: iterate topicNames (since it is a List) and lookup into partitionForHost (since it is a Set and likely has O(1) lookup time). The overall complexity would be reduced: O(m*n) -> O(m)
@mjsax Got it. Thanks for your response!
Are these methods the sam as in the class above? If so consider refactoring so we only have them once
the node where the shard should move to
I think we should use `writeAtomic` everywhere just to reduce the complexity.
nit: one too many line break? :)
ditto here and others below
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
nit: one too many line break? :)
ditto here and others below
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
with vint we save a cast to byte I guess, that's it :)
do we do this in other places? I mean using read/WriteByte for enum ordinals? I think there's many many places where we have VInt instead
oh boy, I see that we were using VInt for writing and Byte for reading.... thanks for fixing...
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Nit: rename to `shouldThrowOnInvalidTopicNames`
nit: you could just specify one `String` variable at the top of the method and set it accordingly if `topics` is `null` or not then have a single `return` statement. Just a personal preference though.
nit: add `final`
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This test seems to be overlapping with `shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound`. I don't think we need both to return `LeaderNotAvailable` unless they are evaluating different scenarios.
same for tests below as well
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
Note to remember: while this is kept as a QueryBuilder internally, I think we need to make sure to call `toFiler()` on it once on the shard (e.g. in the new build() method, doesn't seem to be there yet)
same for tests below as well
This shouldn't be possible, right? It wouldn't make much sense to put a topic in the result if it didn't have a corresponding `TopicListing`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
This test seems to be overlapping with `shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound`. I don't think we need both to return `LeaderNotAvailable` unless they are evaluating different scenarios.
same for tests below as well
All the `null` checks at each layer of the call stack make me think that particular issue might be better handled with an exception. Not critical since this is all internal code, but seems like then we'd only need to check version compatibility in one or two places.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
A ``` python if count == retries: ``` is needed here, otherwise on the last retry the program will say **Retrying...** and then exit.
This should be ``` python if count == retries: ``` since you changed the while condition to `count < retries` and since this will never be reached if the retries are infinite.
It should be robust in case of some missing fields.
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
nit: add `final`
Can replace the three lines with: ``` assertEquals(Utils.mkSet("TLSv1.2"), Utils.mkSet(engine.getEnabledProtocols())); ```
req: Could you please rename `StreamsMetricsImpl metrics` to `StreamsMetricsImpl streamsMetrics` and then format the code like this ``` final StreamsMetricsImpl streamsMetrics = new StreamsMetricsImpl(metrics, "test", StreamsConfig.METRICS_LATEST); ```
It seems I also could approve it. I will read all code tomorrow and work with you to get this approved.
@jeffchao traditionally Kafka used key,value pairs in properties and pass it everywhere and each implementation takes look at this config and pulls their interested key,value pairs. Example, authorizer interface https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/security/auth/Authorizer.scala#L35 . The pluggable class when it gets instantiated a configure method will be called and all the key,value in server.properties will be passed and it will pick whats relevant to the class. We can do the same here instead of asking users append key,values into the a config which is hard to configure and hard to get it right.
ditto here and others below
same for tests below as well
It should be robust in case of some missing fields.
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
If it's possible to directly forward to `LoggingDeprecationHandler.INSTANCE` I'd rather do that because it would avoid duplicating the knowledge that the logger for `ParseField.class` goes to the deprecation log.
Not needed anymore.
Minor suggestion to make it clearer that we're not waiting for the write index not to exist: ```suggestion public static final String NAME = "check-not-write-index"; ```
can we open an issue/track it somewhere that these should be evaluated
This isn't a REST extension necessarily, right? It's also used by Kafka via JMX. I think mentioning `worker restarts` and `rest extension` might be confusing
same for tests below as well
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
I meant that we can have the if clause once in `Security.java` and call `check()` on all the checks (or the one `check()` if we decide to implement `FipsChecks` in a simpler manner ) IF `fips_mode` is set
Depending on other changes/suggestions, we should probably conditionally apply the FipsChecks if FIPS_MODE_ENABLED already in `Security.java` so that we don't have to check the settings value each time.
I think this should be: ``` ^(?:[-\\w]+[.])*[-\\w]+$ ``` - non-capturing groups (`(?:..)`) are more efficient - `\w` already includes `\d` and `_` - a `-` inside `[ ]` should appear first, otherwise it indicates a range (at least in pcre)
This should be: ``` ^(?:[-\\w]+[.])+$ ``` This assumes that (a) at least one level is required and (b) there is nothing after the group key (so it is anchored to the end of the string)
Ah yeah I suppose that might be ok, in this case it's user-defined input so that's pretty awkward but it beats breaking.
Yes, pass the value as a json string.
I think this should be a concurrentSet to be honest we remove stuff from this under locks and I don't like the runtime otherwise.
I think this should be: ``` ^(?:[-\\w]+[.])*[-\\w]+$ ``` - non-capturing groups (`(?:..)`) are more efficient - `\w` already includes `\d` and `_` - a `-` inside `[ ]` should appear first, otherwise it indicates a range (at least in pcre)
This should be: ``` ^(?:[-\\w]+[.])+$ ``` This assumes that (a) at least one level is required and (b) there is nothing after the group key (so it is anchored to the end of the string)
Ah yeah I suppose that might be ok, in this case it's user-defined input so that's pretty awkward but it beats breaking.
Yes, pass the value as a json string.
I think this should be a concurrentSet to be honest we remove stuff from this under locks and I don't like the runtime otherwise.
Nit: you can remove `value =`
Nit: unnecessary new line.
nit: remove the redundant line. Same as below.
`asList` -> `Collections.singletonList`
I'm somewhat inclined to add the local id to the builder rather than making it constant. It makes the builder a bit more self-contained. On a similar note, it would be nice to push the other static config values into the builder as well.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
nit: maybe call this `fixedLengthDeserializers` -- it's not about primitive types.
I am wondering, if we should get the `List` type as generic (not sure). `public class ListDeseializer<L extends List<T>, T> implements Deserializer<L>`
I think we should call `deserializer.configure(...)` here
Can we actually include UUID type? It always 16 bytes.
Remove the last sentence, since the `reset` method is private, and looks like it's handle automatically.
```suggestion /** * Metadata of a task. */ ```
```suggestion /** * The value of {@link StreamsConfig#APPLICATION_SERVER_CONFIG} configured for the Streams * client. * * @return {@link HostInfo} corresponding to the Streams client */ ```
Yes, we could add `ignoredExtensions` and include that in the log in the server.
```suggestion /** * Task ID of the task. * * @return task ID consisting of subtopology and partition ID */ ```
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
Should it be `Class<L> listClass` ? (or `Class<List<T>` if we don't introduce `L`)
`asList` -> `Collections.singletonList`
Why not have the standard to string? A multiline return value is difficult to work with in a debugger...
mmm this is not 100% correct. although it makes little sense, you can still set boost and queryname on the result, which would end up modifying the prototype and all subsequent match_none queries read.
obscure error message... let's start by `"could not read alias fields filtering from xcontent. expected an object but found [" + parser.currentToken() + "] instead"`
Perhaps something like "Represents a pattern that is used by ACLs to match zero or more Resources"
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Ah yes, thanks!
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
Nit, and I know it was there, but there's an extra space between `URLClassLoader` and `)`.
right, I forgot about the skip part. then we also end up trying to validate that there's only one version, otherwise skip won't quite work. if we really want to run this thing against a multi-versioned cluster, we should rather take the lower version and lose the validation. But for now this is ok as-is.
Ah yes, thanks!
Can you split this out into 2 tests please?. One for each method that is being tested. Thanks
maybe like this: ``` Java try { IOUtils.close(() -> processes.stream().map(s -> (Closeable)s::destroy).iterator()); } finally { processes.clear(); } ```
lets call `stdinReferences.clear()` after we closed all of them. I also think you should use `IOUtils.close(stdinReferences)` instead, it will close all references even if one close call throws an exception.
This should be done in reset()
Maybe: Include in the log the Connect key, value, and other details of records that resulted in errors and failures.
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
You don't need to specify any symbolic name for a group since you have only one.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It should be robust in case of some missing fields.
You have some unmerged lines here
You don't need to specify any symbolic name for a group since you have only one.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
That is a good point. I think adding a boolean flag in addition to the `future` result indicating if it may be incomplete is better than exposing the node map. I.e. we could have two fields inside `ListConsumerGroupsResult`, a `boolean` and a `KafkaFuture<Collection<ConsumerGroupListing>>` (I think we do not need to have nested KafkaFutures so I did not have that inside `Collection`, but correct me if I overlook anything).
I think we can just have one function between `values` and `groups` here. I'd suggest we use ``` public Map<TopicPartition, KafkaFuture<Void>> deletedGroups() ```
We should mention somewhere that users should prefer this new assignor for newer clusters.
We typically don't use java serialization. Is Serializable needed? Ditto in a few other classes.
We shouldn't use `<br>`; instead, use a `<pre>` section around the lines.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
This should be done in reset()
You can do this directly on the member variable: ``` private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class) ```
Same question here about just using a static ConfigDef instead of a static method.
Might be more useful if this explained what an "error context" is. Something like: Log to application logs the errors and the information describing where they occurred.
Why would `workerId` ever be `null`? And does having the `CONNECT_WORKER_ID_SEQUENCE` really help since all your workers would just have ID = 1? If this is just for tests, seems better to just require the ID to be passed in since we effectively require it for `Worker` and everything else.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
We do not need to have a separate `KTableForeach`, since it does not generate any new KTable object and hence no need for `view` etc. Instead we can just reuse `KStreamForeach` inside `KTableImpl`.
If we start from scratch then maybe these would be better be in `state`, but they have been added to `processor` and moving them would be incompatible changes. So I'm more concerning about the newly added classes.
We could do a small KIP and move the classes (preserving the old ones as deprecated). Overall, I don't have a strong opinion.
Actually I was really just asking for people's opinions :) the cons are that these classes will be in different packages which may looks a bit weird.
Does this need to be in `o.a.k.streams.state` or this package? I'm just wondering..
Yeah, something like that sounds good. Still, I'd like to select the right location after we need to use it from two or more different packages.
This looks good. Basically a JavaFx version of 'unsubscribeOn'. This is better because it allows executing immediately if already in the right thread.
This PR looks good. Once the build issue is resolved I will merge it. Thanks for contributing!
Whoops. I just merged it :-) I'll have to fix the build later.
nit: single parameter per line
ok, potentially reduces allocations for the user, thanks
Seems that this class is a bit redundant, i.e, we could just construct an `AssignedTasks` with the `logContext` and `"standby task"`
nit `Production exception handler` -> `{@code ProductionExceptionHandler}`
I think we probably should clean these up so they are more useful for users, but won't block merging this on that. I was thinking something more along the lines of: ``` UUIDDeserializer deserializes UUIDs in standard 36-byte hexidecimal string representation. ``` then followed by the encoding details, i.e. the stuff a user wants to know. Many users won't even think about the fact that what's going into the deserializer (or out of the serializer) is actually a `byte[]`.
I really like this class.
We only applied for `ElementType.METHOD`, so `ElementType.ANNOTATION_TYPE` can be removed.
add `final` twice
Can remove if initialize above
Remove double blank.
Can `LogManager.getRootLogger().getLevel()` be `null`? With other loggers you return the effective level if that's the case.
yea Im all for not exetnding that class. And Im also all for putting things that are primitive and easily validatable into the constructors. Optionals, i think im ok with setters but i think this also deserves a wider audience to discuss.
This should only be done in close()
I think this could be `String` or `Class` type. Not sure. For any case, we should test for both cases.
Not 100% sure -- but we need tests for this cases. The `configure()` code is untested atm
This shouldn't be necessary. I believe the config parser will coerce the value to the type you declared the configuration as, `Type.CLASS`. Might be worth to double-check, but we shouldn't add a bunch of branches if they're not necessary.
Cool. I think the fewer configs overall, the better. If we can get away with just the Serde configs then let's do so to keep the API surface area smaller for users ð
Strings.EMPTY_ARRAY could be used too (if you want)
Nit: "doens't" -> "doesn't"
seems redundant indeed
I'll leave this one
This multi-line `||` is super ugly to read without syntax highlighting (on github, for instance). How about: ``` java boolean same = local.isSame(remote); boolean hashAndLengthEqual = (local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length()); boolean consistent = same || hashAndLengthEqual; ```
Strings.EMPTY_ARRAY could be used too (if you want)
Nit: "doens't" -> "doesn't"
seems redundant indeed
I'll leave this one
This multi-line `||` is super ugly to read without syntax highlighting (on github, for instance). How about: ``` java boolean same = local.isSame(remote); boolean hashAndLengthEqual = (local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length()); boolean consistent = same || hashAndLengthEqual; ```
nit: `final` + next line and might as well do the previous while you are at it ;-)
nit: new lines are generally not recommended to break object type declaration with object name. For this specific line I think we can still make them in one line.
I was thinking something similar to how we use [addValidationError](https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/common/ValidationException.java)
we should probably consolidate the error messages from the results so that we don't only present the first (from a seemingly arbitrary check order) error that was encountered to the user
`newInstance()` can throw `ExceptionInInitializerError` and `SecurityException` as well.
It should be robust in case of some missing fields.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
You don't need to specify any symbolic name for a group since you have only one.
same for tests below as well
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
I wonder what will happen under parallel unit test environment like Jenkins, for `KafkaProducerTest`, `KafkaConsumerTest` and `KafkaStreamsTest`, won't the global counts be messed since AFAIK they are executed under a single JVM? cc @ijuma
We can call `selectKey()` instead which is like a syntax-sugar for such cases.
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
Do we need to check if it is null here? I think it is probably ok if it doesn't throw any exceptions? Obviously it would be better if we could check that `loginManger.release()` was only called on the first invocation, but i appreciate that involves further refactoring
nit: extra blank line ```suggestion ```
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
nit: could use Utils.mkSet
There is a `StreamsConfig.METRIC_REPORTER_CLASSES_CONFIG`, we can just use that.
Thanks @ijuma , obviously what I learned about gradle unit tests are totally wrong.
I wonder what will happen under parallel unit test environment like Jenkins, for `KafkaProducerTest`, `KafkaConsumerTest` and `KafkaStreamsTest`, won't the global counts be messed since AFAIK they are executed under a single JVM? cc @ijuma
@guozhangwang Tests are executed sequentially in each JVM. Parallel execution is achieved by forking multiple JVMs.
use `try-catch` plus `fail()` for this line and remove annotation `@expected` -- right now, for example, a bug in `builder.stream` raising `NullPointerException` would not get detected. ``` try { stream.peek(null); fail("Should not allow null Action"); } catch (final NullPointerException e) { // expected } `@expected` should only be used in "single line test" for which it is clear that no exception can happen before the actual tested code.
We can call `selectKey()` instead which is like a syntax-sugar for such cases.
only one parameter should be `null` -- otherwise it's unclear what this test actually does
We should explain why the key ("temp") is hard-coded here.
I'd suggest to replace `5000` with `TimeUnit.SECONDS.toMillis(5)`. This is better than magic numbers.
braces please. for the rest of the method too. (I realize you just tweaked this to be a lambda but it would be good to fix this as two line single statement `if`s are dangerous and evil).
You know, we can add a checkstyle check for those....
maybe just `esVersion()`
While we're at it, we may as well use another `{}` substitution for the parameter and remove the unneeded `toString()`.
I know you just moved these lines around, but while you're doing that it probably would be worthwhile to combine these 2 statements into one. If the log is busy, these might not appear next to each other.
Wow, test inheritance made this a truly mysterious change... Managed to track it down, though.
I think this will be clearer if we say - "// precreate incoming indices and popluate them with the relevant types"
this curly bracket should be on the previous line
As what we're actually storing is the list, I would make this constructor the leaf one. Then the varargs one can just call `this(Arrays.asList(jobIds))`.
```suggestion * @return map from tasks with caught-up clients to the list of client candidates ``` or something similar to make it clear the map only contains tasks with caught-up clients
Couple notes: You probably shouldn't pop from module.params.... I usually consider that to be a "constant" value. It's the record of what the user specified in the playbook for the module to look at but not to change. If you do want to pop it, you don't need to do it as two steps. This should be equivalent to what the present code does: ``` python module.params['binding:vnic_type'] = module.params.pop('vnic_type', None) ```
Yes, that would be the way to do it. Also, just for clarity, those are not blockers for merging this PR. The question of behaviour change is the only thing holding this up.
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
same for tests below as well
ditto here and others below
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
It should be robust in case of some missing fields.
Couple notes: You probably shouldn't pop from module.params.... I usually consider that to be a "constant" value. It's the record of what the user specified in the playbook for the module to look at but not to change. If you do want to pop it, you don't need to do it as two steps. This should be equivalent to what the present code does: ``` python module.params['binding:vnic_type'] = module.params.pop('vnic_type', None) ```
Yes, that would be the way to do it. Also, just for clarity, those are not blockers for merging this PR. The question of behaviour change is the only thing holding this up.
why not native boolean type instead of Boolean object? Also, we use the package names as prefix for modules settings, so I would go with `plugins.isolation` compared to `plugin.isolation`.
Seems strange to split the string here rather than moving `Mapper.etc` to a new line
Also minor, but I think I'd prefer `node == null ? null : node.toString()` because it requires less negative-resolving in my brain, up to you though.
This seems to defeat the purpose... If we really want to skip this test in this environment, we should rather put it in the beginning and do ``` if (isUnix) { return; } ```
`STATICFILES_IGNORE_PATTERS` -> `STATICFILES_IGNORE_PATTERNS`
To get `retryBackOffMs` config, we will need to add it explicitly with prefix `admin.` in `StreamsConfig#getMainConsumerConfig()` similar to retries: ``` consumerProps.put(adminClientPrefix(AdminClientConfig.RETRIES_CONFIG), adminClientDefaultConfig.getInt(AdminClientConfig.RETRIES_CONFIG)); ``` Nit: fix indention (similar below) -- there should not be any tabs, but spaces only.
Uh oh. Just use `self._match_id(url)` and change the symbolic name of regex group to `id`.
It does not matter that it's not an actual id. The code where you extract the actual `video_id` remains the same.
I think we can just call `createKeyValueStore` and inline `createStore` inside `createKeyValueStore`. Also since all the calls in this class are the same, we can extract the `store` as a class variable.
should we implement SearchContext.toString? This way it would also be easier to look at SearchContext objects when debugging
I think it is fine: we only build one search context per request per shard.
`wrappedStore()` should `return wrapped;` -- that's why I argue for renaming the variable.
Not sure about this -- why not add two generics to the store, one for "wrapped" and one for "root" and keep this method that return the root type? I would also rename `inner()` -> `root()`

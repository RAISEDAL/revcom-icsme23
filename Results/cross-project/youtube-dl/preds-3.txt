Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
A temporary variable is not necessary: ```suggestion # Remove all non-printable characters. file_name = ''.join([char for char in file_name if char.isprintable()]) ``` Also, it should be faster to check with `string.printable`: ```python file_name = ''.join([x for x in file_name if x in string.printable]) ``` ``` $ python3 -m timeit 'import random; x = "".join([chr(random.randint(1, 10000)) for _ in range(10000)]); "".join([char for char in x if char.isprintable()])' 50 loops, best of 5: 7.03 msec per loop $ python3 -m timeit 'import random; import string; x = "".join([chr(random.randint(1, 10000)) for _ in range(10000)]); "".join([char for char in x if char in string.printable])' 50 loops, best of 5: 6.76 msec per loop ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Please use hanging indentation and avoid using of `\` (here and below), e.g. ```python subquery = AggregateTestModel.objects.values('char_field').annotate( stringagg=StringAgg('char_field', delimiter=';', ordering='-char_field'), ).exclude( char_field=OuterRef('char_field'), ).values('stringagg') ... ```
Note, the advice to use to_text() here was incorrect. to_text should be used if the msg is not text where the msg enters the system as a whole. It should not be used where msg is used (unless it is a non-string type until then. But with a name like msg, it should be a string type when passed in here)
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
Should the default be https, if so update docs
It's not really a warning, given the user cannot continue.
I'm not sure "This should not have happened." adds much. Also, use 1 space between sentences.
pip >= 9.0 and setuptools >= 24.2
It's not really a warning, given the user cannot continue.
I'm not sure "This should not have happened." adds much. Also, use 1 space between sentences.
pip >= 9.0 and setuptools >= 24.2
To avoid linter errors, change this to ```suggestion d_ = d self.assertTrue(d == d_) ``` and hope that the linter doesn't get too clever ;-)
Use `self.assertEqual(d, d)` instead of `self.assertTrue(d == d)`.
`@unittest.skipUnless(basic.has_journal, ...)` might be clearer.
`@unittest.skipUnless(basic.has_journal, ...)` might be clearer.
The various `CALLBACK_` prefixed class attributes are missing. Take a look at the other callbacks for an example. In particular, this is needed: ``` python CALLBACK_NEEDS_WHITELIST = True ```
New unit tests should be written using pytest style instead of unittest. The biggest difference being the use of functions and fixtures instead of classes.
The default should match all jobs.
Typo in the help message
Typo in the help message
"for working with retry limiting"
It looks like there will be a SQL syntax error due to a trailing comma if gin_pending_list_limit is used without fastupdate. Maybe `with_params` should be a list and joined with `', '`.
Do you think we're adding value with such complicated `__repr__` methods? I've thought maybe we should ditch worrying about including of Index's params in them and just let `Index.__repr__` show the basics. Does the repr should up anywhere important? I can't think of anywhere.
If I remember how this worked in 2.9 the 2nd tuple entry controls whether the file is excluded from the root only or throughout the collection. I would have thought we would want the latter so this should be ```suggestion b_ignore_files = frozenset([(b'*.pyc', False), (b'*.retry', False), (b'.git', False), ``` Then again looking at devel the pattern is `.git` so this does act the same as devel.
It'd be cleaner to have only kwargs conditional: ```suggestion optional_kwargs = {'ExtraArgs': {'VersionId': version}} if version else {} s3.download_file(bucket, obj, dest, **optional_kwargs) ```
Oh.. `version` is immutable within the loop. You can move kwargs outside: https://github.com/ansible/ansible/pull/47867/files#r237441147 ```suggestion s3.download_file(bucket, obj, dest, **optional_kwargs) ```
It'd be cleaner to have only kwargs conditional: ```suggestion optional_kwargs = {'ExtraArgs': {'VersionId': version}} if version else {} s3.download_file(bucket, obj, dest, **optional_kwargs) ```
Oh.. `version` is immutable within the loop. You can move kwargs outside: https://github.com/ansible/ansible/pull/47867/files#r237441147 ```suggestion s3.download_file(bucket, obj, dest, **optional_kwargs) ```
Nit - Change the message to: "Operation aborted, self-heal in progress." removing the capitalisations.
It probably makes sense to create a new `utils.py` module which has a function `write_to_file_if_different(filename, data)` which does the heavy lifting (and where this is done cleanly), so that all the details are only repeated once.
Why not simply compare contents, instead of computing sha1 of both first? Since you read both into memory, that's more efficient :) Also: it currently fails under Python 3: ``` Traceback (most recent call last): File "../bin/dump_config.py", line 84, in <module> sys.exit(main(sys.argv[:])) File "../bin/dump_config.py", line 72, in main sha1_old = sha1(open(output_name).read()).hexdigest() TypeError: Unicode-objects must be encoded before hashing ```
Also: since you're not closing the file, this might break under strange file systems (such under Windows -- no idea if anyone ever tries to do that, tough :) ).
The change to this module is the only one that I question. I'm leaning towards putting this on the allowed list. The reason is that the code presently in the module is the equivalent of a UNIX pipe. The decompressor is able to chunk the data from the file to the database program as it decompresses that portion of the file. The run_command() version has to store all of the data from the decompressor in memory before passing it to the database program. So the memory usage can balloon in this case.
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
Huh, I haven't the foggiest idea. I didn't do any editing of that content that I recall. Funny that it works. I guess we submit a patch and fix it in the backports? Funny that everything still works. I wish this was all handled in one place...
Hmm. On second thought, I'm not even sure if ANSIBLE_METADATA is used in lookup plugins? I think that's only for modules specifically.
Please format this like this: ```python ANSIBLE_METADATA = { 'metadata_version': '1.1', 'status': ['preview'], ï¿¼ 'supported_by': 'core' } ```
Would be nice to know the minimum version.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I think we should be consistent and use double-quotes.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
Then we can get rid of these. ```suggestion ```
lines 10-12 are imported by not used (unless I'm missing something)
You appear to have dropped `Element`
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
@pierremahot we'll need a test for this
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
Good idea :+1:
I noticed that all logs and prompts have `ERROR` style when using `--scriptable`, e.g.: ![image](https://user-images.githubusercontent.com/2865885/148344507-ada0d115-4a48-4001-81a2-b62c919c5e45.png) ![image](https://user-images.githubusercontent.com/2865885/148344684-e00db0d8-c25f-45fc-ba54-9dfef13eac7c.png) We could create a copy of `stderr` without the `ERROR` style and use it where appropriate :thinking: ```diff diff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py index cdb200f22e..096702814c 100644 --- a/django/core/management/commands/makemigrations.py +++ b/django/core/management/commands/makemigrations.py @@ -6,7 +6,7 @@ from itertools import takewhile from django.apps import apps from django.conf import settings from django.core.management.base import ( - BaseCommand, CommandError, no_translations, + BaseCommand, CommandError, no_translations, OutputWrapper ) from django.db import DEFAULT_DB_ALIAS, OperationalError, connections, router from django.db.migrations import Migration @@ -62,9 +62,17 @@ class Command(BaseCommand): help='Output only created migration filepaths to stdout; divert logging and prompts to stderr.', ) + def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False): + super().__init__(stdout, stderr, no_color, force_color) + if no_color: + self.stderr_log = self.stderr + else: + # stderr without the ERROR style. + self.stderr_log = OutputWrapper(stderr or sys.stderr) + ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Remove a level of indentation by flattening this if statement into the previous.
Ah, sneaky 🤗 Too early in the morning!
:thinking: As far as I'm concerned it will not change a level of indentation: ```python if name in self.annotations: if not allow_joins: annotation = self.annotations[name] ```
`can not` -> `cannot`, or better `may not `
Passing `sys.argv[:]` here is useless wrt current implementation. If you look at the `main()`'s first three lines there's: ```python def main(args): ... (options, args) = parser.parse_args() # <-- immediatelly rewrites args variable ``` It looks like the initial implementation has been written by the person with some C-like background, where main accepts args data and returns 0. But in fact in this case it's not needed. Please remove this arg.
Anyway, removal of `return 0` was not related to the purpose of the PR, but related to my refactoring suggestion. So it fits next to your change :)
`can not` -> `cannot`, or better `may not `
Passing `sys.argv[:]` here is useless wrt current implementation. If you look at the `main()`'s first three lines there's: ```python def main(args): ... (options, args) = parser.parse_args() # <-- immediatelly rewrites args variable ``` It looks like the initial implementation has been written by the person with some C-like background, where main accepts args data and returns 0. But in fact in this case it's not needed. Please remove this arg.
Anyway, removal of `return 0` was not related to the purpose of the PR, but related to my refactoring suggestion. So it fits next to your change :)
Add this snippet at the top of the module: ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ``` Then, you won't have to inherit from `object`.
When using pytest, create top-level functions without using a class.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
I'd go for underlining.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
community, no core here please.
Bike shed: would be good if this included `yaml` in its name.
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
community, no core here please.
Bike shed: would be good if this included `yaml` in its name.
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
community, no core here please.
Bike shed: would be good if this included `yaml` in its name.
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
community, no core here please.
Bike shed: would be good if this included `yaml` in its name.
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
```suggestion module.fail_json(msg='The following volume names were not found: ' ```
```suggestion - content library id for which details needs to be fetched. ```
Again, suggest rewording this as suggested for win_http_proxy.
This is fine as is.
+1 to a public method on the handler
This is fine as is.
This is fine as is.
+1 to a public method on the handler
This is fine as is.
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
Bike shed: would be good if this included `yaml` in its name.
community, no core here please.
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
Bike shed: would be good if this included `yaml` in its name.
community, no core here please.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Isn't `raise` missing there ? Calls to `str` are useless.
This can be converted to return True. No need of new variable retry_request
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment) and rebase.
We should probably put this into ansible.utils.unicode with a note about when to use it and what sort of literals to use it with for those that don't understand the native string distinction.
Lastest decision is to use pep8 style docstrings for new code. e.g. "Packs -> Pack"
I'm going to be a +1 to just dropping `converters`
How about omitting it until we have a use case? That will save writing tests and docs for a theoretical feature. :-) From a readability point of view, writing a `re_path()` that mixes regexes and converters in the string, and then has to initialize and pass converters in the URLconf sounds nasty and not something to encourage!
hmmm.. now I think I'm wrong, you want to only have the first partial func.. `func.func` shouldn't anyway be another partial or else that would be problematic I think, as views have to return something else.. Sorry for disturbance ;)
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
hmmm.. now I think I'm wrong, you want to only have the first partial func.. `func.func` shouldn't anyway be another partial or else that would be problematic I think, as views have to return something else.. Sorry for disturbance ;)
didn't knew about RegexURLPattern having the same method.. reading the docstring I'm thinking both should do this: ``` python # .. if isinstance(func, functools.partial): while isinstance(func, functools.partial): func = func.func # ... ``` shouldn't it ? again that's my wild guess here, I don't have read more about the context of how this method is used (nor the other one), etc.. So I could be simply wrong.
Please open a ticket to track the bug (all non-trivial changes should have a ticket).
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
Yeah, a list is fine.
Is this function used to retrieve large files? If so, I suggest redirecting directly to the file, instead of using PIPE -> 'stdout' variable and writing to the file only then.
Line 355 to 368 are unused.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Line 355 to 368 are unused.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Line 355 to 368 are unused.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
I think you meant `get_ellipsized_page_range` here. Use `number` instead of `page_num` which matches the argument name used by `Paginator.get_page()`.
There is no need to provide a value for `max_pages_num` - I think it should be calculated automatically: ```python (self.on_each_side + self.on_ends) * 2 ``` Otherwise developers can provide values that are incompatible with each other...
Single quotes for all of these as well.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
In the `exit_json`, you should also return `changed` and `state`.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Not supported on Python 3.4.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
TBH, I don't think we need this test. I will chop it.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Not supported on Python 3.4.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
So we have to probably use try-except blocks for all the stuff that could fail. Nowadays with python3 you'd be doing something like: ```python from ansible.module_utils.pycompat24 import get_exception .... try: <whatever action that could fail> except: e = get_exception() module.fail_json(msg=str(e))
I am a bit scared by this. Because the module indicates it supports check-mode, but if I look at the code it seems to be doing all the stuff and only at the end appear to say there hasn't been a change. That cannot be right (it's dangerous!).
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
This is duplicated 15 lines above that ;)
Thank you very much for your review of this! Will fix.
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
Grammar nitpick... Quick fix here would be to swap the comma for a semi-colon. The more detailed version is that this forms an invalid dependent clause the way it is written right now. A semi-colon would fix that, as would splitting off the `use the ...` content into its own sentence.
Nice. So I'd go with `_validate_$whatever_name_we_bikeshed` method to check for invalid values. Unless we decide to use a boolean.
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
All `description:` must be full sentences, e.g. capital letter and full stop. This applies to the other descriptions from this point down.
no need to specify 'string'
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
Isn't `raise` missing there ? Calls to `str` are useless.
Note that format strings changed in python-2.7 So things like "{} {}".format() needs to change to "{0} {1}".format() for python-2.6 compatibility.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
fixture with load_json
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
Another test that I would move into version specific classes with pytest skipifs
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
Note, the advice to use to_text() here was incorrect. to_text should be used if the msg is not text where the msg enters the system as a whole. It should not be used where msg is used (unless it is a non-string type until then. But with a name like msg, it should be a string type when passed in here)
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
nothing. The point is to make collision between nonce and key as unlikely as possible. Using static nonce doesn't give you that. Cryptography is hard enough to get right _without_ going against recommended best practice.
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
trailing comma here and next line
Chop blank line.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
that's the default in 1.9, but I don't if you want to include it anyway
Damn it, there is clear way to get this working. Ie there is no reliable way to determine the source_model_admin for a given URL :( I think we might have to relax permissions a bit and provide the autocomplete to any user for every model which has search fields defined and where the user has any permissions on it.
Sorry, I couldn't figure out how to continue the conversation that I started here -- the fact that you changed the code seems to "trick" github into thinking that we are done here :) As you pointed out, `get_inline_instances` with no request is very weird and probably (tm) breaks existing code out there. What do you think about the following: Add only one (or two, if it makes handling inlines easier) autocomplete view to the urlpattern (statically) which disapatches to `self.autocomplete_view` and the returns `AutocompleteJsonView` accordingly. This way you'd have access to the request and would just need one view which you'd pass the information you need.
```suggestion Question.objects.create(question='Not a question.') ```
Line is too long.
Line is too long.
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
fixture with load_json
Another test that I would move into version specific classes with pytest skipifs
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
For algorithmic code, it can make sense to test private methods and private functions in isolation from the rest of the code. This does seem to be a place where that could be justified. The code being tested is functional (meaning it operates via parameters and return values rather than callbacks) and it plugs into a larger framework which is outside of our control. What I'll sometimes do is push all the permutations of data that I care about at the private function and then push a small subset at the public interface to make sure that the interaction between the public and private code is working as expected.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
For algorithmic code, it can make sense to test private methods and private functions in isolation from the rest of the code. This does seem to be a place where that could be justified. The code being tested is functional (meaning it operates via parameters and return values rather than callbacks) and it plugs into a larger framework which is outside of our control. What I'll sometimes do is push all the permutations of data that I care about at the private function and then push a small subset at the public interface to make sure that the interaction between the public and private code is working as expected.
Like I said I don't remember exactly where it happened but that is why I added that if block. I am ok without if block if it is working on your systems.
This will fail when there is no vlanId or vswitch in portgroup. I don't remember the exact reason, but I encountered error here sometimes in past.
I am not sure we have such deprecation policy, need to check.
```suggestion form = PartiallyRequiredForm({'f_0': 'Hello', 'f_1': ''}) ```
Chop blank line.
```suggestion form = PartiallyRequiredForm({'f_0': '', 'f_1': ''}) ```
```suggestion form = PartiallyRequiredForm({'f_0': 'Hello', 'f_1': ''}) ```
Chop blank line.
```suggestion form = PartiallyRequiredForm({'f_0': '', 'f_1': ''}) ```
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
> Would this be better as `if key not in module.params` so we don't capture the case where the user explicitly sets things to `null`? The ansible way for the user to skip an upon is `{{ omit }}`
This can be a single line.
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Line too long
Line too long
You can use `module.deprecate` to throw a deprecation warning.
a leftover here which can be removed
Just a note here. We decided that by convention we will use the same naming as maven. `groupId` has now changed to `org.elasticsearch.distribution.[packaging]` so I think we should also reflect that change here and use `org/elasticsearch/distribution/[packaging]` where `packaging` is: - rpm - deb - zip - tar
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
It looks to me like these URLs are better suited for a `seealso` section.
Need to bump this to `2.6`
It looks to me like these URLs are better suited for a `seealso` section.
Please only import what you need.
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
It looks to me like these URLs are better suited for a `seealso` section.
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
Please only import what you need.
It looks to me like these URLs are better suited for a `seealso` section.
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
Please only import what you need.
Please remove empty line.
Net new tests should be `pytest` style tests.
This key appears to be unused, and also a typo of `session`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
I think we should be consistent and use double-quotes.
Explicit is better than what's happening implicitly: ```suggestion host=to_text(host), err=to_text(err), url=to_text(self.foreman_url))) ```
You reassign this var on each loop iteration, please move it outside. ```suggestion ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Fine with me.
What's the purpose of these lines? When I run the script, the suffix is always ".js" so this condition is always True.
`AttributeError: 'PosixPath' object has no attribute 'with_suffic`
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
```suggestion class VMwareExportVmOvf(PyVmomi): ```
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
`Hook has been updated`
```suggestion elif date_string.match(self.when): ```
This may apply to some of the other PRs in flight, as well as some of your existing modules.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
```suggestion elif date_string.match(self.when): ```
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
```suggestion elif date_string.match(self.when): ```
type='str' is a default value not required to mention in separately.
I think this if-else condition is to handle value of `size`. Can this be handled outside? This will reduce code duplication
Typo in the help message
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
Typo in the help message
This probably needs to be bytes.
```suggestion if not os.path.exists(to_bytes(xdg_path, errors='surrogate_or_strict')) and euid != 0: ```
```suggestion if not os.path_exists(to_bytes(xdg_path, errors='surrogate_or_strict')) and euid != 0: ```
Just put this on one line (or two if needed for line lengths) ``` from a.b.c import x, y, z from a.b.c import u, v, w ```
Then we can get rid of these. ```suggestion ```
This line is now an unused import
I think it's not pylint itself, but our own checks...
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
fixture with load_json
Another test that I would move into version specific classes with pytest skipifs
It's possible to get a `jenkins.JenkinsException: job[your_job] number[1] does not exist` here. Maybe adding a try/catch for this? ```python try: if self.server.get_build_info(self.name, self.build_number)['building']: time.sleep(1) else: return except jenkins.JenkinsException as e: time.sleep(1) ```
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
fixture with load_json
You're checking two separate properties here. This should be in a separate test.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
I don't think testing against the invalid (missing quotes) introspection SQL is necessary given the assertions below already fail without the `get_filters` changes.
I removed these assertions.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
Should use `assertRaisesMessage()` to verify the string also.
a leftover here which can be removed
this should use the new API without hardcoded id now
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
My bad, I've missed it !
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
so this assertion looks incorrect, i would expect and empty string as the ssh args
no, if the variable is set but empty, you should empty out the options
This fails for me: ``` AssertionError: <MagicMock name='WatchmanReloader()' id='140033332456584'> is not an instance of <class 'django.utils.autoreload.StatReloader'> ``` perhaps that's the failure that Jenkins encountered.
Missing `raise`. I would probably change to `AnsibleAssertionError`.
Display should use text strings, will need a to_text in the format and u prefix the string so we don't have any ASCII encoding errors on Python 2.
to_text and u prefix on string.
I always sort alphabetically if the order has no meaning.
This change is not required, please revert it.
I would add `('availability', BooleanFieldListFilter)` to the `BookAdminWithTupleBooleanFilter` instead of creating a separate class.
I always sort alphabetically if the order has no meaning.
This change is not required, please revert it.
I would add `('availability', BooleanFieldListFilter)` to the `BookAdminWithTupleBooleanFilter` instead of creating a separate class.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
I would use `%s` formatting consistently.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Maybe this should be a class docstring :thinking:
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
Maybe this should be a class docstring :thinking:
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`K.floatx()` is the preferred way to access this.
This looks to be incorrect, there should be if not os.path.exists() protection, or better yet, have _createdir() do (very pseudocodish) try: makedirs(); except: if already-exists: pass; else raise EDIT: Sorry, was reading the old version of _createdir()...
I mentioned this recently in an unrelated PR, mentioning here as well so that everyone is on the same page. Rationale for import location is in the "New Files" section of https://github.com/ansible/proposals/issues/50 .
One option would be to pass add an arg for the local fs path (or even an open file handler).
The code that gets replaced by this method (in crc32 for ex), the url is downloaded to a dir local to the module source. Here, a new temp dir is created. Afaict, those could have different permissions. If the mkdtemp() result is more open than the __file__/* path, a downloaded file may be readable with different permissions. Haven't tested to see if that is a problem so would like some clarification.
I talked to Jmainguy on IRC and he thinks that using mkdtemp() should be fine from a permissions standpoint. There are some other thoughts though: * Using the module tempdir, the temp dir should be cleaned up automatically by the controller. If we use a separate tempfile, it becomes the calling code's responsibility to clean up the temp file (and the temp file can be left if the module raises an exception before it cleans up). * the module doesn't always have a file (in pipelining mode). When that happens, we can't use __file__ to determine where to place a tempfile. bcoca proposed adding a mkdtemp/mktemp function that could handle this but that is probably worthy of a separate PR. * bcoca also noted that overall, it's better not to have modules do this. Having two separate tasks works just as well (however, we need to start shipping roles at some point so that composing multiple tasks into a single logical unit is as easy as creating a module). Perhaps a note in the docstring that modules shouldn't tack on downloading files as a secondary function would be satisfactory for now.
I'd expect the set to be done after mangers & admins are added
Can you just add the managers and admins including their names, please. I think that I'd expect the names to show up in the message if I define them in my settings.py
if it were not for the `-C` i would not say 'tempted' but actually request it
This method definition shares most of its functionality with `get_request` method, which indicates that the common functionality (common parameters, error handling, etc.) should be extracted into private method.
It's fine if it's a placeholder for future capabilities.
This might not work, but the __str__ return result of error might have what your looking for.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
I think we should be consistent and use double-quotes.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
I'd rename `subminor` to `patch`.
I think we should be consistent and use double-quotes.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
I'd rename `subminor` to `patch`.
I think we should be consistent and use double-quotes.
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
I think we should be consistent and use double-quotes.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
The query should be something like ``` G.V().Has('TID', 'bd7f5334-115c-5943-487d-a77c486fa854') ``` according to the `name`
Would you kindly add some line feeds here to make it look like json instead of a wall of text? It'd be so much easier to read.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Since this isn't implemented, perhaps lets not mention it? I found it confusing
Trivial fix, but it would be good to say 2.12 instead of 2.12.1 here so that we get the latest patch release. There's one other place in the file that also needs to be updated.
kushal found that check_call is 2.5 ; check_output is what is 2.7.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
You asked me about the `lru_cache` here; I don't think it matters one way or another :-)
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Not supported on Python 3.4.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
if not handling become methods update the class variable to indicate this
not that, i'm talking about `become_methods` list class variable.
```suggestion raise AnsibleError('Unable to use "%s" as a search parameter: %s' % (term, to_native(e))) ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
not that, i'm talking about `become_methods` list class variable.
The current coding style prefers single quotes. Please fix throughout, but new code only. ```suggestion if 'PICKLE_VERSION' in options: ``` _(Eventually it will be double quotes when we can use `black`.)_
I think this assertion has been copied from another test. I would use ```python constraint_name = 'ints_between' self.assertNotIn(constraint_name, self.get_constraints(RangesModel._meta.db_table)) ```
Complement the docstring adding the parameters, might be useful (to the other functions as well)
You asked me about the `lru_cache` here; I don't think it matters one way or another :-)
Not supported on Python 3.4.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Plz also use `match` arg here
fixture with load_json
drop u prefixes on strings (we use `from __future__ import unicode_literals` instead)
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Please remove empty line.
remove extra newline
check that -> and that (no comma needed since the two clauses are independent)
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I'd go for underlining.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
fixture with load_json
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
fixture with load_json
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
else is unnecessary here because we raise an exception before
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
add space after `(w[1])`
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
add space after `(w[1])`
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
Please remove empty line.
I think I'd make this an `Error` - I don't think translation works at all if this is wrong.
We don't need to call `len()`, `slice()` will work the same with `None`.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
It looks like there's a race condition here. The log file could be read before supervisord has reopened it.
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
Usually, testing private interfaces doesn't make sense.
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
use `self.MAX_FILES` instead of 999999
1) No need to inherit from object explicitly due to `__metaclass__ = type` set above 2) It's nice to properly support all stringifications ```suggestion @six.python_2_unicode_compatible class CollectionRequirement: ```
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
Usually, testing private interfaces doesn't make sense.
I think it would be better to put these tests in `tests/auth_tests` unless there's some reason that's not feasible.
Please rebase your branch. Master now supports Python 3 only, so `unicode_literals` may be removed.
I don't think you need `absolute_import` here - you don't need to to do a relative `.models` import a few lines down. You would need it to ensure that `import models` would fail to import the relative module.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
fixture with load_json
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
fixture with load_json
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be converted to return True. No need of new variable retry_request
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
As above, wrap the format in quotes. "Your URL pattern '{}' has .."
Maybe this should be a class docstring :thinking:
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
As above, wrap the format in quotes. "Your URL pattern '{}' has .."
Maybe this should be a class docstring :thinking:
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
And the same here
```suggestion del self.headers[header] ```
Please use more descriptive variable names for at least `_h` and `_k`, and probably `k` and `v` also. I think it's fine to use some single letter variables in list/dict comprehensions or simple loops, but once there is some additional logic I think readability is improved by using longer names. Also, it should be fine to reassign the lowercase version of `k` (or whatever it ends up being) to itself since the original value isn't used anywhere else and the type hasn't changed.
```suggestion del self.headers[header] ```
The leading underscore in the '_meta' key is missing here.
required is by-default is 'False', so no need to add explicitly.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
You shouldn't need the extra parentheses inside `extend()`, FYI.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion re.compile(br'[\r\n]?<.+>(?:\s*)$'), ``` And so on for all the entries of both `terminal_stdout_re` and `terminal_stderr_re`.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Without all those connection arguments, this goes away, too
Do we need to specify `human` as an option? That could just the default and `yaml` or `json` are specified.
I was unable to find examples of a `default` that is not listed in `choices` on the internet. This may need to be checked experimentally.
This is not a blocker, just a thought on the interface.
Maybe this should be a class docstring :thinking:
Too many empty rows here...
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Without all those connection arguments, this goes away, too
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
We can add assertion for number of queries `self.assertNumQueries(0)` because that's the real impact of this optimization.
`aws_connect_kwargs` won't be defined at this point unless `ec2_url` is set, which is the unlikelier of the code paths
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
correction: It's not a byte string, it's a raw-string literal
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
correction: It's not a byte string, it's a raw-string literal
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
```suggestion with self.assertWarnsMessage(RemovedInDjango50Warning, msg): ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
a leftover here which can be removed
this should use the new API without hardcoded id now
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
This could be problematic. If you set the seed to a constant and use multi-processing then all children processes would share the same seed and you'll get batches with repeated samples.
In that case the first seed can be used to generate separate seeds for each sub process before the fork
add param to provide a seed at init time
Or just a random 16bit IV.
"for working with retry limiting"
This seems random and can lead to flaky tests. So there is no way to measure latency while Trogdor task is running? For the rate limit test below we do wait for task to run.
If you make this: ```python with self.assertRaises(VariableDoesNotExist) as exception_ctx: ``` then later on when you need the exception you can just do: ```python self.assertEqual( str(exception_ctx.exception), ... ) ``` which looks a bit cleaner than the `exc_info[1]` stuff.
Rather than use a `lamdba` here, it would be better to use a generator expression for clarity ```suggestion lines = line.split('::::')[1].split(';') tmp = dict(x.split('=') for x in lines) ```
The code that gets replaced by this method (in crc32 for ex), the url is downloaded to a dir local to the module source. Here, a new temp dir is created. Afaict, those could have different permissions. If the mkdtemp() result is more open than the __file__/* path, a downloaded file may be readable with different permissions. Haven't tested to see if that is a problem so would like some clarification.
be more specific than Django -- e.g. "CommonMiddleware"
single line is okay here (we allow longer lines up to 119 characters if it helps readability)
Rather than use a `lamdba` here, it would be better to use a generator expression for clarity ```suggestion lines = line.split('::::')[1].split(';') tmp = dict(x.split('=') for x in lines) ```
Then people's results won't be valid and they won't have a way to know! Imagine if you're trying to train on very small datasets and you skip one.... I think raising an Exception is the correct behavior.
Sometimes you'll have entries in your Dataset that you won't want to process in your model (a class that you can't handle, an image that is too big etc.) and in some other cases your pre-processor might simply fail (bad communication, missing file, invalid labels, etc.). The user can handle those cases by having `Dataset.__getitem__` return an exception, and when that happens simply don't add the index into the queue. Otherwise the user has to pre-preemptively remove from the Dataset every object that might "break". This is not always possible to know in advance.
@Dref360 I can throw a specific exception for the case a data element should be just skipped.
@Dref360 I can throw a specific exception for the case a data element should be just skipped.
Then people's results won't be valid and they won't have a way to know! Imagine if you're trying to train on very small datasets and you skip one.... I think raising an Exception is the correct behavior.
Should there be a timeout option? It might be wise to also have `proportion_full_before_start` parameter so the queue isn't kept empty. This can help improve throughput.
It should be noted that this is an optional epoch break point if your `data/epoch_generator` does not stop.
Maybe the following will be more explicit: ```python first_author_books = result[0].books.all() self.assertEqual([self.book1], [first_author_books]) self.assertEqual([self.reader], [first_author_books[0].read_by.all()])) ```
Okay I think this makes sense, let's just follow this pattern then.
Use `num_` as the counter prefix for naming consistency.
Maybe the following will be more explicit: ```python first_author_books = result[0].books.all() self.assertEqual([self.book1], [first_author_books]) self.assertEqual([self.reader], [first_author_books[0].read_by.all()])) ```
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
Use `num_` as the counter prefix for naming consistency.
Maybe the following will be more explicit: ```python first_author_books = result[0].books.all() self.assertEqual([self.book1], [first_author_books]) self.assertEqual([self.reader], [first_author_books[0].read_by.all()])) ```
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
You're right. You know I both saw that and missed it too...
I'd rename `subminor` to `patch`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
The task name is incorrect (copy-paste error). Please, consider introducing a proper task name: ```yaml - name: gather the time at the end of the operation ```
I think `if opt_val:` is sufficient.
ah, true, i forgot the `format` option forces always to stringify
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Cool. Thanks. Let me know once done.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
This is inconsistent but I think the patch can land as is and the test be modified later on based on the direction of [#24082](https://code.djangoproject.com/ticket/24082).
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Thanks. I think that gives a pointer in the right direction. 👍
Same question here about unsafe_shell as in get_default_interfaces()
What's the reason for using the shell here? There's no redirection, pipes, or other needs for the shell that I can see.
Should raise a ValueError instead.
Omit the outer `[]` to use a generator instead of list comprehension.
We should take keys into account (like in `__eq__()`), so maybe: ```suggestion if hasattr(self, 'error_dict'): return hash(tuple(sorted(make_hashable(self.error_dict)))) return hash(tuple(sorted(self))) ```
"for working with retry limiting"
This seems random and can lead to flaky tests. So there is no way to measure latency while Trogdor task is running? For the rate limit test below we do wait for task to run.
nit: add a newline here too.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
`kwargs` parameter is neglected, all subclass context data is ignored
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
`kwargs` parameter is neglected, all subclass context data is ignored
Should use `assertRaisesMessage()` to verify the string also.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Isn't `raise` missing there ? Calls to `str` are useless.
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Should use `assertRaisesMessage()` to verify the string also.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
It's already stripped: ```suggestion (PODMAN_OUTPUT, ''), ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I think you need `to_native` here.
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Is `user_id` something secret, just wondering why it has `no_log`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Is `user_id` something secret, just wondering why it has `no_log`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
We have no intention of adding attrs as a dependency.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Is `user_id` something secret, just wondering why it has `no_log`
Please use a single quote.
Use another lookup instead of `epoch` e.g. `second`.
@timgraham It might be more appropriate in another commit then. I believe I wanted to make sure nothing was logged if a m2m backed inline was submitted without changes.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
You should handle the case that `time_str` is not actually a string.
Maybe this should be a class docstring :thinking:
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Again, imports at the top of the file
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Does it need to be a separate test case from the one above? I don't see the distinction.
```suggestion if 'num' in opt and opt['num'] not in special_num: ```
New tests pass without this change.
This seems like it would break galaxy which needed expand_paths
This can be single-lined.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Could be reduced to a list comprehension ```python return [ value for key, value in request.POST.items() if regexp.match(key) ] ```
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Could be reduced to a list comprehension ```python return [ value for key, value in request.POST.items() if regexp.match(key) ] ```
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
SubnetIds expects a list `[result['subnets'][0]]`
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`raise` is missing. Call to `str` is useless there.
I don't think returning `stdout` is necessary. _Maybe_ returning `stderr` could be helpful, but a better approach would be using `fail_json()` when an error is encountered and displaying `stderr` there rather than returning it by default. Also, it'd be nicer to use a literal here rather than a generator. ```python results = { 'changed': False, 'volumes': inspect_results, 'stdout': out, 'stderr': err } ```
If you use `env_fallback` then you don't require this check.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
to_text and prefix the string with u.
probably want a to_text and u prefix.
we could U() the link
The check-mode test should come as late as possible. There are various failure-cases that you are skipping in check-mode.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Required=false are implicit could you remove them ? Default=None too in case of string
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Required=false are implicit could you remove them ? Default=None too in case of string
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
BotoCoreError does not have a .response attribute so this may throw an AttributeError.
Wouldn't this end up returning `changed=200` to callers? Usually we keep this a boolean.
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This one is a bit newer to CliBase, but also implemented verbatim in superclass
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This one is a bit newer to CliBase, but also implemented verbatim in superclass
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
Ah I see, okay then.
As far as I'm aware we don't need to iterate twice over the same list: ```suggestion return { '%s.%s' % ( fixture_name, '.'.join([ext for ext in combo if ext]), ) for combo in product(databases, ser_fmts, cmp_fmts) } ```
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
Ah I see, okay then.
As far as I'm aware we don't need to iterate twice over the same list: ```suggestion return { '%s.%s' % ( fixture_name, '.'.join([ext for ext in combo if ext]), ) for combo in product(databases, ser_fmts, cmp_fmts) } ```
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
Most likely this will not work on Windows because files created with `NamedTemporaryFile` cannot be reopened on Windows (which defeats the whole purpose of naming them in the first place -- I have no idea why `NamedTemporaryFile` even exists on Windows). I'm not saying this is blocking the merge because I don't think we have that many users of PostgreSQL on Windows, but I thought I'd bring it up in case someone wants to check.
Better to use the file handler's write than `print`.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This syntax is not supported in python2.6. You will need to index your format like {0}
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Not added in module definition, (required_one_of)
```suggestion def validate_wwn(module): ```
The failing tests are due to the randomized order of the dict items on Python 3.5. Sorting them will fix that: ```suggestion @pytest.mark.parametrize('text, expected', sorted(TTY_IFY_DATA.items())) ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This syntax is not supported in python2.6. You will need to index your format like {0}
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This syntax is not supported in python2.6. You will need to index your format like {0}
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This should be the version that you will be removing the functionality
seems like a helper method to get the attachment path would save some repetition
In fact, maybe the tests could be refactored to use a loop and list of options for each iteration like filename and mimetype.
This should be the version that you will be removing the functionality
seems like a helper method to get the attachment path would save some repetition
In fact, maybe the tests could be refactored to use a loop and list of options for each iteration like filename and mimetype.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
For the sake of clarity with the bug report, can you check for `'b"' not in output` :)
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
This is not required since we are already doing this in individual APIs.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
Style note, I finally convinced people a year or so ago that ```{}``` is superior to ```dict()```. So new code should use the literal syntax.
I see, thanks for your answer. I really don't want to hold the template based widget stuff from landing any longer. I suppose this is something we could refactor later on.
I find it odd that this does't appear as `('django.template.loaders.filesystem.Loader', ['dirs'])` while the `POST_APP_DIRS` does.
There is no need to create a random suffix. We should also test all described scenarios, e.g. ```suggestion test_connection = copy.copy(connections[DEFAULT_DB_ALIAS]) test_connection.settings_dict = copy.deepcopy( connections[DEFAULT_DB_ALIAS].settings_dict, ) tests = [ ('test.sqlite3', 'test_1.sqlite3'), ('test', 'test_1'), ] for test_db_name, expected_clone_name in tests: with self.subTest(test_db_name=test_db_name): test_connection.settings_dict['NAME'] = test_db_name test_connection.settings_dict['TEST']['NAME'] = test_db_name creation_class = test_connection.creation_class(test_connection) clone_settings_dict = creation_class.get_test_db_clone_settings('1') self.assertEqual(clone_settings_dict['NAME'], expected_clone_name) ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
use `self.MAX_FILES` instead of 999999
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
Please use `module= AnsibleModule(` I guess it is a convention
I think there's no reason to prefer `smart_str` over `force_str` in these tests. Revised existing usage in https://github.com/django/django/pull/6290.
This break will be unnecessary if the loop gets dropped
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Please remove empty line.
.get() falls back to None to `False` isn't really needed I think.
Remove the PY3 conditional below and just do `cmd = b"\nexit\n"`. There's no variable substitution so just create the byte string itself.
Unlike `_sqlite_lpad()`, I'm not sure we can really improve this. `fill_text * length` is likely to be too long in most cases, and even worse if `fill_text` is multiple characters, but any alternative will probably be slower in general.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
same for these 2, though in diff from
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`raise` is missing. Call to `str` is useless there.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I'd go for underlining.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I'd go for underlining.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
pytest.mark.skip Though I'm surprised we did not see any bot error.
Needs testing, though I thinnk you want something like: ```suggestion pytest.skip("skipping as missing required netapp_lib") ```
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
Same question for dropping lambda here as well.
For python3 compatibility, you will need to wrap `map` with `list` as python3 doesn't return a list. It would probably just be best to use a list comprehension instead.
Please move the last closing `}` into a new line (at same indentation level as `argument_spec`)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```python if size_pct is not None ```
use `self.MAX_FILES` instead of 999999
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I guess we could try calling the primary key's `to_python` instead of hitting the database here. ```python def get_list_editable_queryset(self, request, prefix): object_pks = self.get_edited_object_pks(request, prefix) queryset = self.get_queryset(request) validate = queryset.model._meta.pk.to_python try: for pk in object_pks: validate(pk) except ValidationError: # Disable optimization return queryset return queryset.filter(pk__in=object_pks) ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
This class does not need to live inside this method.
This import should be at the top of the file, and is likely not python 2/3 compatible
The way we have done this before is via something like `_validate_debugger`. That method effectively does this, but for `debugger`
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
Is this even needed, we will be dropping py2 and `to_text` does not call `__unicode__`. You may as well just put this in `__str__`.
Too long line.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
That's a really interesting piece of information I did not know.
Maybe `map()`: ```suggestion fallback_keys=map(_cookie_signer_key, settings.SECRET_KEY_FALLBACKS), ```
If the user is able to make the server sign arbitrary data of their choosing, using the same salt and key will yield the same signature. However, if we slightly modify the key, they can't. This makes chosen plaintext attacks less vulnerable.
While I realize we cannot change that now, do we remember why we added `django.http.cookies` here? The salt alone should make sure that we do not clash with other signatures.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
same for these 2, though in diff from
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
same for these 2, though in diff from
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
An example of using the `mocker` fixture. ```suggestion def mock_NamedTemporaryFile(mocker, **args): mock_ntf = mocker.MagicMock() mock_ntf.write = mocker.MagicMock() mock_ntf.close = mocker.MagicMock() ```
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Why store these values in a dict, with the right key names, but the wrong case, and then later, build a new dict with the right case? Probably best to just do it lowercase here, and then just return it.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Maybe this should be a class docstring :thinking:
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
Maybe this should be a class docstring :thinking:
Not sure why the error starts with a whitespace here.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Not sure why the error starts with a whitespace here.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Not sure why the error starts with a whitespace here.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Maybe this should be a class docstring :thinking:
Not sure why the error starts with a whitespace here.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
It seems this URL doesn't work anymore.
```suggestion - Required for C(type=DS) when C(state=present). ```
```suggestion - "You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)." ```
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
`raise` is missing. Call to `str` is useless there.
Should the default be https, if so update docs
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`raise` is missing. Call to `str` is useless there.
Should the default be https, if so update docs
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`raise` is missing. Call to `str` is useless there.
Should the default be https, if so update docs
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
this is not a good test, and could cause bugs in the future
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Could be a personal or project preference for all I know, but does this re-assignment need to occur, instead of just having `return _format_string(f'{number:f}', ...)`? Doubt it matters much, of course.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Could be a personal or project preference for all I know, but does this re-assignment need to occur, instead of just having `return _format_string(f'{number:f}', ...)`? Doubt it matters much, of course.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
this is not a good test, and could cause bugs in the future
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Shouldn't use a mutable container as default arg in python. If you ever add to the container you then find that you're sharing a single opy of that container everytime the function in python. You can do one of these two instead: ``` python # If you don't need to add to the container now. This just prevents doing something stupid when the code is changed in the future. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=tuple()): # if matches needs to be a mutable container. This creates a fresh list everytime the function is called. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=None): if matches is None: matches = [] ```
Please raise a `NotIplementedError` when the use case is not supported yet.
Incredibly unlikely to be a problem, but this should be `>=`. Actually, this is a bit risky anyway because one timestamp is from the driver machine, the other is from the worker machine where the connector is running. (We ntp the workers during setup, so they are reasonably in sync. I can't remember the exact details, but I think we had issues with this previously due to clock skew; iirc it was in code that generated security certs on the host and then tried to use them on the workers.)
With the addition of `on_fit_batch_begin`, it might seem to users that `on_batch_begin` will run in all modes (fit/eval/predict). Same for `on_batch_end`. I'm not sure if there's a great way around that since we want to maintain backwards compatibility. Maybe we can just have `on_batch_begin` / `on_validation_batch_begin` (same for `end`)? Do we have use cases where users would want Callbacks in the public `evaluate` and `predict` methods? I'm picturing users mostly using the extra hooks for their validation data (especially with the TensorBoard callback)
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
this should just be `db_instances=results` - otherwise the instance data gets resnakified and tag case won't be preserved.
This doesn't support aurora snapshots. Besides that, this looks great.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This doesn't support aurora snapshots. Besides that, this looks great.
this should just be `db_instances=results` - otherwise the instance data gets resnakified and tag case won't be preserved.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
indentation doesn't look right here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
put closing ) on next lin
too many newlines (check code with flake8).
I think there's no reason to prefer `smart_str` over `force_str` in these tests. Revised existing usage in https://github.com/django/django/pull/6290.
Same question for dropping lambda here as well.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I'd suggest rewriting most of the preceding 25 lines with list comprehensions and/or some more reusable functions. This is all a bit too LISP-y and the readability suffers.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
@webknjaz we have no gaurantees that the artifacts are being built from a git checkout.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Exception handling here too.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
The other formats.py seem to use `'\xa0'`
unicode -> str (Python 3, first)
The various `CALLBACK_` prefixed class attributes are missing. Take a look at the other callbacks for an example. In particular, this is needed: ``` python CALLBACK_NEEDS_WHITELIST = True ```
unicode -> str (Python 3, first)
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Not sure why the error starts with a whitespace here.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
`normalize_interfaces` is aimed at sanitizing user input, and seems to be redundant while parsing running-config where the interface names are already normalized.
I think we should add also `lzma` format.
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
Best to be conservative and error rather than silently swallow mistyped arguments :) I think `ValueError` or `TypeError` are more appropriate, they're normally used for argument validation.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Note: I believe that both python2 and python3's json.loads() can handle resp_data as unicode strings. So you should be able to do this like this: ``` python from ansible.module_utils._text import to_text [...] resp_data = resp.read() resp_data = to_text(resp_data, errors='surrogate_or_strict') resp_json = json.loads(resp_data) ``` to_text is a nice helper because it allows much better control over tracebacks and won't touch the value if resp_data is already a text string (whereas resp_data.decode could traceback if resp_data is already a text string for some strange reason)
better to move this line in else part. something like ``` if hasattr(resp, 'data_xml') or hasattr(resp, 'data_ele'): result = resp.data_xml else: result = resp.xml ```
In most cases data_xml object is present the resp object, returning `xml` object is catch all type of scenario, hence in former code result variable is assigned twice most of the times.
add trailing ,
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
add trailing ,
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
Yeah, the import itself is very likely non-necessary, too.
I can't see a need for it...
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
Please put this on a single line. Lines can be 159 characters wide.
In most of cases names won't contain multibyte chars, so it should be worth avoiding multiple encoding and slicing, e.g.: ```python if len(table_name.encode()) == len(table_name): table_name = table_name[:other_length] else: # Shorten table name accounting for multibyte characters. while len(table_name.encode()) > other_length: table_name = table_name[:-1] ```
I added a small hook for this.
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
Please put this on a single line. Lines can be 159 characters wide.
add trailing ,
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
Please put this on a single line. Lines can be 159 characters wide.
Oops. I think you meant to put the space to the _**right**_ of the quote!
Alphabetized, here and in docs.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Isn't `raise` missing there ? Calls to `str` are useless.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like {0}
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
`raise` is missing. Call to `str` is useless there.
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
```python if size_pct is not None ```
```python elif max_num is not None and () ```
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
```python if size_pct is not None ```
```python elif max_num is not None and () ```
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
```python if size_pct is not None ```
```python elif max_num is not None and () ```
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
```python if size_pct is not None ```
```python elif max_num is not None and () ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This should go outside of try block
this should probably go to the debug level
This check always fails on my machine: `self.principals == None`, `principals == ['(none)']`
We can move `msg` before assertions ```python msg = "'City' instance expected, got %s" % chicago.pk with self.assertRaisesMessage(TypeError, msg): ... with self.assertRaisesMessage(TypeError, msg): ... ```
i would check that all list elements are strings at that point
This exception message is different from that in `related.py` though the logic/intention surrounding it seems to be the same. Is this intentional? (FWIW, I find the message in `related.py` to be clearer)
no wholesale exceptions plz
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
`self.assertEqual(f.choices), [])` looks simpler to me (plus if the list isn't empty, another debugging step isn't needed to see what the list contains).
We can move `msg` before assertions ```python msg = "'City' instance expected, got %s" % chicago.pk with self.assertRaisesMessage(TypeError, msg): ... with self.assertRaisesMessage(TypeError, msg): ... ```
This exception message is different from that in `related.py` though the logic/intention surrounding it seems to be the same. Is this intentional? (FWIW, I find the message in `related.py` to be clearer)
We can move `msg` before assertions ```python msg = "'City' instance expected, got %s" % chicago.pk with self.assertRaisesMessage(TypeError, msg): ... with self.assertRaisesMessage(TypeError, msg): ... ```
use `unfrackpath(filename)` to ensure we get something the user can always use
i would check that all list elements are strings at that point
Since we expect the name to start with 'http://' or 'https://' I would so this: ```python if name.startswith('http://') or name.startswith('https://'): ... ```
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
As this is a new module you don't have to worry about backwards compatibility. If you remove it remember to also remove from docs and examples.
no wholesale exceptions plz
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
no wholesale exceptions plz
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
no wholesale exceptions plz
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
I'd expect the set to be done after mangers & admins are added
im not sure syntax check makes any sense in this context, why do it via pull? the playbook should be checked by ansible-playbook, using pull as a proxy for a check seems contrived.
that's the default in 1.9, but I don't if you want to include it anyway
Can we prepend `ERROR: ` here? ```suggestion raise SystemExit('ERROR: Ansible requires blocking IO on stdin/stdout/stderr. Non-blocking file handles detected: %s' % ', '.join(_io for _io in handles)) ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
that's the default in 1.9, but I don't if you want to include it anyway
Can we prepend `ERROR: ` here? ```suggestion raise SystemExit('ERROR: Ansible requires blocking IO on stdin/stdout/stderr. Non-blocking file handles detected: %s' % ', '.join(_io for _io in handles)) ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
that's the default in 1.9, but I don't if you want to include it anyway
Can we prepend `ERROR: ` here? ```suggestion raise SystemExit('ERROR: Ansible requires blocking IO on stdin/stdout/stderr. Non-blocking file handles detected: %s' % ', '.join(_io for _io in handles)) ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Required=false are implicit could you remove them ? Default=None too in case of string
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
maybe create_and_call -> "test" to be a bit shorter
I would rather see ValueError instead of general exception
what happens if a parameter is deleted? I think this would be missed.
maybe create_and_call -> "test" to be a bit shorter
I would rather see ValueError instead of general exception
what happens if a parameter is deleted? I think this would be missed.
maybe create_and_call -> "test" to be a bit shorter
I would rather see ValueError instead of general exception
what happens if a parameter is deleted? I think this would be missed.
maybe create_and_call -> "test" to be a bit shorter
I would rather see ValueError instead of general exception
what happens if a parameter is deleted? I think this would be missed.
Since 'iso-8859-1' is being used in the line above also, I wonder if it is not better have a variable on top like `FALLBACK_ENCODING = 'iso-8859-1'`
Use ansible. module_utils.to_native or to_text here. To_Native converts to the str type (which is bytes on Python2 and text on python3). To_text converts to text type (Unicode on Python2. Str on python 3). Which you choose depends on what the rest of the module uses..
https://github.com/ansible/ansible/blob/devel/lib/ansible/parsing/splitter.py also, you probably want to add these in a collection, not core
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
this should use the new API without hardcoded id now
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
For the author information we normally only keep name and GitHub handle.
Missing period at end.
add github handle too.
For the author information we normally only keep name and GitHub handle.
Missing period at end.
add github handle too.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
You shouldn't need the extra parentheses inside `extend()`, FYI.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
ditto on `.` in character groups
Not sure how much a difference it makes, but it seems better to store this in Python rather than having to read from a text file. Worth it to make the file location customizable? If so, it might be nice to make "common passwords" a separate package so we don't have to include that list in Django. I guess users might not care for the additional setup tasks though.
missing from docs fragment
suggest to call this `state` and make set the `default=present`
I see now. I think a more readable structure would be to rename `SimplePoFileTests` to something like `PoFileAssertionMixin` and use that as well as `SimpleTestCase` in the subclasses.
This doesn't seem correct as `SimplePoFileTests` no longer has any tests in it so now this subclass doesn't do anything.
Perhaps it could be SPACEWALK_CONFIG, and be consistent with other variables such as ANSIBLE_CONFIG, [COLINS_CONFIG](https://github.com/ansible/ansible/blob/devel/contrib/inventory/collins.py#L38). Note that gce uses [GCE_INI_PATH](https://github.com/ansible/ansible/blob/devel/contrib/inventory/gce.py#L134), docker uses DOCKER_CONFIG_FILE, nsot uses NSOT_INVENTORY_CONFIG. Not sure what the core devs would prefer here, but perhaps it would make sense to be consistent with ANSIBLE_CONFIG.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
check that -> and that (no comma needed since the two clauses are independent)
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
That's a really interesting piece of information I did not know.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
That's a really interesting piece of information I did not know.
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
Exception handling here too.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Is it correct that this `args` is different from the previous test? I'd expect the same test for both Python 2 and 3 with something like `self.assertEqual(response.status_code, 200 if six.PY3 else 404)` but maybe I missed something.
Here you pass the variable `label`. You have never defined it, though (you defined `ch_label` -- maybe you meant that one?). That's the first of the sanity checks which fails. You might already get that output by running `flake8` on your module.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
else is unnecessary here because we raise an exception before
This exception message is different from that in `related.py` though the logic/intention surrounding it seems to be the same. Is this intentional? (FWIW, I find the message in `related.py` to be clearer)
We can't assume that the `objects` manager exists, you can just use `self.using()` since its already a manager.
I'd rather find out why we are getting the failure first. User can opt in for `self` to be a custom manager with the `__call__` syntax, doing `self.model._default_manager` bypasses it.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
no wholesale exceptions plz
```suggestion elif date_string.match(self.when): ```
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Not catching non-200 responses.
Not catching non-200 responses.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Like above, I think this should be `userid, name, password, group, email`
Missing from docs
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Indeed, we do not need to be so specific. The downside I see when being permissive is a bit more computation by going more often in `get_supported_language_variant` and possible `get_supported_language_variant` lru cache exhaustion. But I don't see a nice alternative.
Do we need to be so restrictive? There are many language tags in the [IANA](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry) registry that don't match this regex, e.g. `i-mingo`, `de-CH-1996`, `de-1996`, or `kl-tunumiit`.
TIL that character classes also work inside `[]` :D
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Might want to use simple quote here.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
The vmware modules only support Python 2.7 because of pyvmomi.
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
Ok, not sure why this one is still open.
The vmware modules only support Python 2.7 because of pyvmomi.
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
Ok, not sure why this one is still open.
The indentation is a bit odd here, it gives the impression that the second line is still in the isinstance()
Maybe it would be better to catch `TypeError` instead of adding complicated checks :thinking: ```python try: if code.co_argcount == 2: # one argument is 'self' return attr(obj) else: return attr() except TypeError as e: raise ImproperlyConfigured(...) from e ```
For clarity here, shouldn't we use `Func` rather than `Transform`, since they are equivalent and the latter is a back-compat-only name? It seems like using `Transform` might suggest to someone reading this code that there's something distinct about `Transform` as opposed to `Func`.
Please remove empty line.
.get() falls back to None to `False` isn't really needed I think.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
This argument is only accepted in Python 3, it would not work with Python 2.
a leftover here which can be removed
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
a leftover here which can be removed
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
a leftover here which can be removed
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
```suggestion trailing_punctuation_chars = '.,:;!' wrapping_punctuation = [('(', ')'), ('[', ']')] ```
I talked to Jmainguy on IRC and he thinks that using mkdtemp() should be fine from a permissions standpoint. There are some other thoughts though: * Using the module tempdir, the temp dir should be cleaned up automatically by the controller. If we use a separate tempfile, it becomes the calling code's responsibility to clean up the temp file (and the temp file can be left if the module raises an exception before it cleans up). * the module doesn't always have a file (in pipelining mode). When that happens, we can't use __file__ to determine where to place a tempfile. bcoca proposed adding a mkdtemp/mktemp function that could handle this but that is probably worthy of a separate PR. * bcoca also noted that overall, it's better not to have modules do this. Having two separate tasks works just as well (however, we need to start shipping roles at some point so that composing multiple tasks into a single logical unit is as easy as creating a module). Perhaps a note in the docstring that modules shouldn't tack on downloading files as a secondary function would be satisfactory for now.
The code that gets replaced by this method (in crc32 for ex), the url is downloaded to a dir local to the module source. Here, a new temp dir is created. Afaict, those could have different permissions. If the mkdtemp() result is more open than the __file__/* path, a downloaded file may be readable with different permissions. Haven't tested to see if that is a problem so would like some clarification.
This doesn't seem right. Surely `show_save_and_continue` should only be available if you can change an existing item. If you only have the _add_ permission and not _change_, once you have added an item, you can no longer change it.
Except the message displayed isn't quite right in this case: ``` The X "Great new X" was added successfully. You may edit it again below. ``` It's not true that it may be edited.
Remove this line as `opts` is already added by `ctx = Context(context)`.
You shouldn't need the extra parentheses inside `extend()`, FYI.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Remove this line as `is_popup` is already added by `ctx = Context(context)`. The local variable is just for convenience.
This doesn't seem right. Surely `show_save_and_continue` should only be available if you can change an existing item. If you only have the _add_ permission and not _change_, once you have added an item, you can no longer change it.
Except the message displayed isn't quite right in this case: ``` The X "Great new X" was added successfully. You may edit it again below. ``` It's not true that it may be edited.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
no need to specify required=False or type=str as these are defaults
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Exception handling here too.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Line 355 to 368 are unused.
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
in the tests k.backend() == `cntk` might want to lower case here
maybe tell the user the valid data_formats
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
Move the leading period to the initial definition of `msg`.
Best to be conservative and error rather than silently swallow mistyped arguments :) I think `ValueError` or `TypeError` are more appropriate, they're normally used for argument validation.
`band_input`, you don't get much by saving one char :-)
`has_key` is deprecated, use `if 'origin' in ds_input:` instead. Also please replace other occurrences in the patch.
I think `enumerate` would work here
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
in the tests k.backend() == `cntk` might want to lower case here
maybe tell the user the valid data_formats
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
in the tests k.backend() == `cntk` might want to lower case here
maybe tell the user the valid data_formats
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
chop the blank lines before each attribute
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Required=false are implicit could you remove them ? Default=None too in case of string
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
SubnetIds expects a list `[result['subnets'][0]]`
I think it would be better to use ``params`` with ``requests.get`` rather than building url query.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I think it may be cleaner to check this right away ```suggestion actual_versions = api.get_collection_versions('namespace', 'collection') assert actual_versions == [u'1.0.0', u'1.0.1', u'1.0.2', u'1.0.3', u'1.0.4', u'1.0.5'] ``` and this would simplify the check at the end of this test.
~~typo result~~ fixed
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
For the get('organization') request response? I'm assuming the list of 'organizations' and 'users' will always have a single item? (at least as used with a oauth token as used here). Will that depend on the type of api_token? (ie, if there is something like a organization or group level api_key, would the results be different? If so, could be useful to explain in the docs)
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I think it may be cleaner to check this right away ```suggestion actual_versions = api.get_collection_versions('namespace', 'collection') assert actual_versions == [u'1.0.0', u'1.0.1', u'1.0.2', u'1.0.3', u'1.0.4', u'1.0.5'] ``` and this would simplify the check at the end of this test.
~~typo result~~ fixed
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I think it may be cleaner to check this right away ```suggestion actual_versions = api.get_collection_versions('namespace', 'collection') assert actual_versions == [u'1.0.0', u'1.0.1', u'1.0.2', u'1.0.3', u'1.0.4', u'1.0.5'] ``` and this would simplify the check at the end of this test.
~~typo result~~ fixed
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
no need to specify required=False or type=str as these are defaults
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I think it may be cleaner to check this right away ```suggestion actual_versions = api.get_collection_versions('namespace', 'collection') assert actual_versions == [u'1.0.0', u'1.0.1', u'1.0.2', u'1.0.3', u'1.0.4', u'1.0.5'] ``` and this would simplify the check at the end of this test.
~~typo result~~ fixed
Same as for the updated, I'd rather say `has been deleted`
I would say `Deploy key has been updated` instead of `should have been updated`
Please use 'msg' for returned messages, this is a standardized return value.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Are there any disks apart from system disks? If so then this should be named `system_disk_category` and remove the aliases.
Please remove this line
Please remove this line
`default=None` is the default (can be removed from the others too, along with `required=False`, if desired)
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe output the bad value here as well, to help the user find out which one was wrong.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Style note, I finally convinced people a year or so ago that ```{}``` is superior to ```dict()```. So new code should use the literal syntax.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe output the bad value here as well, to help the user find out which one was wrong.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
In the `exit_json`, you should also return `changed` and `state`.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Isn't `raise` missing there ? Calls to `str` are useless.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
It is looking like `height_factor` and `width_factor` can only be positive integers. This should be specified in the docstring. The API makes it sound like `*_factor` could be a float (e.g. 0.75 for an output image with 75% of the original height).
I am also wondering whether it is necessary to specify the original height and width as part of the arguments (this information is part of the tensor X).
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
`border_mode` is not required. The output is of value : (batch size, num_input_channels, input row size * row ratio, input column size * column ratio) So fi the ratio is good, everything should be.
Same question for dropping lambda here as well.
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
It is looking like `height_factor` and `width_factor` can only be positive integers. This should be specified in the docstring. The API makes it sound like `*_factor` could be a float (e.g. 0.75 for an output image with 75% of the original height).
I am also wondering whether it is necessary to specify the original height and width as part of the arguments (this information is part of the tensor X).
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Make a common method in class to get url and return json loads response.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`asc` is misleading, because it's basically a default ordering. Renamed to the `default_order`.
Please ignore, my suggestion is invalid syntax.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
this line could go in "else" of try/except/else
prefer hanging indent to allow longer lines
pytest.mark.skip Though I'm surprised we did not see any bot error.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
pytest.mark.skip Though I'm surprised we did not see any bot error.
should this be: pytestmark = pytest.mark.skip('skipping as missing required netapp_lib')
Typo in `module_utils`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This should also use UTC now. The test should used a fixed year and find a way to mock `parse_http_date`'s way of obtaining a current year.
Let me know if you need assistance with that. You should be able to achieve it by using a `mock('django.utils.http.datetime.datetime.utcnow')` context manager with a `return_value=datetime(...)`.
I would move mocking `datetime` to a decorator, after that we will be able to test different dates, e.g. ```python @mock.patch('django.utils.http.datetime.datetime') def test_parsing_rfc850(self, mocked_datetime): mocked_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw) utcnow_first_fifty = datetime(2019, 11, 6, 8, 49, 37) utcnow_second_fifty = datetime(2051, 11, 6, 8, 49, 37) date = ( ('Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37), utcnow_first_fifty), ('Monday, 10-Nov-70 18:49:37 GMT', datetime(1970, 11, 10, 18, 49, 37), utcnow_first_fifty), ('Wednesday, 31-Dec-71 18:49:37 GMT', datetime(1971, 12, 31, 18, 49, 37), utcnow_first_fifty), ('Thursday, 31-Dec-99 08:49:37 GMT', datetime(2099, 12, 31, 8, 49, 37), utcnow_second_fifty), ('Thursday, 10-Nov-50 18:49:37 GMT', datetime(2050, 11, 10, 18, 49, 37), utcnow_second_fifty), ('Sunday, 31-Dec-00 18:49:37 GMT', datetime(2000, 12, 31, 18, 49, 37), utcnow_second_fifty), ) for rfc850str, expected_date, utcnow in date: mocked_datetime.utcnow = mock.Mock(return_value=utcnow) with self.subTest(string=rfc850str): parsed = parse_http_date(rfc850str) self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date) ```
`# Sphinx 1.6+` is enough
instead of "(1.7)", I'd suggest "(remove in 1.8)"
Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment) and rebase.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
PEP 8 requires this blank line
nit: we try to avoid wildcard imports.
Since you're touching this line anyways, could you rewrap the import like ``` python from .base import ( a, b, c, d, e, ) ```
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
You don't need start with this code as it will be virtually the same for all the things launched by apply_async in your loop. You can just use a single scalar local variable to hold the value. (It also is the end time or max time (and maxtime is really max_timeout), not start). Adding that together with the note that we should probably process statvfs information separate from the uuid info: ``` python results[mount] = {'info': mount_info, 'statvfs': pool.apply_async(get_mount_size, (mount_info['mount'],)), 'uuid': uuids.get(mount_info['device']) or pool.apply_async(self._udevadm_uuid, (mount_info['device'],)),} max_time = time.time() + max_timeout ```
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
You don't need start with this code as it will be virtually the same for all the things launched by apply_async in your loop. You can just use a single scalar local variable to hold the value. (It also is the end time or max time (and maxtime is really max_timeout), not start). Adding that together with the note that we should probably process statvfs information separate from the uuid info: ``` python results[mount] = {'info': mount_info, 'statvfs': pool.apply_async(get_mount_size, (mount_info['mount'],)), 'uuid': uuids.get(mount_info['device']) or pool.apply_async(self._udevadm_uuid, (mount_info['device'],)),} max_time = time.time() + max_timeout ```
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
This should just be `template_params = kwargs`. The `extra` in the signature that was removed is acting like a `kwargs` anyway.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
I wouldn't omit parenthesis here
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
`now` is unnecessary.
I wouldn't omit parenthesis here
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
`now` is unnecessary.
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This can be moved to `check_dict` method.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
please check code with flake8 (`E231 missing whitespace after ','`)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
@pierremahot we'll need a test for this
please check code with flake8 (`E231 missing whitespace after ','`)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
please check code with flake8 (`E231 missing whitespace after ','`)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Probably the check functions should be called directly rather than invoking them through `run_checks()` (otherwise, this runs all registered checks across all installed apps which doesn't provide good isolation) -- see `tests/check_framework`.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
This can be converted to return True. No need of new variable retry_request
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
fixture with load_json
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
fixture with load_json
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be converted to return True. No need of new variable retry_request
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be converted to return True. No need of new variable retry_request
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
well, maybe. I haven't checked what `.absolute()` does.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
that won't work with config values
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
fixture with load_json
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
fixture with load_json
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
```suggestion password=dict(type='str', required=True, no_log=True), ```
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
This can be converted to return True. No need of new variable retry_request
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
that won't work with config values
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
fixture with load_json
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
The locale should be set to C if we do string matching.
```suggestion # just get value from attribute itself as normal ```
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
The locale should be set to C if we do string matching.
```suggestion # just get value from attribute itself as normal ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This is unnecessary as error checking is handled in `get_hosts_by_host_name` as well. I think you can remove it completely with the whole `is_host_exist` method to save a few lines of code. Basically you want to do the same as with `get_hosts_by_ip`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
Why `dict(required=True)` is added here? It is already part of the spec.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
We prefer hanging indent style like this: ``` self.assertEqual( res.context_data["form"].errors["__all__"], ['You must confirm the delete.']) ) ``` Also please drop the u prefix on strings.
```suggestion self.assertEqual( res.context_data['form'].errors['__all__'], ['You must confirm the delete.'], ) self.assertEqual( res.context_data['form'].errors['confirm'], ['This field is required.'], ) ```
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
task_uuid seems unused
Please "rebase" to pickup the changes in 44c0ecdd9226d039a8c666b36ae320af2046a1c1.
single line looks more readable here
I'm not sure what this sentence means
We prefer hanging indent style like this: ``` self.assertEqual( res.context_data["form"].errors["__all__"], ['You must confirm the delete.']) ) ``` Also please drop the u prefix on strings.
```suggestion self.assertEqual( res.context_data['form'].errors['__all__'], ['You must confirm the delete.'], ) self.assertEqual( res.context_data['form'].errors['confirm'], ['This field is required.'], ) ```
task_uuid seems unused
Please "rebase" to pickup the changes in 44c0ecdd9226d039a8c666b36ae320af2046a1c1.
single line looks more readable here
We prefer hanging indent style like this: ``` self.assertEqual( res.context_data["form"].errors["__all__"], ['You must confirm the delete.']) ) ``` Also please drop the u prefix on strings.
I guess you should follow the indentation of the other tests.
```suggestion self.assertEqual( res.context_data['form'].errors['__all__'], ['You must confirm the delete.'], ) self.assertEqual( res.context_data['form'].errors['confirm'], ['This field is required.'], ) ```
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
Usually, testing private interfaces doesn't make sense.
nit: It doesn't actually set anything in the context, it's just a context processor that returns values that will be set in the context.
I'd omit this blank line.
Just use `get_current_site()`.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think we should be consistent and use double-quotes.
Just `params.get('jump')` is enough. `None` is already the default value.
ditto ```suggestion ```
```suggestion cmd_array = shlex.split(module.params['virtualenv_command']) ```
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
no need to specify required=False or type=str as these are defaults
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
no need to specify required=False or type=str as these are defaults
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think we should be consistent and use double-quotes.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
no need to specify required=False or type=str as these are defaults
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
I think we should be consistent and use double-quotes.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
In the `exit_json`, you should also return `changed` and `state`.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Why do you wait to fail ? I think you must fail in "main"
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
In the `exit_json`, you should also return `changed` and `state`.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Why do you wait to fail ? I think you must fail in "main"
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
We don't modify `creation` so there is no need to create a new one.
If you make this: ```python with self.assertRaises(VariableDoesNotExist) as exception_ctx: ``` then later on when you need the exception you can just do: ```python self.assertEqual( str(exception_ctx.exception), ... ) ``` which looks a bit cleaner than the `exc_info[1]` stuff.
aws_ip_ranges -> aws_service_ip_ranges
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Line 355 to 368 are unused.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Line 355 to 368 are unused.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Line 355 to 368 are unused.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Required=false are implicit could you remove them ? Default=None too in case of string
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
use `self.MAX_FILES` instead of 999999
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
use `self.MAX_FILES` instead of 999999
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
use `self.MAX_FILES` instead of 999999
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
ok, just something for consideration, I trust your/the community's judgement on it
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
I prefer to have a trailing comma everywhere, it makes further diff review easier. ```suggestion 'eos': re.compile(r'^Arista'), ```
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
You have some syntax errors in this `if` statement.
Please remove `module.fail_json` and use `ModuleFailException`.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
I think we should be consistent and use double-quotes.
Every day I get to learn something new. Thanks.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
No need for get(key, None) as None is the default fix also for following get()
Maybe this should be a class docstring :thinking:
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Maybe this should be a class docstring :thinking:
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
I think that this part can be dropped: ```diff diff --git a/tests/db_functions/test_datetime.py b/tests/db_functions/test_datetime.py index 51dbcb6..3560a76 100644 --- a/tests/db_functions/test_datetime.py +++ b/tests/db_functions/test_datetime.py @@ -211,12 +211,6 @@ class DateFunctionTests(TestCase): self.create_model(end_datetime, start_datetime) self.assertQuerysetEqual( - DTModel.objects.annotate(extracted=Extract('duration', 'epoch')).order_by('start_datetime'), - [(start_datetime, int((end_datetime - start_datetime).total_seconds())), - (end_datetime, int((start_datetime - end_datetime).total_seconds()))], - lambda m: (m.start_datetime, m.extracted) - ) - self.assertQuerysetEqual( ```
Use another lookup instead of `epoch` e.g. `second`.
Please use a single quote.
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
```suggestion # just get value from attribute itself as normal ```
Please wrap at 79 chars.
```suggestion value = super().__get__(obj, obj_type=obj_type) ```
```suggestion # just get value from attribute itself as normal ```
Please wrap at 79 chars.
```suggestion value = super().__get__(obj, obj_type=obj_type) ```
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
`border_mode` is not required. The output is of value : (batch size, num_input_channels, input row size * row ratio, input column size * column ratio) So fi the ratio is good, everything should be.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
+1 it's better to just patch `time.time`
In the `exit_json`, you should also return `changed` and `state`.
use the `missing_required_lib` function from `ansible.module_utils.basic`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Just use ` and ...` instead of nesting. Less indentation == better readable.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
For readability please include a blank line between tasks ```suggestion - name: Retrieve credential from CyberArk Vault using PAS Web Services SDK via Central Credential Provider ```
indentation doesn't look right here
For readability please include a blank line between tasks ```suggestion - name: Retrieve credential from CyberArk Vault using PAS Web Services SDK via Central Credential Provider ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Again, quote names and values: ```suggestion meraki.fail_json(msg="Parameters 'net_name' and 'net_id' are mutually exclusive") ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Line 355 to 368 are unused.
In the `exit_json`, you should also return `changed` and `state`.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Line 355 to 368 are unused.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
For integers please: use `type='int` remove the `isdigit` check from `check_params`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
This syntax is not supported in python2.6. You will need to index your format like {0}
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like {0}
chop the blank lines before each attribute
remove extra newline
I thinking removing APP_DIRS from TEMPLATES (since it defaults to False) is a better suggestion than setting it to False.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Maybe output the bad value here as well, to help the user find out which one was wrong.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
Remove the PY3 conditional below and just do `cmd = b"\nexit\n"`. There's no variable substitution so just create the byte string itself.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
You should not use `curl` as the alias for `Invoke-WebRequest`. Use the full cmdlet name to avoid confusing people whether it's actually using curl or a PowerShell cmdlet.
In addition to type, I think you should also check the value after clipping by placeholder variable.
This can just be `if t_opt:` since an empty list is false.
might be better to have some kind of mapping here ``` convert_list = ['image_id', 'instance_type', 'instance_id', ...] camel_params = dict((k,v) for k, v in snake_dict_to_camel_dict(module.params).items() if v is not None and k is in convert_list) ``` and then special case any exceptions like IamInstanceProfile and InstanceMonitoring
Use single quotes.
This needs to be a list of 2 dictionaries. ``` [{'ndmpd-authtypes': 'plaintext'}, {'ndmpd-authtypes': 'challenge'}] ```
last loaded wins, but iirc, we reverse search on handlers list
we use -o for output file elsewhere, it is not good to overload options with diff meanings
I admit Django still has much code looking like that, but it should be safe to simply use `if options['empty']:` below without first pushing the result in `self`. Having the value on `self` might make sense when we want to use the value in other methods. Same for `options.get('help', False)`, as we are using the parser in both `call_command` and `run_from_argv`, we can be sure that `'help'` is in the options dictionary, so `options['help']` is fine.
The flake8/test failure is because the above `help` is missing a closing parenthesis, hence a `SyntaxError`. You can always repush to the branch to rerun the tests.
Both `update_fields` and `unique_fields` should be passed through. You can keep them as positional arguments: ```suggestion return super().on_conflict_suffix_sql(opts, fields, on_conflict, update_fields, unique_fields) ```
I would do keep two lists `construct_inline_exclude = list(exclude)` and append to each of them, passing `construct_inline_exclude` to `construct_instance()`, rather than the list comprehension. A commend as two why we need the two different variables would be helpful.
You don't need the trailing \ here. EDIT: I see you just moved that code, that's fine.
I was unable to find examples of a `default` that is not listed in `choices` on the internet. This may need to be checked experimentally.
This is not a blocker, just a thought on the interface.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
We could lowercase the vendored files, that would help at least for the `zh-*` variants.
This will probably break for `zh-CN` and others because Django returns lower cased language names. I do not have a good idea on how to fix that though.
Looking at the code now, it's wrong. You don't have `self.error` anymore. And the KeyError will never hit, so you surely didn't test these failures. (integration tests !) There's also no difference between `>= 300` and `>= 400` so I guess `>= 300` only would do (but I don't know if that is intentional).
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
You don't need start with this code as it will be virtually the same for all the things launched by apply_async in your loop. You can just use a single scalar local variable to hold the value. (It also is the end time or max time (and maxtime is really max_timeout), not start). Adding that together with the note that we should probably process statvfs information separate from the uuid info: ``` python results[mount] = {'info': mount_info, 'statvfs': pool.apply_async(get_mount_size, (mount_info['mount'],)), 'uuid': uuids.get(mount_info['device']) or pool.apply_async(self._udevadm_uuid, (mount_info['device'],)),} max_time = time.time() + max_timeout ```
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
You will need to include the OAUTH_TOKEN environment variable also.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
As far as I'm aware we don't need to iterate twice over the same list: ```suggestion return { '%s.%s' % ( fixture_name, '.'.join([ext for ext in combo if ext]), ) for combo in product(databases, ser_fmts, cmp_fmts) } ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
And there: ``` work_file = os.path.join(self.dirpath, '%s.c' % self.file) ```
```suggestion RuntimeWarning, ```
And use `work_file` here.
Required=false are implicit could you remove them ? Default=None too in case of string
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please add spaces around the equal sign.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please use 'msg' for returned messages, this is a standardized return value.
Maybe this should be a class docstring :thinking:
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
This won't work as is because `In.process_rhs` optimizes empty result sets which breaks vacuous truth in this case. In other words `.filter(field__notin=[])` won't return *any* results when it should return *all* results.
I believe this change could have some unintended consequences. Query.setup_joins() has an allow_explicit_fk parameter, and this change will likely break that code. (I haven't tested this, but seems likely...)
Almost forgot this one... I think it would be nice to allow attnames to work for .update() - the attnames are usable almost everywhere, so having them available in even more places doesn't really hurt. It is worth checking if the allow_explicit_fk could be removed from ORM, and the proposed patch added to init_name_map(). I am not sure what (if anything) this would break. Quick look indicates that allow_explicit_fk is set to True somewhat randomly. Another option is to deal with this inside update, but as said that amounts to another hack.
ok, just something for consideration, I trust your/the community's judgement on it
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
This is unreachable code, as module.fail_json will be exit point the module.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
'readme' is required. Galaxy artifact import enforces that the field exists when validating the galaxy.yml. Later in the import process, it's verified that the file 'readme' points to exists in the archive (https://github.com/ansible/galaxy/blob/devel/galaxy/importer/collection.py#L102)
s/'file_manifest'/'file_manifest_file' https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L301 https://github.com/ansible/mazer/blob/devel/ansible_galaxy/models/collection_artifact_manifest.py#L21
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
This is not required since we are already doing this in individual APIs.
Line 355 to 368 are unused.
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
Either 'license' has to exist (and be a non-empty list) or non-None 'license_file' is required. https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L236-L247
s/'file_manifest'/'file_manifest_file' https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L301 https://github.com/ansible/mazer/blob/devel/ansible_galaxy/models/collection_artifact_manifest.py#L21
I'd expect the set to be done after mangers & admins are added
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
Can you just add the managers and admins including their names, please. I think that I'd expect the names to show up in the message if I define them in my settings.py
I'd expect the set to be done after mangers & admins are added
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
im not sure syntax check makes any sense in this context, why do it via pull? the playbook should be checked by ansible-playbook, using pull as a proxy for a check seems contrived.
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
if it were not for the `-C` i would not say 'tempted' but actually request it
tempted to say just use check_opts=True and remove syntax check afterward with remove_option (we do this in ansible-inventory).
I'd expect the set to be done after mangers & admins are added
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
Can you just add the managers and admins including their names, please. I think that I'd expect the names to show up in the message if I define them in my settings.py
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This might fail on python 3 and json.loads expects string and getvalue() will return bytes .
Note that format strings changed in python-2.7 So things like "{} {}".format() needs to change to "{0} {1}".format() for python-2.6 compatibility.
probably inside the `if` instead of before since it's kind of confusing to see this for a test that isn't going to actually read the DLQ
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
I think we should be consistent and use double-quotes.
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This might fail on python 3 and json.loads expects string and getvalue() will return bytes .
drop 'this will" / "it will"
I'd drop that last line since it doesn't really escape according to the rules suggested there.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Generally we don't treat usernames as secrets, so no need to mask
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Should the default be https, if so update docs
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Should the default be https, if so update docs
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
use the `missing_required_lib` function from `ansible.module_utils.basic`
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
use the `missing_required_lib` function from `ansible.module_utils.basic`
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Not necessary but exception handling (since this is ansible-2.4+) cna be written as: ``` except etree.XMLSyntaxError as e: module.fail_json(msg="Error while parsing path: %s" % to_native(e)) ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Not necessary but exception handling (since this is ansible-2.4+) cna be written as: ``` except etree.XMLSyntaxError as e: module.fail_json(msg="Error while parsing path: %s" % to_native(e)) ```
Maybe this should be a class docstring :thinking:
no need to specify required=False or type=str as these are defaults
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Please use 'msg' for returned messages, this is a standardized return value.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
I think you need `to_native` here.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
I think you need `to_native` here.
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
`cls.staff_user = User.objects.create_user(username='user', password='secret', email='user@example.com', is_staff=True)`
I think you can use `assertRaisesMessage` throughout these tests.
Use hanging indent as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Don't use automatic field numbering!
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Don't use automatic field numbering!
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
no need to specify required=False or type=str as these are defaults
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This could be simplified to use `m.groups()`...
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I wouldn't have changed the ones where the test doesn't care either way what type of redirect is done (of course we'll have to go back to silencing those)
I wouldn't have changed the ones where the test doesn't care either way what type of redirect is done (of course we'll have to go back to silencing those)
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
use ```from ansible.module_utils.vmware import get_parent_datacenter```
My bad. Could you please add this to vmware.py
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
use ```from ansible.module_utils.vmware import get_parent_datacenter```
My bad. Could you please add this to vmware.py
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Please add check-mode support (and if possible also diff support).
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
This doesn't allow the caller to cancel downtime by scope. _get_downtime returns an empty dictionary when id is not specified. It'd be great if this was changed to require id or scope instead of just id.
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
I'd move these two into describe_subnets, makes a bit more sense there I think.
```suggestion password=dict(type='str', required=True, no_log=True), ```
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
This doesn't allow the caller to cancel downtime by scope. _get_downtime returns an empty dictionary when id is not specified. It'd be great if this was changed to require id or scope instead of just id.
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
I looked at the log and realized those tests are run with `USE_TZ=False` so everything should be good here.
See my previous review for indentation style of this. Perhaps the common qs stuff before the last filter can be moved to setUpTestData.
Please add a trailing comma.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Should the default be https, if so update docs
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Should the default be https, if so update docs
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
I'd move these two into describe_subnets, makes a bit more sense there I think.
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
I don't understand why we have methods with a double underscores prefix which are copies from `SessionBase`, e.g. `__hash()`, `__legacy_encode()`, `__legacy_decode()` :thinking:
Please add a trailing comma.
```suggestion assertIs(self.set_up_called, True) ```
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Should the default be https, if so update docs
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
Keep `vswitch_name` for backward compatibility.
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
```suggestion password=dict(type='str', required=True, no_log=True), ```
Keep `vswitch_name` for backward compatibility.
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
```suggestion password=dict(type='str', required=True, no_log=True), ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Line is too long.
Line is too long.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Line is too long.
Line is too long.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Should the default be https, if so update docs
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
When hitting an error you must exit with module.fail_json
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
When hitting an error you must exit with module.fail_json
I think we should be consistent and use double-quotes.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`kwargs` parameter is neglected, all subclass context data is ignored
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe output the bad value here as well, to help the user find out which one was wrong.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This syntax is not supported in python2.6. You will need to index your format like {0}
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be converted to return True. No need of new variable retry_request
The code that gets replaced by this method (in crc32 for ex), the url is downloaded to a dir local to the module source. Here, a new temp dir is created. Afaict, those could have different permissions. If the mkdtemp() result is more open than the __file__/* path, a downloaded file may be readable with different permissions. Haven't tested to see if that is a problem so would like some clarification.
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
I'd move these two into describe_subnets, makes a bit more sense there I think.
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
You need to wrap the second instantiation in its own assertRaises to actually test it.
This is inconsistent but I think the patch can land as is and the test be modified later on based on the direction of [#24082](https://code.djangoproject.com/ticket/24082).
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
`kwargs` parameter is neglected, all subclass context data is ignored
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
missing quote after `modelname` which should also be `model_name`
`((app_label, model_name), [fields])` LGTM On April 1, 2015 3:46:12 PM GMT+02:00, Alex Hill notifications@github.com wrote: > > - from those operations and use them to provide a nicer error > > message. > > + > > - This will work for any function passed to > > lazy_related_operation that > > - has a keyword argument called 'field'. > > - """ > > + > > - def extract_field(operation): > > - # Expect a functools.partial with a kwarg called 'field' > > applied. > > - try: > > - return operation.func.keywords['field'] > > - except (AttributeError, KeyError): > > - return None > > + > > - extract_fields = lambda ops: list(filter(None, > > map(extract_field, ops))) > > + > > - # Generate pairs of (("app_label", "modelname), [fields]) > > Yes you do. The idea was to give an example of the literal contents of > the variable rather than its origins, hence the quotes surrounding each > element. I'm happy to go with `(app_label, model_name)`, without the > quotes. > > --- > > Reply to this email directly or view it on GitHub: > https://github.com/django/django/pull/4423/files#r27569838
It's nice to include a message for the exception (we had a ticket about adding messages to all of them)
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
You need to wrap the second instantiation in its own assertRaises to actually test it.
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
Maybe this should be a class docstring :thinking:
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Exception handling here too.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Exception handling here too.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Exception handling here too.
```suggestion """ Parse a Content-type like header. Return the main content-type and a dictionary of options. """ ```
This branch in untested :thinking:
You are right! Fixed it in https://github.com/mheap/ansible/pull/3.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
Ah yes. It no doubt will. (That's too much DRF that is. 🙂) We need to handle this. 👍
I guess we could try calling the primary key's `to_python` instead of hitting the database here. ```python def get_list_editable_queryset(self, request, prefix): object_pks = self.get_edited_object_pks(request, prefix) queryset = self.get_queryset(request) validate = queryset.model._meta.pk.to_python try: for pk in object_pks: validate(pk) except ValidationError: # Disable optimization return queryset return queryset.filter(pk__in=object_pks) ```
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
Ah yes. It no doubt will. (That's too much DRF that is. 🙂) We need to handle this. 👍
I guess we could try calling the primary key's `to_python` instead of hitting the database here. ```python def get_list_editable_queryset(self, request, prefix): object_pks = self.get_edited_object_pks(request, prefix) queryset = self.get_queryset(request) validate = queryset.model._meta.pk.to_python try: for pk in object_pks: validate(pk) except ValidationError: # Disable optimization return queryset return queryset.filter(pk__in=object_pks) ```
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
Is this condition necessary? Surely all backends will support a default `TEXT` format? (Even if it can't be explicitly provided in the query...)
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
Use single quotes consistently.
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
I think `name.rsplit('-', 1)[-1]` is easier to read.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I'm pretty sure you can make the abstract bases once in the test case class level: ``` class ...Tests(...): class SomeBase(models.Model): ... ``` Then reuse them appropriately in the individual test methods, which should only need to create the "bottom" classes? I grepped for `\btype\(` and found a few uses, but none are for "quick" building. I personally think the "tonnes of vertical scrolling" is a small concern compared to having to grok how `type()` works.
Appreciate what you've done with the tests but I think they're harder to comprehend now. As a Django dev I can jump in and read model classes, but the helpers are obscuring things a bit to me. Also you now have multiple tests per test method now - ideally there should just be a handful of classes per test and some assertions. I guess you can split based on overriding, non-overriding, etc.
I think we should be consistent and use double-quotes.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
Is this condition necessary? Surely all backends will support a default `TEXT` format? (Even if it can't be explicitly provided in the query...)
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I'm pretty sure you can make the abstract bases once in the test case class level: ``` class ...Tests(...): class SomeBase(models.Model): ... ``` Then reuse them appropriately in the individual test methods, which should only need to create the "bottom" classes? I grepped for `\btype\(` and found a few uses, but none are for "quick" building. I personally think the "tonnes of vertical scrolling" is a small concern compared to having to grok how `type()` works.
Appreciate what you've done with the tests but I think they're harder to comprehend now. As a Django dev I can jump in and read model classes, but the helpers are obscuring things a bit to me. Also you now have multiple tests per test method now - ideally there should just be a handful of classes per test and some assertions. I guess you can split based on overriding, non-overriding, etc.
I'd go for underlining.
This is not a good return on (complexity) investment IMO 🙂
no parens needed here and a couple lines below
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
why an empty string? might as well use assertRaises at that point.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
That's a really interesting piece of information I did not know.
Since we're now targetting python-2.6+ we can just ```import json```
Will the azure API always return a non-zero list or could this result in an `IndexError`? (If so, please wrap in `try`/`except`)
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
I think we should be consistent and use double-quotes.
Why this variable is called `unnamed_...` since it also stores named group? :thinking:
We don't need to add `named` branches everywhere. I'd return `m` in the tuple and use it when needed. Moreover, we could use a generator instead of list. IMO, `_find_group()` is unnecessarily complicated and unreadable. I'd move `get_group_start_and_end_indices()` to a module hook `_get_group_start_end()`: ```python def _get_group_start_end(start, end, pattern): unmatched_open_brackets, prev_char = 1, None for idx, val in enumerate(pattern[end:]): if val == '(' and prev_char != '\\': unmatched_open_brackets += 1 elif val == ')' and prev_char != '\\': unmatched_open_brackets -= 1 prev_char = val if unmatched_open_brackets == 0: return start, (end + idx + 1) ``` and simplify `_find_groups()` to a few lines generator: ```python def _find_groups(pattern, group_matcher): prev_end = None for m in group_matcher.finditer(pattern): if indices := _get_group_start_end(m.start(0), m.end(0), pattern): start, end = indices if prev_end and start > prev_end or not prev_end: yield start, end, m prev_end = end ``` now you can use `m` when needed, e.g.: ```python def replace_named_groups(pattern): group_pattern_and_name = [ (pattern[start:end], match[1]) for start, end, match in _find_groups(pattern, named_group_matcher) ] for group_pattern, group_name in group_pattern_and_name: pattern = pattern.replace(group_pattern, group_name) return pattern ... def replace_unnamed_groups(pattern): group_start_end_indices = _find_groups(pattern, unnamed_group_matcher) final_pattern, prev_end = '', None for start, end, _ in group_start_end_indices: if prev_end: final_pattern += pattern[prev_end:start] final_pattern += pattern[:start] + '<var>' prev_end = end return final_pattern + pattern[prev_end:] ... ```
I think we should be consistent and use double-quotes.
We don't need to add `named` branches everywhere. I'd return `m` in the tuple and use it when needed. Moreover, we could use a generator instead of list. IMO, `_find_group()` is unnecessarily complicated and unreadable. I'd move `get_group_start_and_end_indices()` to a module hook `_get_group_start_end()`: ```python def _get_group_start_end(start, end, pattern): unmatched_open_brackets, prev_char = 1, None for idx, val in enumerate(pattern[end:]): if val == '(' and prev_char != '\\': unmatched_open_brackets += 1 elif val == ')' and prev_char != '\\': unmatched_open_brackets -= 1 prev_char = val if unmatched_open_brackets == 0: return start, (end + idx + 1) ``` and simplify `_find_groups()` to a few lines generator: ```python def _find_groups(pattern, group_matcher): prev_end = None for m in group_matcher.finditer(pattern): if indices := _get_group_start_end(m.start(0), m.end(0), pattern): start, end = indices if prev_end and start > prev_end or not prev_end: yield start, end, m prev_end = end ``` now you can use `m` when needed, e.g.: ```python def replace_named_groups(pattern): group_pattern_and_name = [ (pattern[start:end], match[1]) for start, end, match in _find_groups(pattern, named_group_matcher) ] for group_pattern, group_name in group_pattern_and_name: pattern = pattern.replace(group_pattern, group_name) return pattern ... def replace_unnamed_groups(pattern): group_start_end_indices = _find_groups(pattern, unnamed_group_matcher) final_pattern, prev_end = '', None for start, end, _ in group_start_end_indices: if prev_end: final_pattern += pattern[prev_end:start] final_pattern += pattern[:start] + '<var>' prev_end = end return final_pattern + pattern[prev_end:] ... ```
Why this variable is called `unnamed_...` since it also stores named group? :thinking:
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
Required=false are implicit could you remove them ? Default=None too in case of string
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Required=false are implicit could you remove them ? Default=None too in case of string
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Required=false are implicit could you remove them ? Default=None too in case of string
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Could maybe use self.find_file_in_search_paths(variables, ['templates', 'vars', 'files'], fn) here.
Omit 0/1. There was a past commit that removed all usage of that since it just adds verbosity.
Wrap `then` and `else` with ` to make the sentence easier to parse.
ERROR rather than BLAH :)
Not tested, though this may lead to a similar issue as https://github.com/ansible/ansible/issues/20391 due to `timeout` having a default value
Drop this empty line
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Isn't `raise` missing there ? Calls to `str` are useless.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
You could do solve this recursively, but I don't know if this better readable really. meh
Why don't you make unique_items a `set` too? This would save you the whole `not in` clause. You just do `Set.add` which will add the item if it's not in the present anyways ;) That being said, since you are adding all items of the list to a set. Just create a set from the list. This will be a lot faster, since the `in` clause performs only at `O(n)`.
Use `django.utils.datastructures.OrderedSet` to make it clear what you are using this datastructure for.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
I think it's not pylint itself, but our own checks...
FYI when you accept the suggested changes using GitHub UI, it preserves the authorship of the patch.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This should probably mention both slash and no-slash paths...
We can reuse `self.user`: ```suggestion request.user = self.user ```
@codingjoe `setUpClassData` gives us a staff user: ```python cls.user = User.objects.create_user( username='user', password='secret', email='user@example.com', is_staff=True, ) ```
no need to specify required=False or type=str as these are defaults
Required=false are implicit could you remove them ? Default=None too in case of string
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Is the copy absolutely necessary? Wondering.
This could fit on a single line: `# Subqueries must use a different set of aliases than the outer query.`
Sample weight standardization should be moved to `input_validation`. Same in `Graph`.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Should the default be https, if so update docs
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
You don't need this conditional, since Ansible enforces that these are the only choices.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Why do you wait to fail ? I think you must fail in "main"
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```python elif max_num is not None and () ```
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
```python elif max_num is not None and () ```
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
```python elif max_num is not None and () ```
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Same note here as for bundler
Do we need to change `related_name` here? We could add `note` with `related_name='owner'` instead.
I think it's best to always provide **template_destpath**, and if it wasn't defined return `jinja.StrictUndefined` or possible `None`.
Same note here as for bundler
Do we need to change `related_name` here? We could add `note` with `related_name='owner'` instead.
I think it's best to always provide **template_destpath**, and if it wasn't defined return `jinja.StrictUndefined` or possible `None`.
Same note here as for bundler
Do we need to change `related_name` here? We could add `note` with `related_name='owner'` instead.
I think it's best to always provide **template_destpath**, and if it wasn't defined return `jinja.StrictUndefined` or possible `None`.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion elif date_string.match(self.when): ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Move this line to line 15 and you're good :smile:
assertEquals (deprecated alias) -> assertEqual I would also reverse the order of the arguments and use `self.assertEqual(Article.objects.all().count(), 0)`. That is what I have seen most often in tests.
This change looks unrelated.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
This docstring should be used for the `CallbackModule` class instead of the module.
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
Please use a single quote.
Please rebase your branch. Master now supports Python 3 only, so `unicode_literals` may be removed.
I think it would be better to put these tests in `tests/auth_tests` unless there's some reason that's not feasible.
I don't think you need `absolute_import` here - you don't need to to do a relative `.models` import a few lines down. You would need it to ensure that `import models` would fail to import the relative module.
remove extra newline
Please remove empty line.
I thinking removing APP_DIRS from TEMPLATES (since it defaults to False) is a better suggestion than setting it to False.
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Any problem with: ``` @property def media(self): ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This will probably break for `zh-CN` and others because Django returns lower cased language names. I do not have a good idea on how to fix that though.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Use single quotes consistently.
.get() falls back to None to `False` isn't really needed I think.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This will probably break for `zh-CN` and others because Django returns lower cased language names. I do not have a good idea on how to fix that though.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Use single quotes consistently.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Is `user_id` something secret, just wondering why it has `no_log`
The other formats.py seem to use `'\xa0'`
@PluckyPrecious Can you confirm that `DECIMAL_SEPARATOR` is a comma? I found that it's probably a dot `'.'` :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Cool. Thanks. Let me know once done.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like {0}
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Are you sure about the commas in the `DATETIME_INPUT_FORMATS` strings? I don't think any other locale has those.
OK then, thanks for the references.
@PluckyPrecious Can you confirm that `DECIMAL_SEPARATOR` is a comma? I found that it's probably a dot `'.'` :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
well, maybe. I haven't checked what `.absolute()` does.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
chop the blank lines before each attribute
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
I think something like this will be better (please test it to ensure you do get an error if the param/ENV isn't set) `api_token=dict(fallback=(env_fallback, ['CLOUDSCALE_API_TOKEN']), no_log=True, required=True),` Then you can delete ``` api_token = module.params['api_token'] or os.environ.get('CLOUDSCALE_API_TOKEN') if not api_token: module.fail_json... ```
I would probably make this a module level constant like `ALLOWED_STATES`. I also noticed that you don't transform the output for the diff. I don't think it matters much but for consistency this should ideally also be transformed. Maybe the best way to handle this would be to transform the values already in `def _get_server_info`. This way the module internal name would always be "state" and there would be no confusion between "state" and "status". That's also how this was handled before your change.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I think something like this will be better (please test it to ensure you do get an error if the param/ENV isn't set) `api_token=dict(fallback=(env_fallback, ['CLOUDSCALE_API_TOKEN']), no_log=True, required=True),` Then you can delete ``` api_token = module.params['api_token'] or os.environ.get('CLOUDSCALE_API_TOKEN') if not api_token: module.fail_json... ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
I'd go for underlining.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
is this limited to TLDs? it seems all labels are limited to 63 characters.
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
TIL that character classes also work inside `[]` :D
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
`band_input`, you don't get much by saving one char :-)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
``` # If the filename already exists, generate an alternative filename # until it doesn't exist. ```
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
``` # If the filename already exists, generate an alternative filename # until it doesn't exist. ```
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
ditto on `.` in character groups
Maybe this should be a class docstring :thinking:
This break will be unnecessary if the loop gets dropped
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This syntax is not supported in python2.6. You will need to index your format like {0}
Isn't `raise` missing there ? Calls to `str` are useless.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
`kwargs` parameter is neglected, all subclass context data is ignored
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
`kwargs` parameter is neglected, all subclass context data is ignored
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This test works without the patch, I will move it to a separate commit.
```suggestion msg = ... with self.assertRaisesMessage(ValueError, msg): ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
I would suggest using ``` python from six.moves import configparser ``` Currently inventory scripts aren't real consistent about how they handle compat issues like configparser, but thats closest to how the app code and modules do it (they use the six provided in module_utils, but that is not recommended for external inv scripts) ``` python from ansible.module_utils.six.moves import configparser ```
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
But now the imports aren't alphabetized anymore... :)
Do we expect users to use strings like `&&` and `&` directly anywhere else? It seems like we're exposing an implementation detail we'd usually hide.
add 'python library' , then the 'pip install' becomes redundant, some people cannot use pip to install libraries
Is the first element here meant to be a 1-tuple? You're missing the required comma.
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
You could also just return `credentials` rather than the three attributes
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
You could also just return `credentials` rather than the three attributes
Do we expect users to use strings like `&&` and `&` directly anywhere else? It seems like we're exposing an implementation detail we'd usually hide.
add 'python library' , then the 'pip install' becomes redundant, some people cannot use pip to install libraries
Is the first element here meant to be a 1-tuple? You're missing the required comma.
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
You could also just return `credentials` rather than the three attributes
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Why is it `ClearableFileInput` and not `FileInput`? Tests are also required.
This seemed to include svg as well but django does not accept svg file input.
+1 it's better to just patch `time.time`
Need a colon at the end here
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In the `exit_json`, you should also return `changed` and `state`.
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This is fine as is.
For a gzip file, I believe this will cause the browser to unzip it. ``` $ python3 >>> import mimetypes >>> mimetypes.guess_type('f.tar.gz') ('application/x-tar', 'gzip') ``` But I'm guessing the user wants the mime type to be `application/gzip` (or similar) with no encoding. [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding) > The Content-Encoding entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know, how to decode in order to obtain the media-type referenced by the Content-Type header. I know of at least one third party Django app that has this issue: https://github.com/johnsensible/django-sendfile/issues/38
This is fine as is.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ok, just something for consideration, I trust your/the community's judgement on it
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
+1 this isn't used anywhere
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I found sources that claim that it's Sunday :thinking: : - https://www.timeanddate.com/calendar/?year=2021&country=69 - https://en.wikipedia.org/wiki/Names_of_the_days_of_the_week#Days_numbered_from_Sunday
@sdil Can you take a look? Thanks!
My pleasure :)
Could you remove this outer try/except (it was only for debugging)? The build is failing because `print` needs to be `print(e)` for Python 3 compatibility but that can be removed anyway.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Various things that can be improved here: - Avoid unnecessary elifs. - Raise NotImplementedError in the default case for unknown operators. ```suggestion if operator == '+': # typecast_timestamp() returns a date or a datetime without timezone. # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]" return str(real_lhs + real_rhs) if operator == '-': return str(real_lhs - real_rhs) if operator == '*': return real_lhs * real_rhs if operator == '/': return real_lhs / real_rhs raise NotImplementedError(f"Unsupported operator: {operator}") ```
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
This needs to pass `return_docs=True` for return docs.
Leftover reference to `vcenter`.
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
This needs to pass `return_docs=True` for return docs.
Leftover reference to `vcenter`.
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
This needs to pass `return_docs=True` for return docs.
Leftover reference to `vcenter`.
```suggestion trailing_punctuation_chars = '.,:;!' wrapping_punctuation = [('(', ')'), ('[', ']')] ```
I'm not sure about changing the signature. Can we restore the previous one? ```suggestion def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False): return urlizer(text, trim_url_limit=None, nofollow=False, autoescape=False) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like {0}
is this limited to TLDs? it seems all labels are limited to 63 characters.
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
TIL that character classes also work inside `[]` :D
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
We should also change `\d+` to `[0-9]+` in all cases.
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
I think you can use `assertRaisesMessage` throughout these tests.
Could you update this to pull in: https://github.com/ansible/awx/commit/34e2d9b47ccc923623627e1d8cfafdb25afb70e4#diff-08d6dd3b52bc7b9781186afe8c1e29ea This adds the response data in cases where it's available. Without that, the root cause is not exposed in some circumstances.
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
It seems like no_log and deprecation are separate things and should be handled in separate functions.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
It seems like no_log and deprecation are separate things and should be handled in separate functions.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
here you can set 'changed' status in `else`
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
check is redundant as you already flagged as 'required'
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
I think the most we could probably do here is validate authentication... most of what could fail requires information about permissions that might not be available or shouldn't be encoded in the module itself due to shifting requirements on Tower itself.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
this looks wrong to me, so the file is changed if it already exists? also you don't compare the contents
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
use a single loop? ~~~python for server in _retrieve_servers(api_key): server = Vultr.normalize_result(server, SCHEMA) .... ~~~ ~~~
you just described check mode in general
I do not believe this change is correct. The main config file is different than the location of the policy files. The policy directory will exist in `/etc/selinux/[policy name]`. We would need a separate parameter, `policy_path`, in order to check that the policy exists.
On CentOS, `/etc/sysconf/selinux` is a symlink to `/etc/selinux/config`: ``` [root@lab-centos7 ~]# ll /etc/sysconfig/selinux lrwxrwxrwx. 1 root root 17 Aug 29 06:21 /etc/sysconfig/selinux -> ../selinux/config ``` > On centos there is no such thing as `/etc/selinux/%s/policy`. This is the path where the policy files for the selected policy, as configured by `SELINUXTYPE` in `/etc/selinux/config`: ``` [root@lab-centos7 ~]# ll /etc/selinux/targeted/ total 16 drwx------. 3 root root 263 Aug 29 06:30 active -rw-r--r--. 1 root root 2623 Aug 16 17:40 booleans.subs_dist drwxr-xr-x. 4 root root 4096 Aug 29 06:28 contexts drwxr-xr-x. 2 root root 6 Aug 16 17:40 logins drwxr-xr-x. 3 root root 20 Aug 29 06:21 modules drwxr-xr-x. 2 root root 23 Aug 29 06:30 policy -rw-------. 1 root root 0 Aug 16 17:10 semanage.read.LOCK -rw-------. 1 root root 0 Aug 16 17:10 semanage.trans.LOCK -rw-r--r--. 1 root root 607 Aug 16 17:40 setrans.conf -rw-r--r--. 1 root root 106 Aug 29 06:30 seusers ``` What the existing code is doing is preventing you from setting a policy in `/etc/selinux/config` that does not have a corresponding set of policy files, which would be an invalid configuration. If we change that behavior to just checking for the existence of the config file, it would allow someone to configure a policy that does not exist. I don't think that is a good idea.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
Isn't `raise` missing there ? Calls to `str` are useless.
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
Isn't `raise` missing there ? Calls to `str` are useless.
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
this changed from a list to a string. Perhaps this is related to the "h" message in the error.
docs say name is required, spec does not
use type=path for files
TIL that character classes also work inside `[]` :D
You're right. You know I both saw that and missed it too...
I'd rename `subminor` to `patch`.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
TIL that character classes also work inside `[]` :D
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
My bad, I've missed it !
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
@timgraham It might be more appropriate in another commit then. I believe I wanted to make sure nothing was logged if a m2m backed inline was submitted without changes.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
a leftover here which can be removed
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Will this command work on all supported platforms? I tried this patch on mac and it failed. Example I used: ``` - git: repo: 'https://github.com/ganeshrn/ansible.git' dest: /var/tmp/ansible archive: yes ``` ``` TASK [git] ************************************************************************************************************************************************ fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "msg": "Failed to perform archive operation"} ```
Adding traceback (`module.fail_json(msg="Failed to perform archive operation", exception=traceback.format_exc())`) to help here too would be nice, since git archive doesn't always work right out of the box.
This isn't showing changed=True for me when is succeeds. In fact, I don't know if it will ever complete without changing something, since right now we're failing if the git archive command isn't successful and if the directory creation isn't successful. Maybe a nice addition would be to compare the checksums of the contents of the archive destination to see if they are different than initially so changed could be False. But that would entail putting adding the zipfile to the directory, since I think we wouldn't want to rewrite the possibly existing file. Not sure what the best course of action is here. But exit with changed=True here, for now at least.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
`raise` is missing. Call to `str` is useless there.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
This branch in untested :thinking:
Use another lookup instead of `epoch` e.g. `second`.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
It's more about readability. When you see two if-branches it's different than just one and then following scenario. Plus it's less indentation, which is less important in this simple case, but in general helps to have such habit :)
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Use hanging indent as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Use hanging indent as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Does it need to be a separate test case from the one above? I don't see the distinction.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Does it need to be a separate test case from the one above? I don't see the distinction.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Should use `assertRaisesMessage()` to verify the string also.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
I'd go for underlining.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I'd go for underlining.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
immediatelly -> immediately
```suggestion self.assertEqual( res.context_data['form'].errors['__all__'], ['You must confirm the delete.'], ) self.assertEqual( res.context_data['form'].errors['confirm'], ['This field is required.'], ) ```
We avoid backslashes and use this style: ``` msg = ( "Redirection loop for authenticated user detected. Check that " "...." ) ```
Maybe this should be a class docstring :thinking:
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Use `missing_required_lib` from `ansible.module_utils.basic`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
this changed from a list to a string. Perhaps this is related to the "h" message in the error.
And use `work_file` here.
Not sure why the error starts with a whitespace here.
`default: null/None` is the default, it can be omitted
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
In the `exit_json`, you should also return `changed` and `state`.
there is no need to version params for new modules
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
this is not a 1.0 callback, its using 2.0 API
The description looks wrong...
there is no need to version params for new modules
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Not sure why the error starts with a whitespace here.
Not sure why the error starts with a whitespace here.
`default: null/None` is the default, it can be omitted
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Not sure why the error starts with a whitespace here.
there is no need to version params for new modules
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
this is not a 1.0 callback, its using 2.0 API
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Not sure why the error starts with a whitespace here.
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
In the `exit_json`, you should also return `changed` and `state`.
Not sure why the error starts with a whitespace here.
`default: null/None` is the default, it can be omitted
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
what will happen if modification of `.git` file fails while `.git/` dir is already moved? I think we could try to roll it back.
```suggestion 'Unable to connect to socket %s. See the socket path issue category in ' ```
```suggestion 'Unable to connect to socket %s. See the socket path issue category in ' ```
to_text and prefix the string with u.
this would fix https://code.djangoproject.com/ticket/23912 too
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
to_text and prefix the string with u.
probably want a to_text and u prefix.
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
This might not work well for Windows paths with drive letters.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
This might not work well for Windows paths with drive letters.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
the closing `)` on this line is misplaced.
It would be nice to see the same msg in exit_json.
```suggestion Test that the returned value for timezone consists of only uppercase ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
Please add `monitoring` and pass this argument to the request.
Please include the `DO_OAUTH_TOKEN` environment variable as one of the `env_fallback` values.
use the `missing_required_lib` function from `ansible.module_utils.basic`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
use the `missing_required_lib` function from `ansible.module_utils.basic`
I would say `Deploy key has been updated` instead of `should have been updated`
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
Please add `monitoring` and pass this argument to the request.
Please include the `DO_OAUTH_TOKEN` environment variable as one of the `env_fallback` values.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
TIL that character classes also work inside `[]` :D
else is unnecessary here because we raise an exception before
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Use hanging indentation as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
TIL that character classes also work inside `[]` :D
else is unnecessary here because we raise an exception before
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
I think we should be consistent and use double-quotes.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
```suggestion b_password_string = b"|".join((br'(\w+\'s )?' + to_bytes(p.format(**self._fields))) for p in prompts) ``` `.format` requires splatting the dict, instead of just the dict itself
Mark any string that you are going to call encode on as a ```u"string"```. Otherwise you can run into problems on Python2.
(Similarly, mark any string that you are going to call decode on with as a b"string".)
after_group does not exist at this point, this will stacktrace
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
after_group does not exist at this point, this will stacktrace
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
It should give 'Modification de Title et Historique.'. I guess a gettext call is missing inside the `LogEntry.get_change_message`.
Don't hardcode a primary key (or `Model.__str__()`). Wrap strings at 79 characters.
`and Historique` does not look right. It should give the untranslated `History` here (we are outside of the override).
Fields can use custom encoders so it's better to use `get_prep_value()`.
Is this condition necessary? Surely all backends will support a default `TEXT` format? (Even if it can't be explicitly provided in the query...)
Move the leading period to the initial definition of `msg`.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
Maybe this should be a class docstring :thinking:
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Maybe this should be a class docstring :thinking:
No need for the `u` prefix, we're already importing `unicode_literals`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
I can't see a need for it...
Yeah, the import itself is very likely non-necessary, too.
This could be moved inside the conditional that follows to avoid checking when there are no vendored modules.
ok, just something for consideration, I trust your/the community's judgement on it
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I think we should be consistent and use double-quotes.
I wouldn't write a function which was itself a single function call ;-)
Remark: with regexp factored out this could become just ```python from functools import partial ... _is_vcs_url = partial(re.match, _VCS_RE) """Test whether a name is package name or version specifier.""" ``` (But I bet Toshio would blame it for being unreadable, so don't do it :smile:)
This function checks whether input does not start with an operator, not that it's a package name at all. Let's invent a better name.
ok, just something for consideration, I trust your/the community's judgement on it
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
preferred format: "#12554 - Make sure ..."
I'd omit the blank line after the docstring as you've done in most places.
when you opt-in to using a CM like this, make sure you only patch lines that you really need to patch. and put any assertions outside, whenever possible: ```suggestion assert ret == [] ```
preferred format: "#12554 - Make sure ..."
I'd omit the blank line after the docstring as you've done in most places.
when you opt-in to using a CM like this, make sure you only patch lines that you really need to patch. and put any assertions outside, whenever possible: ```suggestion assert ret == [] ```
I wouldn't write a function which was itself a single function call ;-)
Remark: with regexp factored out this could become just ```python from functools import partial ... _is_vcs_url = partial(re.match, _VCS_RE) """Test whether a name is package name or version specifier.""" ``` (But I bet Toshio would blame it for being unreadable, so don't do it :smile:)
This function checks whether input does not start with an operator, not that it's a package name at all. Let's invent a better name.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I'll update this... try/except isn't needed -- that just makes debugging in the case of a failure more difficult since it hides the traceback.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Required=false are implicit could you remove them ? Default=None too in case of string
Rather than raising Exception that isn't caught anywhere, fail_json should be called.
This syntax is not supported in python2.6. You will need to index your format like {0}
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
we use -o for output file elsewhere, it is not good to overload options with diff meanings
This is not a blocker, just a thought on the interface.
I was unable to find examples of a `default` that is not listed in `choices` on the internet. This may need to be checked experimentally.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Rather than raising Exception that isn't caught anywhere, fail_json should be called.
This syntax is not supported in python2.6. You will need to index your format like {0}
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
this should use the new API without hardcoded id now
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
If the result was a 4xx or 5xx then I think this fails.
An example of using the `mocker` fixture. ```suggestion def mock_NamedTemporaryFile(mocker, **args): mock_ntf = mocker.MagicMock() mock_ntf.write = mocker.MagicMock() mock_ntf.close = mocker.MagicMock() ```
Oh, and `args[0]` is the module, so you want to look at `args[1]` for the url.
This doesn't match because your test uses `http://` instead of `https://`.
`str` isn't needed here.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Remove this since it doesn't do anything and `Mock` isn't defined.
An example of using the `mocker` fixture. ```suggestion def mock_NamedTemporaryFile(mocker, **args): mock_ntf = mocker.MagicMock() mock_ntf.write = mocker.MagicMock() mock_ntf.close = mocker.MagicMock() ```
Maybe this should be a class docstring :thinking:
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Line 355 to 368 are unused.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Should the default be https, if so update docs
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
You'll need to define `info` for both code paths.
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
I did think about that yesterday, but since that's called only once, that should be ok. But it could be a good idea to handle the case, in case the code start to do use extract_name more than once.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
I did think about that yesterday, but since that's called only once, that should be ok. But it could be a good idea to handle the case, in case the code start to do use extract_name more than once.
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Line 355 to 368 are unused.
please remove your email here.
Please replace your mail with your github handle (also in cloudscale_server module)
To match the headers in https://github.com/sieben/ansible/blob/b119f2652a160707ee718566ad1e49a510935553/lib/ansible/module_utils/scaleway.py#L40 `Content-Type` must be `Content-type`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Line 355 to 368 are unused.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
That's a really interesting piece of information I did not know.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I prefer to have a trailing comma everywhere, it makes further diff review easier. ```suggestion 'eos': re.compile(r'^Arista'), ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I prefer to have a trailing comma everywhere, it makes further diff review easier. ```suggestion 'eos': re.compile(r'^Arista'), ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
No, no, the module name should definitely be singular. I would probably use internally the same name as the REST API, especially because it is not exposed to the user and the internal stuff is in itself more consistent. But again, a personal choice, not something that is written into stone. (I think the plurar in the REST interface does make sense and is a common thing even, because it does e.q. affect networks, but that is debatable).
I think this would be more readable if you do: ```python org_id = self.get_org_id(org_name) net_id = self.get_net_id(org_name, net_name, data) path = '/organizations/{org_id}/networks/{net_id}'.format(org_id=org_id, net_id=net_id) ``` So using positional arguments where there's no discussion, moving different operations in separate steps, and bring the information together at the very end. The path-string could be coming from somewhere else (if this is something that is being reused, but probably not relevant here).
Generally, your coding style uses many more blank lines than the rest of Django.
Why do you wait to fail ? I think you must fail in "main"
Required=false are implicit could you remove them ? Default=None too in case of string
You need to wrap the second instantiation in its own assertRaises to actually test it.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Here you pass the variable `label`. You have never defined it, though (you defined `ch_label` -- maybe you meant that one?). That's the first of the sanity checks which fails. You might already get that output by running `flake8` on your module.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Maybe this should be a class docstring :thinking:
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Line 355 to 368 are unused.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Ahh. Got it. That makes sense. (Seems fine to me if we eventually remove it. Maybe raise a deprecation warning.)
It would allow our "AJAX" method to continue working unchanged: https://docs.djangoproject.com/en/dev/ref/csrf/#ajax
```suggestion vault_data(), ```
```suggestion assert ansible_json_encoder.default(m) == expected ```
I think it's nicer to have trailing commas: ```suggestion ], indirect=['mapping'], ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
use `self.MAX_FILES` instead of 999999
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
@pierremahot we'll need a test for this
TIL that character classes also work inside `[]` :D
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
chop the blank lines before each attribute
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
@pierremahot we'll need a test for this
Oh, I see. `run_commands()` runs list of commands and returns list of results.
```suggestion 'field_name': 'related_questions', ```
@codingjoe `setUpClassData` gives us a staff user: ```python cls.user = User.objects.create_user( username='user', password='secret', email='user@example.com', is_staff=True, ) ```
We can reuse `self.user`: ```suggestion request.user = self.user ```
```suggestion 'field_name': 'related_questions', ```
@codingjoe `setUpClassData` gives us a staff user: ```python cls.user = User.objects.create_user( username='user', password='secret', email='user@example.com', is_staff=True, ) ```
We can reuse `self.user`: ```suggestion request.user = self.user ```
shorten line (rule of thumb I'm using is ~120 characters so I don't have scroll horizontally in github review)
No, I mean that `clean_<fieldname>()` should take care of it. https://docs.djangoproject.com/en/stable/ref/forms/validation/
```suggestion library_id: '13b0f060-f4d3-4f84-b61f-0fe1b0c0a5a8' ``` This will hint user that, user is expected to enter something similar.
Maybe this should be a class docstring :thinking:
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
All of these empty tests look awkward. I'll try to find a better way to share some tests -- probably along the lines of ``` python class CSRFTestBase(object): # all the common parts go here class CSRFCookieTest(CSRFTestBase, TestCase): # Cookie-specific tests and utilities class CSRFSessionTest(CSRFTestBase, TestCase): # Session-specific tests and utilities ```
Oh sorry, I did mix it up with `dict.get` -- /me goes into the shame corner
`getattr` raises an exception when the attribute doesn't exist and no default is given
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
A form validation error seems sensible to me
```suggestion timeout=60, ``` "60" on its own looks a bit weird. Also, it surely doesn't need to be as long as 60 seconds if `DELAY_AFTER_FAILED_LOGIN` is so much smaller? What if `DELAY_AFTER_FAILED_LOGIN > 60`? Maybe this should be: ```suggestion timeout=self.DELAY_AFTER_FAILED_LOGIN + 10, ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
No need for get(key, None) as None is the default fix also for following get()
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Line 355 to 368 are unused.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
In the `exit_json`, you should also return `changed` and `state`.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Required=false are implicit could you remove them ? Default=None too in case of string
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Line 355 to 368 are unused.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
In the `exit_json`, you should also return `changed` and `state`.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
Line 355 to 368 are unused.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Line 355 to 368 are unused.
In the `exit_json`, you should also return `changed` and `state`.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
no need to specify required=False or type=str as these are defaults
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
no need to specify required=False or type=str as these are defaults
~~typo result~~ fixed
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
no need to specify required=False or type=str as these are defaults
~~typo result~~ fixed
In the `exit_json`, you should also return `changed` and `state`.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
TIL that character classes also work inside `[]` :D
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
that's the default in 1.9, but I don't if you want to include it anyway
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
compatibility in Django 1.9
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Please use 'msg' for returned messages, this is a standardized return value.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Please use 'msg' for returned messages, this is a standardized return value.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Please use 'msg' for returned messages, this is a standardized return value.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
When hitting an error you must exit with module.fail_json
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
On second thoughts creating a URL with to_field isn't required to test this issue – so the string interpolation can simply be removed: ```suggestion admin_user_change_url = reverse( "admin:%s_%s_change" % (user._meta.app_label, user._meta.model_name), args=(user.username,), ) ```
Keep what's done in `try` to the minimal expected to raise `self.model.DoesNotExist`. Move this after `except:` block.
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
On second thoughts creating a URL with to_field isn't required to test this issue – so the string interpolation can simply be removed: ```suggestion admin_user_change_url = reverse( "admin:%s_%s_change" % (user._meta.app_label, user._meta.model_name), args=(user.username,), ) ```
Keep what's done in `try` to the minimal expected to raise `self.model.DoesNotExist`. Move this after `except:` block.
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Exception handling here too.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Exception handling here too.
Exception handling here too.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
I would call `split()` once only. ``` entry = x.split() if len(entry) > 0: ldp = {} ldp['neighbor'] = entry[1] ldp['source'] = entry[3] ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Line 355 to 368 are unused.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Exception handling here too.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
In the `exit_json`, you should also return `changed` and `state`.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This can be converted to return True. No need of new variable retry_request
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Generally we don't treat usernames as secrets, so no need to mask
We don't need tags in this function, I think.
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
In the `exit_json`, you should also return `changed` and `state`.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Please write as: ``` if __name__ == "__main__": main() ```
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
else is unnecessary here because we raise an exception before
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
else is unnecessary here because we raise an exception before
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
else is unnecessary here because we raise an exception before
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Maybe this should be a class docstring :thinking:
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
Another option is one Andrew suggested to me in django/asgiref#288 (which I need to get back to) which is small and elegant enough that it might be useful to Django-proper, possibly here in `import_string` and more generally where imports happen inside functions/methods (to avoid circular refs) in hot loops, and it looks like: ``` def cached_import(module_name, item_name): modules = sys.modules if module_name not in modules: importlib.import_module(module_name) return getattr(sys.modules[module_name], item_name) ``` A benefit of it would be not having another _separate_ cache (LRU) with a finite hit-rate, and it still avoids going through the import machinery for hits.
We may consider such a change as a data loss. Even if `USE_TZ` is False, I think that a datetime input *with* timezone information should keep the timezone (and hence be aware). I think the docs might need to be updated to say that parsing a datetime with timezone gives an aware datetime even if USE_TZ is False.
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
Another option is one Andrew suggested to me in django/asgiref#288 (which I need to get back to) which is small and elegant enough that it might be useful to Django-proper, possibly here in `import_string` and more generally where imports happen inside functions/methods (to avoid circular refs) in hot loops, and it looks like: ``` def cached_import(module_name, item_name): modules = sys.modules if module_name not in modules: importlib.import_module(module_name) return getattr(sys.modules[module_name], item_name) ``` A benefit of it would be not having another _separate_ cache (LRU) with a finite hit-rate, and it still avoids going through the import machinery for hits.
We may consider such a change as a data loss. Even if `USE_TZ` is False, I think that a datetime input *with* timezone information should keep the timezone (and hence be aware). I think the docs might need to be updated to say that parsing a datetime with timezone gives an aware datetime even if USE_TZ is False.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Maybe this should be a class docstring :thinking:
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
Another option is one Andrew suggested to me in django/asgiref#288 (which I need to get back to) which is small and elegant enough that it might be useful to Django-proper, possibly here in `import_string` and more generally where imports happen inside functions/methods (to avoid circular refs) in hot loops, and it looks like: ``` def cached_import(module_name, item_name): modules = sys.modules if module_name not in modules: importlib.import_module(module_name) return getattr(sys.modules[module_name], item_name) ``` A benefit of it would be not having another _separate_ cache (LRU) with a finite hit-rate, and it still avoids going through the import machinery for hits.
We may consider such a change as a data loss. Even if `USE_TZ` is False, I think that a datetime input *with* timezone information should keep the timezone (and hence be aware). I think the docs might need to be updated to say that parsing a datetime with timezone gives an aware datetime even if USE_TZ is False.
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
This can be single-lined. ```suggestion '<option value="" selected="">---------</option>', ```
The current names are misleading, e.g. `RenderableForm` is not really a render-able form it's a mixin which makes the form render-able. I would rename these classes: - `Renderable` to `RenderableMixin`, - `RenderableForm` to `RenderableFormMixin`, - `RenderableError` to `RenderableErrorMixin`.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
The current names are misleading, e.g. `RenderableForm` is not really a render-able form it's a mixin which makes the form render-able. I would rename these classes: - `Renderable` to `RenderableMixin`, - `RenderableForm` to `RenderableFormMixin`, - `RenderableError` to `RenderableErrorMixin`.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Use single quotes consistently.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Maybe output the bad value here as well, to help the user find out which one was wrong.
This change is backwards incompatible for someone having subclassed the widget and customized `none_value`. We might let `none_value` as is, and simply update `none_value` in `__init__` (I'm open to arguments...).
Add an alias to make this match the parameter for the `community.general.ini` module, which calls this `allow_no_value`.
Ack, thanks for the explanation.
Maybe this should be a class docstring :thinking:
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
This change is backwards incompatible for someone having subclassed the widget and customized `none_value`. We might let `none_value` as is, and simply update `none_value` in `__init__` (I'm open to arguments...).
Add an alias to make this match the parameter for the `community.general.ini` module, which calls this `allow_no_value`.
Ack, thanks for the explanation.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
User should be able to delete key. Keys with `None` value could be deleted.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
Isn't `raise` missing there ? Calls to `str` are useless.
Add absent as well.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
Isn't `raise` missing there ? Calls to `str` are useless.
Add absent as well.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
no need to specify required=False or type=str as these are defaults
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
You can drop `int` here now (you already are doing it in `decode`), same for other hashers/methods probably.
Same as above, I'd revert to the simpler version. The main idea behind `decode` for me is a consistent interface where it makes sense, we don't have to bend backwards just to use it.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
You can drop `int` here now (you already are doing it in `decode`), same for other hashers/methods probably.
Same as above, I'd revert to the simpler version. The main idea behind `decode` for me is a consistent interface where it makes sense, we don't have to bend backwards just to use it.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
You can drop `int` here now (you already are doing it in `decode`), same for other hashers/methods probably.
Same as above, I'd revert to the simpler version. The main idea behind `decode` for me is a consistent interface where it makes sense, we don't have to bend backwards just to use it.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
You can drop `int` here now (you already are doing it in `decode`), same for other hashers/methods probably.
Same as above, I'd revert to the simpler version. The main idea behind `decode` for me is a consistent interface where it makes sense, we don't have to bend backwards just to use it.
There doesn't appear to be any way for `sha1sum_old` to be `None`.
I don't see a reason we can't use Python's `hash()` builtin, which is even faster and cached on strings I also don't think we need a class here - a single function to do the shuffling would do.
Why don't you make unique_items a `set` too? This would save you the whole `not in` clause. You just do `Set.add` which will add the item if it's not in the present anyways ;) That being said, since you are adding all items of the list to a set. Just create a set from the list. This will be a lot faster, since the `in` clause performs only at `O(n)`.
It looks like Python3 doesn't raise an error. It surrogateescapes: ``` [toshio@el7-test ~][PROD]$ TESTING='cafÃ©' LC_ALL=C python3.6 test.py 'caf\udcc3\udca9' [toshio@el7-test ~][PROD]$ cat test.py import os a = os.environ.get('TESTING') print(repr(a)) ```
This is not correct.... and it also leads me to see that the code which prints self.WARNINGS is not correct :-( This is going to be a short rabbit hole but probably not appropriate for 2.9.0. I notice that @sivel's code does not emit a warning. I think there was a reason and simply passes over this entry. I think there was a reason (that's what happens on Python3, perhaps?) So if sivel can confirm that, then maybe that's what we should do here.
Python3 looks like it will raise an exception on `__getitem__`. So that wasn't it. I couldn't find context, or jog my memory.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Causes unhelpful error if get() returns None ``` $ cat nmap_inv.yml plugin: nmap $ ansible-inventory -i nmap_inv.yml --graph ERROR! Invalid settings supplied for address: argument of type 'NoneType' is not iterable ```
Read operation: ditto
Can we remplace this line by the following three lines: ``` p = subprocess.Popen(['acme-tiny', '--account-key', self.accountkey, '--csr', self.csr_path, '--acme-dir', self.challenge_path], stdout=subprocess.PIPE) crt = p.communicate()[0] open(self.dest, 'w').write(str(crt)) ```
Causes unhelpful error if get() returns None ``` $ cat nmap_inv.yml plugin: nmap $ ansible-inventory -i nmap_inv.yml --graph ERROR! Invalid settings supplied for address: argument of type 'NoneType' is not iterable ```
Read operation: ditto
Can we remplace this line by the following three lines: ``` p = subprocess.Popen(['acme-tiny', '--account-key', self.accountkey, '--csr', self.csr_path, '--acme-dir', self.challenge_path], stdout=subprocess.PIPE) crt = p.communicate()[0] open(self.dest, 'w').write(str(crt)) ```
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
It looks like Python3 doesn't raise an error. It surrogateescapes: ``` [toshio@el7-test ~][PROD]$ TESTING='cafÃ©' LC_ALL=C python3.6 test.py 'caf\udcc3\udca9' [toshio@el7-test ~][PROD]$ cat test.py import os a = os.environ.get('TESTING') print(repr(a)) ```
The reason this is not correct, is that it should set text strings, rather than native strings. When I looked at the code that outputs this, I found that one pathway needs text strings and the other pathway needs native strings. That all needs to be fixed so that we input text strings into self.WARNINGS and then the output code converts it to byte strings when appropriate (either inside of display as done now, or just before outputting to sys.stderr on python2 or outputting to sys.stderr.buffer on python3).
Python3 looks like it will raise an exception on `__getitem__`. So that wasn't it. I couldn't find context, or jog my memory.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Please remove `no_log=True` from username
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
Yes, f-strings should use only plain variable and property access as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
Keep what's done in `try` to the minimal expected to raise `self.model.DoesNotExist`. Move this after `except:` block.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
Yes, f-strings should use only plain variable and property access as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
Keep what's done in `try` to the minimal expected to raise `self.model.DoesNotExist`. Move this after `except:` block.
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
Fair enough, I'm good with that.
I think this can just be `name`
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
Fair enough, I'm good with that.
I think this can just be `name`
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
Fair enough, I'm good with that.
I think this can just be `name`
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
You shouldn't need the extra parentheses inside `extend()`, FYI.
Keep what's done in `try` to the minimal expected to raise `self.model.DoesNotExist`. Move this after `except:` block.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Are both host groups really needed? Does the one that contains ':' handle both? We have regex in other places in the project that do similar parsing we may want to keep in sync: - https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/utils/Utils.java#L53 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/BrokerEndPoint.scala#L27 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/EndPoint.scala#L29
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
Maybe this should be a class docstring :thinking:
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Is `user_id` something secret, just wondering why it has `no_log`
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Thanks for reviewing this @rubentsirunyan
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Is `user_id` something secret, just wondering why it has `no_log`
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Thanks for reviewing this @rubentsirunyan
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Thanks for reviewing this @rubentsirunyan
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
Looks like a few tests are missing. If I remove this if/else and just leave `return _not_modified(request, response)`, no tests fail.
Removing this 'if' and leaving the return doesn't result in any failures.
Use `six.assertRegex` to avoid the deprecated alias on Python 3.
Not necessary but this map and the one on 690 are better written as: ``` python elif LooseVersion('.'.join(to_native(ver_field) for ver_field in etree.LXML_VERSION)) < LooseVersion('2.3.0'):
😃 Yeah, I can see that. But I was scanning the code and looking for the definition. I wanted to find all the helpers in one place. (As ever, there are different ways of wanting to read it. That's OK.) If you feel strongly you can leave it for now. Tim will have a look before merging it anyway so he can input.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
okey. not a big deal.
I know this is existing, but I think we can lift this up to a singleton so that we do not create a new instance on every publish to every node.
yeah again, its definitely bad the way it is now, easy to break. if we initialize netty classes too early before security kicks in, we might not notice anything, then suddenly users jvms are crashing (e.g. because of some bug in unsafe/native usage, or whatever). with a netty module things would get way better: one advantage is, netty isnt on the classpath anymore, instead we load it explicitly with `URLClassLoader.newInstance` in PluginService, followed by `Class.forName` and so on with the registered plugin class from the plugins configuration file. So it would be well-defined exactly when these classes will get loaded, and its all after security and everything else is fully initialized.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
Maybe this should be a class docstring :thinking:
This should be in the `except` above.
please multiline these strings so they aren't longer than 120 chars. ``` row_html = ( '...' '...' ) ```
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
This should be in the `except` above.
Again, imports at the top of the file
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
This should be in the `except` above.
Again, imports at the top of the file
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
Again, imports at the top of the file
This class does not need to live inside this method.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
Again, imports at the top of the file
This class does not need to live inside this method.
Why do you wait to fail ? I think you must fail in "main"
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Required=false are implicit could you remove them ? Default=None too in case of string
remove extra newline
check that -> and that (no comma needed since the two clauses are independent)
chop the blank lines before each attribute
Why do you wait to fail ? I think you must fail in "main"
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
I think we should be consistent and use double-quotes.
@pierremahot we'll need a test for this
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Maybe this should be a class docstring :thinking:
Ok, not sure why this one is still open.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
TIL that character classes also work inside `[]` :D
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Every day I get to learn something new. Thanks.
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I would say `Deploy key has been updated` instead of `should have been updated`
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
The security group rule and the trunk are not present in any of the resources' contents here: https://github.com/openstack/openstacksdk/tree/master/openstack/cloud, consequently using the `cloud.get_<resource>` call fails. Instead the `could.network` call can be used.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
I would say `Deploy key has been updated` instead of `should have been updated`
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Required=false are implicit could you remove them ? Default=None too in case of string
no need to specify required=False or type=str as these are defaults
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
no need to specify required=False or type=str as these are defaults
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I'd move these two into describe_subnets, makes a bit more sense there I think.
botocore.exceptions.PartialCredentialsError can also occur on connection creation.
boto3_conn now handles region problems, no need to do it in the module
Use single quotes.
Minor: if the test fails, the value of `basic.has_journal` won't be restored. This probably doesn't matter.
`@unittest.skipUnless(basic.has_journal, ...)` might be clearer.
What is the reason of change? it would break the backwards compatibility.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
not a blocker but default=None is not needed because it is already the default and can be omited.
The code is the same, just the data differs, so I think it would be clearer to move the loop outside the if. ``` python output_data = self.py3_output_data if sys.version_info[0] >= 3 else self.py2_output_data for msg, param in output_data.items(): ... ```
Yeah, a name can either be a global or a local in a scope, and Python determines that during compilation time by looking for certain statement types (such as assignments or imports). You could do this at the top level: ``` python try: # Python 3 from importlib import reload except ImportError: # Python 2 pass ``` or use `six.moves.reload_module`. (Hm, [importlib.reload](https://docs.python.org/3/library/importlib.html#importlib.reload) appeared in Python 3.4, before that it was [imp.reload](https://docs.python.org/3/library/imp.html#imp.reload). I suppose it's fine to require Python 3.4+ for Ansible -- people who don't have it can fall back to 2.7.)
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Is there a typo? I'm not sure what "hub" means in this sentence.
no restructured text (:class:) in docstrings please
Any problem with: ``` @property def media(self): ```
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This will probably break for `zh-CN` and others because Django returns lower cased language names. I do not have a good idea on how to fix that though.
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We could lowercase the vendored files, that would help at least for the `zh-*` variants.
TIL that character classes also work inside `[]` :D
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
For the get('organization') request response? I'm assuming the list of 'organizations' and 'users' will always have a single item? (at least as used with a oauth token as used here). Will that depend on the type of api_token? (ie, if there is something like a organization or group level api_key, would the results be different? If so, could be useful to explain in the docs)
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
I would use `%s` formatting consistently.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
Required=false are implicit could you remove them ? Default=None too in case of string
For easier typing and consistency with elsewhere, I'd omit the dash in the domains and names.
I would use `%s` formatting consistently.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
For easier typing and consistency with elsewhere, I'd omit the dash in the domains and names.
I would use `%s` formatting consistently.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
I'd use .objects.create
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
That's not the correct solution, with e.g.: ```python DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'OPTIONS': { 'service': 'django_ticket', } }, } ``` the connection parameters will be set to: ```python {'database': 'postgres', 'service': 'django_ticket'} ``` The default `postgres` db shouldn't be used in this case.
Most likely this will not work on Windows because files created with `NamedTemporaryFile` cannot be reopened on Windows (which defeats the whole purpose of naming them in the first place -- I have no idea why `NamedTemporaryFile` even exists on Windows). I'm not saying this is blocking the merge because I don't think we have that many users of PostgreSQL on Windows, but I thought I'd bring it up in case someone wants to check.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
While you're making changes for readability, I would find it best to declare one key-value pair on each line, like you did in the other diff.
This is fine as is.
This is fine as is.
Can you simplify using `super()`, e.g. something like-- ```python kwargs = super().get_test_runner_kwargs() if hasattr(self, 'stream'): kwargs['stream'] = ... return kwargs ```
could create a module variable so we don't have a second "magic string" in `runtests.py`: `SELENIUM_WEBDRIVER_PATH = 'selenium.webdriver.%s.webdriver.WebDriver'`
Can you please rename this one to `ModelManagerSerializer` and let it inherit from `DeconstructableSerializer`.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This would be a nice place to use tuple expansion `action, index = index_of_matching_route(....)`
Yeah, you'd need `return None, None` at the end of index_of_matching_route()
~~typo result~~ fixed
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
> ... so I made it a required parameter. Sorry, I think we're not understanding each other. 🤔 * The `on_bind` parameter is defined as `on_bind=None`, so it's optional. * Exactly when `on_bind=None` that `server_bind` is only declared conditionally with lead to a `... is referenced before assignment` problem. If looks like this: ``` >>> on_bind = None >>> if on_bind is not None: ... a = "I won't be defined" ... >>> a Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name 'a' is not defined ```
I don't understand why we have methods with a double underscores prefix which are copies from `SessionBase`, e.g. `__hash()`, `__legacy_encode()`, `__legacy_decode()` :thinking:
Since the existence of instance lookups will be rare I suggest we avoid an unncessary dict creation when `instance_lookups` is missing ```suggestion if not (instance_lookups := self.__dict__.get("instance_lookups"): return class_lookups return {**class_lookups, **instance_lookups} ```
> ... so I made it a required parameter. Sorry, I think we're not understanding each other. 🤔 * The `on_bind` parameter is defined as `on_bind=None`, so it's optional. * Exactly when `on_bind=None` that `server_bind` is only declared conditionally with lead to a `... is referenced before assignment` problem. If looks like this: ``` >>> on_bind = None >>> if on_bind is not None: ... a = "I won't be defined" ... >>> a Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name 'a' is not defined ```
I don't understand why we have methods with a double underscores prefix which are copies from `SessionBase`, e.g. `__hash()`, `__legacy_encode()`, `__legacy_decode()` :thinking:
Since the existence of instance lookups will be rare I suggest we avoid an unncessary dict creation when `instance_lookups` is missing ```suggestion if not (instance_lookups := self.__dict__.get("instance_lookups"): return class_lookups return {**class_lookups, **instance_lookups} ```
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Perhaps we should continue to test the simpler case where we don't provide a `name` or `condition`.
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
This is not unicode frienly, see `INVALID_VARIABLE_NAMES` in `lib/ansible/constants.py` , we had to update to allow for unicode chars .. also you should be able to reuse
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Maybe this should be a class docstring :thinking:
This is indented 4 spaces too much.
How about the following? ``` mean, var, beta, gamma = [np.random.random(other_shape).astype(np.float32) for _ in range(4)] ```
I guess you'll have to test the `split_domain_port()` function since it'll be impossible to write a regression test using `HttpRequest.get_host()` since the fix is moving logic around in that method.
We could fall back to `__file__` or something in that case at minimum. Could be useful to include that regardless.
You should have spaces around the `-` operator.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
You should have spaces around the `-` operator.
```suggestion check_failed(args, 'results indicate tests did not pass (result: %s)\n' ```
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Unrelated, but I wonder if we need '-k', '-r', '-d' for the new options rather than only their verbose counterparts. Seems like we are going to run into a conflict a some point with two options with the same first letter if we keep doing that.
I feel like this boiler-plate could be handled more nicely. For example, what about defining a function above that looks something like-- ```python def add_argument(parser, name, *args, help=None, **kwargs): if name in self.suppressed_base_arguments: help = argparse.SUPPRESS parser.add_argument(*args, help=help, **kwargs) ``` Then each `parser.add_argument(...)` would become `add_argument(parser, name, ...)`. I also think it would be better if the convention were for the string in `suppressed_base_arguments` to match the first option string passed to `parser.add_argument()` (e.g. `--force-color` instead of `force-color`). I think it would be easier to remember. Also, if that were done, the name wouldn't have to be passed a second time, or manipulated in any way inside the helper function above before checking for membership in `self.suppressed_base_arguments`.
You can use `type='choice'` with `choices=['ipython', 'bpython']` for options with a predefined set of choices: http://docs.python.org/library/optparse.html#optparse-standard-option-types
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Typo in the help message
Typo in the help message
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
You can drop this assertion, the way `from_date` is constructed and that this branch is behind the `if day` one makes it impossible to reach.
Use `django.utils.timezone.make_aware` instead.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
might be a good idea to have a 3rd option like `default` or `human` which is the current behaviour. You can also have a `choices=[]` kwarg where you define the valid choices. This helps both on validation and people using argcomplete to tab complete the options.
Do we need to specify `human` as an option? That could just the default and `yaml` or `json` are specified.
Typo in the help message
Typo in the help message
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
nothing outside the fail_json/exit_json should write to stdout/stderr
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
`test_choice_value_hash` is sufficient. IMO we can remove this test.
IMO checking how `empty_form` is rendered is not necessary. It's enough to check `empty_permitted`, e.g. ```suggestion self.assertIs(formset.empty_form.empty_permitted, True) ```
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This assumes that we always make changes, even if the directory already exists (or is already missing), or if the file already exists and is not overwritten.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This assumes that we always make changes, even if the directory already exists (or is already missing), or if the file already exists and is not overwritten.
In the `exit_json`, you should also return `changed` and `state`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
I think we should be consistent and use double-quotes.
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
TIL that character classes also work inside `[]` :D
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Would be better to put this as a module constant to avoid compiling it over and over.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
I think we should be consistent and use double-quotes.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
no need to specify required=False or type=str as these are defaults
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Not necessary but this map and the one on 690 are better written as: ``` python elif LooseVersion('.'.join(to_native(ver_field) for ver_field in etree.LXML_VERSION)) < LooseVersion('2.3.0'):
Not necessary but exception handling (since this is ansible-2.4+) cna be written as: ``` except etree.XMLSyntaxError as e: module.fail_json(msg="Error while parsing path: %s" % to_native(e)) ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Sorry it's now 2.10
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Can we use instead `assertEqual()` and `assertIsNot()`? ```suggestion self.assertEqual(clone, source) self.assertIsNot(clone, source) ```
flake8 complains about missing spaces around `*`
I'd reverse this to `if data is None`, to match the structure below (and prevent unnecessary negation).
Can we use instead `assertEqual()` and `assertIsNot()`? ```suggestion self.assertEqual(clone, source) self.assertIsNot(clone, source) ```
flake8 complains about missing spaces around `*`
I'd reverse this to `if data is None`, to match the structure below (and prevent unnecessary negation).
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove this. If there isn't a specified return, None is returned.
Yes. Either to_native or to_text would be fine in this case.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Remove the PY3 conditional below and just do `cmd = b"\nexit\n"`. There's no variable substitution so just create the byte string itself.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Yeah, you'd need `return None, None` at the end of index_of_matching_route()
This would be a nice place to use tuple expansion `action, index = index_of_matching_route(....)`
Should the default be https, if so update docs
Yeah, you'd need `return None, None` at the end of index_of_matching_route()
This would be a nice place to use tuple expansion `action, index = index_of_matching_route(....)`
Should the default be https, if so update docs
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
You need to wrap the second instantiation in its own assertRaises to actually test it.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
You need to wrap the second instantiation in its own assertRaises to actually test it.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
`raise` is missing. Call to `str` is useless there.
```python elif max_num is not None and () ```
use `self.MAX_FILES` instead of 999999
```python if size_pct is not None ```
The optional trailing dot may "protect" an ending dash -- `xn--.` passes this. Is this intended? If not, switch the last two lines.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
a leftover here which can be removed
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
User could set `user_data` parameter to `None`, in such case exception still occurs.
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Use `missing_required_lib` from `ansible.module_utils.basic`
```suggestion password=dict(type='str', required=True, no_log=True), ```
Ok, not sure why this one is still open.
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
In the `exit_json`, you should also return `changed` and `state`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
```suggestion raise AnsibleError('Failed to download Git submodules') from proc_err ```
This should probably mention both slash and no-slash paths...
I don't want to hold up the PR but you could use a loop instead of a nested KeyError like ```suggestion member_names = [to_native(dirname, errors='surrogate_or_strict')] if not member_names[-1].endswith(os.path.sep): member_names.append(member_names[-1] + os.path.sep) for name in member_names: try: tar_member = tar.getmember(name) except KeyError: continue break else: raise AnsibleError("Unable to extract '%s' from collection" % member_names[0]) ``` Potentially allows us to try more options in the future if need be.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
In the `exit_json`, you should also return `changed` and `state`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Generally we don't treat usernames as secrets, so no need to mask
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Is `user_id` something secret, just wondering why it has `no_log`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
In the `exit_json`, you should also return `changed` and `state`.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Use `missing_required_lib` from `ansible.module_utils.basic`
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
I'd `conditional_escape()` each argument.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Indentation level of `return` statement need to be increased.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
I'd go for underlining.
this seems like it should be shared with the main one rather than duplicated here
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Please use `module= AnsibleModule(` I guess it is a convention
This fails for me: ``` AssertionError: <MagicMock name='WatchmanReloader()' id='140033332456584'> is not an instance of <class 'django.utils.autoreload.StatReloader'> ``` perhaps that's the failure that Jenkins encountered.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Please use `module= AnsibleModule(` I guess it is a convention
This fails for me: ``` AssertionError: <MagicMock name='WatchmanReloader()' id='140033332456584'> is not an instance of <class 'django.utils.autoreload.StatReloader'> ``` perhaps that's the failure that Jenkins encountered.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Please use `module= AnsibleModule(` I guess it is a convention
This fails for me: ``` AssertionError: <MagicMock name='WatchmanReloader()' id='140033332456584'> is not an instance of <class 'django.utils.autoreload.StatReloader'> ``` perhaps that's the failure that Jenkins encountered.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
`start`/`stop` is flexible since it means `_count/list_valid_files_in_directory` will be agnostic to the validation/training story, and only needs the `split` argument. But it doesn't make a big difference.
You can make the whole PR a lot simpler by using: `for fname in sorted(files)[start : stop]` Remember: this feature should only total a few lines of change. The only "logic" required by this PR is the computation of `start` and `stop` above given the `validation_split` passed by the user (if any).
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Style note, I finally convinced people a year or so ago that ```{}``` is superior to ```dict()```. So new code should use the literal syntax.
```suggestion return b'\r\n'.join(to_bytes(line, nonstring='passthru') for line in result) ``` (and import `to_bytes`)
Should the default be https, if so update docs
You have some syntax errors in this `if` statement.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Please use `module= AnsibleModule(` I guess it is a convention
This fails for me: ``` AssertionError: <MagicMock name='WatchmanReloader()' id='140033332456584'> is not an instance of <class 'django.utils.autoreload.StatReloader'> ``` perhaps that's the failure that Jenkins encountered.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This is unreachable code, as module.fail_json will be exit point the module.
Try except blocks should be as small as possible. In this case, if is only needed around the calls to modify and delete. Perhaps put the try except around the if state conditional to limit the statements that it surrounds
I think it make sense to support running state for ephmeral VM, as well as stopped and absent. which would be same. The code will be more straighforward then without not needed ifs
Maybe this should be a class docstring :thinking:
The failing tests are due to the randomized order of the dict items on Python 3.5. Sorting them will fix that: ```suggestion @pytest.mark.parametrize('text, expected', sorted(TTY_IFY_DATA.items())) ```
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
Maybe this should be a class docstring :thinking:
The failing tests are due to the randomized order of the dict items on Python 3.5. Sorting them will fix that: ```suggestion @pytest.mark.parametrize('text, expected', sorted(TTY_IFY_DATA.items())) ```
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
The failing tests are due to the randomized order of the dict items on Python 3.5. Sorting them will fix that: ```suggestion @pytest.mark.parametrize('text, expected', sorted(TTY_IFY_DATA.items())) ```
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
Maybe this should be a class docstring :thinking:
The failing tests are due to the randomized order of the dict items on Python 3.5. Sorting them will fix that: ```suggestion @pytest.mark.parametrize('text, expected', sorted(TTY_IFY_DATA.items())) ```
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Missing from docs
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Missing from docs
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Again, imports at the top of the file
Not really - if people wanted to use tagging they'd need 1.4.4+ but otherwise any version of boto3 would pretty much work. (This is the same as your existing change) It's probably worth adding a warning if people try and use tagging with a version of boto3 that does not support tagging too (using `hasattr(client, 'create_tags')` or similar)
Rather than just use boto3 for tagging, might just be worth moving to boto3 as a whole, particularly as that avoids the need for the boto3 sts connection (as boto3's create_table returns a TableArn field)
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Use another lookup instead of `epoch` e.g. `second`.
```suggestion Question.objects.create(question='Not a question.') ```
Please use a single quote.
I'm not sure if `isinstance(pages_per_range, int)` is required. I think Python/Django doesn't do strict type checking like that in general.
I think that should be `hire_date` (two words).
Making this change here doesn't work because we aren't guaranteed to have passlib installed. The crypt.crypt() method will require that we have a salt set. You could move salt generation into the conditional for ```not HAS_PASSLIB```.
```suggestion elif date_string.match(self.when): ```
Required=false are implicit could you remove them ? Default=None too in case of string
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Maybe this should be a class docstring :thinking:
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Maybe this should be a class docstring :thinking:
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Maybe this should be a class docstring :thinking:
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Maybe this should be a class docstring :thinking:
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This change looks unrelated.
I wouldn't transform the whole class to TransactionTestCase, but rather create a new class containing transaction-dependent tests. On some setups at least, TransactionTestCase is heavily slowering tests.
This should be a warning. Also, please use single quotes. And "backend" in one word.
Why do you wait to fail ? I think you must fail in "main"
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This needs to be updated with `api_url`
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Isn't `raise` missing there ? Calls to `str` are useless.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
drop u prefixes on strings (we use `from __future__ import unicode_literals` instead)
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
drop u prefixes on strings (we use `from __future__ import unicode_literals` instead)
You could skip these, but I thought that the rewording read better. I guess if you go for the proposed `Renderable` then they'd be moved anyway and then it doesn't hurt to update them. (Also note that the docstring for `BaseFormSet.as_ul()` neglected to mention that it isn't wrapped in `<ul>`.) 🤷🏻‍♂️
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
drop u prefixes on strings (we use `from __future__ import unicode_literals` instead)
You could skip these, but I thought that the rewording read better. I guess if you go for the proposed `Renderable` then they'd be moved anyway and then it doesn't hurt to update them. (Also note that the docstring for `BaseFormSet.as_ul()` neglected to mention that it isn't wrapped in `<ul>`.) 🤷🏻‍♂️
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
In the `exit_json`, you should also return `changed` and `state`.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Please use `module= AnsibleModule(` I guess it is a convention
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion elif date_string.match(self.when): ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
We should also change `\d+` to `[0-9]+` in all cases.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This should use `module.deprecate`, there's a good example in https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/aws_kms.py#L954:L956
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
Omit these lines please.
TIL that character classes also work inside `[]` :D
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
```suggestion """Render as <p> elements.""" ```
I know this is the sort of layout that `black` would generate, but it's one of the more ugly choices it doesn't get right in my opinion. Perhaps we should `+=` instead of `.extend()`: ```suggestion top_errors += [ _('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': str(e)} for e in bf_errors ] ```
I know this is the sort of layout that `black` would generate, but it's one of the more ugly choices it doesn't get right in my opinion. Perhaps we should `+=` instead of `.extend()`: ```suggestion top_errors += [ _('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': str(e)} for e in bf_errors ] ```
```suggestion # RemovedInDjango50Warning: when the deprecation ends, remove # mark_safe() call. ```
We seem to be calling `str()` twice here. Maybe: ```suggestion errors_str = str(bf_errors) if not isinstance(errors_str, SafeString): warnings.warn( 'Returning a plain string from ErrorList is deprecated. ' 'Please customize via the template system instead.', RemovedInDjango50Warning, ) errors_str = mark_safe(errors_str) # RemovedInDjango50Warning: remove check and replace errors_str # with str(bf_errors) fields.append((bf, errors_str)) ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Need a colon at the end here
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
boto3_conn never throws a ClientError at this point. You need to handle missing Profile (botocore.exceptions.ProfileNotFound) and presumably if `region` is not set too.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
That's a really interesting piece of information I did not know.
This is wrong, already explained.
Again, quote names and values: ```suggestion meraki.fail_json(msg="Parameters 'net_name' and 'net_id' are mutually exclusive") ```
That's a really interesting piece of information I did not know.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
`raise` is missing. Call to `str` is useless there.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Cool. Thanks. Let me know once done.
Also we should still call this in case of check mode, and say whether it will be changed
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
So we don't wait for empheral VM? I think we should
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Yes, that sounds good to me.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
```suggestion binary_path = module.get_bin_path('virsh', required=True) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
In the `exit_json`, you should also return `changed` and `state`.
I absolutely did misunderstand then. For the primary use case, I think we do want an Ansible call to create/update profile X with alerts A and B to make sure that only alerts A & B are associated with profile X. There is an edge case where we may want to surgically append/remove alerts from profile X, but I don't think it is critical to support this use case at this time.
It's a `@staticmethod`/pure function
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
Exception handling here too.
And I would rename this attribute `superusers` as it's meant to contain multiple users.
```suggestion cls.set_up_called = True ```
```suggestion # LiveServerTestCase's change to ALLOWED_HOSTS should be reverted. ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Exception handling here too.
"new" may sound as "to be added", suggest "desired" instead.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This one is a bit newer to CliBase, but also implemented verbatim in superclass
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
Valid point. Feel free to change the decorator in a separate commit.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
Valid point. Feel free to change the decorator in a separate commit.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
Valid point. Feel free to change the decorator in a separate commit.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
The module claims to support check mode but never actually checks if the module is being executed in check mode.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
use the `missing_required_lib` function from `ansible.module_utils.basic`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
The module claims to support check mode but never actually checks if the module is being executed in check mode.
Please use assertRaisesMessage to check the message too. We prefer the context manager version usually `with self.assertRaisesMessage(ValueError, msg)`. I think combining the two tests so you can reuse the `msg` variable would be fine.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
Valid point. Feel free to change the decorator in a separate commit.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Could also be ```suggestion skydive: >- ```
No need to parametrize with just one case.
I think it's nicer to have trailing commas: ```suggestion ], indirect=['mapping'], ```
Are these style changes intentional? Somehow they don't look like that.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
a leftover here which can be removed
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
a leftover here which can be removed
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
I think we should be consistent and use double-quotes.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Maybe this should be a class docstring :thinking:
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
It seems the `if shuffle` block is repeated twice, you can move it out of the conditional block
Is there a typo? I'm not sure what "hub" means in this sentence.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Matt may not OK with these choices. Refer: https://github.com/ansible/ansible/pull/51320#discussion_r267579389
We may need at least the following features here: - [ ] `list_keys()`: Show the SAS policies of the Event Hub, so that we can have connection string - [ ] `list_consumer_group()` We usually add these with a flag to avoid network overhead. refer: https://github.com/ansible/ansible/blob/1dc8436ed91ef25748dd270c289c05f893cca6e3/lib/ansible/modules/cloud/azure/azure_rm_servicebus_facts.py#L55-L60
also extends `azure_tags`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
That's a really interesting piece of information I did not know.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
That's a really interesting piece of information I did not know.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
Should the default be https, if so update docs
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
No need for the 'else' here either. The 'if' is the exit statement.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
No need for the 'else' here either. The 'if' is the exit statement.
In fact you could have one big try-except statement, and only a single KeyError exception clause for the connection error.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
``` module = AnsibleModule( argument_spec=dict( state=dict(default='present', choices=['present', 'absent']), username=dict(type='str'), password=dict(no_log=True), token=dict(no_log=True), src=dict(type='path'), priority=dict(type='int'), ), mutually_exclusive=(['password', 'token'],), required_together=(['username', 'password'],), required_one_of=[['password', 'token']], required_if=[('state', 'present', ['src', 'priority'])], supports_check_mode=True )``` `required_together` looks like it should work
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
No need for the 'else' here either. The 'if' is the exit statement.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
`getattr()` rather than calling a dunder method
Offset cannot have seconds and milliseconds, so this workaround is unnecessary.
I'd use .objects.create
Maybe this should be a class docstring :thinking:
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
We don't need tags in this function, I think.
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
need to catch BotoCoreError here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Low-level tests are not necessary, it should be feasible to test using `Lexeme()` with special characters in a query.
Please use `module= AnsibleModule(` I guess it is a convention
I think we have a problem here. The version that is supposed to be supplied as a parameter should only consist of major.minor version like `2.0` (so that all 2.x version go into the same repository) - this one is `2.0.0-beta1` though.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
I think there are enough tests about forms using the formats machine to sanitize input values. I'd rather specifically tests `sanitize_separators` in a separate `test_sanitize_separators` test.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think there are enough tests about forms using the formats machine to sanitize input values. I'd rather specifically tests `sanitize_separators` in a separate `test_sanitize_separators` test.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
The `u` prefix is not necessary (as unicode_literals is imported at the top of the file). `self.assertIn` can be used here.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
chop the blank lines before each attribute
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
use `self.MAX_FILES` instead of 999999
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
`raise` is missing. Call to `str` is useless there.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Please create dicts immediately with the values you already have.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
In the `exit_json`, you should also return `changed` and `state`.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
In the `exit_json`, you should also return `changed` and `state`.
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
In the `exit_json`, you should also return `changed` and `state`.
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I see there is no grouping in this inventory. Is this intentional for the first patch? Fine to me but I'd like to raise that grouping based on `os_name` of `offer` allow greater flexibility when dealing with a fleet of machine, might be interesting to add.
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Maybe use `self.execute_module(changed=True, commands=['vlan 6', 'vlan 7', 'vlan 8', 'vlan 9', 'vlan 10'])`? That automatically handles ensuring `commands` retains sort order. (and can add `sort=False` if you want to use it for the others and don't need sorting)
Fun fact: when I run this as my user, it returns nothing. When I run it as root, it works. On the other hand, `blkid --uuid <UUID>` also works when I run it as my user. So why not use ```suggestion result = self._run_command([self._blkid_bin, '--uuid', query]) ``` instead? That seems to be simpler. Also, you don't need any postprocessing, since it returns only the device name and nothing else.
Too many empty rows here...
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Please ignore, my suggestion is invalid syntax.
Does the result provide any insight into if anything's changed? Looks like put and delete are currently both hard coded to return ``changed=True``
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Please ignore, my suggestion is invalid syntax.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I think the test should be split into multiple test methods, one per thing-being-tested, as above
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Please remove whitespaces around the braces.
Need a colon at the end here
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Please ignore, my suggestion is invalid syntax.
253, can go, this one... ``` print (' export S3_BUCKET_SYNC_FROM="%s"' % (s3_bucket_sync_to)) ```
I thought about this and it is wrong. We need to specify the existing official repo here. So, if we release 2.0.0 we retain the beta release in there. Just remove this line and the `download.elasticsearch.co` is used to sync and all works as expected.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I have a real dislike for one character variables (even if they are local) because they make it harder to read your code. This could have been **org** instead of **o**.
Not a big issue now, but something to think of in the future. Readability is one of the highest goods in community collaboration.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
TBH, I don't think we need this test. I will chop it.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
TBH, I don't think we need this test. I will chop it.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Since this is a new module, this should be fixed from its beginning: ```suggestion supports_check_mode=True, ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Please write as: ``` if __name__ == "__main__": main() ```
```python elif max_num is not None and () ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
No need for get(key, None) as None is the default fix also for following get()
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Line 355 to 368 are unused.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This exception will never be raised. `args['password']` is always set; it has the value `None` if the user didn't specify `password`.
Exception handling here too.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Will info['body'] be json? Might be a string/HTML.
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
That's a really interesting piece of information I did not know.
```suggestion def validate_wwn(module): ```
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
No need for get(key, None) as None is the default fix also for following get()
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
I think this blank line can be removed.
`updates` should be `commands`
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
I think this blank line can be removed.
`updates` should be `commands`
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion elif date_string.match(self.when): ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion elif date_string.match(self.when): ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion elif date_string.match(self.when): ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is wrong, already explained.
Again, quote names and values: ```suggestion meraki.fail_json(msg="Parameters 'net_name' and 'net_id' are mutually exclusive") ```
Maybe this should be a class docstring :thinking:
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is wrong, already explained.
Again, quote names and values: ```suggestion meraki.fail_json(msg="Parameters 'net_name' and 'net_id' are mutually exclusive") ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is wrong, already explained.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is wrong, already explained.
Again, quote names and values: ```suggestion meraki.fail_json(msg="Parameters 'net_name' and 'net_id' are mutually exclusive") ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
Exception handling here too.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Exception handling here too.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Hmmn... I think we are going to want the env var here and in the ansible package to match. Otherwise users will have to set both if they want to override. If you prefer your name, just open a pr against ansible-community/antsibull to change that one
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
I'd go for underlining.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please use `module= AnsibleModule(` I guess it is a convention
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Hmmn... I think we are going to want the env var here and in the ansible package to match. Otherwise users will have to set both if they want to override. If you prefer your name, just open a pr against ansible-community/antsibull to change that one
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
Hmmn... I think we are going to want the env var here and in the ansible package to match. Otherwise users will have to set both if they want to override. If you prefer your name, just open a pr against ansible-community/antsibull to change that one
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
I would use `%s` formatting consistently.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
I would use `%s` formatting consistently.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
"actor" variables are unused
I would say `Deploy key has been updated` instead of `should have been updated`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Not sure it makes a difference but before it looks like we got `form=None` in the context.
`kwargs` parameter is neglected, all subclass context data is ignored
Not sure it makes a difference but before it looks like we got `form=None` in the context.
`kwargs` parameter is neglected, all subclass context data is ignored
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Not sure it makes a difference but before it looks like we got `form=None` in the context.
`kwargs` parameter is neglected, all subclass context data is ignored
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
``` py self.assertIs(type(f.__repr__()), str) ```
Make `__str__` return `self.string_rep` and nuke `__unicode__`.
Wrap docstrings at 79 characters. Try to avoid "we... " (often this results in simpler language).
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
It'd be nice to hint users about what version is not old.
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
Move the leading period to the initial definition of `msg`.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
ok, just something for consideration, I trust your/the community's judgement on it
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
ok, just something for consideration, I trust your/the community's judgement on it
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
ok, just something for consideration, I trust your/the community's judgement on it
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
TIL that character classes also work inside `[]` :D
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I'd rename `subminor` to `patch`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Situations where the v6 string in question doesn't actually specify a port, e.g., 2001:db8:0:1 See: ``` def test_parse_ip_host_and_port_v6_with_brackets ```
I prefer to have a trailing comma everywhere, it makes further diff review easier. ```suggestion 'eos': re.compile(r'^Arista'), ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
ok, just something for consideration, I trust your/the community's judgement on it
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
Use the [boto3 exception guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2)
`InvalidInternetID` doesn't seem to exist according to botocore's source
Technically this will never be `None` because of the defaults.
I see - if possible I'd like this in a separate PR because it's not related to IPv6, and has its own bug open already.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Unclear why we're mixing some parameter substitution inline, and leaving others to the final substitution with the `args`. Made it confusing to figure out what was going on with the `JMX_PORT`, which looked like it had been lost since it wasn't in `args` any longer.
Since these two branches do the same thing and half of the inner conditional is the same, it seems like you could just combine it all into one condition and only have one copy of that code.
Could be simplified to `not hasattr(node, "version") or node.version > LATEST_0_8_2)`
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
In the `exit_json`, you should also return `changed` and `state`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Isn't `raise` missing there ? Calls to `str` are useless.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please use `module= AnsibleModule(` I guess it is a convention
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Please use `module= AnsibleModule(` I guess it is a convention
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Please use `module= AnsibleModule(` I guess it is a convention
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
TIL that character classes also work inside `[]` :D
Ok, not sure why this one is still open.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
check that -> and that (no comma needed since the two clauses are independent)
please check code with flake8 (`E231 missing whitespace after ','`)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
@timgraham is ordering by the result of an aggregate allowed without subqueries? If ordering by count does not error, then it should be safe to use that ordering. If not, introducing a different field into the orderby will affect the grouping (not that you suggested that), so we'll need to look at comparing the queryset out of order if there's another assert method available that does that. I'm not able to check either of these things at the moment, but I can take a look in about 8 hours if it's not resolved.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
We can remove an aggregation (which is not important for this test) and chop `@skipUnlessDBFeature`.
Will info['body'] be json? Might be a string/HTML.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Will info['body'] be json? Might be a string/HTML.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Could you remove this outer try/except (it was only for debugging)? The build is failing because `print` needs to be `print(e)` for Python 3 compatibility but that can be removed anyway.
it should also check if it can write there
This is not covered by tests, also raising an exceptions in user-defined functions is not really helpful for users: ```python django.db.utils.OperationalError: user-defined function raised exception ``` I think we should return `None` instead.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Where's it? I cannot see it.
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Where's it? I cannot see it.
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
ok, just something for consideration, I trust your/the community's judgement on it
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same as for the updated, I'd rather say `has been deleted`
The `foo_attrs` variables could be removed.
This PR looks good. It would be slightly more consistent with `SelectDate` and `Multiwidget` if this render was handled in the template. The `SelectDate` widget does something similar where the widget type is instantiated for each subfield, `get_context` is called, and the `widget` return value is added to `subwidgets`: https://github.com/django/django/blob/3e91850dccecd13dde8cef7b81c798217f74a301/django/forms/widgets.py#L961
In each of the three cases, can you change `False` to `None` and add a trailing comma. (I think we *could* also move the placeholder line to the top to allow it to be overridden by the context, but it may not be worth it as I'm not sure the attributes passed down can be specified for each select individually...)
You're right. You know I both saw that and missed it too...
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Maybe this should be a class docstring :thinking:
```suggestion return '-' + value if neg else value ```
we lost 'invalid' here
```suggestion return '-' + value if neg else int(value) ```
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
`expected_url` is more consistent with naming elsewhere. Also, I would use `%s` formatting consistently rather than `format()`.
Wrap lines closer to 79 characters and use () when referring to a function. ``` # get_current_site() will lookup a Site object, so these must match the # domains in the MockSite model. ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Please use 'msg' for returned messages, this is a standardized return value.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Would you mind also importing traceback with the other imports and adding exception=traceback.format_exc() to the end of this fail_json? Example: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
remove extra newline
Please check code with flake8 as described in the patch review checklist and correct the "no newline at end of file" warning here.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Again, suggest rewording this as suggested for win_http_proxy.
there is no need to version params for new modules
there is no need to version params for new modules
Again, suggest rewording this as suggested for win_http_proxy.
there is no need to version params for new modules
there is no need to version params for new modules
This is not py2.6 compatible. You will need to index these.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
This is not py2.6 compatible. You will need to index these.
add an alias to `domain` as `domainname`
This is also to deprecate parameter `domainname`.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
I think if you import this here, it will solve the CI problem.
```suggestion import gi gi.require_version('NMClient', '1.0') ```
This syntax is not supported in python2.6. You will need to index your format like {0}
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
This seems like it would break galaxy which needed expand_paths
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
This seems like it would break galaxy which needed expand_paths
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
I would suggest using ``` python from six.moves import configparser ``` Currently inventory scripts aren't real consistent about how they handle compat issues like configparser, but thats closest to how the app code and modules do it (they use the six provided in module_utils, but that is not recommended for external inv scripts) ``` python from ansible.module_utils.six.moves import configparser ```
I also don't see why the import is needed, it's not used by the changes.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This is not py2.6 compatible. You will need to index these.
Is that error "the port is in use by something" or "port is already in the state you asked for"? If it's the former (as I suspect), it's arguably incorrect to silently succeed (as the port will not be in the requested state since it's a member of the wrong broadcast domain).
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
And the same here
Don't check arg_type here. A module could do something silly like: ``` encryptor: passphrases_for_each_user: - foo - bar - baz ``` The arg_type in this case will be a list but we'd still want to catch it here.
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
I would suggest using ``` python from six.moves import configparser ``` Currently inventory scripts aren't real consistent about how they handle compat issues like configparser, but thats closest to how the app code and modules do it (they use the six provided in module_utils, but that is not recommended for external inv scripts) ``` python from ansible.module_utils.six.moves import configparser ```
I also don't see why the import is needed, it's not used by the changes.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
But this code is never going to be hit if the argument_spec is set to required=True, unless someone set `url: ""`, but it's difficult to test for every bad input format - someone could equally pass `url: "not_a_protocol://thisisnonsense"`
Basically @gundalow's point is that you don't need to repeat the work that Ansible is already doing enforcing required parameters
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Basically @gundalow's point is that you don't need to repeat the work that Ansible is already doing enforcing required parameters
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
To be consistent with other modules each of the options should be on a single line (unless they have many choices)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please use `module= AnsibleModule(` I guess it is a convention
Exception handling here too.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
Exception handling here too.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
Exception handling here too.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
Exception handling here too.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Please use `module= AnsibleModule(` I guess it is a convention
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Exception handling here too.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Required=false are implicit could you remove them ? Default=None too in case of string
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
chop the blank lines before each attribute
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Exception handling here too.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
If I were writing this from scratch, I'd consider "a bunch of functions that all take an optional `password_validators` arg and call `get_default_password_validators()` if it's not given" to be an indication that perhaps a higher-level class is in order that you can instantiate with a set of password validators and then call methods on (and a default instance of that class based on settings could be provided at module level). But I don't feel strongly enough about this to suggest actually rewriting it on that model.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Exception handling here too.
Maybe this should be a class docstring :thinking:
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Exception handling here too.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Exception handling here too.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Maybe this should be a class docstring :thinking:
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Will info['body'] be json? Might be a string/HTML.
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I wouldn't exactly call a dictionary `list`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Please write as: ``` if __name__ == "__main__": main() ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Not a problem, though wasn't obvious
This should use `self.subTest`, I also don't think that we need a `namedtuple` and `self.script_name_test_cases` variable, e.g. ```python tests = ( # SCRIPT_NAME ends with no slash, settings start with slashes. ('/somesubpath', '/static/', '/somesubpath/static/', '/media/', '/somesubpath/media/'), # SCRIPT_NAME ends with no slash, settings start with no slashes. ('/somesubpath', 'static/', '/somesubpath/static/', 'media/', '/somesubpath/media/'), ... ) for script_name, initial_static_url, final_static_url, initial_media_url, final_media_url in tests: with self.subTest(...): ... ```
Use a context manager with this read operation to ensure the file handler is closed as soon as it is no longer needed rather than relying on successful program termination. ```suggestion with open(self.LOGIN_DEFS, 'r') as f: for line in f.readlines(): ```
Fair engough. Then, if I haven't overlooked anything, there is no need to pass `privatekey` to `_check_signature()` as you can call `csr.verify(self.privatekey)` directly.
We're avoiding the `self.fail()` pattern in favor of letting the entire exception bubble up.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
No need for get(key, None) as None is the default fix also for following get()
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
As this is a new module you don't have to worry about backwards compatibility. If you remove it remember to also remove from docs and examples.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
use `self.MAX_FILES` instead of 999999
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
You shouldn't need the extra parentheses inside `extend()`, FYI.
The URL tests got started off on a bad foot, I think. I prefer the pattern used in `test_security`. For one thing, if this first assertion fails, you have to use print statement debugging to figure out what the result actually was as opposed to the assertion error giving some useful info.
You don't have to inherit from object if you have the boilerplate ```__metaclass__ = type```
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I'd chop every other empty line and group the `auto_now` and `auto_now_add`, but that's just cosmetics.
I don't mind either way, it just took a second to spot the differences between the groups.
Should use `assertRaisesMessage()` to verify the string also.
Do we need the `tzinfo` bit for the test? I'm worried relying on `get_current_timezone` could make the test flaky.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
I don't see where this test has anything to do with `tbl_space` - it looks like a duplicate of the previous test.
```suggestion if os.path.exists(writer.path): raise CommandError( f'Migration {new_migration.name} already exists. Use a different name.' ) ```
```suggestion fileh = open(self.b_cron_file, 'wb') ```
Is the prefix necessary here? Why no let tempfile choose a location? Sudoing to non-root is fairly common and should work.
Same question for dropping lambda here as well.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Use single quotes consistently.
Use `'` as string delimiter for consistency
Ok I get it, `compiler.compile(Value(5))` would return something like `'%d', (5,)`.
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
prefer hanging indent style with 1 arg per line
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Various things that can be improved here: - Avoid unnecessary elifs. - Raise NotImplementedError in the default case for unknown operators. ```suggestion if operator == '+': # typecast_timestamp() returns a date or a datetime without timezone. # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]" return str(real_lhs + real_rhs) if operator == '-': return str(real_lhs - real_rhs) if operator == '*': return real_lhs * real_rhs if operator == '/': return real_lhs / real_rhs raise NotImplementedError(f"Unsupported operator: {operator}") ```
Annoying that `datetime.time` cannot be subtracted from each other to give a `datetime.timedelta`, so we cannot use `duration_microseconds()` as in `_sqlite_timestamp_diff()` below.
I would avoid the `closer to replace` phrasing, it can do pruning but is still sending a `PATCH` (just an intelligently computed `PATCH` instead of the hail mary we're currently sending). If possible I'd try to match our phrasing to the [official docs](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply) as much as possible
I don't think I'd say this, it's more like a really smart patch that can automatically compute deletions. It's still going to be sending a PATCH and not a PUT so I'd just worry someone gets the wrong idea.
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
In the `exit_json`, you should also return `changed` and `state`.
I think this should be 'exit' instead of 'abort'
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
`short_description: Create, update, or destroy custom Ansible Tower credential type`
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
```suggestion module.exit_json(msg=msg, changed=changed) ```
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think we should be consistent and use double-quotes.
Use single quotes.
I think we should be consistent and use double-quotes.
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
(Additional whitespaceânumber of spaces not multiple of 4.)
I see there is no grouping in this inventory. Is this intentional for the first patch? Fine to me but I'd like to raise that grouping based on `os_name` of `offer` allow greater flexibility when dealing with a fleet of machine, might be interesting to add.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I suggested yesterday something more convenient and readable: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
The check-mode test should come as late as possible. There are various failure-cases that you are skipping in check-mode.
For python 2.6 compatibility, this and the following four strings have to look like `cmd = "ping {0} {1}".format(vrf, dest)`
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
TBH, I don't think we need this test. I will chop it.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
```suggestion Test that the returned value for timezone consists of only uppercase ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Still I think `'&nbsp;<strong>%s</strong>'` could be factored as a variable and `<a href=...` interpolated inside that. Let's use `format_html` instead of `escape`. This return could go in the `else` block of `try/except/else`.
Could you try to improve this so that there isn't duplication of the HTML and `escape(Truncator(obj)....`
This is really hacky, moving to the previous day should work as expected ```python return "TO_CHAR(%s - 1, 'D')" % field_name ```
TIL that character classes also work inside `[]` :D
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Typo in `module_utils`.
Needs testing, though I thinnk you want something like: ```suggestion pytest.skip("skipping as missing required netapp_lib") ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
blank line not needed
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
Isn't `raise` missing there ? Calls to `str` are useless.
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
This is supposed to be the most used Accept content, however I don't think it contains those added spaces.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
This is supposed to be the most used Accept content, however I don't think it contains those added spaces.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
chop the blank lines before each attribute
remove extra newline
Please remove empty line.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
blank line not needed
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
blank line not needed
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Why do you wait to fail ? I think you must fail in "main"
Same here as `create` method
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
s/strng or or/string or/
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Wrap at 79 chars, please.
s/strng or or/string or/
A form validation error seems sensible to me
```suggestion timeout=60, ``` "60" on its own looks a bit weird. Also, it surely doesn't need to be as long as 60 seconds if `DELAY_AFTER_FAILED_LOGIN` is so much smaller? What if `DELAY_AFTER_FAILED_LOGIN > 60`? Maybe this should be: ```suggestion timeout=self.DELAY_AFTER_FAILED_LOGIN + 10, ```
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
s/strng or or/string or/
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
this should use the new API without hardcoded id now
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I'd also include a check for server errors (500)
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_USER']), ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We don't like these catch-all statements in Ansible. In this case I would expect the library to handle any exceptions caused by connect_to_api. `all_facts()` should be quite safe, if not the smaller pieces that may raise exceptions should be wrapped. `exit_json()` is not expected to raise exceptions. So I'd remove the whole try-block here altogether.
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Initialized must go first.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please use `module= AnsibleModule(` I guess it is a convention
type='str' is the default so I think you can remove those.
Mea culpa. I told them to take the defaults out for brevity. I'll keep your preference in mind in the future.
I don't think the default is string. The default is to use whatever YAML makes of it IMO (that's the only backward compatible way to add type-support when we did). This also makes it possible to have a parameter that accepts both e.g. a list or dict and let the module figure it out (like it used to be in the old days ;-)) There are modules that use YAML as input, so in this case it doesn't matter whether it is a string, dict or list. (e.g. the xml module) and there is no type-indication for those parameters.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
This syntax is not supported in python2.6. You will need to index your format like {0}
`raise` is missing. Call to `str` is useless there.
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
This syntax is not supported in python2.6. You will need to index your format like {0}
@lindong28 I tried this a bit locally, and realized the command now has two pipes to `tee` (see line 58 as well) When I drop the pipe to tee here on line 51 and keep the one below, the producer runs as expected.
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Array ellipsis is an obscure feature and not necessary here. It hinders readability
return directly, no need for `path` variable.
Shouldn't `w[0].message` be `w[0].category`? You could also deindent this line.
```suggestion return b'\r\n'.join(to_bytes(line, nonstring='passthru') for line in result) ``` (and import `to_bytes`)
```suggestion data ```
I hacked this up using `to_bytes` generously. I dropped the `result` list and instead appended bytes to a `b_result` bytes object. Thus, I could merely append the data to the `b_result` without any additional processing. My hack was very ugly. I can share it if you like, but it is not clean enough to be merged :P
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
chop the blank lines before each attribute
remove extra newline
Please remove empty line.
Why do you wait to fail ? I think you must fail in "main"
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Maybe this should be a class docstring :thinking:
I tried to fix these in #12645 but clearly that hasn't carried over to docstrings 🤔
This PR looks good. It would be slightly more consistent with `SelectDate` and `Multiwidget` if this render was handled in the template. The `SelectDate` widget does something similar where the widget type is instantiated for each subfield, `get_context` is called, and the `widget` return value is added to `subwidgets`: https://github.com/django/django/blob/3e91850dccecd13dde8cef7b81c798217f74a301/django/forms/widgets.py#L961
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion elif date_string.match(self.when): ```
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
That `get_multi_something` pattern repeats itself quite a few times in the file, which makes it a good candidate for a refactor into more general function. Something similar to this should work: def aggregate(self, func): ret = True entries = [] for systems_uri in self.systems_uris: inventory = func(systems_uri) ret = inventory.pop('ret') and ret entries.append(inventory) return dict(ret=ret, entries=entries) def get_multi_storage_controller_inventory(self): return self.aggregate(self.get_storage_controller_inventory) def get_multi_disk_inventory(self): return self.aggregate(self.get_disk_inventory) This should reduce the code duplication significantly.
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
You can define an `as_sqlite` method for this case.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
TIL that character classes also work inside `[]` :D
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I thought `formset = ChoiceFormSet(self.data, auto_id=False, prefix='choices')` could go in `setUp()` also.
I'm not sure whether it should be considered part of a separate clean up across all cases of this in the code base or whether we can handle this here for all of the adjacent lines, but it would be nice to fix the indentation: ```python self.management_form_html + ( '<tr><th>Choice:</th><td><input type="text" name="choices-0-choice" value="Calexico"></td></tr>' '<tr><th>Votes:</th><td><input type="number" name="choices-0-votes" value="100"></td></tr>' ) ```
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
I think we should be consistent and use double-quotes.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Isn't `raise` missing there ? Calls to `str` are useless.
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like {0}
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like {0}
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Please remove empty line.
I'm about to commit this, but for future reference note that assertEquals is a deprecated alias and should be assertEqual
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Please use 'msg' for returned messages, this is a standardized return value.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
I think we can drop the empty line here.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
And this one.
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Typo? ```suggestion files = info.get('files', {}) ```
In the `exit_json`, you should also return `changed` and `state`.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
chop blank line
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
Please check test coverage carefully. I didn't spot a test for this change.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Line 355 to 368 are unused.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
It looks like `(' %s' % order).strip()` can simply be `order` now.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
this is not a 1.0 callback, its using 2.0 API
Use another lookup instead of `epoch` e.g. `second`.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
Use another lookup instead of `epoch` e.g. `second`.
this is not a 1.0 callback, its using 2.0 API
Please use a single quote.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
this is not a 1.0 callback, its using 2.0 API
Use another lookup instead of `epoch` e.g. `second`.
We should remember that migration files are auto generated code. They first and foremost need to not have syntax errors. There was a discussion on running some form of isort on migration files while generating them. We decided against that for the sake of migration files being auto-generated. Furthermore, lines in migration files can easily end up having lines way past 79 or 119 characters. And I'm against starting to linebreak those lines with some other tool. Users should exclude migration files from linting, IMO.
The other alternative would be to avoid performing analysis of the migration files. FWIW I personally find set literals to be better looking and easier to parse particularly in cases where the set doesn't contain many elements and the `set([])` boilerplate accounts for half the length of the whole statement.
This is not the most explicit way to chain those lists. I recommend to use `itertools.chain.from_iterable(batch_querysets)`.
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
```suggestion display.vvv(u"No connection ot reset: %s" % to_text(stderr)) ``` ```suggestion display.vvv(u"No connection to reset: %s" % to_text(stderr)) ```
chop "should" (just state the behavior)
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
I think we should be consistent and use double-quotes.
Single line looks okay here, in the next test and in the assertEqual of the test.
I think combining this with the previous test case is okay.
I think this would be a bit more readable: ``` url = reverse('... show_less_response = self.client.get(url) ```
Why do you wait to fail ? I think you must fail in "main"
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Required=false are implicit could you remove them ? Default=None too in case of string
Is there a need to hardcode pks? This is generally to be avoided, I think.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Is there a need to hardcode pks? This is generally to be avoided, I think.
This one as well.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
I'm going to leave this in needs_revision. My requirements for considering this change have been outlined above.
I'm not really a fan of this approach, and generally speaking, we have tried to stay away from it. I am more in favor of just doing: ``` try: sock = socket.create_connection(address) except AttributeError: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect(address) ```
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
Sorry for the slow response, I am concerned both with pythonic implementations, speed and obfuscation combined. Creating a function named the same as the original method, by which it is hard to tell in the calling location which is happening will often lead to confusion. hasattr can also sometimes work in strange ways such as what is described in https://hynek.me/articles/hasattr/ Additionally, with hasattr you are performing the lookup multiple times, instead of just trying to use it and handle the exception. In the majority of cases, just trying to use it and handling the exception will be the faster way.
I'm going to leave this in needs_revision. My requirements for considering this change have been outlined above.
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
This could be a bare `super()`.
This one as well.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
I'd rename `subminor` to `patch`.
@pierremahot we'll need a test for this
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
@pierremahot we'll need a test for this
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
@pierremahot we'll need a test for this
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Use single quotes consistently.
`assertEquals` is deprecated and should be replaced by `assertEqual`. In a more personal-taste spirit, is it really useful to make 4 separate tests instead of consolidating them into one? The fact that the last 3 are identically named is an error, for sure.
Could you a docstring along the lines of `test_file_url()`, please :smile:
Use single quotes consistently.
`assertEquals` is deprecated and should be replaced by `assertEqual`. In a more personal-taste spirit, is it really useful to make 4 separate tests instead of consolidating them into one? The fact that the last 3 are identically named is an error, for sure.
Could you a docstring along the lines of `test_file_url()`, please :smile:
no restructured text (:class:) in docstrings please
Is there a typo? I'm not sure what "hub" means in this sentence.
I'd go for underlining.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Yes, I know. I'll leave it to Aymeric for a second opinion.
Use single quotes consistently.
Use single quotes consistently.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
This should use `self.subTest`, I also don't think that we need a `namedtuple` and `self.script_name_test_cases` variable, e.g. ```python tests = ( # SCRIPT_NAME ends with no slash, settings start with slashes. ('/somesubpath', '/static/', '/somesubpath/static/', '/media/', '/somesubpath/media/'), # SCRIPT_NAME ends with no slash, settings start with no slashes. ('/somesubpath', 'static/', '/somesubpath/static/', 'media/', '/somesubpath/media/'), ... ) for script_name, initial_static_url, final_static_url, initial_media_url, final_media_url in tests: with self.subTest(...): ... ```
Please ignore, my suggestion is invalid syntax.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
When hitting an error you must exit with module.fail_json
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
In the `exit_json`, you should also return `changed` and `state`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
When hitting an error you must exit with module.fail_json
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
In the `exit_json`, you should also return `changed` and `state`.
When hitting an error you must exit with module.fail_json
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This branch in untested :thinking:
I think we should be consistent and use double-quotes.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
This branch in untested :thinking:
I think we should be consistent and use double-quotes.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This branch in untested :thinking:
I think we should be consistent and use double-quotes.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
I'm about to commit this, but for future reference note that assertEquals is a deprecated alias and should be assertEqual
I think it's not pylint itself, but our own checks...
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Make a common method in class to get url and return json loads response.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Make a common method in class to get url and return json loads response.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Can you just do `name.startswith('__') and not name.endswith('__')`? Simpler is better
Maybe this should be a class docstring :thinking:
Missing end parenthesis
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Can you just do `name.startswith('__') and not name.endswith('__')`? Simpler is better
This can be converted to return True. No need of new variable retry_request
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
You're right. You know I both saw that and missed it too...
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
You're right. You know I both saw that and missed it too...
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
Oops. I think you meant to put the space to the _**right**_ of the quote!
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
Oops. I think you meant to put the space to the _**right**_ of the quote!
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion elif date_string.match(self.when): ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
add trailing ,
move this to the previous line (we favor longer lines over non-hanging indent)
please use `assertRaisesMessage` to verify it's the `ValueError` we expect (also makes the test easier to read and debug).
The layout should be something along those lines ``` python for enclosure in item.get("enclosures") or []: handler.addQuickElement("link", "", { "rel": "enclosure", "href": enclosure.url, "length": enclosure.length, "type": enclosure.mime_type }) ```
add trailing ,
move this to the previous line (we favor longer lines over non-hanging indent)
add trailing ,
please use `assertRaisesMessage` to verify it's the `ValueError` we expect (also makes the test easier to read and debug).
use hanging indent please: ``` raise ValueError( "..." "..." ) ```
The layout should be something along those lines ``` python for enclosure in item.get("enclosures") or []: handler.addQuickElement("link", "", { "rel": "enclosure", "href": enclosure.url, "length": enclosure.length, "type": enclosure.mime_type }) ```
add trailing ,
move this to the previous line (we favor longer lines over non-hanging indent)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion elif date_string.match(self.when): ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
Line 355 to 368 are unused.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Required=false are implicit could you remove them ? Default=None too in case of string
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Required=false are implicit could you remove them ? Default=None too in case of string
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`raise` is missing. Call to `str` is useless there.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I think we should be consistent and use double-quotes.
We should also change `\d+` to `[0-9]+` in all cases.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I think we should be consistent and use double-quotes.
We should also change `\d+` to `[0-9]+` in all cases.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Please use assertRaisesMessage to check the message too. We prefer the context manager version usually `with self.assertRaisesMessage(ValueError, msg)`. I think combining the two tests so you can reuse the `msg` variable would be fine.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be converted to return True. No need of new variable retry_request
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be converted to return True. No need of new variable retry_request
Please change these vars to ansible Host vars rather OS env vars.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
check that -> and that (no comma needed since the two clauses are independent)
please check code with flake8 (`E231 missing whitespace after ','`)
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Consider `open_url` from `ansible.module_utils.urls` as an option to remove the dependency on `requests`.
Since we expect the name to start with 'http://' or 'https://' I would so this: ```python if name.startswith('http://') or name.startswith('https://'): ... ```
+1 it's better to just patch `time.time`
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
I would prefer to avoid the try/except block. Because it can potentially hide a problem and it reduces the readability. This being said, it was already here, so it's up to you.
```suggestion self.module.fail_json(msg="Invalid start VLAN id %s." % vlan_id_start) ```
```suggestion self.module.fail_json(msg="The specified user or group does not exist: %s" % to_native(user_not_found)) ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Should the default be https, if so update docs
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
Could you add a message here: ``` python raise NotImplementedError('Subclasses of BaseSerializer need to implement the serialize() method') ```
1) No need to inherit from object explicitly due to `__metaclass__ = type` set above 2) It's nice to properly support all stringifications ```suggestion @six.python_2_unicode_compatible class CollectionRequirement: ```
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
https://github.com/ansible/ansible/blob/cd988f645aaf774c55a98a90e3ef42cc5b1a1563/lib/ansible/module_utils/urls.py#L1147 gives all options.
Could you add a message here: ``` python raise NotImplementedError('Subclasses of BaseSerializer need to implement the serialize() method') ```
1) No need to inherit from object explicitly due to `__metaclass__ = type` set above 2) It's nice to properly support all stringifications ```suggestion @six.python_2_unicode_compatible class CollectionRequirement: ```
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Minor but the `else` clause wrapping is unnecessary here given you return in the `except`.
@CruxBox my point is that you are already returning in the case of an exception *and* in the `else` clause so the code is equivalent to ```python try: date_value = datetime.date(int(y), int(m), int(d)) except ValueError: # Return pseudo-ISO dates with zeros for any unselected values, # e.g. '2017-0-23'. return '%s-%s-%s' % (y or 0, m or 0, d or 0) date_value = datetime_safe.new_date(date_value) return date_value.strftime(input_format) ``` Again, this is minor but we usually avoid using `try/else` in the rest of the code base unless it's necessary.
This is not covered by tests, also raising an exceptions in user-defined functions is not really helpful for users: ```python django.db.utils.OperationalError: user-defined function raised exception ``` I think we should return `None` instead.
Minor but the `else` clause wrapping is unnecessary here given you return in the `except`.
@CruxBox my point is that you are already returning in the case of an exception *and* in the `else` clause so the code is equivalent to ```python try: date_value = datetime.date(int(y), int(m), int(d)) except ValueError: # Return pseudo-ISO dates with zeros for any unselected values, # e.g. '2017-0-23'. return '%s-%s-%s' % (y or 0, m or 0, d or 0) date_value = datetime_safe.new_date(date_value) return date_value.strftime(input_format) ``` Again, this is minor but we usually avoid using `try/else` in the rest of the code base unless it's necessary.
This is not covered by tests, also raising an exceptions in user-defined functions is not really helpful for users: ```python django.db.utils.OperationalError: user-defined function raised exception ``` I think we should return `None` instead.
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
User could set `user_data` parameter to `None`, in such case exception still occurs.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
And there: ``` work_file = os.path.join(self.dirpath, '%s.c' % self.file) ```
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Is `user_id` something secret, just wondering why it has `no_log`
pytest.mark.skip Though I'm surprised we did not see any bot error.
The `L` suffix raise a `SyntaxError` under python3. This should be `lambda: long(9999999999999999999)`.
Typo in `module_utils`.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
You don't like f-strings at all, do you? :-)
We could lowercase the vendored files, that would help at least for the `zh-*` variants.
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
You don't like f-strings at all, do you? :-)
We could lowercase the vendored files, that would help at least for the `zh-*` variants.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
You don't like f-strings at all, do you? :-)
We could lowercase the vendored files, that would help at least for the `zh-*` variants.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
This will probably break for `zh-CN` and others because Django returns lower cased language names. I do not have a good idea on how to fix that though.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
A form validation error seems sensible to me
You can skip the blank lines in these tests as three lines long isn't too difficult too read with spaces.
```suggestion 'After a failed login, you need to wait for %s second before trying a new login.', 'After a failed login, you need to wait for %s seconds before trying a new login.', ```
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
Maybe this should be a class docstring :thinking:
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
A form validation error seems sensible to me
You can skip the blank lines in these tests as three lines long isn't too difficult too read with spaces.
```suggestion 'After a failed login, you need to wait for %s second before trying a new login.', 'After a failed login, you need to wait for %s seconds before trying a new login.', ```
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Please use 'msg' for returned messages, this is a standardized return value.
this should use the new API without hardcoded id now
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
If the result was a 4xx or 5xx then I think this fails.
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
Hmmn... I think we are going to want the env var here and in the ansible package to match. Otherwise users will have to set both if they want to override. If you prefer your name, just open a pr against ansible-community/antsibull to change that one
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
In the `exit_json`, you should also return `changed` and `state`.
Please use `module= AnsibleModule(` I guess it is a convention
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Please use `module= AnsibleModule(` I guess it is a convention
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Please use `module= AnsibleModule(` I guess it is a convention
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
We could fall back to `__file__` or something in that case at minimum. Could be useful to include that regardless.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
This is also to deprecate parameter `domainname`.
add an alias to `domain` as `domainname`
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Ok, not sure why this one is still open.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
TBH, I don't think we need this test. I will chop it.
Maybe this should be a class docstring :thinking:
@pierremahot we'll need a test for this
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
please multiline these strings so they aren't longer than 120 chars. ``` row_html = ( '...' '...' ) ```
immediatelly -> immediately
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
please multiline these strings so they aren't longer than 120 chars. ``` row_html = ( '...' '...' ) ```
immediatelly -> immediately
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
set, with and without...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Line 355 to 368 are unused.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
We don't need to support different bases or other negation signs so I would expect a simplified implementation.
```suggestion return '-' + value if neg else int(value) ```
```suggestion return '-' + value if neg else value ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This should probably mention both slash and no-slash paths...
I don't want to hold up the PR but you could use a loop instead of a nested KeyError like ```suggestion member_names = [to_native(dirname, errors='surrogate_or_strict')] if not member_names[-1].endswith(os.path.sep): member_names.append(member_names[-1] + os.path.sep) for name in member_names: try: tar_member = tar.getmember(name) except KeyError: continue break else: raise AnsibleError("Unable to extract '%s' from collection" % member_names[0]) ``` Potentially allows us to try more options in the future if need be.
You have some syntax errors in this `if` statement.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
You're right. You know I both saw that and missed it too...
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
You have some syntax errors in this `if` statement.
Please remove `module.fail_json` and use `ModuleFailException`.
I don't want to hold up the PR but you could use a loop instead of a nested KeyError like ```suggestion member_names = [to_native(dirname, errors='surrogate_or_strict')] if not member_names[-1].endswith(os.path.sep): member_names.append(member_names[-1] + os.path.sep) for name in member_names: try: tar_member = tar.getmember(name) except KeyError: continue break else: raise AnsibleError("Unable to extract '%s' from collection" % member_names[0]) ``` Potentially allows us to try more options in the future if need be.
You have some syntax errors in this `if` statement.
Please remove `module.fail_json` and use `ModuleFailException`.
I don't want to hold up the PR but you could use a loop instead of a nested KeyError like ```suggestion member_names = [to_native(dirname, errors='surrogate_or_strict')] if not member_names[-1].endswith(os.path.sep): member_names.append(member_names[-1] + os.path.sep) for name in member_names: try: tar_member = tar.getmember(name) except KeyError: continue break else: raise AnsibleError("Unable to extract '%s' from collection" % member_names[0]) ``` Potentially allows us to try more options in the future if need be.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We avoid backslashes and use this style: ``` msg = ( "Redirection loop for authenticated user detected. Check that " "...." ) ```
please include the trailing comma on the last item in a dictionary so if more items are added we don't have to modify this line again
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I would prefer to reuse
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I would prefer to reuse
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Maybe this should be a class docstring :thinking:
Best to be conservative and error rather than silently swallow mistyped arguments :) I think `ValueError` or `TypeError` are more appropriate, they're normally used for argument validation.
What about erroring if `options` is non-empty at this point? Subclasses should have already consumed their arguments from it, and if there's anything left it's probably a mistake, like `explain(formatt='json')`
Ah I see, okay then.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
That's a really interesting piece of information I did not know.
Situations where the v6 string in question doesn't actually specify a port, e.g., 2001:db8:0:1 See: ``` def test_parse_ip_host_and_port_v6_with_brackets ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
Since we expect the name to start with 'http://' or 'https://' I would so this: ```python if name.startswith('http://') or name.startswith('https://'): ... ```
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Could you a docstring along the lines of `test_file_url()`, please :smile:
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
a leftover here which can be removed
Could you a docstring along the lines of `test_file_url()`, please :smile:
`assertEquals` is deprecated and should be replaced by `assertEqual`. In a more personal-taste spirit, is it really useful to make 4 separate tests instead of consolidating them into one? The fact that the last 3 are identically named is an error, for sure.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
check that -> and that (no comma needed since the two clauses are independent)
For the author information we normally only keep name and GitHub handle.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Required=false are implicit could you remove them ? Default=None too in case of string
Same here as `create` method
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
I would actually return, per host: * current_host_power_policy.name * current_host_power_policy.short_name * current_host_power_policy.description * changed (true/false, to indicate if a change was made for the host specifically)
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
use `self.MAX_FILES` instead of 999999
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
I would actually return, per host: * current_host_power_policy.name * current_host_power_policy.short_name * current_host_power_policy.description * changed (true/false, to indicate if a change was made for the host specifically)
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
check that -> and that (no comma needed since the two clauses are independent)
For the author information we normally only keep name and GitHub handle.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
Exception handling here too.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
You could also just return `credentials` rather than the three attributes
Yes, it's good this way!
Could you keep `'MANIFEST.json'` in a var? I was hoping to extract https://github.com/ansible/ansible/blob/4a82e2c/lib/ansible/galaxy/dependency_resolution/dataclasses.py#L44 into a publicly exposed constant at some point...
You have some syntax errors in this `if` statement.
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Fair enough, I assumed it was a small tweak to the stdlib version.
They can only be decoded if these bytes were previously encoded in this encoding.
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Fair enough, I assumed it was a small tweak to the stdlib version.
They can only be decoded if these bytes were previously encoded in this encoding.
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Fair enough, I assumed it was a small tweak to the stdlib version.
They can only be decoded if these bytes were previously encoded in this encoding.
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
I'm a little iffy about the ungrouped or all group here. I would skip ungrouped.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Do we have PEP257 linter in CI? It should've failed here.
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
@nitzmahone and I talked about this last night and the timeout is an expectation of how long fact gathering as a whole will take, not how long any specific piece of fact gathering will take. We thought that probably the best place to enforce that sort of fact gathering would be in the action plugin being worked on in a separate PR. However, for this PR, it would make more sense to at least try to replicate the status quo as much as possible, ie: take a time at the start of this function. Then every time we check the time to see if it's time to exit due to timeout, we compare time.time() > function_start_time + timeout to see if it's time to exit.
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
You don't need this conditional, since Ansible enforces that these are the only choices.
I think it would be good to include a message giving context before we start listing unresolved issues.
`copy()` in unnecessary.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
You don't need start with this code as it will be virtually the same for all the things launched by apply_async in your loop. You can just use a single scalar local variable to hold the value. (It also is the end time or max time (and maxtime is really max_timeout), not start). Adding that together with the note that we should probably process statvfs information separate from the uuid info: ``` python results[mount] = {'info': mount_info, 'statvfs': pool.apply_async(get_mount_size, (mount_info['mount'],)), 'uuid': uuids.get(mount_info['device']) or pool.apply_async(self._udevadm_uuid, (mount_info['device'],)),} max_time = time.time() + max_timeout ```
@nitzmahone and I talked about this last night and the timeout is an expectation of how long fact gathering as a whole will take, not how long any specific piece of fact gathering will take. We thought that probably the best place to enforce that sort of fact gathering would be in the action plugin being worked on in a separate PR. However, for this PR, it would make more sense to at least try to replicate the status quo as much as possible, ie: take a time at the start of this function. Then every time we check the time to see if it's time to exit due to timeout, we compare time.time() > function_start_time + timeout to see if it's time to exit.
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
Various things that can be improved here: - Avoid unnecessary elifs. - Raise NotImplementedError in the default case for unknown operators. ```suggestion if operator == '+': # typecast_timestamp() returns a date or a datetime without timezone. # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]" return str(real_lhs + real_rhs) if operator == '-': return str(real_lhs - real_rhs) if operator == '*': return real_lhs * real_rhs if operator == '/': return real_lhs / real_rhs raise NotImplementedError(f"Unsupported operator: {operator}") ```
This seems suboptimal for a number of reasons: - It's doing `len(text)` twice. - If `len(text) == length` it's slicing unnecessarily instead of returning `text`. - Using `fill_text * length` is too much as we'll only ever need `lengrh - len(text)`. Maybe the following would be better: ```suggestion delta = length - len(text) if delta == 0: return text if delta < 0: return text[:length] return (fill_text * delta)[:delta] + text ``` If `fill_text` is more than one character, `fill_text * delta` still generates too much, so we still need to `[:delta]`. Offhand, I'm not sure I can think of anything better that wouldn't be slower.
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Required=false are implicit could you remove them ? Default=None too in case of string
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Why the loop here? `if match` should be sufficient
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why the loop here? `if match` should be sufficient
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why the loop here? `if match` should be sufficient
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
ditto on `.` in character groups
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
put the closing ) on the next line
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
I'd move these two into describe_subnets, makes a bit more sense there I think.
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
```suggestion query=dict(type='list', elements='str'), ```
How about ```suggestion q = q.lstrip()[0:max_keyword_len].upper() ``` and removing the `.upper()` calls below? Will be more efficient :)
Would it maybe be better to only check the beginning of the query? Assume that the query is `SELECT * FROM USER_UPDATES`; in that case, because `INSERT` appears in `q.upper()` and `cursor.rowcount > 0` (assuming the table isn't empty), the module will say something was changed.
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
+1 it's better to just patch `time.time`
This doesn't need to be in the try/except. After it you should also do something like ``` if not region: module.fail_json(msg="region must be specified") ```
```suggestion query=dict(type='list', elements='str'), ```
How about ```suggestion q = q.lstrip()[0:max_keyword_len].upper() ``` and removing the `.upper()` calls below? Will be more efficient :)
This is a significant regression which breaks a lot of my code too.
I have my custom loss function that accepts data of the same shape as `sparse_categorical_crossentropy` which doesn't match output shape of model. It seems this line was needed to skip output shape check for custom loss functions, because currently it fails as they don't match.
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
+1 it's better to just patch `time.time`
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
botocore.exceptions.ProfileNotFound may also be raised
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
I wouldn't omit parenthesis here
`now` is unnecessary.
I wouldn't omit parenthesis here
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
I wouldn't omit parenthesis here
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
`now` is unnecessary.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
(Additional whitespaceânumber of spaces not multiple of 4.)
Oops. I think you meant to put the space to the _**right**_ of the quote!
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Probably the check functions should be called directly rather than invoking them through `run_checks()` (otherwise, this runs all registered checks across all installed apps which doesn't provide good isolation) -- see `tests/check_framework`.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This can be moved to `check_dict` method.
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
+1 it's better to just patch `time.time`
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
ok, just something for consideration, I trust your/the community's judgement on it
I'd rename `subminor` to `patch`.
You're right. You know I both saw that and missed it too...
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
no blank line
Returns -> Return use period
I think this should error somehow get printed or a warning given or something (maybe only with verbose?). (in my case it's happening if pywatchman is installed, but not watchman.): `pywatchman.WatchmanError: "watchman" executable not in PATH (%s), while executing [Errno 2] No such file or directory: 'watchman': 'watchman'`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Why do you wait to fail ? I think you must fail in "main"
In check-mode we would like to test as much as possible without inducing changes. So in this case I would expect to connect/authenticate to Spark, but not send a message. That would properly catch connectivity or login-errors in check-mode.
Right, would this work: ```python if module_checkmode: payload = None else: payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ``` I prefer to use the same paths for checkmode and without. I think it is more future-proof when changes are being made.
3rd attempt, it would help if you applied the concept to a working module instead of expecting a perfect example. Consider this pseudo-code instead. ```python if module.check_mode: url = "https://api.ciscospark.com/v1/people/me" payload = None else: url = "https://api.ciscospark.com/v1/messages" payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ```
Yes, it's good this way!
Exception handling here too.
For the get('organization') request response? I'm assuming the list of 'organizations' and 'users' will always have a single item? (at least as used with a oauth token as used here). Will that depend on the type of api_token? (ie, if there is something like a organization or group level api_key, would the results be different? If so, could be useful to explain in the docs)
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
We generally use `absent` and `present` for `state`
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
We generally use `absent` and `present` for `state`
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Why do you wait to fail ? I think you must fail in "main"
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
We generally use `absent` and `present` for `state`
Required=false are implicit could you remove them ? Default=None too in case of string
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Wrap all instances of `result['msg']` within `fail_json()` in `to_native()`.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
We generally use `absent` and `present` for `state`
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Required=false are implicit could you remove them ? Default=None too in case of string
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
We generally use `absent` and `present` for `state`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
That's a really interesting piece of information I did not know.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
else is unnecessary here because we raise an exception before
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
else is unnecessary here because we raise an exception before
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Missing from docs
Missing from docs
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Missing from docs
Missing from docs
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
That's a really interesting piece of information I did not know.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
remove extra newline
Please check code with flake8 as described in the patch review checklist and correct the "no newline at end of file" warning here.
check that -> and that (no comma needed since the two clauses are independent)
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
It looks like there's a race condition here. The log file could be read before supervisord has reopened it.
These imports need to be moved back to where they were. As you can see moving it has caused CI to fail.
2.7 at this point, we don't add features in minor versions, only bugfixes
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
I'd rather be explicit here and refresh from the database. On that note, there's `u.refresh_from_db()` :wink:
pushed the cosmetic edits
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Since we're now targetting python-2.6+ we can just ```import json```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
Use `subTest()` in this and the other new test methods below to reduce copy-paste.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
Use `subTest()` in this and the other new test methods below to reduce copy-paste.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
Use `subTest()` in this and the other new test methods below to reduce copy-paste.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
Use `subTest()` in this and the other new test methods below to reduce copy-paste.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
Use `subTest()` in this and the other new test methods below to reduce copy-paste.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
immediatelly -> immediately
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
~~typo result~~ fixed
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
```suggestion query=dict(type='list', elements='str'), ```
Please remove this, `AnsibleModule` already prevents this.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
```suggestion # Create a temporary file in the new directory ```
Required=false are implicit could you remove them ? Default=None too in case of string
In the `exit_json`, you should also return `changed` and `state`.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
```suggestion query=dict(type='list', elements='str'), ```
Please remove this, `AnsibleModule` already prevents this.
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
This seems like something that will change frequently, is there an API method to list these so we can do validation at run-time and not stop people from using new voices as they become available.
should this really be 'endswith' or more like equal? `path.strip() == '@tower_inventory'`
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_REGION']), ```
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_REGION']), ```
In the `exit_json`, you should also return `changed` and `state`.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
~~typo result~~ fixed
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please remove empty line.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
please check code with flake8 (`E231 missing whitespace after ','`)
Required=false are implicit could you remove them ? Default=None too in case of string
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
`no_log=True` is argument spec will handle this.
There could be a check in here to prevent both label and label_id from being specified if state is absent.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Required=false are implicit could you remove them ? Default=None too in case of string
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
There could be a check in here to prevent both label and label_id from being specified if state is absent.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
There could be a check in here to prevent both label and label_id from being specified if state is absent.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Line 355 to 368 are unused.
~~typo result~~ fixed
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
```suggestion query=dict(type='list', elements='str'), ```
Please remove this, `AnsibleModule` already prevents this.
```suggestion query=dict(type='list', elements='str'), ```
Please remove this, `AnsibleModule` already prevents this.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
~~typo result~~ fixed
Line 355 to 368 are unused.
~~typo result~~ fixed
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Please create dicts immediately with the values you already have.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
~~typo result~~ fixed
There could be a check in here to prevent both label and label_id from being specified if state is absent.
Required=false are implicit could you remove them ? Default=None too in case of string
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
Line 355 to 368 are unused.
Required=false are implicit could you remove them ? Default=None too in case of string
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Please create dicts immediately with the values you already have.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
Line 355 to 368 are unused.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Please remove this, `AnsibleModule` already prevents this.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
Why `dict(required=True)` is added here? It is already part of the spec.
Not something that you have to change but I think this could be simplified to ```python for obj_func in self.obj_func_mapping.values(): obj_func() ```
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
I think we should be consistent and use double-quotes.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
Why `dict(required=True)` is added here? It is already part of the spec.
Not something that you have to change but I think this could be simplified to ```python for obj_func in self.obj_func_mapping.values(): obj_func() ```
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
I think we should be consistent and use double-quotes.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
Not something that you have to change but I think this could be simplified to ```python for obj_func in self.obj_func_mapping.values(): obj_func() ```
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
Why `dict(required=True)` is added here? It is already part of the spec.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
Why `dict(required=True)` is added here? It is already part of the spec.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This can be moved to `check_dict` method.
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This can be converted to return True. No need of new variable retry_request
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
`kwargs` parameter is neglected, all subclass context data is ignored
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
I'd rename `subminor` to `patch`.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
Consider, instead of the `__iexact`: ``` python table_name = "gis_neighborhood" if not connection.features.uppercases_column_names else "GIS_NEIGHBORHOOD" GeometryColumns.objects.filter(**{GeometryColumns.table_name_col(): table_name }) ```
State the expected behavior, e.g. "Prototypes are registered only if their respective driver counts aren't zero."
You can drop the "04".
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
You are right! Fixed it in https://github.com/mheap/ansible/pull/3.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Please change these vars to ansible Host vars rather OS env vars.
Use `missing_required_lib` from `ansible.module_utils.basic`
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
We may consider such a change as a data loss. Even if `USE_TZ` is False, I think that a datetime input *with* timezone information should keep the timezone (and hence be aware). I think the docs might need to be updated to say that parsing a datetime with timezone gives an aware datetime even if USE_TZ is False.
It is highly recommended to use `assert` statements in the pytest env because it integrates with its reporting better and more natively. ```suggestion assert len(ret) == 3 ```
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
We can keep `invert` directly in the `SearchQuery` instead of `extra`, e.g. ```python ... self.invert = invert super().__init__(*expressions, output_field=output_field, function=function) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
To be consistent with other modules each of the options should be on a single line (unless they have many choices)
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Also, you can do ```python lv_type=dict(default='jfs2'), # ...snip... opts=dict(default=''), ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Unrelated, but perhaps the default kwarg should be `exclude=()` to allow removing the `exclude is not None` check.
Oops. I think you meant to put the space to the _**right**_ of the quote!
What about erroring if `options` is non-empty at this point? Subclasses should have already consumed their arguments from it, and if there's anything left it's probably a mistake, like `explain(formatt='json')`
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
ditto on `.` in character groups
```suggestion ''' Wrapper function to update var sources dict and call combine_vars() See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ''' ```
This is actually one reason you want to use `MutableMapping` over subclassing `dict`. `.get()` does not use `.__getitem__()` in `dict`. Both methods duplicate code for performance: ```pycon >>> class VarsWithSources(dict): ... def __getitem__(self, key): ... val = super(VarsWithSources, self).__getitem__(key) ... print(('__getitem__', val)) ... return val ... >>> v = VarsWithSources() >>> v['foo'] = 'bar' >>> v['foo'] ('__getitem__', 'bar') 'bar' >>> v.get('foo') 'bar' ``` Notice that `.get()` doesn't cause the print to happen. As such, your implementation as is will only work with some accesses of keys, and not others.
I'm not sure why the change I suggested to add `ATan2.as_sqlite()` targeting SpatiaLite >= 4.3.0 resolved this issue for me locally and not on Jenkins. Could you confirm the version of SpatiaLite on the xenial and bionic boxes, @timgraham? (Maybe a build just needs to be re-triggered.)
`cls.staff_user = User.objects.create_user(username='user', password='secret', email='user@example.com', is_staff=True)`
I think it's something like: 'browser' contains the first browser to run the tests against and 'browsers' will contain the rest of the browsers (if more than one are requested).
flow 'when' to previous line
how about ```suggestion installed_packages = defaultdict(list) ```
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Also, see ticket trac, it seems 2396 is obsolete.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
You can remove this since it's handled in module_utils/aws/core.py: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/aws/core.py#L98-L100
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Oh, I see. `run_commands()` runs list of commands and returns list of results.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Use another lookup instead of `epoch` e.g. `second`.
Please use a single quote.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
I think you meant to use `self.get_context()`.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
This break will be unnecessary if the loop gets dropped
Ah I see, okay then.
I guess these could be merged by doing a ```python self.assertEqual( qstr.count("LIMIT 1"), 3 if connection.features.supports_limiting_in_compound else 1 ) ```
Why not just pass the target directory? This is all your need to perform this task.
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
The optional trailing dot may "protect" an ending dash -- `xn--.` passes this. Is this intended? If not, switch the last two lines.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
mandatory msg is missing
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
If `self._module.params['name'] is None`, this will never match and the module fails.
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
You will need to include the OAUTH_TOKEN environment variable also.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Yes, 'msg' key and value should always present on *_exit() calls
mandatory msg is missing
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Instead of deriving from `CryptHandler`, why not pass `CryptHandler` as a constructor argument? Otherwise, I don't see why you need both a `CryptHandler` and a `Conditions` instance in the main module code (since you can use the `Conditions` instance for both).
Yes, that's a better solution. BTW, why not put all functionality calling `cryptsetup` into `CryptHandler`, and giving `ConditionsHandler` a reference to `CryptHandler` for the calls it needs to do? Then there's a more clear separation into `CryptHandler`, which does all the `cryptsetup` calls, and `ConditionsHandler`, which contains most of the decision logic.
ditto on `.` in character groups
ditto on `.` in character groups
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
ditto on `.` in character groups
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
ditto on `.` in character groups
ditto on `.` in character groups
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I would `return match is not None` or `return bool(match)` rather than this
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
I tried to fix these in #12645 but clearly that hasn't carried over to docstrings 🤔
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
(Additional whitespaceânumber of spaces not multiple of 4.)
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like {0}
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Please create dicts immediately with the values you already have.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
I think we should be consistent and use double-quotes.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
no need to specify required=False or type=str as these are defaults
chop blank line
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
+1 it's better to just patch `time.time`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
(Additional whitespaceânumber of spaces not multiple of 4.)
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This argument is only accepted in Python 3, it would not work with Python 2.
Please make `update_fields` and `unique_fields` have `None` instead of using mutable defaults and do the following inside the function: ```python update_fields = update_fields or [] unique_fields = unique_fields or []
And `\r` or `\n` -- I dunno if Django protects from header injection
This argument is only accepted in Python 3, it would not work with Python 2.
Please make `update_fields` and `unique_fields` have `None` instead of using mutable defaults and do the following inside the function: ```python update_fields = update_fields or [] unique_fields = unique_fields or []
And `\r` or `\n` -- I dunno if Django protects from header injection
This argument is only accepted in Python 3, it would not work with Python 2.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Please add a trailing comma: ```suggestion update_conflicts=False, update_fields=None, unique_fields=None, ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
chop blank line
+1 it's better to just patch `time.time`
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
prefer hanging indent style with 1 arg per line
`band_input`, you don't get much by saving one char :-)
I think `enumerate` would work here
Isn't this equivalent? ``` if (start and start < 0) and (end and end > 0): raise ... ```
How about omitting it until we have a use case? That will save writing tests and docs for a theoretical feature. :-) From a readability point of view, writing a `re_path()` that mixes regexes and converters in the string, and then has to initialize and pass converters in the URLconf sounds nasty and not something to encourage!
I'm going to be a +1 to just dropping `converters`
I think this line isn't needed, tests seem to work fine without it.
~if not keeping encryption, remove the __ansible_vault key, just assign the value directly~ nmvd, misread the if to the opposite ...
Maybe @felixxm or @carltongibson can guide, but I believe it'd be good practice to use a `warnings.warn` in `__init__`, although a deprecation timeline has not been determined for `django.contrib.postgres.field.JSONField`.
I think this line isn't needed, tests seem to work fine without it.
chop trailing newline (check code with flake8 to see a couple other minor formatting things)
I can see a decent reason to use the `DjangoJSONEncoder` as the default as it gives us `Decimal` and `datetime` support for free. These are very common use cases for django sites (especially datetime!).
Yes, that's the idea. I'm not sure if we need to include a long list of schemes though. As Claude suggested on the ticket, some minimal validation like alphanumeric + period is probably sufficient. That way we don't have to maintain a list. Any projects that require such a list can supply it.
Changing this list is outside the scope of this ticket and also backwards-incompatible.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Are these style changes intentional? Somehow they don't look like that.
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
The optional trailing dot may "protect" an ending dash -- `xn--.` passes this. Is this intended? If not, switch the last two lines.
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
It'd be nice to hint users about what version is not old.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
To be consistent with other modules each of the options should be on a single line (unless they have many choices)
`band_input`, you don't get much by saving one char :-)
`has_key` is deprecated, use `if 'origin' in ds_input:` instead. Also please replace other occurrences in the patch.
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
`type(self)(...)` looks more Pythonic to me.
I think a simple `django.template.Context` will do here.
Unless I'm missing something you don't need to define a class and nest an instance of it in a list to reproduce your use case. Simply passing a callable that throws an exception should do. e.g. ``` python engine = Engine(loaders=[ ('django.template.loaders.locmem.Loader', { 'child': '{{ raises }}', }), ], debug=False) def raises(): raise Exception engine.from_string('{% include "child" %}').render(Context({'raises': raises})) ```
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
No need for get(key, None) as None is the default fix also for following get()
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
This one as well.
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
Again, imports at the top of the file
It's a `@staticmethod`/pure function
Do we have PEP257 linter in CI? It should've failed here.
Again, imports at the top of the file
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
add space after `(w[1])`
Maybe this should be a class docstring :thinking:
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Exception handling here too.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
`[None:start]` works the same as `[:start]`: ```suggestion final_pattern += pattern[prev_end:start] ```
Exception handling here too.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
please check code with flake8 (`E231 missing whitespace after ','`)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
use `self.MAX_FILES` instead of 999999
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Required=false are implicit could you remove them ? Default=None too in case of string
Why do you wait to fail ? I think you must fail in "main"
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why do you wait to fail ? I think you must fail in "main"
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why do you wait to fail ? I think you must fail in "main"
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion self.headers = { 'Content-Type': "application/json" } ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be moved to `check_dict` method.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
Please use `module= AnsibleModule(` I guess it is a convention
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
What is the reason of change? it would break the backwards compatibility.
Use single quotes consistently.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion creation_date=dict(type='str', required=False), ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion creation_date=dict(type='str', required=False), ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion creation_date=dict(type='str', required=False), ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
I think we should be consistent and use double-quotes.
This was already there, but we likely want to change it so we don't hold the lock while unsubscribing.
We are holding the lock while connecting/subscribing.
Are you tracking this, or should a new issue be created? I've merged this PR.
We are holding the lock while connecting/subscribing.
Are you tracking this, or should a new issue be created? I've merged this PR.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This was already there, but we likely want to change it so we don't hold the lock while unsubscribing.
Are you tracking this, or should a new issue be created? I've merged this PR.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This was already there, but we likely want to change it so we don't hold the lock while unsubscribing.
Are you tracking this, or should a new issue be created? I've merged this PR.
Required=false are implicit could you remove them ? Default=None too in case of string
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This was already there, but we likely want to change it so we don't hold the lock while unsubscribing.
Are you tracking this, or should a new issue be created? I've merged this PR.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
Use `missing_required_lib` from `ansible.module_utils.basic`
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
In the `exit_json`, you should also return `changed` and `state`.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
Use `missing_required_lib` from `ansible.module_utils.basic`
In the `exit_json`, you should also return `changed` and `state`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Use `missing_required_lib` from `ansible.module_utils.basic`
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion password=dict(type='str', required=True, no_log=True), ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I guess it should be `_compare_salted_tokens` (rather than "padded") to fix build errors.
this line could go in "else" of try/except/else
It would be better to factor out shared elements such as these variables and MultipleLocaleActivationTests setUp/tearDown into a `base.py`.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
I would call `split()` once only. ``` entry = x.split() if len(entry) > 0: ldp = {} ldp['neighbor'] = entry[1] ldp['source'] = entry[3] ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
I would call `split()` once only. ``` entry = x.split() if len(entry) > 0: ldp = {} ldp['neighbor'] = entry[1] ldp['source'] = entry[3] ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
I would call `split()` once only. ``` entry = x.split() if len(entry) > 0: ldp = {} ldp['neighbor'] = entry[1] ldp['source'] = entry[3] ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
I would call `split()` once only. ``` entry = x.split() if len(entry) > 0: ldp = {} ldp['neighbor'] = entry[1] ldp['source'] = entry[3] ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
When `hostname_preference` is equal to `name`, there is no need to define `ansible_host`.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
use `self.MAX_FILES` instead of 999999
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
That's a really interesting piece of information I did not know.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
This may apply to some of the other PRs in flight, as well as some of your existing modules.
ok, just something for consideration, I trust your/the community's judgement on it
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
That's a really interesting piece of information I did not know.
Actually, better would be to move this to the toplevel as a regular function
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This syntax is not supported in python2.6. You will need to index your format like {0}
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
In the `exit_json`, you should also return `changed` and `state`.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
It's more about readability. When you see two if-branches it's different than just one and then following scenario. Plus it's less indentation, which is less important in this simple case, but in general helps to have such habit :)
self._connected is set by CliBase.connect(), shouldn't need to specify it here
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
Usually, testing private interfaces doesn't make sense.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Isn't `raise` missing there ? Calls to `str` are useless.
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
For the get('organization') request response? I'm assuming the list of 'organizations' and 'users' will always have a single item? (at least as used with a oauth token as used here). Will that depend on the type of api_token? (ie, if there is something like a organization or group level api_key, would the results be different? If so, could be useful to explain in the docs)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Are both host groups really needed? Does the one that contains ':' handle both? We have regex in other places in the project that do similar parsing we may want to keep in sync: - https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/utils/Utils.java#L53 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/BrokerEndPoint.scala#L27 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/EndPoint.scala#L29
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
This bare `except` will catch anything, including the exception that marks a failing test, I think :-) Better to use `assertRaises` and explicitly assert that the specific expected uncaught exception bubbles up.
This class does not need to live inside this method.
This import should be at the top of the file, and is likely not python 2/3 compatible
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
Please ignore, my suggestion is invalid syntax.
indentation doesn't look right here
Indentation doesn't look right here.
TIL that character classes also work inside `[]` :D
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This is unnecessary as error checking is handled in `get_hosts_by_host_name` as well. I think you can remove it completely with the whole `is_host_exist` method to save a few lines of code. Basically you want to do the same as with `get_hosts_by_ip`.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
This doesn't seem to be necessary to reproduce the bug. Just refreshing the page without making any changes caused the select options to clear.
Again, imports at the top of the file
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This is unnecessary as error checking is handled in `get_hosts_by_host_name` as well. I think you can remove it completely with the whole `is_host_exist` method to save a few lines of code. Basically you want to do the same as with `get_hosts_by_ip`.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Please add `monitoring` and pass this argument to the request.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`default=False` (same for others)
Please add `monitoring` and pass this argument to the request.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`default=False` (same for others)
This should verify the output.
Use single quotes.
You should also add an assertion for the imports provided in the second value of the tuple.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
This break will be unnecessary if the loop gets dropped
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I think we should be consistent and use double-quotes.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This break will be unnecessary if the loop gets dropped
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I guess you also need the name? ```suggestion - If I(state=absent) other options will be ignored except of I(name) and I(schema). ```
```suggestion I(minvalue), I(maxvalue), I(start), I(cache), I(cycle), I(rename_to), ```
Yeah, I found someting ;) ~~~diff - hetzner_pass: bar + hetzner_password: bar ~~~
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
I think we should be consistent and use double-quotes.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
It might be smarter to validate the token first and only modify the session + redirect if it's valid. Otherwise it makes it really easy to create a session just by GET'ing a url (possible DoS vector). It also means you can't pass `accounts/password_reset` as the token and take advantage of our `request.path.replace()` code. It probably means validating the token twice, which is slightly slower. Seems fine to me if an invalid token gets leaked.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
The 1.29 API change might only refer to allowing to *filter* by scope, though I'd be surprised that the API only allows to filter when you can't *create* a network with a given scope. It looks to me more and more like the docker API docs are kind of a mess ;-) Anyway, going to 1.30 is probably safe. If someone reports it also works with 1.29, we can still change it back.
```suggestion self.assertTrue(self.temp_dir.joinpath("path", "to", "test.file").exists()) ```
If the line length bothers you, I think dropping "database" would be fine.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Required=false are implicit could you remove them ? Default=None too in case of string
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
@urbaniak yes you are right, nevermind
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
@urbaniak yes you are right, nevermind
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I'd rename `subminor` to `patch`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
We should also change `\d+` to `[0-9]+` in all cases.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
We generally use `absent` and `present` for `state`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
We generally use `absent` and `present` for `state`
Net new tests should be `pytest` style tests.
Typo in `module_utils`.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
We generally use `absent` and `present` for `state`
Maybe this should be a class docstring :thinking:
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
We generally use `absent` and `present` for `state`
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Make a common method in class to get url and return json loads response.
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
Create a new method on the `GitLabServices` class to do the creation + saving job
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
should this be: pytestmark = pytest.mark.skip('skipping as missing required netapp_lib')
pytest.mark.skip Though I'm surprised we did not see any bot error.
That's a really interesting piece of information I did not know.
Make a common method in class to get url and return json loads response.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Create a new method on the `GitLabServices` class to do the creation + saving job
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Create a new method on the `GitLabServices` class to do the creation + saving job
The return msg should be indentical in normal and check mode
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
We generally use `absent` and `present` for `state`
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
A `minimumInputLength` of zero is [the default for Select2](https://github.com/select2/select2/blob/120672dce79b6862cb17a966af06e0617a404b58/src/js/select2/defaults.js#L363).
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
A `minimumInputLength` of zero is [the default for Select2](https://github.com/select2/select2/blob/120672dce79b6862cb17a966af06e0617a404b58/src/js/select2/defaults.js#L363).
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
We don't need the extra variable here. ```suggestion client.mset({k: self._serializer.dumps(v) for k, v in data.items()}) ```
We could flatten this? ```suggestion return default if value is None else self._serializer.loads(value) ```
Don't use `.items()` if you don't need the values. ```suggestion # Set timeout for each key individually as .mset() doesn't support # setting the timeout for all keys at the same time. for key in data: if timeout is None: client.persist(key) else: client.expire(key, timeout) ```
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Use single quotes consistently.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Where does the RHS decrypt come from? It appears to be undefined here. Needs to be passed to _assemble_from_fragments as an kwarg I assume.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
IMO we should check options against PostreSQL names.
return here -- no need for intermediate variables
append instead of creating a new list ```suggestion options_params.append(', '.join(options)) ``` All off the above could also be reduced to ```python options_params.append(', '.join( '%s=%s' % (option, psycopg2.extensions.adapt(value).getquoted().decode()) for option, value in options.items() ))
param -> params
I'd chop this blank line since the } on its own line is providing whitespace.
To keep the diff a bit cleaner, I wouldn't make this unrelated whitespace change.
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
In Ansible, we are ok with lines that are 160 characters wide. No need to wrap here. ```suggestion executable = module.get_bin_path(module.params['executable'], required=True) ```
I don't think extending `Subquery.__init__` to allow any `QuerySet` some method (e.g. `filter`, `order_by`, ...) is desirable.
chop "one of" add comma before "or"
IMO it will me more readable to move `base` outside, also we resolve `F()` expressions twice (line 28 & 29), so maybe, e.g. ```python if isinstance(expression, str): expression = F(expression) if isinstance(expression, F): expression = base.resolve_expression(query=query, simple_col=True) else: expression = expression.resolve_expression(query=query) ``` Moreover I think we don't need to iterate twice over the expressions: ```python for expression, operator in self.expressions: ... expressions.append('%s WITH %s' % (sql % params, operator) return expressions ```
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
Ok I get it, `compiler.compile(Value(5))` would return something like `'%d', (5,)`.
I feel like it should be `_delete_unique_sql`'s decision to do the bool casting. Maybe some backends will need access to the condition to appropriately delete it. Lets just pass `condition=condition` and let database backends do `if condition`.
No need for `keys()` here.
I'd do ```suggestion if not ignore_errors: raise ```
It's actually missing `--ignore-certs` CLI arg that implies `validate_certs=True` according to the code I saw...
No need for `keys()` here.
I'd do ```suggestion if not ignore_errors: raise ```
It's actually missing `--ignore-certs` CLI arg that implies `validate_certs=True` according to the code I saw...
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
The flake8/test failure is because the above `help` is missing a closing parenthesis, hence a `SyntaxError`. You can always repush to the branch to rerun the tests.
I admit Django still has much code looking like that, but it should be safe to simply use `if options['empty']:` below without first pushing the result in `self`. Having the value on `self` might make sense when we want to use the value in other methods. Same for `options.get('help', False)`, as we are using the parser in both `call_command` and `run_from_argv`, we can be sure that `'help'` is in the options dictionary, so `options['help']` is fine.
No need for `keys()` here.
I'd do ```suggestion if not ignore_errors: raise ```
It's actually missing `--ignore-certs` CLI arg that implies `validate_certs=True` according to the code I saw...
No need for `keys()` here.
I'd do ```suggestion if not ignore_errors: raise ```
It's actually missing `--ignore-certs` CLI arg that implies `validate_certs=True` according to the code I saw...
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
Ok I get it, `compiler.compile(Value(5))` would return something like `'%d', (5,)`.
I feel like it should be `_delete_unique_sql`'s decision to do the bool casting. Maybe some backends will need access to the condition to appropriately delete it. Lets just pass `condition=condition` and let database backends do `if condition`.
ok, just something for consideration, I trust your/the community's judgement on it
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Line 355 to 368 are unused.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Line 355 to 368 are unused.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
ok, just something for consideration, I trust your/the community's judgement on it
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Maybe this should be a class docstring :thinking:
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`delete` and `create` are not valid states
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
TIL that character classes also work inside `[]` :D
I'd rename `subminor` to `patch`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
TIL that character classes also work inside `[]` :D
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Line 355 to 368 are unused.
This is not required since we are already doing this in individual APIs.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
TIL that character classes also work inside `[]` :D
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
a leftover here which can be removed
Valid point. Feel free to change the decorator in a separate commit.
Can you switch to the same logic as in the decorator: `if isinstance(..., (list, tuple)): ...`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
`_postprocess_border_mode` should be part of `_postprocess_conv2d_output`, it doesn't need to be its own function.
`border_mode` is not required. The output is of value : (batch size, num_input_channels, input row size * row ratio, input column size * column ratio) So fi the ratio is good, everything should be.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Should be "Can't detect any" rather than "none" I think.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Should be "Can't detect any" rather than "none" I think.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion creation_date = module.params['creation_date'] or datetime.datetime.utcnow().isoformat() + 'Z' ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
This needs to be updated with `api_url`
There seems to be an assumed structure of what is returned by the API endpoint, operating under the pretense that the structure won't change since the API is versioned, is there any chance that this assignment could fail and cause an unhandled exception? (similar question for other functions doing similar things below)
@sdodsley sounds good, thank you for the clarification
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In theory a locale dependant pattern could be provided and `locale.setlocale` be called but this is really unlikely.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion def validate_wwn(module): ```
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
I think we should be consistent and use double-quotes.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like {0}
Move this to line 175
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
It would be nice to see the same msg in exit_json.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like {0}
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
is this limited to TLDs? it seems all labels are limited to 63 characters.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Right, would this work: ```python if module_checkmode: payload = None else: payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ``` I prefer to use the same paths for checkmode and without. I think it is more future-proof when changes are being made.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
If `self._module.params['name'] is None`, this will never match and the module fails.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I guess the `add_argument` could be `action='store_false', dest='uses_https'`
Yup, this extra line won't hurt, IMHO.
I nearly missed the `not` before `options['sitemap_uses_http']` while reading.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
The other formats.py seem to use `'\xa0'`
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
The other formats.py seem to use `'\xa0'`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
```suggestion display.vvv(u"No connection ot reset: %s" % to_text(stderr)) ``` ```suggestion display.vvv(u"No connection to reset: %s" % to_text(stderr)) ```
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
i've seen plenty of 'dummies', i just have not seen a pattern to them.
```suggestion display.vvv(u"No connection ot reset: %s" % to_text(stderr)) ``` ```suggestion display.vvv(u"No connection to reset: %s" % to_text(stderr)) ```
kushal found that check_call is 2.5 ; check_output is what is 2.7.
<nod> But it seems like it's vulnerable to both symlink attacks and denial of service attacks unless it's randomized. (if it is randomized, it is resistant to but not immune to DOS. Using mkstemp should solve symlink attacks.)
Mind putting this magic value into a constant with a descriptive name? I'd read much better if it was ```suggestion sys.exit(RC_CLI_INIT_FAILURE) ``` or something like that.
Complement the docstring adding the parameters, might be useful (to the other functions as well)
print can be replaced using sys.exit Except this looks good to me.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
TIL that character classes also work inside `[]` :D
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
else is unnecessary here because we raise an exception before
TIL that character classes also work inside `[]` :D
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
If the result was a 4xx or 5xx then I think this fails.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
this should use the new API without hardcoded id now
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Why capitalized? hookHelper or hook_helper
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
I think it is better to pass module as argument to build_xml() and handle lxml install check-in module_utils instead of having it in each module
Maybe this should be a class docstring :thinking:
Group names are supposed to be named similar to variables, i.e. alphanumeric and underscore. So at least the prefix should adhere to that. Besides that, look at this PR: https://github.com/ansible/ansible/pull/52748
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
I would default vars to `{}`
`client.nodes.get()` can also raise `APIError`s on failure.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
return AnsibleParserError so other inventory sources can continue
Group names are supposed to be named similar to variables, i.e. alphanumeric and underscore. So at least the prefix should adhere to that. Besides that, look at this PR: https://github.com/ansible/ansible/pull/52748
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
You can add this^ line before `if` statement, and remove the exactly same code from line 135.
host_storage.type == otypes.StorageType.FCP
Their should be a variable you can read in, rather than hardcoding this
I'd probably prefer a single assignment with a conditional only for the argument. It would probably look cleaner this way: ```suggestion is_openbsd = u"OpenBSD" == to_text(platform.system(), errors='surrogate_or_strict') bcrypt_crypt_id = '2b' if is_openbsd else '2a' algorithms['bcrypt'] = algo(crypt_id=bcrypt_crypt_id, salt_size=22, implicit_rounds=None) ```
I prefer checking for the expected syntax since "NotIn" can fail in all sorts of ways (for example, if you have a typo in the string).
Their should be a variable you can read in, rather than hardcoding this
I'd probably prefer a single assignment with a conditional only for the argument. It would probably look cleaner this way: ```suggestion is_openbsd = u"OpenBSD" == to_text(platform.system(), errors='surrogate_or_strict') bcrypt_crypt_id = '2b' if is_openbsd else '2a' algorithms['bcrypt'] = algo(crypt_id=bcrypt_crypt_id, salt_size=22, implicit_rounds=None) ```
I prefer checking for the expected syntax since "NotIn" can fail in all sorts of ways (for example, if you have a typo in the string).
This block would be a bit more legible, if you checked use_hostnames, then assigned to a temp variable whichever label the user has requested, and then appended that. Something like (pseudopython): ``` this_host = host if not use_hostnames: this_host = ip if frontend: frontends.append(this_host) else: backends.append(this_host) ``` This is admittedly a style thing, but I think it would be more readable/shorten a few lines.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
This is unnecessary as error checking is handled in `get_hosts_by_host_name` as well. I think you can remove it completely with the whole `is_host_exist` method to save a few lines of code. Basically you want to do the same as with `get_hosts_by_ip`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
remove extra newline
check that -> and that (no comma needed since the two clauses are independent)
Please remove empty line.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
use a single loop? ~~~python for server in _retrieve_servers(api_key): server = Vultr.normalize_result(server, SCHEMA) .... ~~~ ~~~
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
use a single loop? ~~~python for server in _retrieve_servers(api_key): server = Vultr.normalize_result(server, SCHEMA) .... ~~~ ~~~
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
use a single loop? ~~~python for server in _retrieve_servers(api_key): server = Vultr.normalize_result(server, SCHEMA) .... ~~~ ~~~
Exception handling here too.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Line 355 to 368 are unused.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Line 355 to 368 are unused.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Line 355 to 368 are unused.
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Line 355 to 368 are unused.
How about splitting up the PR into multiple ones? At least one for the cases where semantics have to change (probably best one PR per module, because it will need discussion for every one of them, and having one module per PR increases the chance that some of them will be merged, even if some others are not or take forever), and one for the "obvious" changes.
Also, this error message is now wrong.
You are changing semantics here. Originally, errors while opening the file were ignored, the function simply returned. Errors while reading the file's content were escalated, and errors while closing the file were handled (by failing the module). Now, you're handling **all** errors by failing the module. You should definitely **not** handle file not found errors this way! (No idea about other errors while opening the file.)
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
You have some syntax errors in this `if` statement.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
Exception handling here too.
```suggestion elif date_string.match(self.when): ```
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
You don't need a lambda here. Also, don't break lines with `\`.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Let's make `write` a keyword-only argument. ```suggestion def get_client(self, key=None, *, write=False): ```
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_PROFILE') ```
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_API_VERSION') ``` Will not work for azure-mgmt-resource before 1.3.0 if you want multi-api support there as well.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Any problem with: ``` @property def media(self): ```
Exception handling here too.
Indentation level of `return` statement need to be increased.
I'd probably prefer a single assignment with a conditional only for the argument. It would probably look cleaner this way: ```suggestion is_openbsd = u"OpenBSD" == to_text(platform.system(), errors='surrogate_or_strict') bcrypt_crypt_id = '2b' if is_openbsd else '2a' algorithms['bcrypt'] = algo(crypt_id=bcrypt_crypt_id, salt_size=22, implicit_rounds=None) ```
Switching to `assertTrue()` seems incorrect.
The problem is that you start the connection before we know the connection details for sure, so getting the data earlier will make it even worse. In some cases (when all is known before task templating) you should have no issues as play_context carries the correct info, but if you need info to change at the task, or worse, loop/delegation levels you'll run into trouble much sooner. Most of the time this problem can be ignored as plays tend to reuse the same information w/o changing it, specially networking ones. As you note, since we are passing the connection information and using set_options/get_option on them, we should be able to ignore most of the play_context data, but this requires all connection plugins to correctly source the data (all those in core do, but many of those in collections do not). Why I was planning to add deprecation notices to play_context soon.
ah, I thought this would already made by add_group().
@resmo it is, but they are not using the results to compare, so same group will never be in inventory.groups (which you don't need to do since add_group already checks this).
Any problem with: ``` @property def media(self): ```
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Yes, I know. I'll leave it to Aymeric for a second opinion.
Any problem with: ``` @property def media(self): ```
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
return without intermediate `etags` variable
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
I think, unless you have a good reason, that you should use stack_params here and four lines down instead of module.params. Honestly I wish we didn't have to push module around.
Yeah, I know you need module. That was just a general musing.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
I think, unless you have a good reason, that you should use stack_params here and four lines down instead of module.params. Honestly I wish we didn't have to push module around.
Yeah, I know you need module. That was just a general musing.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
I'm not sure this needs to be changed. Testing the default value seems useful.
On balance I will leave this one as it is.
I think keeping the explicit `process_response()` call here would make sense. By changing to `__call__()` we're running through `process_request()`, which is not a no-op, which is perhaps fine but it's subtly changing the intent/behaviour of the test. (I guess this is something we'd have to think about removing the `process_x()` hooks, but not in this PR) Same for line 677 below. **Update**: Tests in `csrf_tests` are more explicit about this... (So maybe the small change here is OK)
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Now this can just point to the new FAQ entry.
Link on a single line, otherwise it won't work (we don't enforce line length)
Just say that it defaults to the Keras directory. The rest of the description is not directly related to this function.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
the tests should not really be for hostfile, as we are going to remove it. a mock setting with 2 entries would test the functionality, not the specific setting
Typo in `module_utils`.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
the tests should not really be for hostfile, as we are going to remove it. a mock setting with 2 entries would test the functionality, not the specific setting
Typo in `module_utils`.
Now this can just point to the new FAQ entry.
In general your docstrings have an indentation problem, the lines after the first one should be indented by 1 level (4 spaces).
Just say that it defaults to the Keras directory. The rest of the description is not directly related to this function.
Now this can just point to the new FAQ entry.
In general your docstrings have an indentation problem, the lines after the first one should be indented by 1 level (4 spaces).
Just say that it defaults to the Keras directory. The rest of the description is not directly related to this function.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`kwargs` parameter is neglected, all subclass context data is ignored
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`kwargs` parameter is neglected, all subclass context data is ignored
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I'd rename `subminor` to `patch`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
okay, but it still find it misleading from reader's point of view. i think, it's important to make it better maintainable. P.S. I've hid concat based implementation, once noticed that it's not only about lists (which was not obvious).
Even better: ```python for i in loop: ind, val = i if val == omit_token: continue if isinstance(val, (dict, list)): val = remove_omit(val, omit_token) new_args = [val] + new_args[1:] ```
Oh, and it's `KeyError` for dict.
I think we should be consistent and use double-quotes.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This break will be unnecessary if the loop gets dropped
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
Please drop that new line
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
Please drop that new line
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Can we use `subTest()` for these three tests? ```python with self.subTest(http_host=http_host, http_origin=http_origin): ... ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Please drop that new line
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Please drop that new line
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Please drop that new line
Cool. Thanks. Let me know once done.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Please drop that new line
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This isn't needed because of the ```__metaclass__ = type``` boilerplate
`S_IROTH` is "other read", not "owner read".
Is it worthwhile taking a copy of the text utils we already have in Ansible. They have a `nonstring` option to define things like what to do when a None object is being encoded.
This isn't needed because of the ```__metaclass__ = type``` boilerplate
`S_IROTH` is "other read", not "owner read".
Is it worthwhile taking a copy of the text utils we already have in Ansible. They have a `nonstring` option to define things like what to do when a None object is being encoded.
Is it worthwhile taking a copy of the text utils we already have in Ansible. They have a `nonstring` option to define things like what to do when a None object is being encoded.
`S_IROTH` is "other read", not "owner read".
We have removed checks like this in the past. One thing to note is that the key need not exist on the filesystem to work if it has already been loaded into the agent. We would need to ensure that missing files are allowed.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
User could set `user_data` parameter to `None`, in such case exception still occurs.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
We don't need to add `named` branches everywhere. I'd return `m` in the tuple and use it when needed. Moreover, we could use a generator instead of list. IMO, `_find_group()` is unnecessarily complicated and unreadable. I'd move `get_group_start_and_end_indices()` to a module hook `_get_group_start_end()`: ```python def _get_group_start_end(start, end, pattern): unmatched_open_brackets, prev_char = 1, None for idx, val in enumerate(pattern[end:]): if val == '(' and prev_char != '\\': unmatched_open_brackets += 1 elif val == ')' and prev_char != '\\': unmatched_open_brackets -= 1 prev_char = val if unmatched_open_brackets == 0: return start, (end + idx + 1) ``` and simplify `_find_groups()` to a few lines generator: ```python def _find_groups(pattern, group_matcher): prev_end = None for m in group_matcher.finditer(pattern): if indices := _get_group_start_end(m.start(0), m.end(0), pattern): start, end = indices if prev_end and start > prev_end or not prev_end: yield start, end, m prev_end = end ``` now you can use `m` when needed, e.g.: ```python def replace_named_groups(pattern): group_pattern_and_name = [ (pattern[start:end], match[1]) for start, end, match in _find_groups(pattern, named_group_matcher) ] for group_pattern, group_name in group_pattern_and_name: pattern = pattern.replace(group_pattern, group_name) return pattern ... def replace_unnamed_groups(pattern): group_start_end_indices = _find_groups(pattern, unnamed_group_matcher) final_pattern, prev_end = '', None for start, end, _ in group_start_end_indices: if prev_end: final_pattern += pattern[prev_end:start] final_pattern += pattern[:start] + '<var>' prev_end = end return final_pattern + pattern[prev_end:] ... ```
This is inconsistent but I think the patch can land as is and the test be modified later on based on the direction of [#24082](https://code.djangoproject.com/ticket/24082).
fields -> options comma after auto_now_add
At first sight it could be simplified to: ``` [option not in [None, False] for option in mutually_exclusive_options].count(True) ``` But I have a feeling even more simplification might be possible. Note that we can't simply cast default to bool, which would make this even simpler, as some valid dates evaluate to false: https://mail.python.org/pipermail/python-ideas/2014-March/026446.html
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
one more for the single line version
```suggestion self.module.fail_json(msg='Unable to get required signing key', rc=rc, stderr=stderr, command=command) ```
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
one more for the single line version
```suggestion self.module.fail_json(msg='Unable to get required signing key', rc=rc, stderr=stderr, command=command) ```
I think we should be consistent and use double-quotes.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
`try/finally` should be a bit smaller. If there's an exception before `form.save()` the photo won't exist so there's no need to cleanup. I'll make this change and merge it.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
This introduces a different race condition, file can now be looked at in 'intermediate' state.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
chop blank lines
`try/finally` should be a bit smaller. If there's an exception before `form.save()` the photo won't exist so there's no need to cleanup. I'll make this change and merge it.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
This introduces a different race condition, file can now be looked at in 'intermediate' state.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
chop blank lines
Use `url = reverse('password_reset_confirm', kwargs={'uidb64': uidb64, 'token': token}))` to avoid the funky indentation (we prefer hanging indent).
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
TIL that character classes also work inside `[]` :D
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
Line 355 to 368 are unused.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
```suggestion chapter = Chapter.objects.create(title='testchapter', book=book) ```
We could reuse `test_readonly_foreignkey_links()`, e.g. ```diff diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py index a8524379f8..7e0a3a3415 100644 --- a/tests/admin_views/tests.py +++ b/tests/admin_views/tests.py @@ -5093,7 +5093,7 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase): response = self.client.get(reverse('admin:admin_views_choice_change', args=(choice.pk,))) self.assertContains(response, '<div class="readonly">No opinion</div>', html=True) - def test_readonly_foreignkey_links(self): + def _test_readonly_foreignkey_links(self, admin_site): """ ForeignKey readonly fields render as links if the target model is registered in admin. @@ -5110,10 +5110,10 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase): user=self.superuser, ) response = self.client.get( - reverse('admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)), + reverse(f'{admin_site}:admin_views_readonlyrelatedfield_change', args=(obj.pk,)), ) # Related ForeignKey object registered in admin. - user_url = reverse('admin:auth_user_change', args=(self.superuser.pk,)) + user_url = reverse(f'{admin_site}:auth_user_change', args=(self.superuser.pk,)) self.assertContains( response, '<div class="readonly"><a href="%s">super</a></div>' % user_url, @@ -5121,7 +5121,7 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase): ) # Related ForeignKey with the string primary key registered in admin. language_url = reverse( - 'admin:admin_views_language_change', + f'{admin_site}:admin_views_language_change', args=(quote(language.pk),), ) self.assertContains( @@ -5132,6 +5132,12 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase): # Related ForeignKey object not registered in admin. self.assertContains(response, '<div class="readonly">Chapter 1</div>', html=True) + def test_readonly_foreignkey_links_default_admin_site(self): + self._test_readonly_foreignkey_links('admin') + + def test_readonly_foreignkey_links_custom_admin_site(self): + self._test_readonly_foreignkey_links('namespaced_admin') + def test_readonly_manytomany_backwards_ref(self): """ Regression test for #16433 - backwards references for related **objects** ```
IMO checking how `empty_form` is rendered is not necessary. It's enough to check `empty_permitted`, e.g. ```suggestion self.assertIs(formset.empty_form.empty_permitted, True) ```
I think it would be better to put these tests in `tests/auth_tests` unless there's some reason that's not feasible.
Please rebase your branch. Master now supports Python 3 only, so `unicode_literals` may be removed.
I don't think you need `absolute_import` here - you don't need to to do a relative `.models` import a few lines down. You would need it to ensure that `import models` would fail to import the relative module.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Required=false are implicit could you remove them ? Default=None too in case of string
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
chop the blank lines before each attribute
remove extra newline
I'm not too keen on beginning each warning with "In your url patterns, ..". How about "Your url patterns .." ? "Your url patterns have used `include` with a regex containing a '$'. " .. "Your url patterns have a regex beginning with a '/'." .. "Your url patterns have a pattern with a name containing a ':'." ..
I thinking removing APP_DIRS from TEMPLATES (since it defaults to False) is a better suggestion than setting it to False.
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
Cool. Thanks. Let me know once done.
As long as the input and ouput of the module are in snail_case, I don't see any issue.
Why capitalized? hookHelper or hook_helper
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
please add `no_log=True` to avoid leaking the password in the logs.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Yes, I know. I'll leave it to Aymeric for a second opinion.
Generally we don't treat usernames as secrets, so no need to mask
Running the entire test suite I could reproduce the error, but not if only running `django.contrib.gis`. Not sure exactly the cause but this code seems suspicious as we leave a different model admin registered for other tests.
Please use 'msg' for returned messages, this is a standardized return value.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
no need to specify required=False or type=str as these are defaults
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion I(minvalue), I(maxvalue), I(start), I(cache), I(cycle), I(rename_to), ```
I guess you also need the name? ```suggestion - If I(state=absent) other options will be ignored except of I(name) and I(schema). ```
Perfect, we should keep msg as well with message.
Maybe this should be a class docstring :thinking:
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Shouldn't use a mutable container as default arg in python. If you ever add to the container you then find that you're sharing a single opy of that container everytime the function in python. You can do one of these two instead: ``` python # If you don't need to add to the container now. This just prevents doing something stupid when the code is changed in the future. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=tuple()): # if matches needs to be a mutable container. This creates a fresh list everytime the function is called. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=None): if matches is None: matches = [] ```
This applies to the other functions where a list is the default value as well.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
This applies to the other functions where a list is the default value as well.
Shouldn't use a mutable container as default arg in python. If you ever add to the container you then find that you're sharing a single opy of that container everytime the function in python. You can do one of these two instead: ``` python # If you don't need to add to the container now. This just prevents doing something stupid when the code is changed in the future. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=tuple()): # if matches needs to be a mutable container. This creates a fresh list everytime the function is called. def finish(module, tree, xpath, namespaces, changed=False, msg="", hitcount=0, matches=None): if matches is None: matches = [] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Maybe output the bad value here as well, to help the user find out which one was wrong.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Maybe output the bad value here as well, to help the user find out which one was wrong.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
We should probably rename this. Revisiting this code... this is a pretty special-case function as well. I wonder if it should be a private function inside of parameters.py (basic.py can make it public as part of its API but the idea would be that we don't expect any new code to use it.)
The reason it's very niche is that it is specially adapted to only return values which we can remove from output for no_log. ie: if there was a parameter like secure=[True|False] and that was marked no_log in the argument_spec for some reason, we don't want to hide True or False in all of our output (that could actually tell an attacker what the value of secure was as they could see whether True or False was being hidden in other parameters)
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Not supported on Python 3.4.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
check that -> and that (no comma needed since the two clauses are independent)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
I think it's not pylint itself, but our own checks...
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
@Dref360 Minor typo. This needs to be: ``` if self.preprocessing_function: x = self.preprocessing_function(x) ```
Using `_` for unused variable is a common idiom.
I would suggest not using `_` as a variable name as that may conflict with gettext imports.
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Use single quotes consistently.
TBH, I don't think we need this test. I will chop it.
Use `assertEqual()`, e.g. ```python self.assertEqual( conf_url(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), re_path(r'^regex/(?P<pk>[0-9]+)/$', empty_view, name='regex'), ) ```
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
```suggestion version_added: '2.9' ```
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
`aws_connect_kwargs` won't be defined at this point unless `ec2_url` is set, which is the unlikelier of the code paths
I think this assertion isn't needed.
I can't see an import for camel_dict_to_snake_dict
remove extra newline
Please check code with flake8 as described in the patch review checklist and correct the "no newline at end of file" warning here.
.get() falls back to None to `False` isn't really needed I think.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
What do you think about making this required=True and removing the default? I think it would be best to make sure that users are fully aware of which zone they're using. Many users don't use the us-central1-a zone.
I prefer that the module would check the connection itself as well, without actually sending the message. If the API supports stub messages (or empty messages?), use that. Otherwise just test the authentication/connection some other way.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe output the bad value here as well, to help the user find out which one was wrong.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`timestamps_closed_bounds` field is defined with closed bounds in `default_bounds` so the current name is good, IMO. This test is to ensure that `default_bounds` doesn't impact open bounds pass in `DateTimeTZRange`.
The query should be something like ``` G.V().Has('TID', 'bd7f5334-115c-5943-487d-a77c486fa854') ``` according to the `name`
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Maybe this should be a class docstring :thinking:
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Use a single quote.
I think you can use `with self.assertRaisesMessage` equivalently here (context manager form is much easier to read IMO)
slightly prefer this style so lines don't have some non-multiple of 4 indent: ``` msg = ( "..." ) ```
Use a single quote.
I think you can use `with self.assertRaisesMessage` equivalently here (context manager form is much easier to read IMO)
slightly prefer this style so lines don't have some non-multiple of 4 indent: ``` msg = ( "..." ) ```
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
You're right. You know I both saw that and missed it too...
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Use single quotes consistently.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Use single quotes consistently.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
TIL that character classes also work inside `[]` :D
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please use `module= AnsibleModule(` I guess it is a convention
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Maybe this should be a class docstring :thinking:
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please use `module= AnsibleModule(` I guess it is a convention
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Net new tests should be `pytest` style tests.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
please check code with flake8 (`E231 missing whitespace after ','`)
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please use `module= AnsibleModule(` I guess it is a convention
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Cool. Thanks. Let me know once done.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@nitzmahone and I talked about this last night and the timeout is an expectation of how long fact gathering as a whole will take, not how long any specific piece of fact gathering will take. We thought that probably the best place to enforce that sort of fact gathering would be in the action plugin being worked on in a separate PR. However, for this PR, it would make more sense to at least try to replicate the status quo as much as possible, ie: take a time at the start of this function. Then every time we check the time to see if it's time to exit due to timeout, we compare time.time() > function_start_time + timeout to see if it's time to exit.
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
I think we should be consistent and use double-quotes.
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Should the default be https, if so update docs
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
You can use `if six.PY2` (import `six` from `django.utils`)
Something is wrong with the indentation here, you might want to use `flake8` from the top directory to spot warnings.
Oh the code looks fine, it's just that this should be 4-space indented not 8.
Unrelated, but perhaps the default kwarg should be `exclude=()` to allow removing the `exclude is not None` check.
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
Move the leading period to the initial definition of `msg`.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
AFAIK the Ansible functions should work, could you please provide a sample input value and expected output value given that input.
We tried to use to_text, but the feedback I got from our engineer is that codecs was more appropriate here as we are dealing with hexadecimal.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
When hitting an error you must exit with module.fail_json
There is in theory a chance of hitting a TOCTTOU case here anyway, in which case it is better to handle the exception to avoid a crash.
Maybe: ```python "File '%s' is already compiled and up to date." % po_path ```
We can add assertion for number of queries `self.assertNumQueries(0)` because that's the real impact of this optimization.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Exception handling here too.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Exception handling here too.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
```suggestion system = to_text(platform.system(), errors='surrogate_or_strict') if system == u"OpenBSD": ```
I'd probably prefer a single assignment with a conditional only for the argument. It would probably look cleaner this way: ```suggestion is_openbsd = u"OpenBSD" == to_text(platform.system(), errors='surrogate_or_strict') bcrypt_crypt_id = '2b' if is_openbsd else '2a' algorithms['bcrypt'] = algo(crypt_id=bcrypt_crypt_id, salt_size=22, implicit_rounds=None) ```
Newline before this line
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
this should look like this instead: ``` result = super(ActionModule, self).run(tmp, task_vars) if result.get('skipped', False) or result.get('failed', False): return result ```
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
Syntax error? ```suggestion from ..announce import create_short_message, create_long_message # pylint: disable=relative-beyond-top-level ```
`now` is unnecessary.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
`raise` is missing. Call to `str` is useless there.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
Complement the docstring adding the parameters, might be useful (to the other functions as well)
As per naming convention, the name is `get_lldp_global_facts`
Name as per convention can be `lag_itnerfaces_facts`
This field can be removed in favour of the new `maxHttpFormPostSize` field below.
You may want to consider making a wrapper function that checks the jinja2 version before overriding. The reason being that jinja2 could enhance their dict function in the future at which point we would be providing less features rather than more.
While there isn't much risk, this would match "UMASKFOO". The 2nd part regarding '#' is also not correct, since '#' need to be the first non space characters, I would recommend to use strip() and verify the first char.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Exception handling here too.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Same as for the updated, I'd rather say `has been deleted`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
Please use 'msg' for returned messages, this is a standardized return value.
Same as for the updated, I'd rather say `has been deleted`
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
I would say `Deploy key has been updated` instead of `should have been updated`
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
Indeed, we do not need to be so specific. The downside I see when being permissive is a bit more computation by going more often in `get_supported_language_variant` and possible `get_supported_language_variant` lru cache exhaustion. But I don't see a nice alternative.
Do we need to be so restrictive? There are many language tags in the [IANA](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry) registry that don't match this regex, e.g. `i-mingo`, `de-CH-1996`, `de-1996`, or `kl-tunumiit`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Complement the docstring adding the parameters, might be useful (to the other functions as well)
normalize_interface import is unnecessary here
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
TIL that character classes also work inside `[]` :D
I think you meant to use `self.get_context()`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
It's more about readability. When you see two if-branches it's different than just one and then following scenario. Plus it's less indentation, which is less important in this simple case, but in general helps to have such habit :)
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Wouldn't it make sense if the module does that as well? Also: ```suggestion - To make the DNS record changes effective, you need to run C(update dnsserver) on the ipwcli. ```
The description looks wrong...
The other formats.py seem to use `'\xa0'`
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Running the entire test suite I could reproduce the error, but not if only running `django.contrib.gis`. Not sure exactly the cause but this code seems suspicious as we leave a different model admin registered for other tests.
Although you changed this, I think you missed the the bit in https://github.com/django/django/pull/14437#discussion_r658641917 that the `if` can now go outside of the `for` to avoid a pointless iteration when `timeout` is `None`. ```suggestion # Set timeout for each key individually as .mset() doesn't support # setting the timeout for all keys at the same time. if timeout is not None: for key in data: client.expire(key, timeout) ```
So [`.flushall()`](https://redis-py.readthedocs.io/en/stable/#redis.Redis.flushall) will clear everything in all databases. (Apparently Redis has 16 logical databases that can be switched between.) We should change this to use [`.flushdb()`](https://redis-py.readthedocs.io/en/stable/#redis.Redis.flushdb) instead and only clear the current database. For consistency we can also ensure this returns a boolean. ```suggestion return bool(client.flushdb()) ``` (We should probably also expose a `db` parameter via `RedisCacheClient.__init__()` which can be passed through via `_client_kwargs`. It should have a default value of `0`.)
Yes, sorry, I meant `max()`.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Explicit is better than what's happening implicitly: ```suggestion host=to_text(host), err=to_text(err), url=to_text(self.foreman_url))) ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Running the entire test suite I could reproduce the error, but not if only running `django.contrib.gis`. Not sure exactly the cause but this code seems suspicious as we leave a different model admin registered for other tests.
Can this be rewritten as ```python from functools import reduce return reduce(self.merge, filter(None, self._js_lists)) ``` By the way, how can entries be `None` given the checks in `__init__`? If it's not necessay than this can be reduced to ```python return reduce(self.merge, self._js_lists) ```
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
I think we should be consistent and use double-quotes.
It is safe to just make it default to `hash`, no need for the string conversion. Hash is not the name of a specific hash function anyway, just a Python utility.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
```suggestion Test that the returned value for timezone consists of only uppercase ```
just use `client = module.client('apigateway')`
TIL that character classes also work inside `[]` :D
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
Is `user_id` something secret, just wondering why it has `no_log`
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Use `'` as string delimiter for consistency
there is no need to set a temp variable for `images`
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
flow 'when' to previous line
I'm about to commit this, but for future reference note that assertEquals is a deprecated alias and should be assertEqual
check that -> and that (no comma needed since the two clauses are independent)
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
For the get('organization') request response? I'm assuming the list of 'organizations' and 'users' will always have a single item? (at least as used with a oauth token as used here). Will that depend on the type of api_token? (ie, if there is something like a organization or group level api_key, would the results be different? If so, could be useful to explain in the docs)
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
I'd rename `subminor` to `patch`.
You're right. You know I both saw that and missed it too...
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
I'm not sure if there are lookups where it's not the case, but comparisons such as `Choice.objects.filter(votes__gte='2')` seem to work fine with the value as a string so the "transform" stuff seems unnecessary, at this for the first version of this.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
TIL that character classes also work inside `[]` :D
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Required=false are implicit could you remove them ? Default=None too in case of string
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling here too.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
you could just use this function instead https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/helpers.py#L37
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Exception handling here too.
User could set `user_data` parameter to `None`, in such case exception still occurs.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
User could set `user_data` parameter to `None`, in such case exception still occurs.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
User could set `user_data` parameter to `None`, in such case exception still occurs.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
Just use ` and ...` instead of nesting. Less indentation == better readable.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Please use 'msg' for returned messages, this is a standardized return value.
`band_input`, you don't get much by saving one char :-)
We might instead replace other instances by `self._ptr`, to convey the idea of a private and internal variable. Just a suggestion.
prefer hanging indent style with 1 arg per line
This can be converted to return True. No need of new variable retry_request
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This should be `assertTrue()` as `assert_()` is deprecated.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Missing from docs
This should be `assertTrue()` as `assert_()` is deprecated.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In the `exit_json`, you should also return `changed` and `state`.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Exception handling here too.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Don't check arg_type here. A module could do something silly like: ``` encryptor: passphrases_for_each_user: - foo - bar - baz ``` The arg_type in this case will be a list but we'd still want to catch it here.
And the same here
```suggestion Question.objects.create(question='Not a question.') ```
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
I admit Django still has much code looking like that, but it should be safe to simply use `if options['empty']:` below without first pushing the result in `self`. Having the value on `self` might make sense when we want to use the value in other methods. Same for `options.get('help', False)`, as we are using the parser in both `call_command` and `run_from_argv`, we can be sure that `'help'` is in the options dictionary, so `options['help']` is fine.
The flake8/test failure is because the above `help` is missing a closing parenthesis, hence a `SyntaxError`. You can always repush to the branch to rerun the tests.
I'd expect the set to be done after mangers & admins are added
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
IMO we should check options against PostreSQL names.
This should be handled by the fields themselves, what you've written here is what a special cased `JSONFieldGinIndex.create_sql` implementation would look like.
`extra.get()` returns `None` by default, so we can simplify this: ```python self.options = extra.get('options') ```
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
IMO we should check options against PostreSQL names.
This should be handled by the fields themselves, what you've written here is what a special cased `JSONFieldGinIndex.create_sql` implementation would look like.
`extra.get()` returns `None` by default, so we can simplify this: ```python self.options = extra.get('options') ```
~Never mind, looks it's the other way around. Works on 3.6, fails on 3.8.~ had an old Python 2.7 interpreter lying on my path 🤦
Not sure of the motivation behind these changes but this could be reduced to the following? ```suggestion attrs['declared_fields'] = { key: attrs.pop(key) for key, value in attrs.items() if isinstance(value, Field) } ```
Unified naming behavior is a very important point. Variables should have the same names (or names as close as possible) independently of the backend.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
use `self.MAX_FILES` instead of 999999
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
This can be converted to return True. No need of new variable retry_request
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This can be converted to return True. No need of new variable retry_request
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be converted to return True. No need of new variable retry_request
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Could be: ```python json.dump(host, sys.stdout, indent=2) ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This can be converted to return True. No need of new variable retry_request
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
This can be converted to return True. No need of new variable retry_request
Please change these vars to ansible Host vars rather OS env vars.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
I think it would be good to include a message giving context before we start listing unresolved issues.
We can keep `invert` directly in the `SearchQuery` instead of `extra`, e.g. ```python ... self.invert = invert super().__init__(*expressions, output_field=output_field, function=function) ```
`_combine()` is unnecessary since its introduction, I moved it to a separate commit b62c58d5fccaeedc7bc4a064b4678e4ed1e77581.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think it would be good to include a message giving context before we start listing unresolved issues.
We can keep `invert` directly in the `SearchQuery` instead of `extra`, e.g. ```python ... self.invert = invert super().__init__(*expressions, output_field=output_field, function=function) ```
`_combine()` is unnecessary since its introduction, I moved it to a separate commit b62c58d5fccaeedc7bc4a064b4678e4ed1e77581.
I think it would be good to include a message giving context before we start listing unresolved issues.
We can keep `invert` directly in the `SearchQuery` instead of `extra`, e.g. ```python ... self.invert = invert super().__init__(*expressions, output_field=output_field, function=function) ```
`_combine()` is unnecessary since its introduction, I moved it to a separate commit b62c58d5fccaeedc7bc4a064b4678e4ed1e77581.
I think it would be good to include a message giving context before we start listing unresolved issues.
We can keep `invert` directly in the `SearchQuery` instead of `extra`, e.g. ```python ... self.invert = invert super().__init__(*expressions, output_field=output_field, function=function) ```
`_combine()` is unnecessary since its introduction, I moved it to a separate commit b62c58d5fccaeedc7bc4a064b4678e4ed1e77581.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I may not be allowed to write to current directory. Maybe log path should be passed as parameter.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Should catch `BotoCoreError` and `ClientError` here, and use `module.fail_json_aws()`.
This is unnecessary, AnsibleAWSModule automatically merges the argument_spec that you pass with ec2_argument_spec().
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Uses of `{}` should be updated with positions as this will be incompatible with python 2.6. This applies through the code base. e.g. `'{0}'.format('foo')`
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
Should the default be https, if so update docs
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
Can you style the dict the following way? ``` payload = { 'method': 'login', 'params': {'user': user, 'passwd': passwd} } ```
`DigitalOcean droplet size facts` would be clear to the end user.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Will info['body'] be json? Might be a string/HTML.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Will info['body'] be json? Might be a string/HTML.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
Will info['body'] be json? Might be a string/HTML.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
Will info['body'] be json? Might be a string/HTML.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
TIL that character classes also work inside `[]` :D
I think we should be consistent and use double-quotes.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
TIL that character classes also work inside `[]` :D
Could you have a syntax close to : ``` if not re.match(): raise ... ``` That we don't have as much indentation levels.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Move the leading period to the initial definition of `msg`.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
```suggestion Test that the returned value for timezone consists of only uppercase ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
Required=false are implicit could you remove them ? Default=None too in case of string
The interesting test case is this: ``` season_2009 = Season.objects.create(year=2009, gt=111) season_2009.games.create(home="Houston Astros", away="St. Louis Cardinals") season_2009.games.create(home="Houston Astros", away="Chicago Cubs") season_2009.games.create(home="St. Louis Cardinals", away="Houston Atros") season_2010 = Season.objects.create(year=2010, gt=222) season_2010.games.create(home="Houston Astros", away="Chicago Cubs") qs1 = Season.objects.exclude(games__home__contains='Houston') qs2 = Season.objects.exclude(lookups.Contains(F('games__home'), 'Houston')) ``` where the qs1 and qs2 objects should match. The encouraging thing is that the code is trying to call split_exclude(). It might be hard to make this test actually work, the split_exclude() code is pretty big hack, and especially if the expression creates joins to multiple different relations it will be hard to make the current code work properly. But, if I recall correctly, we don't support .filter(games__away__contains=F('games__home')) either.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
The interesting test case is this: ``` season_2009 = Season.objects.create(year=2009, gt=111) season_2009.games.create(home="Houston Astros", away="St. Louis Cardinals") season_2009.games.create(home="Houston Astros", away="Chicago Cubs") season_2009.games.create(home="St. Louis Cardinals", away="Houston Atros") season_2010 = Season.objects.create(year=2010, gt=222) season_2010.games.create(home="Houston Astros", away="Chicago Cubs") qs1 = Season.objects.exclude(games__home__contains='Houston') qs2 = Season.objects.exclude(lookups.Contains(F('games__home'), 'Houston')) ``` where the qs1 and qs2 objects should match. The encouraging thing is that the code is trying to call split_exclude(). It might be hard to make this test actually work, the split_exclude() code is pretty big hack, and especially if the expression creates joins to multiple different relations it will be hard to make the current code work properly. But, if I recall correctly, we don't support .filter(games__away__contains=F('games__home')) either.
Required=false are implicit could you remove them ? Default=None too in case of string
This is unnecessary as error checking is handled in `get_hosts_by_host_name` as well. I think you can remove it completely with the whole `is_host_exist` method to save a few lines of code. Basically you want to do the same as with `get_hosts_by_ip`.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I think we should be consistent and use double-quotes.
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
The interesting test case is this: ``` season_2009 = Season.objects.create(year=2009, gt=111) season_2009.games.create(home="Houston Astros", away="St. Louis Cardinals") season_2009.games.create(home="Houston Astros", away="Chicago Cubs") season_2009.games.create(home="St. Louis Cardinals", away="Houston Atros") season_2010 = Season.objects.create(year=2010, gt=222) season_2010.games.create(home="Houston Astros", away="Chicago Cubs") qs1 = Season.objects.exclude(games__home__contains='Houston') qs2 = Season.objects.exclude(lookups.Contains(F('games__home'), 'Houston')) ``` where the qs1 and qs2 objects should match. The encouraging thing is that the code is trying to call split_exclude(). It might be hard to make this test actually work, the split_exclude() code is pretty big hack, and especially if the expression creates joins to multiple different relations it will be hard to make the current code work properly. But, if I recall correctly, we don't support .filter(games__away__contains=F('games__home')) either.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Maybe this should be a class docstring :thinking:
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
We shouldn't be adding content-specific rules to the validation code. Why not allow any non `@` prefixed string to be used for collections instead? That will preserve the more strict check for ansible-base while allowing collection authors more flexibility.
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
This whole block could've been done with a nested list comprehension without any need for temporary variable introduction: ```python names = [ name for name_list in names for name in name_list.split(',') ] ``` Alternative FP approach would look like: ```python from itertools import partial, reduce ... names = reduce( lambda l, e: l + e, map( partial(str.split, sep=','), names ), [], ) ``` (but Pythonistas don't like such style in general)
Lists also have .extend() which might be what you need here
```suggestion password=dict(type='str', required=True, no_log=True), ```
This can be converted to return True. No need of new variable retry_request
```suggestion iap_port=dict(type='int', required=True), ```
```suggestion password=dict(type='str', required=True, no_log=True), ```
```suggestion iap_port=dict(type='int', required=True), ```
@gundalow Thank you so much for the feedback. I made the changes you requested but the build failed. The modified file passed but the build failed because of "ImportError while importing test module" for the test_iap_token.py file. I did not modify the test file. The tests did pass the last time. Please let me know what needs to be changed. Thanks in advance. Its complaining about: ```01:31 ____ ERROR collecting test/units/modules/network/itential/test_iap_token.py ____ 01:31 ImportError while importing test module '/root/ansible/test/units/modules/network/itential/test_iap_token.py'. 01:31 Hint: make sure your test modules/packages have valid Python names. 01:31 Traceback: 01:31 /usr/local/lib/python2.7/dist-packages/six.py:709: in exec_ 01:31 exec("""exec _code_ in _globs_, _locs_""") 01:31 test/units/modules/network/itential/test_iap_token.py:28: in <module> ** > 01:31 from ansible.compat.tests import unittest > 01:31 E ImportError: No module named tests ** 01:31 --- generated xml file: /root/ansible/test/results/junit/python2.7-units.xml --- 01:31 =========================== short test summary info ============================ 01:31 ERROR test/units/modules/network/itential/test_iap_token.py```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Yes -- arguably it might be better if it does crash if required is provided so people know to update their code.
this assumes NETRC is always present, you should make it conditional on it actually resulting in something
aws_ip_ranges -> aws_service_ip_ranges
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This can be moved to `check_dict` method.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Is `user_id` something secret, just wondering why it has `no_log`
use the `missing_required_lib` function from `ansible.module_utils.basic`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Line 355 to 368 are unused.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I think `name.rsplit('-', 1)[-1]` is easier to read.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Any problem with: ``` @property def media(self): ```
I meant -- isn't the call to `localtime` going to raise the same exception as the template engine? Because the template engine calls this function or an equivalent one.
This test will be stronger if you assert that `datetime.now` is called with the time zone you expect (or if you write a little mocking function that returns the specified datetime in the time zone passed to `now`).
Usually `__getattr__` is paired with `__dir__`, so that the lazy-loaded stuff is still exposed to `dir()`. My go-to implementation is: ```python def __dir__(): return sorted(list(globals()) + ["utc"]) ```
I meant -- isn't the call to `localtime` going to raise the same exception as the template engine? Because the template engine calls this function or an equivalent one.
This test will be stronger if you assert that `datetime.now` is called with the time zone you expect (or if you write a little mocking function that returns the specified datetime in the time zone passed to `now`).
Usually `__getattr__` is paired with `__dir__`, so that the lazy-loaded stuff is still exposed to `dir()`. My go-to implementation is: ```python def __dir__(): return sorted(list(globals()) + ["utc"]) ```
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Why don't you allow fractions of a second? (Not that it makes too much sense, but after all, docker expects nanoseconds.)
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
@pierremahot we'll need a test for this
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Removal of this line broke one of my scripts, which was relying on the field "name" to contain the portgroup name.
Like I said I don't remember exactly where it happened but that is why I added that if block. I am ok without if block if it is working on your systems.
This will fail when there is no vlanId or vswitch in portgroup. I don't remember the exact reason, but I encountered error here sometimes in past.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This is already covered by `ParseHeaderParameterTests.test_basic()`.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
```suggestion RuntimeWarning, ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
I double people will update this script correctly. We can only hope, that release managers verify this before sending the email... As an alternative, we can also wildcard this, and let release manger insert those manually. Similar to `<DETAILS OF THE CHANGES>` above.
Just a note here. We decided that by convention we will use the same naming as maven. `groupId` has now changed to `org.elasticsearch.distribution.[packaging]` so I think we should also reflect that change here and use `org/elasticsearch/distribution/[packaging]` where `packaging` is: - rpm - deb - zip - tar
This should go to `announce@apache.org` as well, that's actually the most critical one as that makes it "official".
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
@pierremahot we'll need a test for this
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Probably the check functions should be called directly rather than invoking them through `run_checks()` (otherwise, this runs all registered checks across all installed apps which doesn't provide good isolation) -- see `tests/check_framework`.
a leftover here which can be removed
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
Please initially check that `mode` in is `{'auto', 'min', 'max'}`.
No warning should occur with default settings. It is safe to remove this.
Not required after above `load_provider()` change
no blank line
required is by-default is 'False', so no need to add explicitly.
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I don't see much value in this docstring.
```suggestion content_library_info: ``` or `library_info` would be more apt.
It would be nice to have other information about library like description and type etc.
I would leave it as a `lambda`.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
We should pass `using` from the queryset ```suggestion ct_id = self.get_content_type(model=model_cls, using=ct_queryset.db).pk ```
I added a short docstring but without `is provided by developers ...`, this is not a strong argument, a lot of things are provided by developers but we don't mark them as safe. I'd say that's how it is, the decision was made a lot time ago :shrug:
TIL you can index a tuple with a boolean: ``` In [1]: ("no", "yes")[True] Out[1]: 'yes' ``` I do wonder if we can get the report to accept real booleans since they're JSON encoded.
```suggestion @override_settings( CSRF_FAILURE_VIEW=f'{__name__}.failure_view_with_invalid_signature', ) ```
Two things to change here: * Use ansible.module_utils._text.to_text() instead of .decode(). * Catch the UnicodeError and give a better error message. Maybe something like this: ``` python from ansible.module_utils._text import to_native, to_text [...] try: remote_md5 = to_text(self._getContent(remote_url + '.md5', "Failed to retrieve MD5", False), errors='strict') except UnicodeError as e: return "Cannot retrieve a valid md5 from %s: %s" % (remote_url, to_native(e)) ```
I also found `n_url` to be a bit confusing and collide with our string type prefixes for bytes, native, and unicode. It would be good to change `n_url` to something more descriptive, but probably in a separate PR.
I've been meaning to ask... what's the deal with n_url? I thought at first that it needed to be a native string for the APIs it's being used with but the more places I see it, the less that looks like the case. Is it "normalized_url"? If so, could you start using that? We do not want to use `n_` or `b_` prefixes for anything other than variables containing native strings and variables containing byte strings. It will defeat the purpose if we start doing this in other places.
Exception handling here too.
@felixxm I suggested the exact opposite during previous review - I prefer to template it to allow the tests to be moved around in future without any diff noise
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
To be consistent with other modules each of the options should be on a single line (unless they have many choices)
Single quotes please.
Extract this logic to a helper function that can be tested independently.
With the change above this becomes: ```python match_obj = formset_query_regex.match(k) ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Single quotes please.
Extract this logic to a helper function that can be tested independently.
With the change above this becomes: ```python match_obj = formset_query_regex.match(k) ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Single quotes please.
Extract this logic to a helper function that can be tested independently.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
To be consistent with other modules each of the options should be on a single line (unless they have many choices)
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
The original code made use of unpacking generalizations rather than excessive use of `list.append()` and `list.extend()`. Please restore this.
> The browser resubmits the "logout" tab, and the user is logged out again. The browser asks whether it should resubmit POST requests no? But you are right it is not 100% nice if `next_page` is not used.
The output looks like: Number of entries: 0 And you are matching with number with lower case n. This will not work. Also you are comparing a string with an int. line[-2:].strip() returns a string you have to cast it to int. line[-2:] gives last two numbers, let us say the output was '... entries: 100' this logic would return 00. Which will not work. Do a regex match for the number of entries, split everything beyond : to get the actual number of entries remaining.
The original code made use of unpacking generalizations rather than excessive use of `list.append()` and `list.extend()`. Please restore this.
Nit - Change the message to: "Operation aborted, self-heal in progress." removing the capitalisations.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
I think we should be consistent and use double-quotes.
ditto on `.` in character groups
ditto on `.` in character groups
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Yes, I know. I'll leave it to Aymeric for a second opinion.
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Lowercase 'yes' please :-)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Lowercase 'yes' please :-)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Lowercase 'yes' please :-)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
In `_handle_m2m_field()` and `_handle_foreign_key_field()` we can avoid of temporary variables (`value`) and return directly, e.g. ```python def _handle_foreign_key_field(self, field, field_value): return base.deserialize_fk_value(field, field_value, self.using, self.handle_forward_references) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`field_names` are used only when `self.ignorenonexistent is True`, so we can optimize this part, e.g.: ```python field_names = set() if self.ignorenonexistent: if Model not in field_names_cache: self.field_names_cache[Model] = {f.name for f in Model._meta.get_fields()} field_names = self.field_names_cache[Model] ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
I would say `Deploy key has been updated` instead of `should have been updated`
Please use 'msg' for returned messages, this is a standardized return value.
Same as for the updated, I'd rather say `has been deleted`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
remove unnecessary code.
```suggestion module.fail_json(msg=to_native(e), errno=e[0], reason=to_native(e), **result) ```
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I think this would be a bit more readable: ``` return ( '%(func)s %(op)s %(dist)s' % {'func': sql, 'op': self.op, 'dist': dist_sql}, params + dist_params ) ```
to_text and prefix the string with u.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
This is minor, but the double exclamation point feels a little overblown. I'm not sure any exclamation points are needed at all; the text should suffice.
+1 "using this flag as only table names are checked" (combine the last sentence)
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
We can pass `opclasses` to the `super()._create_index_sql()`.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Wouldn't it be much easier to do the following: ``` public Connector createConnector(String listener, String name) { ... String hostname = ... int port = ... ... if (name == null || name.trim().isEmpty()) { name = String.format("%s_%s%d", PROTOCOL_HTTPS, hostname, port); } connector.setName(name); ... ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
For algorithmic code, it can make sense to test private methods and private functions in isolation from the rest of the code. This does seem to be a place where that could be justified. The code being tested is functional (meaning it operates via parameters and return values rather than callbacks) and it plugs into a larger framework which is outside of our control. What I'll sometimes do is push all the permutations of data that I care about at the private function and then push a small subset at the public interface to make sure that the interaction between the public and private code is working as expected.
Usually, testing private interfaces doesn't make sense.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
chop the blank lines before each attribute
remove extra newline
Please remove empty line.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe output the bad value here as well, to help the user find out which one was wrong.
Isn't `raise` missing there ? Calls to `str` are useless.
Typo in `module_utils`.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
check that -> and that (no comma needed since the two clauses are independent)
Net new tests should be `pytest` style tests.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
See my previous review for indentation style of this. Perhaps the common qs stuff before the last filter can be moved to setUpTestData.
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
That's something we should fix in the Keras backend.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
alphabetize g before o also I would combine with the "from" imports below
chop the blank lines before each attribute
remove extra newline
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
I think that this will make it hard to override for third-party backends that run the test suite (e.g. see the recent commits of @timgraham for Cockroach DB).
```suggestion def __init__(self, *args, on_conflict=None, update_fields=None, unique_fields=None, **kwargs): ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
The import should be conditional and the test skipped if enum isn't installed.
Our policy is not to require the installation of requirements and instead skip the relevant tests.
built-in imports like unittest should go above django imports, separate by a newline. e.g. ``` from __future__ import unicode_literals import unittest from django ... ```
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
I think we should be consistent and use double-quotes.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
I think we should be consistent and use double-quotes.
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Same as for the updated, I'd rather say `has been deleted`
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Same here, can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Same as for the updated, I'd rather say `has been deleted`
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
I would say `Deploy key has been updated` instead of `should have been updated`
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
```python elif max_num is not None and () ```
use `self.MAX_FILES` instead of 999999
Typo, should be email
Same typo as above
This `else` branch is unecessary cruft, remove it.
Typo, should be email
Same typo as above
This `else` branch is unecessary cruft, remove it.
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
py3.x-only code; can safely ditch the args to `super()`
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Same as for the updated, I'd rather say `has been deleted`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Same as for the updated, I'd rather say `has been deleted`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
TIL that character classes also work inside `[]` :D
else is unnecessary here because we raise an exception before
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
I'd rename `subminor` to `patch`.
We should also change `\d+` to `[0-9]+` in all cases.
You're right. You know I both saw that and missed it too...
Line is too long.
Please add check-mode support (and if possible also diff support).
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
Maybe this should be a class docstring :thinking:
```suggestion query=dict(type='list', elements='str'), ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
```suggestion query=dict(type='list', elements='str'), ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Don't put logic on an `if` line, introduce a line break. In general, I suggest rewriting the part of the code that prints evaluation results to make it simpler, easier to read, and more user friendly. A big goal of these example scripts is to be as user friendly as possible while introducing best practices.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
This can be single-lined: ```suggestion return (matched_tags or not tags) and not test_tags.intersection(exclude_tags) ```
I would chop `does_`: ```suggestion if test_match_tags(test, tags, exclude_tags) ```
last loaded wins, but iirc, we reverse search on handlers list
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Not supported on Python 3.4.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
```suggestion result['last_modified'] = mtime = date_to_timestamp(info['last-modified']) ```
```suggestion Test that the returned value for timezone consists of only uppercase ```
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
I'd lose the "should be comma separated" and change this to "list of ports associated" (and alter the samples below to use native YAML instead of legacy Ansible key=value syntax).
This is wrong, already explained.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Style-wise, I like to make the thing being tested the last import and visually separate from the other imports (a blank line between them and the import for the thing(s) being tested.
Typo in `module_utils`.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
immediatelly -> immediately
I don't understand why we have methods with a double underscores prefix which are copies from `SessionBase`, e.g. `__hash()`, `__legacy_encode()`, `__legacy_decode()` :thinking:
@collinanderson That is a good point, at first I wanted to be safe against leaking anything (just to be on the safe side), but the DOS argument is more important.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Required=false are implicit could you remove them ? Default=None too in case of string
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Please remove empty line.
I thinking removing APP_DIRS from TEMPLATES (since it defaults to False) is a better suggestion than setting it to False.
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
I think that should be changed=True, since check mode is used to determine if a change will occur if run without check mode.
I prefer that the module would check the connection itself as well, without actually sending the message. If the API supports stub messages (or empty messages?), use that. Otherwise just test the authentication/connection some other way.
we should not be adding a python dependency on ordereddict here, as python2.7 can also use ordereddict from collections: https://docs.python.org/2/library/collections.html#collections.OrderedDict This also means, that python2.7 users now need an additional python dependency installed.
You asked me about the `lru_cache` here; I don't think it matters one way or another :-)
AFAIK no timestamp type defaults to CreateTime, so I think this test and the test below will test the same thing. But need @becketqin to confirm this.
To keep backwards compatibility, we need to add `enclosures=None` after `updateddate=None`.
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
Please use 'msg' for returned messages, this is a standardized return value.
To keep backwards compatibility, we need to add `enclosures=None` after `updateddate=None`.
not listing updateddate as the last kwarg is technically backwards incompatible if someone is calling this item using args instead of kwargs but it seems unlikely to me.
Please use 'msg' for returned messages, this is a standardized return value.
nvmd, had not looked at the called method which already handles skipped coloring
Style mistakes. -70 points
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
In the `exit_json`, you should also return `changed` and `state`.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Maybe this should be a class docstring :thinking:
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
```suggestion raise Exception ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
Required=false are implicit could you remove them ? Default=None too in case of string
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
```suggestion elif date_string.match(self.when): ```
Maybe this should be a class docstring :thinking:
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Yes, I know. I'll leave it to Aymeric for a second opinion.
Use single quotes (unless a string contains a single quote) as described in [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
Use another lookup instead of `epoch` e.g. `second`.
Please use a single quote.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
This one as well.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Exception handling here too.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
a leftover here which can be removed
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Please add `type="str"`
Please add `type="str"`
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe output the bad value here as well, to help the user find out which one was wrong.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe output the bad value here as well, to help the user find out which one was wrong.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
User should be able to delete key. Keys with `None` value could be deleted.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
a leftover here which can be removed
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Exception handling here too.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe output the bad value here as well, to help the user find out which one was wrong.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Maybe output the bad value here as well, to help the user find out which one was wrong.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe output the bad value here as well, to help the user find out which one was wrong.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This can raise a `LookupError`
If I understood the above code correctly, then `self.field` is on the source model, whereas `self.model_admin` points to the target admin, I think we should really rename those to avoid confusion.
`getattr` will throw a `ValueError` if the `to_field` does not exist, this has to be handled.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
one more for the single line version
Bonus points for a link to the `re` man page ð
Does the result provide any insight into if anything's changed? Looks like put and delete are currently both hard coded to return ``changed=True``
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
We might instead replace other instances by `self._ptr`, to convey the idea of a private and internal variable. Just a suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
We might instead replace other instances by `self._ptr`, to convey the idea of a private and internal variable. Just a suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
We might instead replace other instances by `self._ptr`, to convey the idea of a private and internal variable. Just a suggestion.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Isn't `raise` missing there ? Calls to `str` are useless.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Do we need to change `related_name` here? We could add `note` with `related_name='owner'` instead.
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
We can also import `include()` from `django.urls` instead of `django.conf.urls`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
TBH, I don't think we need this test. I will chop it.
Net new tests should be `pytest` style tests.
Please remove empty line.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
This one is a bit newer to CliBase, but also implemented verbatim in superclass
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
`no_log=True` is argument spec will handle this.
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_DOMAIN']), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_REGION']), ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Exception handling here too.
I think we want to deprecate NUMBERTYPES so instead of moving it, just use its definition here (list(ansible.module_utils.six.integer_types) + [float])
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
I'd like to not pull SEQUENCETYPE into this file but this one is a little tricky. A Mapping is an iterable and we have a separate conditional block to work with those. If we just check for collections.abc.Sequence then we wouldn't catch things like sets and keyview.... I think what we can do is put the Mapping conditional before this one and then change this one to ```if is_iterable(obj)```.
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
This line can go in "else" of try/except/else since it isn't expected to raise an exception.
New tests pass without this change.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
This line can go in "else" of try/except/else since it isn't expected to raise an exception.
New tests pass without this change.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Just want to verify - will it be possible to apply these environment variables per host in the inventory file? The idea is that you may have multiple firewalls, some of which need proxy (or even different proxies) to be managed and others don't.
@maorlipchuk Can you please use `get_entity` from `./lib/ansible/module_utils/ovirt.py`? ```python from ansible.module_utils.ovirt import get_entity dc = get_entity(dcs_service.service(self._module.params['data_center'])) ``` No need for `try-except` then.
No need to change this from what it was. All of the other unnecessary line breaks following this that can be undone too. There are a lot of them.
`long_field_name` replaces the existing fields
Please add edge cases to cover caching `IndexError` and `HeaderParseError`: ``` # Other invalid addresses. '@', 'to@', '@example.com', ```
Why not use a list comprehension here? It's probably more efficient: `return [self.sanitize_keys(i) for i in data]`
We usually use hanging indent: ``` with self.settings( USE_L10N=False, DECIMAL_SEPARATOR=',', USE_THOUSAND_SEPARATOR=True, THOUSAND_SEPARATOR='.', ): ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Exception handling here too.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Required=false are implicit could you remove them ? Default=None too in case of string
Same here as `create` method
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
This is not required since we are already doing this in individual APIs.
Same here as `create` method
Required=false are implicit could you remove them ? Default=None too in case of string
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
ditto on `.` in character groups
ditto on `.` in character groups
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
ditto on `.` in character groups
There appears to be a problem here on Py2.6 in that it's turning the options into: ``` -\x00\x00\x00H\x00\x00\x00 ``` Example of `reflag`: ``` ['-\x00\x00\x00H\x00\x00\x00', '\x00\x00\x00-\x00\x00\x00S\x00\x00\x00', '\x00\x00\x00-\x00\x00\x00n\x00\x00\x00'] ```
Python 2.6's `re.sub` doesn't accept `flags` -- but `re.compile` does.
ditto on `.` in character groups
Ah, I see what you are doing now. That is... a bit convoluted. It would seem simpler to `'show running-config aclmgr | section {0}',format(interface)`, and then match `'ip access-group {0} {1}'.format(name, in/out)` directly, unless there's some limitation on section that I'm not aware of.
Why the loop here? `if match` should be sufficient
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Chop blank line.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
When hitting an error you must exit with module.fail_json
Since we expect the name to start with 'http://' or 'https://' I would so this: ```python if name.startswith('http://') or name.startswith('https://'): ... ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please ignore, my suggestion is invalid syntax.
Please use lowercase variable names.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please ignore, my suggestion is invalid syntax.
Exception handling here too.
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
Probably the check functions should be called directly rather than invoking them through `run_checks()` (otherwise, this runs all registered checks across all installed apps which doesn't provide good isolation) -- see `tests/check_framework`.
please check code with flake8 (`E231 missing whitespace after ','`)
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
Wouldn't it be a bit more helpful for this error message to specifically note that the module with the given path couldn't be imported? "Invalid" is a very vague term, which could mean all sorts of things - it seems unhelpful to silence an `ImportError` and replace it with a much vaguer message.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
[`create` already saves the model](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.create), you don't need to repeat it (same for others below)
I have one concern :disappointed: Should we clear cached instance when a value is the same? because this leads to unnecessary queries. Maybe we should check value before clearing an instance, e.g. ```diff diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py index 346f67289e..0b51b68ebe 100644 --- a/django/db/models/fields/related_descriptors.py +++ b/django/db/models/fields/related_descriptors.py @@ -73,7 +73,7 @@ from django.utils.functional import cached_property class ForeignKeyDeferredAttribute(DeferredAttribute): def __set__(self, instance, value): - if self.field.is_cached(instance): + if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance): self.field.delete_cached_value(instance) instance.__dict__[self.field.attname] = value ``` You can find below tests that don't work anymore after the second commit. ```diff diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py index 5efe137730..cf3bea86d4 100644 --- a/tests/many_to_one/tests.py +++ b/tests/many_to_one/tests.py @@ -164,6 +164,8 @@ class ManyToOneTests(TestCase): self.assertFalse(Parent.bestchild.is_cached(parent)) self.assertEqual(parent.bestchild, child2) self.assertTrue(Parent.bestchild.is_cached(parent)) + parent.bestchild_id = child2.pk + self.assertTrue(Parent.bestchild.is_cached(parent)) def test_selects(self): self.r.article_set.create(headline="John's second story", pub_date=datetime.date(2005, 7, 29)) diff --git a/tests/one_to_one/tests.py b/tests/one_to_one/tests.py index 76f9d75417..0bc94bbb32 100644 --- a/tests/one_to_one/tests.py +++ b/tests/one_to_one/tests.py @@ -213,6 +213,8 @@ class OneToOneTests(TestCase): self.assertFalse(UndergroundBar.place.is_cached(b)) self.assertEqual(b.place, self.p2) self.assertTrue(UndergroundBar.place.is_cached(b)) + b.place_id = self.p2.pk + self.assertTrue(UndergroundBar.place.is_cached(b)) def test_related_object_cache(self): """ Regression test for #6886 (the related-object cache) """ ```
Can you put the `ParseField` into a class private var and then use it in the parser (so we don't accidentally typo/change it in the future)
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Exception handling here too.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
use `self.MAX_FILES` instead of 999999
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Chop blank line.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I think we want to sort on create-time here, or something equally deterministic. I'm not sure how sorting works with lists of dictionaries if you don't specify `key=....`
Sorry for the late update, just spotted this (caught me out somewhere else) [fail_json_aws is defined](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/aws/core.py#L191) as `fail_json_aws(self, exception, msg=None):` You can simplify this to ``` module.fail_json_aws(e, msg="Unable to delete user {0}".format(user_name)) ``` Probably worth swapping out most of the fail_json calls for similar fail_json_aws calls too.
I don't see the point ;-)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
This can be converted to return True. No need of new variable retry_request
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
This can be converted to return True. No need of new variable retry_request
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This should be in the `except` above.
This import should be at the top of the file, and is likely not python 2/3 compatible
This class does not need to live inside this method.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
This one is a bit newer to CliBase, but also implemented verbatim in superclass
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Can you explain why this method may be called with an already parsed URL ? And is this something you really want to support ? After all, the caller could also do `url = url if isinstance(url, dict) else Service.parse_url(url)`. Note that i'm not defending one pattern or the other, but just wondering about how you made your choice.
That's a really interesting piece of information I did not know.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
We have no intention of adding attrs as a dependency.
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
```suggestion elif date_string.match(self.when): ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think you can safely remove this.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Will info['body'] be json? Might be a string/HTML.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
~~I think we should pass `True` in all cases, because we're selecting a flag not declaring a value.~~
Yep, i understand there are other `assertNextOutputRecord` methods. I'd probably replace them too (not in this PR!) . I feel using `assertThat` is better in this case as we are just comparing the `ProducerRecord`. I don't see the need to have a method with multiple assertions when it can all be done in a single assertion.
Looks like these could be replaced with: `assertThat(driver.readOutput(...), equalTo(new ProducerRecord<>(topic, null, timestamp, key, value)`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Could you try to improve this so that there isn't duplication of the HTML and `escape(Truncator(obj)....`
`localhost` or rather `localhost.` is a FQDN, that shouldn't require a special case.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
well, maybe. I haven't checked what `.absolute()` does.
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
I'd probably still want to see `.absolute()` in the end
In the `exit_json`, you should also return `changed` and `state`.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
it looks to me this module supports check mode, but it is says not
use python bool for the default `default=False`
required is by-default is 'False', so no need to add explicitly.
problem with original, but still `str` is not portable, use `to_text`.
You are using deleteMonitor URL in resetMonitor API.
Interesting. This is definitely the thing to do since `build_absolute_uri` already returns an _uri_ but I assume the removal of the double escaping might generate a new key. Not a big deal but maybe something worthy of a release note.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
This will fail if `systems_uri` attribute is not set.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
I'd rename `subminor` to `patch`.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
You're right. You know I both saw that and missed it too...
We should also change `\d+` to `[0-9]+` in all cases.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Make a common method in class to get url and return json loads response.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`raise` is missing. Call to `str` is useless there.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
I wonder if this initialization needs to be done in `setUpClass()` or if doing it at the class-level would work? ``` class DateInputTest(WidgetTest): widget = DateInput() ```
Chop blank line.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Make a common method in class to get url and return json loads response.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
I think we should be consistent and use double-quotes.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
please set default to True
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
please set default to True
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
please set default to True
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
please set default to True
Exception handling here too.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
please set default to True
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Please change these vars to ansible Host vars rather OS env vars.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
Usually, testing private interfaces doesn't make sense.
pytest.mark.skip Though I'm surprised we did not see any bot error.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
pytest.mark.skip Though I'm surprised we did not see any bot error.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
For algorithmic code, it can make sense to test private methods and private functions in isolation from the rest of the code. This does seem to be a place where that could be justified. The code being tested is functional (meaning it operates via parameters and return values rather than callbacks) and it plugs into a larger framework which is outside of our control. What I'll sometimes do is push all the permutations of data that I care about at the private function and then push a small subset at the public interface to make sure that the interaction between the public and private code is working as expected.
pytest.mark.skip Though I'm surprised we did not see any bot error.
should this be: pytestmark = pytest.mark.skip('skipping as missing required netapp_lib')
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
The word `generally` doesn't add any value in my opinion.
I think I'd make this an `Error` - I don't think translation works at all if this is wrong.
We tend to start the messages with the job_id. So, this could become: `logger.error("[" + jobId + "] Failed to clear finished_time; source [" + source + "]", e);`
Remove debugging content "bhujay here". Also, iface['subnet'] is not valid when iface is a str.
The order is wrong. The classifier comes after the version part.
This debug message seems like it would appear _before_ we actually attempt to do any checking. It's probably worth keeping the old message (or something similar) _after_ the checking has been completed.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Make sense to me. Thanks for info.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Make sense to me. Thanks for info.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Not supported on Python 3.4.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
Not supported on Python 3.4.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Please remove empty line.
check that -> and that (no comma needed since the two clauses are independent)
I'm about to commit this, but for future reference note that assertEquals is a deprecated alias and should be assertEqual
I had to change this to `template_params['subquery'], sql_params = self.subquery.query.get_compiler(connection=connection).as_sql()` in order to compile correctly when using a database other than the `DEFAULT_DB_ALIAS`.
Maybe you've missed `if summarize` branch (below).
Ah, sneaky 🤗 Too early in the morning!
Ok I get it, `compiler.compile(Value(5))` would return something like `'%d', (5,)`.
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
What does qubes do if the file already exists in QubesIncoming? If it overwrites, I think this code will work. If it errors, we'd have to deal with the error here.
I had to change this to `template_params['subquery'], sql_params = self.subquery.query.get_compiler(connection=connection).as_sql()` in order to compile correctly when using a database other than the `DEFAULT_DB_ALIAS`.
Maybe you've missed `if summarize` branch (below).
Ah, sneaky 🤗 Too early in the morning!
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
It would be fine to call the function with `None` since `r` isn't used. Again, use `self.settings` to verify that `settings.LANGUAGE_CODE` is returned.
This can also use `+=`.
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
Maybe this should be a class docstring :thinking:
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Ok, not sure why this one is still open.
remove extra newline
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
remove extra newline
Please remove empty line.
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
I don't have a strong opinion on this. When it was like that before, I didn't really like the blank browser popping up before the tests started to run. If we change it though, we need to include the original exception in the error message that's reraised. I think the current simple approach is okay.
I think instantiating the browser to check if it works properly is also a part of the "validation" process. I don't see much gain in just checking that provided browsers are "importable" from selenium library. It will be better to keep that part of the error message and trying to instantiate the browsers here instead. Because there are other modules like `remote`, `support` in selenium which would get imported but do not have webdrivers - so these will give `WebDriverException` afterwards during the tests. Also if someone doesn't have the required drivers installed for a particular browser, it will again throw a similar Exception. So the `import_string` is just half of the validation.
`"Selenium browser specification '%s' is not valid."`
I think I'd make this an `Error` - I don't think translation works at all if this is wrong.
This will overwrite an explicitly given message if you use ``` python validator = DomainNameValidator(accept_idna=True, message='Only IDNA domain allowed') ```
nit: this alignment might be a bit off. We can follow the pattern of 2 tabs with first and last line on their own if that looks better I guess.
chop the blank lines before each attribute
remove extra newline
Please remove empty line.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
alphabetize g before o also I would combine with the "from" imports below
chop the blank lines before each attribute
remove extra newline
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
Isn't `raise` missing there ? Calls to `str` are useless.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Isn't `raise` missing there ? Calls to `str` are useless.
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Isn't `raise` missing there ? Calls to `str` are useless.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
What about to simplify this like this: ```python if not module.check_mode: rc, out, err = run_subscription_manager(module, rhsm_arguments) results = out.split('\n') module.exit_json(results=results, changed=changed, repositories=updated_repo_list, diff=diff) ```
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
that won't work with config values
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`raise` is missing. Call to `str` is useless there.
Exception handling here too.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
Can we make these multi-line, such as... ``` 'SELECT "postgres_tests_hotelreservation"."id", "postgres_tests_hotelreservation"."room_id", ' '"postgres_tests_hotelreservation"."datespan", ...' '...' ``` ...and so on.
Could you please keep the same string quoting style across the module? ```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('UTC')), '2019-06-15T14:45:00+00:00'), ```
```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('Europe/Helsinki')), '2019-06-15T14:45:00+01:40'), ```
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
I think it's better to refrain from abbreviations in formal/written text. (At least that's what we learned at school) So make that: ```python module.fail_json(msg="DNA Center did not return JSON compatible data")` ``` So it doesn't look like nested quotes.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Minor consistency nit- our stuff seems to be using `[action]_[backend]()`, where these aliased imports have that reversed. I'd vote for `[action]_[backend]()` over this- makes the code a little easier to read...
Typo in `module_utils`.
pytest.mark.skip Though I'm surprised we did not see any bot error.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Ok, not sure why this one is still open.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.

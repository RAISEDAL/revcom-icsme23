Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
A temporary variable is not necessary: ```suggestion # Remove all non-printable characters. file_name = ''.join([char for char in file_name if char.isprintable()]) ``` Also, it should be faster to check with `string.printable`: ```python file_name = ''.join([x for x in file_name if x in string.printable]) ``` ``` $ python3 -m timeit 'import random; x = "".join([chr(random.randint(1, 10000)) for _ in range(10000)]); "".join([char for char in x if char.isprintable()])' 50 loops, best of 5: 7.03 msec per loop $ python3 -m timeit 'import random; import string; x = "".join([chr(random.randint(1, 10000)) for _ in range(10000)]); "".join([char for char in x if char in string.printable])' 50 loops, best of 5: 6.76 msec per loop ```
Note, the advice to use to_text() here was incorrect. to_text should be used if the msg is not text where the msg enters the system as a whole. It should not be used where msg is used (unless it is a non-string type until then. But with a name like msg, it should be a string type when passed in here)
It's not really a warning, given the user cannot continue.
It's not really a warning, given the user cannot continue.
To avoid linter errors, change this to ```suggestion d_ = d self.assertTrue(d == d_) ``` and hope that the linter doesn't get too clever ;-)
`@unittest.skipUnless(basic.has_journal, ...)` might be clearer.
The default should match all jobs.
"for working with retry limiting"
If I remember how this worked in 2.9 the 2nd tuple entry controls whether the file is excluded from the root only or throughout the collection. I would have thought we would want the latter so this should be ```suggestion b_ignore_files = frozenset([(b'*.pyc', False), (b'*.retry', False), (b'.git', False), ``` Then again looking at devel the pattern is `.git` so this does act the same as devel.
It'd be cleaner to have only kwargs conditional: ```suggestion optional_kwargs = {'ExtraArgs': {'VersionId': version}} if version else {} s3.download_file(bucket, obj, dest, **optional_kwargs) ```
It probably makes sense to create a new `utils.py` module which has a function `write_to_file_if_different(filename, data)` which does the heavy lifting (and where this is done cleanly), so that all the details are only repeated once.
The change to this module is the only one that I question. I'm leaning towards putting this on the allowed list. The reason is that the code presently in the module is the equivalent of a UNIX pipe. The decompressor is able to chunk the data from the file to the database program as it decompresses that portion of the file. The run_command() version has to store all of the data from the decompressor in memory before passing it to the database program. So the memory usage can balloon in this case.
Hmm. On second thought, I'm not even sure if ANSIBLE_METADATA is used in lookup plugins? I think that's only for modules specifically.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Then we can get rid of these. ```suggestion ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
@pierremahot we'll need a test for this
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I'd rename `subminor` to `patch`.
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
Maybe this should be a class docstring :thinking:
Remove a level of indentation by flattening this if statement into the previous.
`can not` -> `cannot`, or better `may not `
`can not` -> `cannot`, or better `may not `
Add this snippet at the top of the module: ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ``` Then, you won't have to inherit from `object`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
community, no core here please.
community, no core here please.
community, no core here please.
community, no core here please.
```suggestion module.fail_json(msg='The following volume names were not found: ' ```
This is fine as is.
This is fine as is.
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This can be converted to return True. No need of new variable retry_request
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment) and rebase.
I'm going to be a +1 to just dropping `converters`
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
hmmm.. now I think I'm wrong, you want to only have the first partial func.. `func.func` shouldn't anyway be another partial or else that would be problematic I think, as views have to return something else.. Sorry for disturbance ;)
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
Line 355 to 368 are unused.
Line 355 to 368 are unused.
Line 355 to 368 are unused.
I think you meant `get_ellipsized_page_range` here. Use `number` instead of `page_num` which matches the argument name used by `Paginator.get_page()`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Maybe this should be a class docstring :thinking:
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
So we have to probably use try-except blocks for all the stuff that could fail. Nowadays with python3 you'd be doing something like: ```python from ansible.module_utils.pycompat24 import get_exception .... try: <whatever action that could fail> except: e = get_exception() module.fail_json(msg=str(e))
This is duplicated 15 lines above that ;)
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
Maybe this should be a class docstring :thinking:
fixture with load_json
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
trailing comma here and next line
that's the default in 1.9, but I don't if you want to include it anyway
```suggestion Question.objects.create(question='Not a question.') ```
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
Like I said I don't remember exactly where it happened but that is why I added that if block. I am ok without if block if it is working on your systems.
```suggestion form = PartiallyRequiredForm({'f_0': 'Hello', 'f_1': ''}) ```
```suggestion form = PartiallyRequiredForm({'f_0': 'Hello', 'f_1': ''}) ```
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
This can be a single line.
Line too long
a leftover here which can be removed
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
It looks to me like these URLs are better suited for a `seealso` section.
It looks to me like these URLs are better suited for a `seealso` section.
It looks to me like these URLs are better suited for a `seealso` section.
Please remove empty line.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Explicit is better than what's happening implicitly: ```suggestion host=to_text(host), err=to_text(err), url=to_text(self.foreman_url))) ```
Fine with me.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
```suggestion class VMwareExportVmOvf(PyVmomi): ```
```suggestion elif date_string.match(self.when): ```
```suggestion elif date_string.match(self.when): ```
```suggestion elif date_string.match(self.when): ```
Typo in the help message
This probably needs to be bytes.
Just put this on one line (or two if needed for line lengths) ``` from a.b.c import x, y, z from a.b.c import u, v, w ```
I think it's not pylint itself, but our own checks...
fixture with load_json
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
this should use the new API without hardcoded id now
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
so this assertion looks incorrect, i would expect and empty string as the ssh args
Missing `raise`. I would probably change to `AnsibleAssertionError`.
I always sort alphabetically if the order has no meaning.
I always sort alphabetically if the order has no meaning.
I think we should be consistent and use double-quotes.
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
`K.floatx()` is the preferred way to access this.
One option would be to pass add an arg for the local fs path (or even an open file handler).
I'd expect the set to be done after mangers & admins are added
This method definition shares most of its functionality with `get_request` method, which indicates that the common functionality (common parameters, error handling, etc.) should be extracted into private method.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
You're right. You know I both saw that and missed it too...
You're right. You know I both saw that and missed it too...
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
The query should be something like ``` G.V().Has('TID', 'bd7f5334-115c-5943-487d-a77c486fa854') ``` according to the `name`
Since this isn't implemented, perhaps lets not mention it? I found it confusing
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
You asked me about the `lru_cache` here; I don't think it matters one way or another :-)
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
```suggestion raise AnsibleError('Unable to use "%s" as a search parameter: %s' % (term, to_native(e))) ```
The current coding style prefers single quotes. Please fix throughout, but new code only. ```suggestion if 'PICKLE_VERSION' in options: ``` _(Eventually it will be double quotes when we can use `black`.)_
You asked me about the `lru_cache` here; I don't think it matters one way or another :-)
Plz also use `match` arg here
Required=false are implicit could you remove them ? Default=None too in case of string
Please remove empty line.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Maybe this should be a class docstring :thinking:
I'd go for underlining.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Maybe this should be a class docstring :thinking:
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
If the minimum value is `1.17` as per module docs, shouldn't this be a float? ```suggestion video_memory_mb=dict(type='float'), ```
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
Please remove empty line.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
It looks like there's a race condition here. The log file could be read before supervisord has reopened it.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
1) No need to inherit from object explicitly due to `__metaclass__ = type` set above 2) It's nice to properly support all stringifications ```suggestion @six.python_2_unicode_compatible class CollectionRequirement: ```
I think it would be better to put these tests in `tests/auth_tests` unless there's some reason that's not feasible.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
fixture with load_json
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
As above, wrap the format in quotes. "Your URL pattern '{}' has .."
As above, wrap the format in quotes. "Your URL pattern '{}' has .."
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
And the same here
```suggestion del self.headers[header] ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion re.compile(br'[\r\n]?<.+>(?:\s*)$'), ``` And so on for all the entries of both `terminal_stdout_re` and `terminal_stderr_re`.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Do we need to specify `human` as an option? That could just the default and `yaml` or `json` are specified.
Maybe this should be a class docstring :thinking:
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
We can add assertion for number of queries `self.assertNumQueries(0)` because that's the real impact of this optimization.
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
correction: It's not a byte string, it's a raw-string literal
Maybe this should be a class docstring :thinking:
a leftover here which can be removed
This could be problematic. If you set the seed to a constant and use multi-processing then all children processes would share the same seed and you'll get batches with repeated samples.
Or just a random 16bit IV.
If you make this: ```python with self.assertRaises(VariableDoesNotExist) as exception_ctx: ``` then later on when you need the exception you can just do: ```python self.assertEqual( str(exception_ctx.exception), ... ) ``` which looks a bit cleaner than the `exc_info[1]` stuff.
be more specific than Django -- e.g. "CommonMiddleware"
Then people's results won't be valid and they won't have a way to know! Imagine if you're trying to train on very small datasets and you skip one.... I think raising an Exception is the correct behavior.
@Dref360 I can throw a specific exception for the case a data element should be just skipped.
It should be noted that this is an optional epoch break point if your `data/epoch_generator` does not stop.
Use `num_` as the counter prefix for naming consistency.
Use `num_` as the counter prefix for naming consistency.
You're right. You know I both saw that and missed it too...
The task name is incorrect (copy-paste error). Please, consider introducing a proper task name: ```yaml - name: gather the time at the end of the operation ```
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Required=false are implicit could you remove them ? Default=None too in case of string
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Thanks. I think that gives a pointer in the right direction. 👍
Should raise a ValueError instead.
"for working with retry limiting"
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Should use `assertRaisesMessage()` to verify the string also.
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
Should use `assertRaisesMessage()` to verify the string also.
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
Maybe this should be a class docstring :thinking:
It's already stripped: ```suggestion (PODMAN_OUTPUT, ''), ```
I'd also include a check for server errors (500)
Yes, I know. I'll leave it to Aymeric for a second opinion.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Please use a single quote.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Again, imports at the top of the file
```suggestion if 'num' in opt and opt['num'] not in special_num: ```
This can be single-lined.
Could be reduced to a list comprehension ```python return [ value for key, value in request.POST.items() if regexp.match(key) ] ```
Could be reduced to a list comprehension ```python return [ value for key, value in request.POST.items() if regexp.match(key) ] ```
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ok, not sure why this one is still open.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
SubnetIds expects a list `[result['subnets'][0]]`
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I don't think returning `stdout` is necessary. _Maybe_ returning `stderr` could be helpful, but a better approach would be using `fail_json()` when an error is encountered and displaying `stderr` there rather than returning it by default. Also, it'd be nicer to use a literal here rather than a generator. ```python results = { 'changed': False, 'volumes': inspect_results, 'stdout': out, 'stderr': err } ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
we could U() the link
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Not added in module definition, (required_one_of)
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should be the version that you will be removing the functionality
This should be the version that you will be removing the functionality
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
I see, thanks for your answer. I really don't want to hold the template based widget stuff from landing any longer. I suppose this is something we could refactor later on.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Maybe this should be a class docstring :thinking:
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
This break will be unnecessary if the loop gets dropped
Maybe this should be a class docstring :thinking:
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Remove the PY3 conditional below and just do `cmd = b"\nexit\n"`. There's no variable substitution so just create the byte string itself.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
`raise` is missing. Call to `str` is useless there.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
I'd go for underlining.
I think we should be consistent and use double-quotes.
Please use 'msg' for returned messages, this is a standardized return value.
pytest.mark.skip Though I'm surprised we did not see any bot error.
Same question for dropping lambda here as well.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
`raise` is missing. Call to `str` is useless there.
I guess we could try calling the primary key's `to_python` instead of hitting the database here. ```python def get_list_editable_queryset(self, request, prefix): object_pks = self.get_edited_object_pks(request, prefix) queryset = self.get_queryset(request) validate = queryset.model._meta.pk.to_python try: for pk in object_pks: validate(pk) except ValidationError: # Disable optimization return queryset return queryset.filter(pk__in=object_pks) ```
This class does not need to live inside this method.
Maybe this should be a class docstring :thinking:
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
If the user is able to make the server sign arbitrary data of their choosing, using the same salt and key will yield the same signature. However, if we slightly modify the key, they can't. This makes chosen plaintext attacks less vulnerable.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
same for these 2, though in diff from
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
prefer including a trailing comma in kwargs so if more items are added in the future we don't have to modify this line again
Maybe this should be a class docstring :thinking:
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Not sure why the error starts with a whitespace here.
Not sure why the error starts with a whitespace here.
Maybe this should be a class docstring :thinking:
It seems this URL doesn't work anymore.
Should the default be https, if so update docs
Should the default be https, if so update docs
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Should the default be https, if so update docs
Should the default be https, if so update docs
Should the default be https, if so update docs
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Should the default be https, if so update docs
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Should the default be https, if so update docs
this is not a good test, and could cause bugs in the future
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Could be a personal or project preference for all I know, but does this re-assignment need to occur, instead of just having `return _format_string(f'{number:f}', ...)`? Doubt it matters much, of course.
Could be a personal or project preference for all I know, but does this re-assignment need to occur, instead of just having `return _format_string(f'{number:f}', ...)`? Doubt it matters much, of course.
this is not a good test, and could cause bugs in the future
Please raise a `NotIplementedError` when the use case is not supported yet.
I think we should be consistent and use double-quotes.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
this should just be `db_instances=results` - otherwise the instance data gets resnakified and tag case won't be preserved.
This doesn't support aurora snapshots. Besides that, this looks great.
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Cool. Thanks. Let me know once done.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
TIL that character classes also work inside `[]` :D
put closing ) on next lin
Same question for dropping lambda here as well.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
The other formats.py seem to use `'\xa0'`
unicode -> str (Python 3, first)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Maybe this should be a class docstring :thinking:
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
I think we should add also `lzma` format.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Note: I believe that both python2 and python3's json.loads() can handle resp_data as unicode strings. So you should be able to do this like this: ``` python from ansible.module_utils._text import to_text [...] resp_data = resp.read() resp_data = to_text(resp_data, errors='surrogate_or_strict') resp_json = json.loads(resp_data) ``` to_text is a nice helper because it allows much better control over tracebacks and won't touch the value if resp_data is already a text string (whereas resp_data.decode could traceback if resp_data is already a text string for some strange reason)
add trailing ,
add trailing ,
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
In most of cases names won't contain multibyte chars, so it should be worth avoiding multiple encoding and slicing, e.g.: ```python if len(table_name.encode()) == len(table_name): table_name = table_name[:other_length] else: # Shorten table name accounting for multibyte characters. while len(table_name.encode()) > other_length: table_name = table_name[:-1] ```
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
add trailing ,
I missed this one in my last review: ```suggestion raise SystemExit('ERROR: Ansible requires the filesystem encoding to be UTF-8; Detected %s.' % fs_enc) ```
Oops. I think you meant to put the space to the _**right**_ of the quote!
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like {0}
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
Type of `src` should be `path` (advantage: `os.path.expanduser` and `os.path.expandvars` will be called automatically).
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This should go outside of try block
We can move `msg` before assertions ```python msg = "'City' instance expected, got %s" % chicago.pk with self.assertRaisesMessage(TypeError, msg): ... with self.assertRaisesMessage(TypeError, msg): ... ```
no wholesale exceptions plz
`self.assertEqual(f.choices), [])` looks simpler to me (plus if the list isn't empty, another debugging step isn't needed to see what the list contains).
We can move `msg` before assertions ```python msg = "'City' instance expected, got %s" % chicago.pk with self.assertRaisesMessage(TypeError, msg): ... with self.assertRaisesMessage(TypeError, msg): ... ```
Since we expect the name to start with 'http://' or 'https://' I would so this: ```python if name.startswith('http://') or name.startswith('https://'): ... ```
no wholesale exceptions plz
no wholesale exceptions plz
no wholesale exceptions plz
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
that's the default in 1.9, but I don't if you want to include it anyway
that's the default in 1.9, but I don't if you want to include it anyway
that's the default in 1.9, but I don't if you want to include it anyway
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Required=false are implicit could you remove them ? Default=None too in case of string
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
maybe create_and_call -> "test" to be a bit shorter
maybe create_and_call -> "test" to be a bit shorter
maybe create_and_call -> "test" to be a bit shorter
maybe create_and_call -> "test" to be a bit shorter
Since 'iso-8859-1' is being used in the line above also, I wonder if it is not better have a variable on top like `FALLBACK_ENCODING = 'iso-8859-1'`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
this should use the new API without hardcoded id now
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
For the author information we normally only keep name and GitHub handle.
For the author information we normally only keep name and GitHub handle.
Is this line correct? Above it's `subTest(url=url_name)` but then we `reverse(url_name,...)`
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Not sure how much a difference it makes, but it seems better to store this in Python rather than having to read from a text file. Worth it to make the file location customizable? If so, it might be nice to make "common passwords" a separate package so we don't have to include that list in Django. I guess users might not care for the additional setup tasks though.
I see now. I think a more readable structure would be to rename `SimplePoFileTests` to something like `PoFileAssertionMixin` and use that as well as `SimpleTestCase` in the subclasses.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
check that -> and that (no comma needed since the two clauses are independent)
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
That's a really interesting piece of information I did not know.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Exception handling here too.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Is it correct that this `args` is different from the previous test? I'd expect the same test for both Python 2 and 3 with something like `self.assertEqual(response.status_code, 200 if six.PY3 else 404)` but maybe I missed something.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
This exception message is different from that in `related.py` though the logic/intention surrounding it seems to be the same. Is this intentional? (FWIW, I find the message in `related.py` to be clearer)
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Should this be `response` since that is what is returned? I don't see `result` used within this function.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Indeed, we do not need to be so specific. The downside I see when being permissive is a bit more computation by going more often in `get_supported_language_variant` and possible `get_supported_language_variant` lru cache exhaustion. But I don't see a nice alternative.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Might want to use simple quote here.
The vmware modules only support Python 2.7 because of pyvmomi.
The vmware modules only support Python 2.7 because of pyvmomi.
The indentation is a bit odd here, it gives the impression that the second line is still in the isinstance()
Please remove empty line.
fixture with load_json. If it's not valid json then load_json just gives you back a plain string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This argument is only accepted in Python 3, it would not work with Python 2.
a leftover here which can be removed
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
```suggestion trailing_punctuation_chars = '.,:;!' wrapping_punctuation = [('(', ')'), ('[', ']')] ```
This doesn't seem right. Surely `show_save_and_continue` should only be available if you can change an existing item. If you only have the _add_ permission and not _change_, once you have added an item, you can no longer change it.
You shouldn't need the extra parentheses inside `extend()`, FYI.
Remove this line as `is_popup` is already added by `ctx = Context(context)`. The local variable is just for convenience.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Exception handling here too.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
no need to specify required=False or type=str as these are defaults
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
`band_input`, you don't get much by saving one char :-)
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
Isn't the existing behavior better here? ``` raise ValueError('CNTK Backend: Invalid data_format:', data_format) ```
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
chop the blank lines before each attribute
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Since the very first thing that both of the above do is create a ```PasswordManagerPro``` object and then they just lightly wrap a method call on that object, it seems like they should really be integrated into the methods they're calling.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Cool. Thanks. Let me know once done.
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
Same as for the updated, I'd rather say `has been deleted`
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Are there any disks apart from system disks? If so then this should be named `system_disk_category` and remove the aliases.
`default=None` is the default (can be removed from the others too, along with `required=False`, if desired)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Style note, I finally convinced people a year or so ago that ```{}``` is superior to ```dict()```. So new code should use the literal syntax.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
In the `exit_json`, you should also return `changed` and `state`.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
In the `exit_json`, you should also return `changed` and `state`.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
It is looking like `height_factor` and `width_factor` can only be positive integers. This should be specified in the docstring. The API makes it sound like `*_factor` could be a float (e.g. 0.75 for an output image with 75% of the original height).
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
I would say `Deploy key has been updated` instead of `should have been updated`
It is looking like `height_factor` and `width_factor` can only be positive integers. This should be specified in the docstring. The API makes it sound like `*_factor` could be a float (e.g. 0.75 for an output image with 75% of the original height).
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
Maybe this should be a class docstring :thinking:
`asc` is misleading, because it's basically a default ordering. Renamed to the `default_order`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
this line could go in "else" of try/except/else
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
pytest.mark.skip Though I'm surprised we did not see any bot error.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This should also use UTC now. The test should used a fixed year and find a way to mock `parse_http_date`'s way of obtaining a current year.
`# Sphinx 1.6+` is enough
Generally we don't treat usernames as secrets, so no need to mask
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
PEP 8 requires this blank line
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
As far as I'm concerned this should impact only `307` and `308` redirects, so maybe: ```diff diff --git a/django/test/client.py b/django/test/client.py index b26504f762..e4201bead4 100644 --- a/django/test/client.py +++ b/django/test/client.py @@ -827,7 +827,10 @@ class Client(ClientMixin, RequestFactory): if response.status_code in (HTTPStatus.TEMPORARY_REDIRECT, HTTPStatus.PERMANENT_REDIRECT): # Preserve request method post-redirect for 307/308 responses. - request_method = getattr(self, response.request['REQUEST_METHOD'].lower()) + request_method = response.request['REQUEST_METHOD'].lower() + if request_method != 'get': + extra['QUERY_STRING'] = url.query + request_method = getattr(self, request_method) else: request_method = self.get data = QueryDict(url.query) ```
I wouldn't omit parenthesis here
I wouldn't omit parenthesis here
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
please check code with flake8 (`E231 missing whitespace after ','`)
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
please check code with flake8 (`E231 missing whitespace after ','`)
please check code with flake8 (`E231 missing whitespace after ','`)
Please remove empty line.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
fixture with load_json
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
fixture with load_json
Please change these vars to ansible Host vars rather OS env vars.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
Since this `int()` call is no longer inside a `try` `except`, we now get a stack trace if the checksum is an invalid base 16 value. ``` ValueError: invalid literal for int() with base 16: '541a1ef5373be3dc49fc542fd9a65177b664aec01c8d8608f99e6ec95577d8ci' ``` ```suggestion try: int(checksum, 16) except ValueError: module.fail_json(msg='The checksum format is invalid', **result) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
We prefer hanging indent style like this: ``` self.assertEqual( res.context_data["form"].errors["__all__"], ['You must confirm the delete.']) ) ``` Also please drop the u prefix on strings.
task_uuid seems unused
I'm not sure what this sentence means
task_uuid seems unused
We prefer hanging indent style like this: ``` self.assertEqual( res.context_data["form"].errors["__all__"], ['You must confirm the delete.']) ) ``` Also please drop the u prefix on strings.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
nit: It doesn't actually set anything in the context, it's just a context processor that returns values that will be set in the context.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
I think you can safely remove this.
Just `params.get('jump')` is enough. `None` is already the default value.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
I think you can safely remove this.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
I think we should be consistent and use double-quotes.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Generally we don't treat usernames as secrets, so no need to mask
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
We don't modify `creation` so there is no need to create a new one.
Generally we don't treat usernames as secrets, so no need to mask
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Required=false are implicit could you remove them ? Default=None too in case of string
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You have some syntax errors in this `if` statement.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think that this part can be dropped: ```diff diff --git a/tests/db_functions/test_datetime.py b/tests/db_functions/test_datetime.py index 51dbcb6..3560a76 100644 --- a/tests/db_functions/test_datetime.py +++ b/tests/db_functions/test_datetime.py @@ -211,12 +211,6 @@ class DateFunctionTests(TestCase): self.create_model(end_datetime, start_datetime) self.assertQuerysetEqual( - DTModel.objects.annotate(extracted=Extract('duration', 'epoch')).order_by('start_datetime'), - [(start_datetime, int((end_datetime - start_datetime).total_seconds())), - (end_datetime, int((start_datetime - end_datetime).total_seconds()))], - lambda m: (m.start_datetime, m.extracted) - ) - self.assertQuerysetEqual( ```
Maybe this should be a class docstring :thinking:
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
```suggestion # just get value from attribute itself as normal ```
```suggestion # just get value from attribute itself as normal ```
For theano, `ratio` needs to be `integer`. ```python ratio = height_factor // width_factor ```
@samdoran then, I'd say that there's something wrong with the setup and TZ should be adjusted somewhere.
In the `exit_json`, you should also return `changed` and `state`.
Just use ` and ...` instead of nesting. Less indentation == better readable.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
For readability please include a blank line between tasks ```suggestion - name: Retrieve credential from CyberArk Vault using PAS Web Services SDK via Central Credential Provider ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
chop the blank lines before each attribute
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Remove the PY3 conditional below and just do `cmd = b"\nexit\n"`. There's no variable substitution so just create the byte string itself.
In addition to type, I think you should also check the value after clipping by placeholder variable.
Use single quotes.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
Both `update_fields` and `unique_fields` should be passed through. You can keep them as positional arguments: ```suggestion return super().on_conflict_suffix_sql(opts, fields, on_conflict, update_fields, unique_fields) ```
I was unable to find examples of a `default` that is not listed in `choices` on the internet. This may need to be checked experimentally.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Looking at the code now, it's wrong. You don't have `self.error` anymore. And the KeyError will never hit, so you surely didn't test these failures. (integration tests !) There's also no difference between `>= 300` and `>= 400` so I guess `>= 300` only would do (but I don't know if that is intentional).
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
I think we should be consistent and use double-quotes.
I'd rename `subminor` to `patch`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
And there: ``` work_file = os.path.join(self.dirpath, '%s.c' % self.file) ```
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This won't work as is because `In.process_rhs` optimizes empty result sets which breaks vacuous truth in this case. In other words `.filter(field__notin=[])` won't return *any* results when it should return *all* results.
ok, just something for consideration, I trust your/the community's judgement on it
This is unreachable code, as module.fail_json will be exit point the module.
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
I'd expect the set to be done after mangers & admins are added
I'd expect the set to be done after mangers & admins are added
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
I'd expect the set to be done after mangers & admins are added
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
This might fail on python 3 and json.loads expects string and getvalue() will return bytes .
Maybe this should be a class docstring :thinking:
Cool. Thanks. Let me know once done.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Maybe this should be a class docstring :thinking:
This might fail on python 3 and json.loads expects string and getvalue() will return bytes .
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
use the `missing_required_lib` function from `ansible.module_utils.basic`
use the `missing_required_lib` function from `ansible.module_utils.basic`
Maybe this should be a class docstring :thinking:
use the `missing_required_lib` function from `ansible.module_utils.basic`
use the `missing_required_lib` function from `ansible.module_utils.basic`
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
I think you need `to_native` here.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Cool. Thanks. Let me know once done.
`cls.staff_user = User.objects.create_user(username='user', password='secret', email='user@example.com', is_staff=True)`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Don't use automatic field numbering!
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Don't use automatic field numbering!
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
no need to specify required=False or type=str as these are defaults
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This could be simplified to use `m.groups()`...
I wouldn't have changed the ones where the test doesn't care either way what type of redirect is done (of course we'll have to go back to silencing those)
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
I'd move these two into describe_subnets, makes a bit more sense there I think.
Can you use the waiter for this instead? http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Waiter.SubnetAvailable
I looked at the log and realized those tests are run with `USE_TZ=False` so everything should be good here.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
I'd move these two into describe_subnets, makes a bit more sense there I think.
I don't understand why we have methods with a double underscores prefix which are copies from `SessionBase`, e.g. `__hash()`, `__legacy_encode()`, `__legacy_decode()` :thinking:
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Keep `vswitch_name` for backward compatibility.
Keep `vswitch_name` for backward compatibility.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
`kwargs` parameter is neglected, all subclass context data is ignored
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
This can be converted to return True. No need of new variable retry_request
I'd move these two into describe_subnets, makes a bit more sense there I think.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
missing quote after `modelname` which should also be `model_name`
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
Maybe this should be a class docstring :thinking:
WDYT about adding `or self.title` here? ``` python self.title = title or self.title or self.lookup_title ``` This would add support for the following: ``` python class MyStaffFilter(BooleanFieldListFilter): title = "By can haz admin" # no effect :( overwritten in __init__ @admin.register(User) class UserAdmin(UserAdminBase): list_filter = ( ("is_staff", MyStaffFilter), ) ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
```suggestion """ Parse a Content-type like header. Return the main content-type and a dictionary of options. """ ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
Use single quotes consistently.
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Yes, I know. I'll leave it to Aymeric for a second opinion.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I think we should be consistent and use double-quotes.
In the current implementation if ``supported_formats`` evaluates to ``False``, then there would be a trailing space at the end of the error message. Probably it would be better to remove it from this string and add it to the string below: ``` msg += ' Allowed formats: {0}'.format(', '.join(supported_formats)) ```
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I'd go for underlining.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I'm rather confused here. It looks like we are both using the `json` module to create JSON, as well as hand crafting JSON? I strongly recommend, dropping this functionality, and building out an actual python datastrcuture, and just using `json.dumps` on the final result.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
why an empty string? might as well use assertRaises at that point.
Maybe this should be a class docstring :thinking:
That's a really interesting piece of information I did not know.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Could maybe use self.find_file_in_search_paths(variables, ['templates', 'vars', 'files'], fn) here.
ERROR rather than BLAH :)
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Maybe this should be a class docstring :thinking:
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
You could do solve this recursively, but I don't know if this better readable really. meh
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
I think it's not pylint itself, but our own checks...
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
This should probably mention both slash and no-slash paths...
no need to specify required=False or type=str as these are defaults
Is the copy absolutely necessary? Wondering.
Required=false are implicit could you remove them ? Default=None too in case of string
Should the default be https, if so update docs
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```python elif max_num is not None and () ```
```python elif max_num is not None and () ```
```python elif max_num is not None and () ```
Same note here as for bundler
Same note here as for bundler
Same note here as for bundler
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Move this line to line 15 and you're good :smile:
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This docstring should be used for the `CallbackModule` class instead of the module.
Please rebase your branch. Master now supports Python 3 only, so `unicode_literals` may be removed.
remove extra newline
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
.get() falls back to None to `False` isn't really needed I think.
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
The other formats.py seem to use `'\xa0'`
Isn't `raise` missing there ? Calls to `str` are useless.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
You're right. You know I both saw that and missed it too...
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Maybe this should be a class docstring :thinking:
Are you sure about the commas in the `DATETIME_INPUT_FORMATS` strings? I don't think any other locale has those.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
My point wasn't the r prefix (I just copied that from above), it was moving the dash next to the close-bracket. But now that you mentioned it -- yes, the first and last (`'\.'` and `'\.?'`) need an r prefix, because without it the strings don't have a backslash in them and these expressions will just match anything. I think a test for this could use some invalid punctuation as the separator for the tld -- e.g. `http://unquoted~dot!`
chop the blank lines before each attribute
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
That's a really interesting piece of information I did not know.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
I'd go for underlining.
Maybe this should be a class docstring :thinking:
is this limited to TLDs? it seems all labels are limited to 63 characters.
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
ditto on `.` in character groups
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This test works without the patch, I will move it to a separate commit.
I would suggest using ``` python from six.moves import configparser ``` Currently inventory scripts aren't real consistent about how they handle compat issues like configparser, but thats closest to how the app code and modules do it (they use the six provided in module_utils, but that is not recommended for external inv scripts) ``` python from ansible.module_utils.six.moves import configparser ```
Do we expect users to use strings like `&&` and `&` directly anywhere else? It seems like we're exposing an implementation detail we'd usually hide.
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
Do we expect users to use strings like `&&` and `&` directly anywhere else? It seems like we're exposing an implementation detail we'd usually hide.
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
Maybe this should be a class docstring :thinking:
Why is it `ClearableFileInput` and not `FileInput`? Tests are also required.
Need a colon at the end here
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
This is fine as is.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
ok, just something for consideration, I trust your/the community's judgement on it
+1 this isn't used anywhere
Maybe this should be a class docstring :thinking:
I found sources that claim that it's Sunday :thinking: : - https://www.timeanddate.com/calendar/?year=2021&country=69 - https://en.wikipedia.org/wiki/Names_of_the_days_of_the_week#Days_numbered_from_Sunday
Could you remove this outer try/except (it was only for debugging)? The build is failing because `print` needs to be `print(e)` for Python 3 compatibility but that can be removed anyway.
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
This changes the return value of `_urlparse`. I think it would be more appropriate to catch the `ValueError` in `_is_safe_url` instead and return `False` there.
```suggestion trailing_punctuation_chars = '.,:;!' wrapping_punctuation = [('(', ')'), ('[', ']')] ```
Maybe this should be a class docstring :thinking:
is this limited to TLDs? it seems all labels are limited to 63 characters.
ok, just something for consideration, I trust your/the community's judgement on it
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
I think you can use `assertRaisesMessage` throughout these tests.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
I do not believe this change is correct. The main config file is different than the location of the policy files. The policy directory will exist in `/etc/selinux/[policy name]`. We would need a separate parameter, `policy_path`, in order to check that the policy exists.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this changed from a list to a string. Perhaps this is related to the "h" message in the error.
TIL that character classes also work inside `[]` :D
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
TIL that character classes also work inside `[]` :D
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
a leftover here which can be removed
Will this command work on all supported platforms? I tried this patch on mac and it failed. Example I used: ``` - git: repo: 'https://github.com/ganeshrn/ansible.git' dest: /var/tmp/ansible archive: yes ``` ``` TASK [git] ************************************************************************************************************************************************ fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "msg": "Failed to perform archive operation"} ```
`raise` is missing. Call to `str` is useless there.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
`raise` is missing. Call to `str` is useless there.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
When hitting an error you must exit with module.fail_json
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
When hitting an error you must exit with module.fail_json
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
When hitting an error you must exit with module.fail_json
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Fine. Yes. (I had a play: there's no actual logic error, since it's pulling the value from the parent scope...) Ta.
Maybe this should be a class docstring :thinking:
well, maybe. I haven't checked what `.absolute()` does.
Maybe this should be a class docstring :thinking:
Please use 'msg' for returned messages, this is a standardized return value.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I'd go for underlining.
I'd go for underlining.
immediatelly -> immediately
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
Not sure why the error starts with a whitespace here.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
there is no need to version params for new modules
The description looks wrong...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Not sure why the error starts with a whitespace here.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
there is no need to version params for new modules
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Not sure why the error starts with a whitespace here.
Maybe this should be a class docstring :thinking:
what will happen if modification of `.git` file fails while `.git/` dir is already moved? I think we could try to roll it back.
to_text and prefix the string with u.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
the closing `)` on this line is misplaced.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
use the `missing_required_lib` function from `ansible.module_utils.basic`
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
This one is a bit newer to CliBase, but also implemented verbatim in superclass
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I think we should be consistent and use double-quotes.
```suggestion b_password_string = b"|".join((br'(\w+\'s )?' + to_bytes(p.format(**self._fields))) for p in prompts) ``` `.format` requires splatting the dict, instead of just the dict itself
after_group does not exist at this point, this will stacktrace
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
It should give 'Modification de Title et Historique.'. I guess a gettext call is missing inside the `LogEntry.get_change_message`.
Fields can use custom encoders so it's better to use `get_prep_value()`.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
I can't see a need for it...
ok, just something for consideration, I trust your/the community's judgement on it
I wouldn't write a function which was itself a single function call ;-)
ok, just something for consideration, I trust your/the community's judgement on it
preferred format: "#12554 - Make sure ..."
preferred format: "#12554 - Make sure ..."
I wouldn't write a function which was itself a single function call ;-)
Maybe this should be a class docstring :thinking:
I'll update this... try/except isn't needed -- that just makes debugging in the case of a failure more difficult since it hides the traceback.
Rather than raising Exception that isn't caught anywhere, fail_json should be called.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Rather than raising Exception that isn't caught anywhere, fail_json should be called.
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
this should use the new API without hardcoded id now
An example of using the `mocker` fixture. ```suggestion def mock_NamedTemporaryFile(mocker, **args): mock_ntf = mocker.MagicMock() mock_ntf.write = mocker.MagicMock() mock_ntf.close = mocker.MagicMock() ```
`str` isn't needed here.
Maybe this should be a class docstring :thinking:
Remove this since it doesn't do anything and `Mock` isn't defined.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
``` "Unable to get hooks from repository %s: %s" % to_native(err) ``` to ``` Unable to get hooks from repository :%s" % to_native(err) ```
Exception handling here too.
Exception handling here too.
Exception handling here too.
please remove your email here.
Exception handling here too.
Exception handling here too.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
That's a really interesting piece of information I did not know.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
No, no, the module name should definitely be singular. I would probably use internally the same name as the REST API, especially because it is not exposed to the user and the internal stuff is in itself more consistent. But again, a personal choice, not something that is written into stone. (I think the plurar in the REST interface does make sense and is a common thing even, because it does e.q. affect networks, but that is debatable).
Why do you wait to fail ? I think you must fail in "main"
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
That's a really interesting piece of information I did not know.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion vault_data(), ```
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
use `self.MAX_FILES` instead of 999999
@pierremahot we'll need a test for this
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
chop the blank lines before each attribute
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion 'field_name': 'related_questions', ```
```suggestion 'field_name': 'related_questions', ```
shorten line (rule of thumb I'm using is ~120 characters so I don't have scroll horizontally in github review)
Maybe this should be a class docstring :thinking:
All of these empty tests look awkward. I'll try to find a better way to share some tests -- probably along the lines of ``` python class CSRFTestBase(object): # all the common parts go here class CSRFCookieTest(CSRFTestBase, TestCase): # Cookie-specific tests and utilities class CSRFSessionTest(CSRFTestBase, TestCase): # Session-specific tests and utilities ```
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Line 355 to 368 are unused.
Generally we don't treat usernames as secrets, so no need to mask
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
In the `exit_json`, you should also return `changed` and `state`.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
In the `exit_json`, you should also return `changed` and `state`.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Forgot to mention earlier, but on first look I found `[a-z-' + ul` a little confusing because of the dash between two ranges that actually serves as a dash and not a range separator. I think it would be more readable as `[a-z' + ul + r'-]` (similar to how it is in `domain_re` above).
Strike that: ``` In [1]: '\.' Out[1]: '\\.' ```
that's the default in 1.9, but I don't if you want to include it anyway
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Please use 'msg' for returned messages, this is a standardized return value.
Please use 'msg' for returned messages, this is a standardized return value.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
On second thoughts creating a URL with to_field isn't required to test this issue – so the string interpolation can simply be removed: ```suggestion admin_user_change_url = reverse( "admin:%s_%s_change" % (user._meta.app_label, user._meta.model_name), args=(user.username,), ) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
On second thoughts creating a URL with to_field isn't required to test this issue – so the string interpolation can simply be removed: ```suggestion admin_user_change_url = reverse( "admin:%s_%s_change" % (user._meta.app_label, user._meta.model_name), args=(user.username,), ) ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Maybe this should be a class docstring :thinking:
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Exception handling here too.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
use the `missing_required_lib` function from `ansible.module_utils.basic`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please use `msg` instead of `result`. Also the standard casing for both parameters as well as return values is snail_case. So it would become `deploy_key` instead of `deployKey`.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Maybe this should be a class docstring :thinking:
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion self.params[k] = 2 if v == 'dns' else 1 ```
This can be converted to return True. No need of new variable retry_request
Exception handling here too.
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Generally we don't treat usernames as secrets, so no need to mask
We have no intention of adding attrs as a dependency.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Please write as: ``` if __name__ == "__main__": main() ```
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
This check isn't quite right since it would just check lexicographically (e.g. `'2.9.0' > '2.11.0'`, but the former is a smaller version than the latter). For now this will probably work fine since we don't hit minor version numbers that large, but eventually this won't work (e.g. major version numbers go > 9). (Similarly, the sort of tags isn't quite right either.)
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
This can be single-lined. ```suggestion '<option value="" selected="">---------</option>', ```
The current names are misleading, e.g. `RenderableForm` is not really a render-able form it's a mixin which makes the form render-able. I would rename these classes: - `Renderable` to `RenderableMixin`, - `RenderableForm` to `RenderableFormMixin`, - `RenderableError` to `RenderableErrorMixin`.
Use single quotes consistently.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This change is backwards incompatible for someone having subclassed the widget and customized `none_value`. We might let `none_value` as is, and simply update `none_value` in `__init__` (I'm open to arguments...).
Maybe this should be a class docstring :thinking:
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
This change is backwards incompatible for someone having subclassed the widget and customized `none_value`. We might let `none_value` as is, and simply update `none_value` in `__init__` (I'm open to arguments...).
Use single quotes consistently.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
Isn't `raise` missing there ? Calls to `str` are useless.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
Isn't `raise` missing there ? Calls to `str` are useless.
no need to specify required=False or type=str as these are defaults
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
There doesn't appear to be any way for `sha1sum_old` to be `None`.
It looks like Python3 doesn't raise an error. It surrogateescapes: ``` [toshio@el7-test ~][PROD]$ TESTING='cafÃ©' LC_ALL=C python3.6 test.py 'caf\udcc3\udca9' [toshio@el7-test ~][PROD]$ cat test.py import os a = os.environ.get('TESTING') print(repr(a)) ```
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Causes unhelpful error if get() returns None ``` $ cat nmap_inv.yml plugin: nmap $ ansible-inventory -i nmap_inv.yml --graph ERROR! Invalid settings supplied for address: argument of type 'NoneType' is not iterable ```
Causes unhelpful error if get() returns None ``` $ cat nmap_inv.yml plugin: nmap $ ansible-inventory -i nmap_inv.yml --graph ERROR! Invalid settings supplied for address: argument of type 'NoneType' is not iterable ```
So removed `required=False` and add `type='str' instead. Do this for the others as well.
It looks like Python3 doesn't raise an error. It surrogateescapes: ``` [toshio@el7-test ~][PROD]$ TESTING='cafÃ©' LC_ALL=C python3.6 test.py 'caf\udcc3\udca9' [toshio@el7-test ~][PROD]$ cat test.py import os a = os.environ.get('TESTING') print(repr(a)) ```
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Just got a typo here 😁 ```suggestion # assert joined_url and pw_change_url are identical ```
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
This one is a bit newer to CliBase, but also implemented verbatim in superclass
This one is a bit newer to CliBase, but also implemented verbatim in superclass
I'd put this caveat below the option descriptions, and say something like `Use the started/allocated/restarted arguments to manage the VM's power state`. (note the distinction of module argument to valid options for those arguments)
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
You shouldn't need the extra parentheses inside `extend()`, FYI.
Are both host groups really needed? Does the one that contains ':' handle both? We have regex in other places in the project that do similar parsing we may want to keep in sync: - https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/utils/Utils.java#L53 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/BrokerEndPoint.scala#L27 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/EndPoint.scala#L29
Maybe this should be a class docstring :thinking:
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
Use `six.assertRegex` to avoid the deprecated alias on Python 3.
Maybe this should be a class docstring :thinking:
It could be `url_uname=url_name` but I don't think it matters much as it's only cosmetic.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think you can safely remove this.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
okey. not a big deal.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
Why do you wait to fail ? I think you must fail in "main"
remove extra newline
Why do you wait to fail ? I think you must fail in "main"
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I'd rename `subminor` to `patch`.
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
Every day I get to learn something new. Thanks.
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I would say `Deploy key has been updated` instead of `should have been updated`
The security group rule and the trunk are not present in any of the resources' contents here: https://github.com/openstack/openstacksdk/tree/master/openstack/cloud, consequently using the `cloud.get_<resource>` call fails. Instead the `could.network` call can be used.
I would say `Deploy key has been updated` instead of `should have been updated`
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Maybe this should be a class docstring :thinking:
I'd move these two into describe_subnets, makes a bit more sense there I think.
Use single quotes.
What is the reason of change? it would break the backwards compatibility.
not a blocker but default=None is not needed because it is already the default and can be omited.
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
Is there a typo? I'm not sure what "hub" means in this sentence.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
TIL that character classes also work inside `[]` :D
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
I would use `%s` formatting consistently.
For easier typing and consistency with elsewhere, I'd omit the dash in the domains and names.
For easier typing and consistency with elsewhere, I'd omit the dash in the domains and names.
I'd use .objects.create
That's not the correct solution, with e.g.: ```python DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'OPTIONS': { 'service': 'django_ticket', } }, } ``` the connection parameters will be set to: ```python {'database': 'postgres', 'service': 'django_ticket'} ``` The default `postgres` db shouldn't be used in this case.
While you're making changes for readability, I would find it best to declare one key-value pair on each line, like you did in the other diff.
Can you simplify using `super()`, e.g. something like-- ```python kwargs = super().get_test_runner_kwargs() if hasattr(self, 'stream'): kwargs['stream'] = ... return kwargs ```
I think we should be consistent and use double-quotes.
This would be a nice place to use tuple expansion `action, index = index_of_matching_route(....)`
Maybe this should be a class docstring :thinking:
> ... so I made it a required parameter. Sorry, I think we're not understanding each other. 🤔 * The `on_bind` parameter is defined as `on_bind=None`, so it's optional. * Exactly when `on_bind=None` that `server_bind` is only declared conditionally with lead to a `... is referenced before assignment` problem. If looks like this: ``` >>> on_bind = None >>> if on_bind is not None: ... a = "I won't be defined" ... >>> a Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name 'a' is not defined ```
> ... so I made it a required parameter. Sorry, I think we're not understanding each other. 🤔 * The `on_bind` parameter is defined as `on_bind=None`, so it's optional. * Exactly when `on_bind=None` that `server_bind` is only declared conditionally with lead to a `... is referenced before assignment` problem. If looks like this: ``` >>> on_bind = None >>> if on_bind is not None: ... a = "I won't be defined" ... >>> a Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name 'a' is not defined ```
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
Perhaps we should continue to test the simpler case where we don't provide a `name` or `condition`.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This is indented 4 spaces too much.
We could fall back to `__file__` or something in that case at minimum. Could be useful to include that regardless.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
You should have spaces around the `-` operator.
Unrelated, but I wonder if we need '-k', '-r', '-d' for the new options rather than only their verbose counterparts. Seems like we are going to run into a conflict a some point with two options with the same first letter if we keep doing that.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
Typo in the help message
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
we use -o for output file elsewhere, it is not good to overload options with diff meanings
Typo in the help message
Maybe this should be a class docstring :thinking:
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
no need to specify required=False or type=str as these are defaults
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Cool. Thanks. Let me know once done.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Sorry it's now 2.10
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Can we use instead `assertEqual()` and `assertIsNot()`? ```suggestion self.assertEqual(clone, source) self.assertIsNot(clone, source) ```
Can we use instead `assertEqual()` and `assertIsNot()`? ```suggestion self.assertEqual(clone, source) self.assertIsNot(clone, source) ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
You can remove this. If there isn't a specified return, None is returned.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Yeah, you'd need `return None, None` at the end of index_of_matching_route()
Yeah, you'd need `return None, None` at the end of index_of_matching_route()
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
You need to wrap the second instantiation in its own assertRaises to actually test it.
You need to wrap the second instantiation in its own assertRaises to actually test it.
ok, just something for consideration, I trust your/the community's judgement on it
Generally we don't treat usernames as secrets, so no need to mask
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```python elif max_num is not None and () ```
The optional trailing dot may "protect" an ending dash -- `xn--.` passes this. Is this intended? If not, switch the last two lines.
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
a leftover here which can be removed
In the `exit_json`, you should also return `changed` and `state`.
```suggestion password=dict(type='str', required=True, no_log=True), ```
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
Like above, I think this should be `userid, name, password, group, email`
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
```suggestion raise AnsibleError('Failed to download Git submodules') from proc_err ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
In the `exit_json`, you should also return `changed` and `state`.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
In the `exit_json`, you should also return `changed` and `state`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
ok, just something for consideration, I trust your/the community's judgement on it
I'd `conditional_escape()` each argument.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
ok, just something for consideration, I trust your/the community's judgement on it
Indentation level of `return` statement need to be increased.
I'd go for underlining.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Style note, I finally convinced people a year or so ago that ```{}``` is superior to ```dict()```. So new code should use the literal syntax.
You have some syntax errors in this `if` statement.
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Are we really testing the Content-Type setting here? It strikes me this test is really about the Content-Disposition behaviour. We should focus it to that. (With a separate case for testing 'Content-Type' branched (such as guessing the content type from the filename.)
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
ok, just something for consideration, I trust your/the community's judgement on it
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This is unreachable code, as module.fail_json will be exit point the module.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Not really - if people wanted to use tagging they'd need 1.4.4+ but otherwise any version of boto3 would pretty much work. (This is the same as your existing change) It's probably worth adding a warning if people try and use tagging with a version of boto3 that does not support tagging too (using `hasattr(client, 'create_tags')` or similar)
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Use another lookup instead of `epoch` e.g. `second`.
I'm not sure if `isinstance(pages_per_range, int)` is required. I think Python/Django doesn't do strict type checking like that in general.
```suggestion elif date_string.match(self.when): ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Maybe this should be a class docstring :thinking:
This change looks unrelated.
Why do you wait to fail ? I think you must fail in "main"
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In the `exit_json`, you should also return `changed` and `state`.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
`raise` is missing. Call to `str` is useless there.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
`raise` is missing. Call to `str` is useless there.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Maybe this should be a class docstring :thinking:
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Generally we don't treat usernames as secrets, so no need to mask
You're right. You know I both saw that and missed it too...
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
This should use `module.deprecate`, there's a good example in https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/aws_kms.py#L954:L956
TIL that character classes also work inside `[]` :D
```suggestion """Render as <li> elements excluding the surrounding <ul> tag.""" ```
I know this is the sort of layout that `black` would generate, but it's one of the more ugly choices it doesn't get right in my opinion. Perhaps we should `+=` instead of `.extend()`: ```suggestion top_errors += [ _('(Hidden field %(name)s) %(error)s') % {'name': name, 'error': str(e)} for e in bf_errors ] ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
We have no intention of adding attrs as a dependency.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
boto3_conn never throws a ClientError at this point. You need to handle missing Profile (botocore.exceptions.ProfileNotFound) and presumably if `region` is not set too.
That's a really interesting piece of information I did not know.
That's a really interesting piece of information I did not know.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
I'd omit the `shortcut_url` variable and put this directly in the `get()`.
Also we should still call this in case of check mode, and say whether it will be changed
Maybe this should be a class docstring :thinking:
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
It's a `@staticmethod`/pure function
And I would rename this attribute `superusers` as it's meant to contain multiple users.
I think we should be consistent and use double-quotes.
Exception handling here too.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
In the `exit_json`, you should also return `changed` and `state`.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Could also be ```suggestion skydive: >- ```
Are these style changes intentional? Somehow they don't look like that.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
Maybe this should be a class docstring :thinking:
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
I think we should be consistent and use double-quotes.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
It seems the `if shuffle` block is repeated twice, you can move it out of the conditional block
Matt may not OK with these choices. Refer: https://github.com/ansible/ansible/pull/51320#discussion_r267579389
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
In fact you could have one big try-except statement, and only a single KeyError exception clause for the connection error.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`getattr()` rather than calling a dunder method
Maybe this should be a class docstring :thinking:
We don't need tags in this function, I think.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Low-level tests are not necessary, it should be feasible to test using `Lexeme()` with special characters in a query.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
I think there are enough tests about forms using the formats machine to sanitize input values. I'd rather specifically tests `sanitize_separators` in a separate `test_sanitize_separators` test.
I think there are enough tests about forms using the formats machine to sanitize input values. I'd rather specifically tests `sanitize_separators` in a separate `test_sanitize_separators` test.
The `u` prefix is not necessary (as unicode_literals is imported at the top of the file). `self.assertIn` can be used here.
chop the blank lines before each attribute
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
This syntax is not supported in python2.6. You will need to index your format like `{0}`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe use `self.execute_module(changed=True, commands=['vlan 6', 'vlan 7', 'vlan 8', 'vlan 9', 'vlan 10'])`? That automatically handles ensuring `commands` retains sort order. (and can add `sort=False` if you want to use it for the others and don't need sorting)
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Please ignore, my suggestion is invalid syntax.
Please ignore, my suggestion is invalid syntax.
I think the test should be split into multiple test methods, one per thing-being-tested, as above
Need a colon at the end here
Please ignore, my suggestion is invalid syntax.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
I have a real dislike for one character variables (even if they are local) because they make it harder to read your code. This could have been **org** instead of **o**.
TBH, I don't think we need this test. I will chop it.
TBH, I don't think we need this test. I will chop it.
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
No need for get(key, None) as None is the default fix also for following get()
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Exception handling here too.
In the `exit_json`, you should also return `changed` and `state`.
That's a really interesting piece of information I did not know.
No need for get(key, None) as None is the default fix also for following get()
I think this blank line can be removed.
I think this blank line can be removed.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Exception handling here too.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
I'd go for underlining.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Hmmn... I think we are going to want the env var here and in the ansible package to match. Otherwise users will have to set both if they want to override. If you prefer your name, just open a pr against ansible-community/antsibull to change that one
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
"actor" variables are unused
Can you use `assertContains()` here to prevent errors due to attribute order in the HTML tags.
Not sure it makes a difference but before it looks like we got `form=None` in the context.
Not sure it makes a difference but before it looks like we got `form=None` in the context.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
``` py self.assertIs(type(f.__repr__()), str) ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
But as I said, I think that is a bad idea as it will have the wrong extension on it. The two acceptable choices to deal with this are: 1. Fail loudly as the user expected a compressed file. 2. Strip the extension and continue with an uncompressed file, but show a warning.
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
TIL that character classes also work inside `[]` :D
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
ok, just something for consideration, I trust your/the community's judgement on it
you need to do camel_dict_to_snake_dict before you do the tag conversion (otherwise tag names get converted to lower case which is unexpected)
Technically this will never be `None` because of the defaults.
Unclear why we're mixing some parameter substitution inline, and leaving others to the final substitution with the `args`. Made it confusing to figure out what was going on with the `JMX_PORT`, which looked like it had been lost since it wasn't in `args` any longer.
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please use `module= AnsibleModule(` I guess it is a convention
Please use `module= AnsibleModule(` I guess it is a convention
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Ok, not sure why this one is still open.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
@timgraham is ordering by the result of an aggregate allowed without subqueries? If ordering by count does not error, then it should be safe to use that ordering. If not, introducing a different field into the orderby will affect the grouping (not that you suggested that), so we'll need to look at comparing the queryset out of order if there's another assert method available that does that. I'm not able to check either of these things at the moment, but I can take a look in about 8 hours if it's not resolved.
Will info['body'] be json? Might be a string/HTML.
Will info['body'] be json? Might be a string/HTML.
Could you remove this outer try/except (it was only for debugging)? The build is failing because `print` needs to be `print(e)` for Python 3 compatibility but that can be removed anyway.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
```suggestion deps = {name: {'version': version} for name, version in dependencies.items()} ```
Maybe this should be a class docstring :thinking:
We have no intention of adding attrs as a dependency.
ok, just something for consideration, I trust your/the community's judgement on it
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
The `foo_attrs` variables could be removed.
You're right. You know I both saw that and missed it too...
```suggestion return '-' + value if neg else value ```
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Would you mind also importing traceback with the other imports and adding exception=traceback.format_exc() to the end of this fail_json? Example: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2
remove extra newline
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Please implement check-mode. In this case check-mode could either not send a notification, or better, sends a "fake" notification (so authentication is attempted). It depends on the API if this is feasible. It's always better that check-mode is performing more logic without actually doing something.
Maybe this should be a class docstring :thinking:
Use single quotes consistently.
Again, suggest rewording this as suggested for win_http_proxy.
Again, suggest rewording this as suggested for win_http_proxy.
This is not py2.6 compatible. You will need to index these.
This is not py2.6 compatible. You will need to index these.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
I think if you import this here, it will solve the CI problem.
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
command line options are not usable from `ansible-playbook`, you probably also want a environment variable as for username and password.
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
This syntax is not supported in python2.6. You will need to index your format like {0}
This is not py2.6 compatible. You will need to index these.
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
But this code is never going to be hit if the argument_spec is set to required=True, unless someone set `url: ""`, but it's difficult to test for every bad input format - someone could equally pass `url: "not_a_protocol://thisisnonsense"`
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Exception handling here too.
remove extra newline
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
Maybe this should be a class docstring :thinking:
Exception handling here too.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Use a context manager with this read operation to ensure the file handler is closed as soon as it is no longer needed rather than relying on successful program termination. ```suggestion with open(self.LOGIN_DEFS, 'r') as f: for line in f.readlines(): ```
Maybe this should be a class docstring :thinking:
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
You shouldn't need the extra parentheses inside `extend()`, FYI.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
I'd chop every other empty line and group the `auto_now` and `auto_now_add`, but that's just cosmetics.
Do we need the `tzinfo` bit for the test? I'm worried relying on `get_current_timezone` could make the test flaky.
```suggestion if os.path.exists(writer.path): raise CommandError( f'Migration {new_migration.name} already exists. Use a different name.' ) ```
Same question for dropping lambda here as well.
Use `'` as string delimiter for consistency
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I would avoid the `closer to replace` phrasing, it can do pruning but is still sending a `PATCH` (just an intelligently computed `PATCH` instead of the hail mary we're currently sending). If possible I'd try to match our phrasing to the [official docs](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply) as much as possible
Generally we don't treat usernames as secrets, so no need to mask
I think this should be 'exit' instead of 'abort'
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Use single quotes.
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
I suggested yesterday something more convenient and readable: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion Test that the returned value for timezone consists of only uppercase ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Still I think `'&nbsp;<strong>%s</strong>'` could be factored as a variable and `<a href=...` interpolated inside that. Let's use `format_html` instead of `escape`. This return could go in the `else` block of `try/except/else`.
TIL that character classes also work inside `[]` :D
Typo in `module_utils`.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
blank line not needed
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
chop the blank lines before each attribute
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
```suggestion 'Accept': '*', 'Host': 'example.com', ```
Use a single line. Our [style guide](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style) allows lines up to 119 characters if it helps readability.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Maybe this should be a class docstring :thinking:
Sorry, I had a typo in https://github.com/django/django/pull/12675#discussion_r418965162 -- what I ment to say was: keep `work factor` in safe summary (since it's for display and already translated) and `work_factor` in `decode`. This will also require less changes in the tests.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
s/strng or or/string or/
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Newline after the open parenthesis, and then just a four-space hanging indent for following lines. Avoids losing so much horizontal space to indentation.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
this should use the new API without hardcoded id now
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
`raise` is missing. Call to `str` is useless there.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Maybe this should be a class docstring :thinking:
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
Maybe this should be a class docstring :thinking:
type='str' is the default so I think you can remove those.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
The reason was that we’d end up with a 500 server error in this case, whereas now we get a validation error. An alternative that we could use here is the old approach ‘cl.result_list’, which we know is sensibily limited to just one page. Either that, or since it's invalid POST data, bail out here and report the error to the user. (That's a little bit more work though; I haven't yet thought what that looks like.)
@lindong28 I tried this a bit locally, and realized the command now has two pipes to `tee` (see line 58 as well) When I drop the pipe to tee here on line 51 and keep the one below, the producer runs as expected.
Array ellipsis is an obscure feature and not necessary here. It hinders readability
```suggestion return b'\r\n'.join(to_bytes(line, nonstring='passthru') for line in result) ``` (and import `to_bytes`)
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
chop the blank lines before each attribute
Why do you wait to fail ? I think you must fail in "main"
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Required=false are implicit could you remove them ? Default=None too in case of string
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
This PR looks good. It would be slightly more consistent with `SelectDate` and `Multiwidget` if this render was handled in the template. The `SelectDate` widget does something similar where the widget type is instantiated for each subfield, `get_context` is called, and the `widget` return value is added to `subwidgets`: https://github.com/django/django/blob/3e91850dccecd13dde8cef7b81c798217f74a301/django/forms/widgets.py#L961
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
That `get_multi_something` pattern repeats itself quite a few times in the file, which makes it a good candidate for a refactor into more general function. Something similar to this should work: def aggregate(self, func): ret = True entries = [] for systems_uri in self.systems_uris: inventory = func(systems_uri) ret = inventory.pop('ret') and ret entries.append(inventory) return dict(ret=ret, entries=entries) def get_multi_storage_controller_inventory(self): return self.aggregate(self.get_storage_controller_inventory) def get_multi_disk_inventory(self): return self.aggregate(self.get_disk_inventory) This should reduce the code duplication significantly.
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.
Unless there's a reason, I'd put all these toplevel variable definitions right after the imports. They're also constants so they probably should be uppercase but I won't block on that.
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
I thought `formset = ChoiceFormSet(self.data, auto_id=False, prefix='choices')` could go in `setUp()` also.
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
In the `exit_json`, you should also return `changed` and `state`.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Please remove empty line.
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
Please use 'msg' for returned messages, this is a standardized return value.
You need to wrap the second instantiation in its own assertRaises to actually test it.
You need to wrap the second instantiation in its own assertRaises to actually test it.
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
You need to wrap the second instantiation in its own assertRaises to actually test it.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
In the `exit_json`, you should also return `changed` and `state`.
ok, just something for consideration, I trust your/the community's judgement on it
Isn't `raise` missing there ? Calls to `str` are useless.
I think we can drop the empty line here.
In the `exit_json`, you should also return `changed` and `state`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
chop blank line
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I think we should be consistent and use double-quotes.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
You should also collect class based unique-constraints, you get can them from `opts.total_unique_constraints`.
I think we should be consistent and use double-quotes.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Use another lookup instead of `epoch` e.g. `second`.
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
We should remember that migration files are auto generated code. They first and foremost need to not have syntax errors. There was a discussion on running some form of isort on migration files while generating them. We decided against that for the sake of migration files being auto-generated. Furthermore, lines in migration files can easily end up having lines way past 79 or 119 characters. And I'm against starting to linebreak those lines with some other tool. Users should exclude migration files from linting, IMO.
I know you asked me about this but it might be a good idea to explain that PowerShell unpacks arrays if there's only a single entry so this is a defensive check on that.
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
Single line looks okay here, in the next test and in the assertEqual of the test.
Why do you wait to fail ? I think you must fail in "main"
Is there a need to hardcode pks? This is generally to be avoided, I think.
Is there a need to hardcode pks? This is generally to be avoided, I think.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
`raise` is missing. Call to `str` is useless there.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
If it is already in the env, can we be sure that we are able to reuse the socket? Does the following code work in pyhton 3.4? I think sockets are not inherited by child processes there. (On the run, but should get investigated)
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
@pierremahot we'll need a test for this
@pierremahot we'll need a test for this
@pierremahot we'll need a test for this
Use single quotes consistently.
Use single quotes consistently.
no restructured text (:class:) in docstrings please
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Use single quotes consistently.
Please ignore, my suggestion is invalid syntax.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
In the `exit_json`, you should also return `changed` and `state`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
When hitting an error you must exit with module.fail_json
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This branch in untested :thinking:
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This branch in untested :thinking:
This branch in untested :thinking:
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Missing end parenthesis
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I'd rename `subminor` to `patch`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
{0} -> {} (I prefer the less verbose %s, actually) recognised -> recognized
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
add trailing ,
The layout should be something along those lines ``` python for enclosure in item.get("enclosures") or []: handler.addQuickElement("link", "", { "rel": "enclosure", "href": enclosure.url, "length": enclosure.length, "type": enclosure.mime_type }) ```
add trailing ,
The layout should be something along those lines ``` python for enclosure in item.get("enclosures") or []: handler.addQuickElement("link", "", { "rel": "enclosure", "href": enclosure.url, "length": enclosure.length, "type": enclosure.mime_type }) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Required=false are implicit could you remove them ? Default=None too in case of string
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
`raise` is missing. Call to `str` is useless there.
In the `exit_json`, you should also return `changed` and `state`.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Exception handling here too.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Exception handling here too.
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
Is `user_id` something secret, just wondering why it has `no_log`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
+1 it's better to just patch `time.time`
Required=false are implicit could you remove them ? Default=None too in case of string
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
I would prefer to avoid the try/except block. Because it can potentially hide a problem and it reduces the readability. This being said, it was already here, so it's up to you.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Could you add a message here: ``` python raise NotImplementedError('Subclasses of BaseSerializer need to implement the serialize() method') ```
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
I'd rename this and the associated CLI option to `artifacts`, since not all artifacts are coverage artifacts.
Could you add a message here: ``` python raise NotImplementedError('Subclasses of BaseSerializer need to implement the serialize() method') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Minor but the `else` clause wrapping is unnecessary here given you return in the `except`.
Minor but the `else` clause wrapping is unnecessary here given you return in the `except`.
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
User could set `user_data` parameter to `None`, in such case exception still occurs.
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
pytest.mark.skip Though I'm surprised we did not see any bot error.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Sure, not this issue, however I don't think we interpreted the discussion the same. f-strings should be excluded in translatable strings, but I don't see what's preventing us to use them at other places.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
A form validation error seems sensible to me
This can be converted to return True. No need of new variable retry_request
Maybe this should be a class docstring :thinking:
This can be converted to return True. No need of new variable retry_request
This can be converted to return True. No need of new variable retry_request
This can be converted to return True. No need of new variable retry_request
A form validation error seems sensible to me
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
ok, just something for consideration, I trust your/the community's judgement on it
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
ok, just something for consideration, I trust your/the community's judgement on it
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
I don't know if the query element is really needed. It seems superfluous as the API is already directed to this vserver. (But we found other cases where the request seems over qualified).
So removed `required=False` and add `type='str' instead. Do this for the others as well.
this should use the new API without hardcoded id now
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This condition is not necessary as `aggregate_spec` will never be an empty dictionary.
Please use `module= AnsibleModule(` I guess it is a convention
We could fall back to `__file__` or something in that case at minimum. Could be useful to include that regardless.
This is also to deprecate parameter `domainname`.
I think we should be consistent and use double-quotes.
Ok, not sure why this one is still open.
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
@pierremahot we'll need a test for this
please multiline these strings so they aren't longer than 120 chars. ``` row_html = ( '...' '...' ) ```
please multiline these strings so they aren't longer than 120 chars. ``` row_html = ( '...' '...' ) ```
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
We don't need to support different bases or other negation signs so I would expect a simplified implementation.
Maybe this should be a class docstring :thinking:
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
This should probably mention both slash and no-slash paths...
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
You have some syntax errors in this `if` statement.
You have some syntax errors in this `if` statement.
Maybe this should be a class docstring :thinking:
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Best to be conservative and error rather than silently swallow mistyped arguments :) I think `ValueError` or `TypeError` are more appropriate, they're normally used for argument validation.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
That's a really interesting piece of information I did not know.
That's a really interesting piece of information I did not know.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
That's a really interesting piece of information I did not know.
This syntax is not supported in python2.6. You will need to index your format like {0}
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like {0}
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Could you a docstring along the lines of `test_file_url()`, please :smile:
a leftover here which can be removed
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
check that -> and that (no comma needed since the two clauses are independent)
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
That's a really interesting piece of information I did not know.
Required=false are implicit could you remove them ? Default=None too in case of string
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Could we patch a StringIO instead of devnull and then verify the contents of log_message()? See tests/check_framework/tests.py for an example. Also the patching should be in setUp/tearDown or in a try/finally so if something goes wrong the unpatching still happens.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
Yes, it's good this way!
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Is this code based on an existing implementation? If that's the case, we should specify it / link to it.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
@nitzmahone and I talked about this last night and the timeout is an expectation of how long fact gathering as a whole will take, not how long any specific piece of fact gathering will take. We thought that probably the best place to enforce that sort of fact gathering would be in the action plugin being worked on in a separate PR. However, for this PR, it would make more sense to at least try to replicate the status quo as much as possible, ie: take a time at the start of this function. Then every time we check the time to see if it's time to exit due to timeout, we compare time.time() > function_start_time + timeout to see if it's time to exit.
I think it would be good to include a message giving context before we start listing unresolved issues.
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Can you make this into a couple statements for easier readability? Something like: ``` invalid_entries = [x for x in statement['Principal']['AWS'] if not x.startswith('arn:aws:iam::)] if clean_invalid_entries and len(invalid_entries): for entry in invalid_entries: statement['Principal']['AWS'].remove(entry) ``` Or there's always: ``` original_size = len(statement['Principal']['AWS']) statement['Principal']['AWS'] = [x for x in statement['Principal']['AWS'] if x.startswith('arn:aws:iam::)] have_invalid_entries = (original_size == len(statement['Principal']['AWS'])) ```
Like above, I think this should be `userid, name, password, group, email`
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
ditto on `.` in character groups
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
put the closing ) on the next line
That's a really interesting piece of information I did not know.
```suggestion query=dict(type='list', elements='str'), ```
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
This doesn't need to be in the try/except. After it you should also do something like ``` if not region: module.fail_json(msg="region must be specified") ```
This is a significant regression which breaks a lot of my code too.
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
I think we should be consistent and use double-quotes.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Required=false are implicit could you remove them ? Default=None too in case of string
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
I wouldn't omit parenthesis here
I wouldn't omit parenthesis here
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
It's a `@staticmethod`/pure function
In the `exit_json`, you should also return `changed` and `state`.
This change is correct and follows pep8 style guidelines. Indentation does not always have to be an increment of 4 if it aligns with the above structure.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Please remove empty line.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
Is `user_id` something secret, just wondering why it has `no_log`
This can be moved to `check_dict` method.
We should also change `\d+` to `[0-9]+` in all cases.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
... and I take a closer look and I see the reason - `RelatedObject.model` already exists. So; what about the other way around; add parent_model to field? That way, you can ask every field "what model do you belong to?" and "what model are you associated with?". Normal data fields return the same model for both; RelatedObjects return different models.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
no blank line
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`raise` is missing. Call to `str` is useless there.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
`raise` is missing. Call to `str` is useless there.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I think we should be consistent and use double-quotes.
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
In check-mode we would like to test as much as possible without inducing changes. So in this case I would expect to connect/authenticate to Spark, but not send a message. That would properly catch connectivity or login-errors in check-mode.
Yes, it's good this way!
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Required=false are implicit could you remove them ? Default=None too in case of string
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
That's a really interesting piece of information I did not know.
Maybe this should be a class docstring :thinking:
added check mode and check for empty banner as this is unexpected --> use case state=absent ~~~python if not module.params['banner']: module.fail_json(msg='Invalid MOTD banner given') if not module.check_mode: array.set(banner=module.params['banner']) changed = True ~~~
``` self.assertRegexpMatches(warning.msg, ( "..." "..." )) ```
else is unnecessary here because we raise an exception before
else is unnecessary here because we raise an exception before
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Missing from docs
Missing from docs
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
In the `exit_json`, you should also return `changed` and `state`.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
remove extra newline
Required=false are implicit could you remove them ? Default=None too in case of string
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
It looks like there's a race condition here. The log file could be read before supervisord has reopened it.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
I'd rather be explicit here and refresh from the database. On that note, there's `u.refresh_from_db()` :wink:
Maybe this should be a class docstring :thinking:
Since we're now targetting python-2.6+ we can just ```import json```
In the `exit_json`, you should also return `changed` and `state`.
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
The removal of this final raising of `HTTPError` means that there are some scenarios that can succeed, such as when given invalid redirection options. ``` RedirectHandlerFactory(follow_redirects='invalid', validate_certs=True) ``` Previous behavior was to raise an `HTTPError` in this situation, somewhat similar to `follow_redirects='none'`
immediatelly -> immediately
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Required=false are implicit could you remove them ? Default=None too in case of string
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
In the `exit_json`, you should also return `changed` and `state`.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
Please remove empty line.
Required=false are implicit could you remove them ? Default=None too in case of string
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
`no_log=True` is argument spec will handle this.
Required=false are implicit could you remove them ? Default=None too in case of string
There could be a check in here to prevent both label and label_id from being specified if state is absent.
There could be a check in here to prevent both label and label_id from being specified if state is absent.
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
```suggestion query=dict(type='list', elements='str'), ```
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Line 355 to 368 are unused.
We tend to quote names and values in messages for readability. ```suggestion meraki.fail_json(msg="Parameters 'org_name' or 'org_id' parameters are required") ```
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Required=false are implicit could you remove them ? Default=None too in case of string
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Required=false are implicit could you remove them ? Default=None too in case of string
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Add support if VMM domain parameters: "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
Isn't `raise` missing there ? Calls to `str` are useless.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
Make sense to me. Thanks for info.
Why `dict(required=True)` is added here? It is already part of the spec.
I think we should be consistent and use double-quotes.
Why `dict(required=True)` is added here? It is already part of the spec.
I think we should be consistent and use double-quotes.
Make sense to me. Thanks for info.
Not something that you have to change but I think this could be simplified to ```python for obj_func in self.obj_func_mapping.values(): obj_func() ```
With this simplification, the pythonic way of generating a list is to use list comprehension. You can replace the whole function body with: ```python return [parse_to_obj(r) for r in parse_to_logical_rows(vlan_out)] ```
```suggestion self.headers = { 'Content-Type': "application/json" } ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
Consider, instead of the `__iexact`: ``` python table_name = "gis_neighborhood" if not connection.features.uppercases_column_names else "GIS_NEIGHBORHOOD" GeometryColumns.objects.filter(**{GeometryColumns.table_name_col(): table_name }) ```
You can use ```required_if``` which is built into AnsibleModule instead of having your own code. Look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_storage_pool.py#L489 as a random example of using that.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
Please change these vars to ansible Host vars rather OS env vars.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
I would handle this in `as_sql()`, i.e. ```python def as_sql(self, compiler, connection, template=None, **extra_context): sql, params = super().as_sql(compiler, connection, template, **extra_context) if self.invert: sql = '!!({})'.format(sql) return sql, params ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Also, you can do ```python lv_type=dict(default='jfs2'), # ...snip... opts=dict(default=''), ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Unrelated, but perhaps the default kwarg should be `exclude=()` to allow removing the `exclude is not None` check.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I think we should be consistent and use double-quotes.
```suggestion ''' Wrapper function to update var sources dict and call combine_vars() See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ''' ```
`cls.staff_user = User.objects.create_user(username='user', password='secret', email='user@example.com', is_staff=True)`
how about ```suggestion installed_packages = defaultdict(list) ```
Also, see ticket trac, it seems 2396 is obsolete.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
I think we should be consistent and use double-quotes.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Ah I see, okay then.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
The optional trailing dot may "protect" an ending dash -- `xn--.` passes this. Is this intended? If not, switch the last two lines.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
You will need to include the OAUTH_TOKEN environment variable also.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
ditto on `.` in character groups
I think we should be consistent and use double-quotes.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ditto on `.` in character groups
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
Please create dicts immediately with the values you already have.
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
chop blank line
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
``` When the object has a ManyToManyField to Site, redirect to the current site only if it's attached to the object.
I think we should be consistent and use double-quotes.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This argument is only accepted in Python 3, it would not work with Python 2.
This argument is only accepted in Python 3, it would not work with Python 2.
This argument is only accepted in Python 3, it would not work with Python 2.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
chop blank line
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
prefer hanging indent style with 1 arg per line
Isn't this equivalent? ``` if (start and start < 0) and (end and end > 0): raise ... ```
I think this line isn't needed, tests seem to work fine without it.
I think this line isn't needed, tests seem to work fine without it.
Yes, that's the idea. I'm not sure if we need to include a long list of schemes though. As Claude suggested on the ticket, some minimal validation like alphanumeric + period is probably sufficient. That way we don't have to maintain a list. Any projects that require such a list can supply it.
Are these style changes intentional? Somehow they don't look like that.
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
`band_input`, you don't get much by saving one char :-)
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Maybe this should be a class docstring :thinking:
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
`type(self)(...)` looks more Pythonic to me.
I think we should be consistent and use double-quotes.
TIL that character classes also work inside `[]` :D
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This one as well.
In the `exit_json`, you should also return `changed` and `state`.
It's a `@staticmethod`/pure function
It's a `@staticmethod`/pure function
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
When hitting an error you must exit with module.fail_json
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please rewrite `@override_settings` into a single line: ```python @override_settings(STATICFILES_DIRS="a string") ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
use `self.MAX_FILES` instead of 999999
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Please use `module= AnsibleModule(` I guess it is a convention
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use 'msg' for returned messages, this is a standardized return value.
What is the reason of change? it would break the backwards compatibility.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion creation_date=dict(type='str', required=False), ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
This was already there, but we likely want to change it so we don't hold the lock while unsubscribing.
We are holding the lock while connecting/subscribing.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
Required=false are implicit could you remove them ? Default=None too in case of string
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
In the `exit_json`, you should also return `changed` and `state`.
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
I made i mistake in the original code here already. Line must be ``` python self._fail('login', info['msg']) ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Also please keep it as HttpResponseNotFound as bug only occurs when that view throws 404.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
I guess it should be `_compare_salted_tokens` (rather than "padded") to fix build errors.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
This check is only necessary in `URLResolver._populate()`, since `URLPattern._populate()` can never be called recursively.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
That's a really interesting piece of information I did not know.
ok, just something for consideration, I trust your/the community's judgement on it
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Isn't `raise` missing there ? Calls to `str` are useless.
Maybe this should be a class docstring :thinking:
Are both host groups really needed? Does the one that contains ':' handle both? We have regex in other places in the project that do similar parsing we may want to keep in sync: - https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/utils/Utils.java#L53 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/BrokerEndPoint.scala#L27 - https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/cluster/EndPoint.scala#L29
Most modules use the `result` variable for storing the result information for fail_json() or exit_json(). Only one module is using `rekwargs`: netconf_config. 262 using `result`, 27 using `ret`. So up to you, but it's easier if people would use the same standard IMO.
This bare `except` will catch anything, including the exception that marks a failing test, I think :-) Better to use `assertRaises` and explicitly assert that the specific expected uncaught exception bubbles up.
This allows `xn----nx` and even `xn-----`. Are they valid? (edit: FWIW, my IceWeasel seems to think they are)
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please ignore, my suggestion is invalid syntax.
TIL that character classes also work inside `[]` :D
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
When `password` is not specified (this is a requirement for MIQ external auth) what get's passed to the MIQ API? Seem like it should test `password is not None` before building the json.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This doesn't seem to be necessary to reproduce the bug. Just refreshing the page without making any changes caused the select options to clear.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Maybe this should be a class docstring :thinking:
It wouldn't validate the following: - http://.com - http://. - http://.. - http://../ - http://.www.foo.bar/ - http://.www.foo.bar./ It would indeed validate the following URL (but they are actually valid): - http://example - http://example. All the others are about leading and trailing hyphens, if we really want to filter them out despite the increased complexity then I suggest we break the pattern into multiple variable for readability: https://gist.github.com/386830e46e8d2aca9dcb Regarding formal grammar, it's spread out among a bunch of RFCs, I doubt it's worth the effort.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Please add `monitoring` and pass this argument to the request.
Please add `monitoring` and pass this argument to the request.
This should verify the output.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
@sir-sigurd Is there any reason to change a regex? :thinking: You added `:`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I guess you also need the name? ```suggestion - If I(state=absent) other options will be ignored except of I(name) and I(schema). ```
Reverting this change and the one below doesn't result in any test failures. We should have tests for these cases too if they are indeed necessary.
ok, just something for consideration, I trust your/the community's judgement on it
ok, just something for consideration, I trust your/the community's judgement on it
I think `ValueError` would be appropriate here (the problem is with the values passed to the login view).
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
Maybe this should be a class docstring :thinking:
The 1.29 API change might only refer to allowing to *filter* by scope, though I'd be surprised that the API only allows to filter when you can't *create* a network with a given scope. It looks to me more and more like the docker API docs are kind of a mess ;-) Anyway, going to 1.30 is probably safe. If someone reports it also works with 1.29, we can still change it back.
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I'd rename `subminor` to `patch`.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Net new tests should be `pytest` style tests.
Make a common method in class to get url and return json loads response.
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Make a common method in class to get url and return json loads response.
Make a common method in class to get url and return json loads response.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Make a common method in class to get url and return json loads response.
Make a common method in class to get url and return json loads response.
should this be: pytestmark = pytest.mark.skip('skipping as missing required netapp_lib')
Make a common method in class to get url and return json loads response.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
Make a common method in class to get url and return json loads response.
Use single quotes consistently.
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
A `minimumInputLength` of zero is [the default for Select2](https://github.com/select2/select2/blob/120672dce79b6862cb17a966af06e0617a404b58/src/js/select2/defaults.js#L363).
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
A `minimumInputLength` of zero is [the default for Select2](https://github.com/select2/select2/blob/120672dce79b6862cb17a966af06e0617a404b58/src/js/select2/defaults.js#L363).
Use single quotes consistently.
We don't need the extra variable here. ```suggestion client.mset({k: self._serializer.dumps(v) for k, v in data.items()}) ```
Unfortunately this doesn't work well for formsets. I get `order.OrdersProducts.ordersproducts_set-15-product`.
Where does the RHS decrypt come from? It appears to be undefined here. Needs to be passed to _assemble_from_fragments as an kwarg I assume.
IMO we should check options against PostreSQL names.
param -> params
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
I don't think extending `Subquery.__init__` to allow any `QuerySet` some method (e.g. `filter`, `order_by`, ...) is desirable.
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
No need for `keys()` here.
No need for `keys()` here.
Can you use `django.utils.timezone.now()` here, please, even though the previous code didn't do that.
No need for `keys()` here.
No need for `keys()` here.
This as_sql method can be deleted if you remove the custom template and implement get/set_source_expressions as above.
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Is `user_id` something secret, just wondering why it has `no_log`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Maybe this should be a class docstring :thinking:
ok, just something for consideration, I trust your/the community's judgement on it
So removed `required=False` and add `type='str' instead. Do this for the others as well.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
a leftover here which can be removed
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`_postprocess_border_mode` should be part of `_postprocess_conv2d_output`, it doesn't need to be its own function.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Should be "Can't detect any" rather than "none" I think.
Should be "Can't detect any" rather than "none" I think.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
There seems to be an assumed structure of what is returned by the API endpoint, operating under the pretense that the structure won't change since the API is versioned, is there any chance that this assignment could fail and cause an unhandled exception? (similar question for other functions doing similar things below)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
```suggestion def validate_wwn(module): ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Move this to line 175
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
is this limited to TLDs? it seems all labels are limited to 63 characters.
Right, would this work: ```python if module_checkmode: payload = None else: payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ``` I prefer to use the same paths for checkmode and without. I think it is more future-proof when changes are being made.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
I guess the `add_argument` could be `action='store_false', dest='uses_https'`
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
The other formats.py seem to use `'\xa0'`
We'd only put the ticket number for a particularly tricky ticket. I don't think it's necessary here.
The other formats.py seem to use `'\xa0'`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
~~why stat and return the data when you are dropping it on caller?~~ 2nd caller does use
```suggestion display.vvv(u"No connection ot reset: %s" % to_text(stderr)) ``` ```suggestion display.vvv(u"No connection to reset: %s" % to_text(stderr)) ```
```suggestion display.vvv(u"No connection ot reset: %s" % to_text(stderr)) ``` ```suggestion display.vvv(u"No connection to reset: %s" % to_text(stderr)) ```
Mind putting this magic value into a constant with a descriptive name? I'd read much better if it was ```suggestion sys.exit(RC_CLI_INIT_FAILURE) ``` or something like that.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
If the result was a 4xx or 5xx then I think this fails.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Having this check in each module will result in code duplication and an overhead for module writer. `module` param will be used if the check is moved to utils function
Group names are supposed to be named similar to variables, i.e. alphanumeric and underscore. So at least the prefix should adhere to that. Besides that, look at this PR: https://github.com/ansible/ansible/pull/52748
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
`client.nodes.get()` can also raise `APIError`s on failure.
Group names are supposed to be named similar to variables, i.e. alphanumeric and underscore. So at least the prefix should adhere to that. Besides that, look at this PR: https://github.com/ansible/ansible/pull/52748
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Their should be a variable you can read in, rather than hardcoding this
Their should be a variable you can read in, rather than hardcoding this
This block would be a bit more legible, if you checked use_hostnames, then assigned to a temp variable whichever label the user has requested, and then appended that. Something like (pseudopython): ``` this_host = host if not use_hostnames: this_host = ip if frontend: frontends.append(this_host) else: backends.append(this_host) ``` This is admittedly a style thing, but I think it would be more readable/shorten a few lines.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`enable_3D` is a bool, so it will always be set, i think this can be a little simplified as well ```suggestion video_spec.device.enable3DSupport = self.params['enabled_3D'] enabled_3d = self.params['enabled_3D'] if self.params['enable_3D'] != video_card_facts['enable_3D_support']: self.change_detected = True ```
remove extra newline
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Exception handling here too.
Exception handling here too.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
How about splitting up the PR into multiple ones? At least one for the cases where semantics have to change (probably best one PR per module, because it will need discussion for every one of them, and having one module per PR increases the chance that some of them will be merged, even if some others are not or take forever), and one for the "obvious" changes.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
You don't need a lambda here. Also, don't break lines with `\`.
Let's make `write` a keyword-only argument. ```suggestion def get_client(self, key=None, *, write=False): ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Indentation level of `return` statement need to be increased.
The problem is that you start the connection before we know the connection details for sure, so getting the data earlier will make it even worse. In some cases (when all is known before task templating) you should have no issues as play_context carries the correct info, but if you need info to change at the task, or worse, loop/delegation levels you'll run into trouble much sooner. Most of the time this problem can be ignored as plays tend to reuse the same information w/o changing it, specially networking ones. As you note, since we are passing the connection information and using set_options/get_option on them, we should be able to ignore most of the play_context data, but this requires all connection plugins to correctly source the data (all those in core do, but many of those in collections do not). Why I was planning to add deprecation notices to play_context soon.
Any problem with: ``` @property def media(self): ```
Any problem with: ``` @property def media(self): ```
return without intermediate `etags` variable
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
Looking at https://github.com/ansible/ansible/pull/47971/files, which attempts the same thing, perhaps it would be good to include `groups_added` in the output, so give data on what new groups have been associated. However, I wonder if a list of all groups may be more helpful.
Maybe this should be a class docstring :thinking:
I don't think we should go so deep into validation, we opt out from numbers but at the same time we allow the whole unicode range. Unicode numbers like `๑` would happily validate therefore it's an uphill battle. I'd opt for a vastly simplified regex to validate FQDN: `'(?:[a-z0-9\u00a1-\uffff-]+\.?)+'`. Sure it'll let some invalid segments go through (e.g. leading/trailing hyphens) but at least it doesn't pretend of being exhaustive. Proper validation requires a parser anyway.
I think, unless you have a good reason, that you should use stack_params here and four lines down instead of module.params. Honestly I wish we didn't have to push module around.
I think, unless you have a good reason, that you should use stack_params here and four lines down instead of module.params. Honestly I wish we didn't have to push module around.
I'm not sure this needs to be changed. Testing the default value seems useful.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
Now this can just point to the new FAQ entry.
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
The `mocker` fixture is available in our tests. You can use `mocker.MagicMock` instead of importing it. ```suggestion ```
Now this can just point to the new FAQ entry.
Now this can just point to the new FAQ entry.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
You need to wrap the second instantiation in its own assertRaises to actually test it.
You need to wrap the second instantiation in its own assertRaises to actually test it.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
okay, but it still find it misleading from reader's point of view. i think, it's important to make it better maintainable. P.S. I've hid concat based implementation, once noticed that it's not only about lists (which was not obvious).
I think we should be consistent and use double-quotes.
TIL that character classes also work inside `[]` :D
Please drop that new line
Please drop that new line
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
Can you please unfold this loop. It's hard to check what actually failed if one item in the list fails.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This isn't needed because of the ```__metaclass__ = type``` boilerplate
This isn't needed because of the ```__metaclass__ = type``` boilerplate
Is it worthwhile taking a copy of the text utils we already have in Ansible. They have a `nonstring` option to define things like what to do when a None object is being encoded.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
User could set `user_data` parameter to `None`, in such case exception still occurs.
Maybe this should be a class docstring :thinking:
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Maybe this should be a class docstring :thinking:
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
This is inconsistent but I think the patch can land as is and the test be modified later on based on the direction of [#24082](https://code.djangoproject.com/ticket/24082).
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
I think we should be consistent and use double-quotes.
ok, just something for consideration, I trust your/the community's judgement on it
`try/finally` should be a bit smaller. If there's an exception before `form.save()` the photo won't exist so there's no need to cleanup. I'll make this change and merge it.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
`try/finally` should be a bit smaller. If there's an exception before `form.save()` the photo won't exist so there's no need to cleanup. I'll make this change and merge it.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Use `url = reverse('password_reset_confirm', kwargs={'uidb64': uidb64, 'token': token}))` to avoid the funky indentation (we prefer hanging indent).
TIL that character classes also work inside `[]` :D
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Maybe this should be a class docstring :thinking:
```suggestion chapter = Chapter.objects.create(title='testchapter', book=book) ```
I think it would be better to put these tests in `tests/auth_tests` unless there's some reason that's not feasible.
Maybe this should be a class docstring :thinking:
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
Required=false are implicit could you remove them ? Default=None too in case of string
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
chop the blank lines before each attribute
I thinking removing APP_DIRS from TEMPLATES (since it defaults to False) is a better suggestion than setting it to False.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Maybe this should be a class docstring :thinking:
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
As long as the input and ouput of the module are in snail_case, I don't see any issue.
Yes, I know. I'll leave it to Aymeric for a second opinion.
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
Running the entire test suite I could reproduce the error, but not if only running `django.contrib.gis`. Not sure exactly the cause but this code seems suspicious as we leave a different model admin registered for other tests.
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion I(minvalue), I(maxvalue), I(start), I(cache), I(cycle), I(rename_to), ```
Maybe this should be a class docstring :thinking:
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Maybe output the bad value here as well, to help the user find out which one was wrong.
Maybe output the bad value here as well, to help the user find out which one was wrong.
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
Another map that can be a list comprehension: ``` content = [x.strip() for x in m.group(3).split(" and ")] ```
We should probably rename this. Revisiting this code... this is a pretty special-case function as well. I wonder if it should be a private function inside of parameters.py (basic.py can make it public as part of its API but the idea would be that we don't expect any new code to use it.)
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
```python return {**DEFAULT_CONVERTERS, **REGISTERED_CONVERTERS} ``` Python 3 FTW
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
check that -> and that (no comma needed since the two clauses are independent)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
@Dref360 Minor typo. This needs to be: ``` if self.preprocessing_function: x = self.preprocessing_function(x) ```
Exception handling here too.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Use single quotes consistently.
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion version_added: '2.9' ```
`aws_connect_kwargs` won't be defined at this point unless `ec2_url` is set, which is the unlikelier of the code paths
remove extra newline
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Just a small hint of "ansible magic": I would add an alisas e.g `aliases=['id']`. Ansible allows to use a single item for a list type: ~~~yaml - one_image_facts: ids: 124 ~~~ with an alias `id` it makes perfect sense: ~~~yaml - one_image_facts: id: 124 ~~~ also update the docs accordenly: ~~~diff ids: description: - A list of images ids whose facts you want to gather + aliases: [ id ] ~~~
This can be a key-value map with key as the fact name and value as the pattern to be searched for
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
`timestamps_closed_bounds` field is defined with closed bounds in `default_bounds` so the current name is good, IMO. This test is to ensure that `default_bounds` doesn't impact open bounds pass in `DateTimeTZRange`.
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Use a single quote.
Use a single quote.
I just cut'n'pasted a working pattern I had in django-contemplation... this was only meant as a PoC [and to shut up the "Oh, but I _want_ it!" whiners :)]
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
Oh I missed the fact `datetime_trunc_sql` was used by `datetimes()`. This is fixing the reported use case where `'field'` is a `DateField` but wouldn't it break in the case of `dates('field', 'day')` where `'field'` is a `DateTimeField`? It looks like it wouldn't get truncated at all in this case.
TIL that character classes also work inside `[]` :D
Maybe this should be a class docstring :thinking:
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please use `module= AnsibleModule(` I guess it is a convention
Net new tests should be `pytest` style tests.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please use `module= AnsibleModule(` I guess it is a convention
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
@nitzmahone and I talked about this last night and the timeout is an expectation of how long fact gathering as a whole will take, not how long any specific piece of fact gathering will take. We thought that probably the best place to enforce that sort of fact gathering would be in the action plugin being worked on in a separate PR. However, for this PR, it would make more sense to at least try to replicate the status quo as much as possible, ie: take a time at the start of this function. Then every time we check the time to see if it's time to exit due to timeout, we compare time.time() > function_start_time + timeout to see if it's time to exit.
Cool. Thanks. Let me know once done.
I think we should be consistent and use double-quotes.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
You can use `if six.PY2` (import `six` from `django.utils`)
Unrelated, but perhaps the default kwarg should be `exclude=()` to allow removing the `exclude is not None` check.
Cool. Thanks. Let me know once done.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
AFAIK the Ansible functions should work, could you please provide a sample input value and expected output value given that input.
Cool. Thanks. Let me know once done.
Cool. Thanks. Let me know once done.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
There is in theory a chance of hitting a TOCTTOU case here anyway, in which case it is better to handle the exception to avoid a crash.
Maybe this should be a class docstring :thinking:
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Exception handling here too.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
In the `exit_json`, you should also return `changed` and `state`.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Exception handling here too.
Exception handling here too.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Exception handling here too.
Exception handling here too.
Exception handling here too.
Exception handling here too.
Exception handling here too.
`raise` is missing. Call to `str` is useless there.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
i would require one of id/name for normal operation and require ID if you want to change name, which now can be a 'check if i need to' making it safe to rerun the same task.
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
`responsive.css` uses only 1024 and 767 so there is not need to check other sizes, it's also better to assert separately: ```suggestion title_field_div = self.selenium.find_element(By.CLASS_NAME, 'field-title') current_size = self.selenium.get_window_size() try: self.selenium.set_window_size(1024, 768) self.assertIs(title_field_div.is_displayed(), False) self.selenium.set_window_size(767, 575) self.assertIs(title_field_div.is_displayed(), False) finally: self.selenium.set_window_size(current_size['width'], current_size['height']) ```
```suggestion system = to_text(platform.system(), errors='surrogate_or_strict') if system == u"OpenBSD": ```
This line should be `el, el._parent`. Otherwise, you are making the block, have a parent of the el, so we create an extra level of parent relationship. Current: ``` el: BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-4d89-34fa-00000000011b)(id=4442932896)(parent=BLOCK(uuid=ca00b048-ca01-4d89-34fa-000000000079)(id=4442932392)(parent=TASK: role1 : call role2 again)) ``` using `el._parent`: ``` el: BLOCK(uuid=ca00b048-ca01-b999-e740-000000000079)(id=4602644128)(parent=TASK: role1 : call role2 again) new_block: BLOCK(uuid=ca00b048-ca01-b999-e740-00000000011b)(id=4602644688)(parent=TASK: role1 : call role2 again) ```
We could use `self.CaptureQueriesContext()` and assert that `JOIN` is only used once.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
`raise` is missing. Call to `str` is useless there.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I don't think boto_params will include access_key or secret_key if a profile is being used (which might be through passing `profile` parameter or with `AWS_PROFILE` set) Looking at https://github.com/jmenga/requests-aws-sign the way to do it is to use ``` session = session.Session() credentials = session.get_credentials() ``` but even there, we'd need to cope with the `profile` parameter.
Complement the docstring adding the parameters, might be useful (to the other functions as well)
This field can be removed in favour of the new `maxHttpFormPostSize` field below.
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
I am not able to create a new monitor - ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "apikey": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "check_type": null, "monitorid": null, "name": "myMonitor_002", "state": "present", "url": "http://www.my-domain.com" } }, "msg": "Could not perform action newMonitor" } ``
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
use the `missing_required_lib` function from `ansible.module_utils.basic`
I would say `Deploy key has been updated` instead of `should have been updated`
Same as for the updated, I'd rather say `has been deleted`
Do we want to capture bad values early in the regex or leave it until later when constructing a `datetime` object as we currently do? ```suggestion __D = r'(?P<day>0[1-9]|[12][0-9]|3[01])' __D2 = r'(?P<day> [1-9]|[12][0-9]|3[01])' ``` Is is valid for `__D2`, i.e. `ASCTIME_DATE`, to contain a zero-padded day? (Given it's looking for space-padded.)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Complement the docstring adding the parameters, might be useful (to the other functions as well)
TIL that character classes also work inside `[]` :D
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like {0}
Wouldn't it make sense if the module does that as well? Also: ```suggestion - To make the DNS record changes effective, you need to run C(update dnsserver) on the ipwcli. ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Although you changed this, I think you missed the the bit in https://github.com/django/django/pull/14437#discussion_r658641917 that the `if` can now go outside of the `for` to avoid a pointless iteration when `timeout` is `None`. ```suggestion # Set timeout for each key individually as .mset() doesn't support # setting the timeout for all keys at the same time. if timeout is not None: for key in data: client.expire(key, timeout) ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
TIL that character classes also work inside `[]` :D
To be consistent with the rest of the codebase, I'd import `from django.utils.six.moves import range` first.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Use `'` as string delimiter for consistency
flow 'when' to previous line
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Maybe this should be a class docstring :thinking:
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Needs to be `run_commands(module, ['show vlan brief'])[0]`.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I'm not sure if there are lookups where it's not the case, but comparisons such as `Choice.objects.filter(votes__gte='2')` seem to work fine with the value as a string so the "transform" stuff seems unnecessary, at this for the first version of this.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This code is almost the same as in `replace_unnamed_groups()`, the only difference is that the beginning of non-capturing group is longer i.e. `'(?:'` instead of `'('`. We could add an internal hook and use it in both places, e.g. ```python def _find_groups(pattern, group_matcher): group_indices = [ (m.start(0), m.end()) for m in non_capturing_group_matcher.finditer(pattern) ] # Loop over the groups. for start, end in unnamed_group_indices: ... for idx, val in enumerate(pattern[end:]): ... if unmatched_open_brackets == 0: group_indices.append((start, end + idx + 1)) break # Remove unnamed group matches inside other unnamed capture groups. group_start_end_indices = [] prev_end = None for start, end in group_indices: if prev_end and start > prev_end or not prev_end: group_start_end_indices.append((start, end)) prev_end = end return group_start_end_indices ``` Moreover, with some boolean flags (e.g. `named=True/False`) this could also be reused in `replace_named_groups()` :thinking: .
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
TIL that character classes also work inside `[]` :D
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
TIL that character classes also work inside `[]` :D
Required=false are implicit could you remove them ? Default=None too in case of string
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
you could just use this function instead https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/helpers.py#L37
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Required=false are implicit could you remove them ? Default=None too in case of string
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
User could set `user_data` parameter to `None`, in such case exception still occurs.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User could set `user_data` parameter to `None`, in such case exception still occurs.
Just use ` and ...` instead of nesting. Less indentation == better readable.
`band_input`, you don't get much by saving one char :-)
This can be converted to return True. No need of new variable retry_request
This can be converted to return True. No need of new variable retry_request
This should be `assertTrue()` as `assert_()` is deprecated.
This should be `assertTrue()` as `assert_()` is deprecated.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Don't check arg_type here. A module could do something silly like: ``` encryptor: passphrases_for_each_user: - foo - bar - baz ``` The arg_type in this case will be a list but we'd still want to catch it here.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
I admit Django still has much code looking like that, but it should be safe to simply use `if options['empty']:` below without first pushing the result in `self`. Having the value on `self` might make sense when we want to use the value in other methods. Same for `options.get('help', False)`, as we are using the parser in both `call_command` and `run_from_argv`, we can be sure that `'help'` is in the options dictionary, so `options['help']` is fine.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
IMO we should check options against PostreSQL names.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
IMO we should check options against PostreSQL names.
~Never mind, looks it's the other way around. Works on 3.6, fails on 3.8.~ had an old Python 2.7 interpreter lying on my path 🤦
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
Please change these vars to ansible Host vars rather OS env vars.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
This can be converted to return True. No need of new variable retry_request
This can be converted to return True. No need of new variable retry_request
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
This can be converted to return True. No need of new variable retry_request
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
This can be converted to return True. No need of new variable retry_request
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
@annikulin it needed more work than I initially thought to get httpapi plugin host var working. Probably we can commit this code as is and I will commit a followup PR to make it configurable using ansible host vars
This can be converted to return True. No need of new variable retry_request
Nitpick: Append a \ to the end so it doesn't generate an empty first line.
This can be converted to return True. No need of new variable retry_request
I think it would be good to include a message giving context before we start listing unresolved issues.
It might be worth compiling the regexp in the class or [module level and reuse](https://github.com/django/django/blob/master/django/contrib/localflavor/ca/forms.py#L16-L17).
I think it would be good to include a message giving context before we start listing unresolved issues.
I think it would be good to include a message giving context before we start listing unresolved issues.
I think it would be good to include a message giving context before we start listing unresolved issues.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
It seems we can probably move deprecation warning handling to the actual test cases now. We can make it a follow-up item after merging the first version of this if you like.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
Let's not block the merge on this. The current implementation matches the DEP which was largely discussed. I'm brainstorming to avoid future problems. Seeing the code sometimes gives new ideas.
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Reading below, I see that Flask has an "any" converter that does something more complicated. Creating a converter with the same name but a different behavior doesn't sound good.
Will info['body'] be json? Might be a string/HTML.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Will info['body'] be json? Might be a string/HTML.
Will info['body'] be json? Might be a string/HTML.
Will info['body'] be json? Might be a string/HTML.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
TIL that character classes also work inside `[]` :D
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
You are completely right. What about this? Too ugly?: ``` js_catalog_template = \ r"""{% autoescape off %} ... ```
Cool. Thanks. Let me know once done.
```suggestion Test that the returned value for timezone consists of only uppercase ```
this is a catchall, we normally frown on those. also note that for all of your `% e` they should be `% to_native(e)` to ensure proper character conversions
Required=false are implicit could you remove them ? Default=None too in case of string
The interesting test case is this: ``` season_2009 = Season.objects.create(year=2009, gt=111) season_2009.games.create(home="Houston Astros", away="St. Louis Cardinals") season_2009.games.create(home="Houston Astros", away="Chicago Cubs") season_2009.games.create(home="St. Louis Cardinals", away="Houston Atros") season_2010 = Season.objects.create(year=2010, gt=222) season_2010.games.create(home="Houston Astros", away="Chicago Cubs") qs1 = Season.objects.exclude(games__home__contains='Houston') qs2 = Season.objects.exclude(lookups.Contains(F('games__home'), 'Houston')) ``` where the qs1 and qs2 objects should match. The encouraging thing is that the code is trying to call split_exclude(). It might be hard to make this test actually work, the split_exclude() code is pretty big hack, and especially if the expression creates joins to multiple different relations it will be hard to make the current code work properly. But, if I recall correctly, we don't support .filter(games__away__contains=F('games__home')) either.
Same here? ```suggestion __T = r'(?P<hour>[01][0-9]|2[0-3]):(?P<min>[0-5][0-9]):(?P<sec>[0-5][0-9])' ``` Maybe this is a bad idea because of leap seconds 🤷🏻‍♂️
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
```suggestion password=dict(type='str', required=True, no_log=True), ```
```suggestion password=dict(type='str', required=True, no_log=True), ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Yes -- arguably it might be better if it does crash if required is provided so people know to update their code.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
I wonder if testing the `LogEntry` items instead of calling the view would be a bit more precise testing. To be evaluated.
This can be moved to `check_dict` method.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
use the `missing_required_lib` function from `ansible.module_utils.basic`
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Is `user_id` something secret, just wondering why it has `no_log`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
I think `name.rsplit('-', 1)[-1]` is easier to read.
I meant -- isn't the call to `localtime` going to raise the same exception as the template engine? Because the template engine calls this function or an equivalent one.
I meant -- isn't the call to `localtime` going to raise the same exception as the template engine? Because the template engine calls this function or an equivalent one.
So add `type='str'` here too. And we tend to sort lists if the order is of no importance.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
In my point of view, it is better to use `rabbitmqctl version` command. It was introduced in some 3.7 release. It seems `status` output is an unreliable source of information - status format can be changed from one release to another. I suggest the following workflow: * try to find a version in `rabbitmqctl version` (use --node option like with other commands) * if this command return error - try `status` with old regex Anyway, I'm not maintainer here ) I don't think that my approval can change anything.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Removal of this line broke one of my scripts, which was relying on the field "name" to contain the portgroup name.
Maybe this should be a class docstring :thinking:
This is already covered by `ParseHeaderParameterTests.test_basic()`.
Same here, default parameter is **validate_certs**, the aliases should be removed. We also simplify this by *not* adding `required=False`, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
This is already covered by `ParseHeaderParameterTests.test_basic()`.
```suggestion RuntimeWarning, ```
I double people will update this script correctly. We can only hope, that release managers verify this before sending the email... As an alternative, we can also wildcard this, and let release manger insert those manually. Similar to `<DETAILS OF THE CHANGES>` above.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
ok, just something for consideration, I trust your/the community's judgement on it
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Maybe this should be a class docstring :thinking:
```suggestion self._exec_cli_command(b'screen-length 0 temporary') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Please remove empty line.
a leftover here which can be removed
Please initially check that `mode` in is `{'auto', 'min', 'max'}`.
no blank line
Please use hanging indent to make better use of line lengths: ``` python inline_re = re.compile( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))""" ) ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
I don't see much value in this docstring.
I would leave it as a `lambda`.
I added a short docstring but without `is provided by developers ...`, this is not a strong argument, a lot of things are provided by developers but we don't mark them as safe. I'd say that's how it is, the decision was made a lot time ago :shrug:
Two things to change here: * Use ansible.module_utils._text.to_text() instead of .decode(). * Catch the UnicodeError and give a better error message. Maybe something like this: ``` python from ansible.module_utils._text import to_native, to_text [...] try: remote_md5 = to_text(self._getContent(remote_url + '.md5', "Failed to retrieve MD5", False), errors='strict') except UnicodeError as e: return "Cannot retrieve a valid md5 from %s: %s" % (remote_url, to_native(e)) ```
Exception handling here too.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
Single quotes please.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Single quotes please.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Single quotes please.
Maybe this should be a class docstring :thinking:
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
The output looks like: Number of entries: 0 And you are matching with number with lower case n. This will not work. Also you are comparing a string with an int. line[-2:].strip() returns a string you have to cast it to int. line[-2:] gives last two numbers, let us say the output was '... entries: 100' this logic would return 00. Which will not work. Do a regex match for the number of entries, split everything beyond : to get the actual number of entries remaining.
Please use 'msg' for returned messages, this is a standardized return value.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
I think we should be consistent and use double-quotes.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
Is `user_id` something secret, just wondering why it has `no_log`
Yes, I know. I'll leave it to Aymeric for a second opinion.
Generally we don't treat usernames as secrets, so no need to mask
Generally we don't treat usernames as secrets, so no need to mask
Is `user_id` something secret, just wondering why it has `no_log`
Maybe this should be a class docstring :thinking:
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
Lowercase 'yes' please :-)
Lowercase 'yes' please :-)
Lowercase 'yes' please :-)
Here as well. `required=False` is not strictly necessary. Sometimes it is easier to find what is required, if only those options have required :)
In `_handle_m2m_field()` and `_handle_foreign_key_field()` we can avoid of temporary variables (`value`) and return directly, e.g. ```python def _handle_foreign_key_field(self, field, field_value): return base.deserialize_fk_value(field, field_value, self.using, self.handle_forward_references) ```
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
I would say `Deploy key has been updated` instead of `should have been updated`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
ok, just something for consideration, I trust your/the community's judgement on it
Also forgot to mention, I don't think I've seen many regex'es written this way before (using string constant concatenation and continuation lines), and I find it pretty neat.
remove unnecessary code.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I think this would be a bit more readable: ``` return ( '%(func)s %(op)s %(dist)s' % {'func': sql, 'op': self.op, 'dist': dist_sql}, params + dist_params ) ```
This is minor, but the double exclamation point feels a little overblown. I'm not sure any exclamation points are needed at all; the text should suffice.
We can pass `opclasses` to the `super()._create_index_sql()`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
chop the blank lines before each attribute
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Typo in `module_utils`.
check that -> and that (no comma needed since the two clauses are independent)
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Generally we don't treat usernames as secrets, so no need to mask
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
See my previous review for indentation style of this. Perhaps the common qs stuff before the last filter can be moved to setUpTestData.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Passing `lead` and `trail` to the `trim_punctuation()` looks unnecessary. This method is called only here so we always pass `('', word, '')`. Maybe: ```suggestion lead, middle, trail = self.trim_punctuation(word) ``` and ```python def trim_punctuation(self, word): """ Trim trailing and wrapping punctuation from `word`. Return the items of the new state. """ lead, middle, trail = '', word, '' ... return lead, middle, trail ```
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
alphabetize g before o also I would combine with the "from" imports below
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This check of for_save could be added to the place where resolve_expression is called in the compiler (first call resolve_expression, then check if resolved.contains_aggregate -> FAIL).
```suggestion NO_LOG_REGEX = re.compile(r'(?:pass(?!ive)|secret|token|key)', re.I) ``` That part wasn't used anymore anyway...
The import should be conditional and the test skipped if enum isn't installed.
Maybe this should be a class docstring :thinking:
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
`raise` is missing. Call to `str` is useless there.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
`raise` is missing. Call to `str` is useless there.
You can also add a deprecation warning for usages like `from django.forms.extras.widgets import SelectDateWidget`.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
I believe you would need to add a custom `save_form` method to a `ModelAdmin` and somehow incorporate the `change` flag in it -- perhaps modify the form's cleaned_data to assign the field to a model field before save.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Maybe this should be a class docstring :thinking:
Same as for the updated, I'd rather say `has been deleted`
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
Same as for the updated, I'd rather say `has been deleted`
I would say `Deploy key has been updated` instead of `should have been updated`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Typo, should be email
Typo, should be email
Maybe this should be a class docstring :thinking:
py3.x-only code; can safely ditch the args to `super()`
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
I think we should be consistent and use double-quotes.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
TIL that character classes also work inside `[]` :D
not sure about the purpose of this test. I don't really like using `assertNotEqual` since there are an infinite number of "not expected" strings that will cause the test to pass.
I'd rename `subminor` to `patch`.
Line is too long.
Maybe this should be a class docstring :thinking:
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
```suggestion query=dict(type='list', elements='str'), ```
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Don't put logic on an `if` line, introduce a line break. In general, I suggest rewriting the part of the code that prints evaluation results to make it simpler, easier to read, and more user friendly. A big goal of these example scripts is to be as user friendly as possible while introducing best practices.
This can be single-lined: ```suggestion return (matched_tags or not tags) and not test_tags.intersection(exclude_tags) ```
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
You can remove the else. AnsibleModule will handle this since state has a list of allowed choices.
```suggestion result['last_modified'] = mtime = date_to_timestamp(info['last-modified']) ```
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
Cool. Thanks. Let me know once done.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Style-wise, I like to make the thing being tested the last import and visually separate from the other imports (a blank line between them and the import for the thing(s) being tested.
immediatelly -> immediately
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
`raise` is missing. Call to `str` is useless there.
Please remove empty line.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
`raise` is missing. Call to `str` is useless there.
We shouldn't change the context to keep this backward compatible: ```suggestion 'action_list': page_obj, ``` Updated.
we should not be adding a python dependency on ordereddict here, as python2.7 can also use ordereddict from collections: https://docs.python.org/2/library/collections.html#collections.OrderedDict This also means, that python2.7 users now need an additional python dependency installed.
To keep backwards compatibility, we need to add `enclosures=None` after `updateddate=None`.
To keep backwards compatibility, we need to add `enclosures=None` after `updateddate=None`.
nvmd, had not looked at the called method which already handles skipped coloring
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Maybe this should be a class docstring :thinking:
Your module claims to support check mode, but I don't see any reference to check_mode being implemented. That said, it would be very useful to actually implement check_mode.
Maybe this should be a class docstring :thinking:
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Maybe this should be a class docstring :thinking:
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
IMO, it might be better to harcode the expected HTML rather than generating it programatically as it would be more clear what's expected.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Use another lookup instead of `epoch` e.g. `second`.
This one as well.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
In most modules, `state` is optional and defaults to `present`. It would be easier for users if this module stuck to that convention.
Maybe this should be a class docstring :thinking:
a leftover here which can be removed
Maybe this should be a class docstring :thinking:
Please add `type="str"`
I think the interfaces should be the same. It's probably the right (more forgiving) behaviour for a response, which isn't a dict. Folks will `s/response[/response.headers[/` not the least. But the docs also say this is the behaviour.
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
a leftover here which can be removed
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
```suggestion return ''.join([ self.handle_word(word) for word in words ]) ``` I changed `handle_word` to return `word` in remaining cases.
This can raise a `LookupError`
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
one more for the single line version
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
We try to avoid line continuation backslashes in Django, and it's not a problem to overcome the 80-chars limit when it makes readability better.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
`raise` is missing. Call to `str` is useless there.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
Maybe this should be a class docstring :thinking:
Isn't `raise` missing there ? Calls to `str` are useless.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Do we need to change `related_name` here? We could add `note` with `related_name='owner'` instead.
We can also import `include()` from `django.urls` instead of `django.conf.urls`.
Net new tests should be `pytest` style tests.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_REGION']), ```
I think we want to deprecate NUMBERTYPES so instead of moving it, just use its definition here (list(ansible.module_utils.six.integer_types) + [float])
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
@maorlipchuk Can you please use `get_entity` from `./lib/ansible/module_utils/ovirt.py`? ```python from ansible.module_utils.ovirt import get_entity dc = get_entity(dcs_service.service(self._module.params['data_center'])) ``` No need for `try-except` then.
Please add edge cases to cover caching `IndexError` and `HeaderParseError`: ``` # Other invalid addresses. '@', 'to@', '@example.com', ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
Required=false are implicit could you remove them ? Default=None too in case of string
ditto on `.` in character groups
ditto on `.` in character groups
ditto on `.` in character groups
Isn't `raise` missing there ? Calls to `str` are useless.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
When hitting an error you must exit with module.fail_json
`raise` is missing. Call to `str` is useless there.
Please ignore, my suggestion is invalid syntax.
Isn't `raise` missing there ? Calls to `str` are useless.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Please remove empty line.
please check code with flake8 (`E231 missing whitespace after ','`)
Isn't `raise` missing there ? Calls to `str` are useless.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Isn't `raise` missing there ? Calls to `str` are useless.
[`create` already saves the model](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.create), you don't need to repeat it (same for others below)
`raise` is missing. Call to `str` is useless there.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
```suggestion 'Accept': '*', 'Host': 'example.com', ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
I think we want to sort on create-time here, or something equally deterministic. I'm not sure how sorting works with lists of dictionaries if you don't specify `key=....`
Maybe this should be a class docstring :thinking:
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
This should be in the `except` above.
Also, it's a classical property. Refactor it in a more elegant way: ```python @property def valid(self): try: return os.path.getmtime(self.file) + self.max_age > time() except IOError: return False ``` P.S. When reusing this snippet, please add the trailer to the long commit description: ``` Co-authored-by: Sviatoslav Sydorenko <wk@sydorenko.org.ua> ```
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
That's a really interesting piece of information I did not know.
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Let's be consistent about whether `app_name` appears above or below `urlpatterns`.
Maybe this should be a class docstring :thinking:
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
If the organization being renamed doesn't exist yet, that should probably throw an error or a warning or something.
Maybe this should be a class docstring :thinking:
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe this should be a class docstring :thinking:
~~I think we should pass `True` in all cases, because we're selecting a flag not declaring a value.~~
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Could you try to improve this so that there isn't duplication of the HTML and `escape(Truncator(obj)....`
I think we should be consistent and use double-quotes.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
Required=false are implicit could you remove them ? Default=None too in case of string
We should move using named groups in regular expressions to a separate commit, and add a new rule and an actual fix in the second one.
I believe more explicit top-level dirs would read better: ```suggestion DEFAULT_TEMPLATE_DIR = ( pathlib.Path(__file__) / '..' / '..' / '..' / '..' / 'docs/templates' ).absolute() ```
Maybe this should be a class docstring :thinking:
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
Ah, i'd expect a bool to always be True/False, if that is not the case (no time to test really right now :)), then indeed, this needs to stay (and this goes for my other bool remarks)
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
well, maybe. I haven't checked what `.absolute()` does.
In the `exit_json`, you should also return `changed` and `state`.
it looks to me this module supports check mode, but it is says not
problem with original, but still `str` is not portable, use `to_text`.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
I think we should be consistent and use double-quotes.
Maybe this should be a class docstring :thinking:
You're right. You know I both saw that and missed it too...
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
This syntax is not supported in python2.6. You will need to index your format like {0}
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Like above, I think this should be `userid, name, password, group, email`
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
This syntax is not supported in python2.6. You will need to index your format like `{0}`
I wonder if this initialization needs to be done in `setUpClass()` or if doing it at the class-level would work? ``` class DateInputTest(WidgetTest): widget = DateInput() ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
I think we should be consistent and use double-quotes.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
please set default to True
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
It Python, you should use a proper camel case for classes: ```suggestion class TestJsonEncodeFallback: ```
pytest.mark.skip Though I'm surprised we did not see any bot error.
pytest.mark.skip Though I'm surprised we did not see any bot error.
pytest.mark.skip Though I'm surprised we did not see any bot error.
The word `generally` doesn't add any value in my opinion.
Remove debugging content "bhujay here". Also, iface['subnet'] is not valid when iface is a str.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
According to the DEP, this should be usable as a class decorator, but I don't see this here... Something like ```python def register_converter(converter, typename=None): if typename is None and isinstance(converter, str): # We're used as a decorator return functools.partial(register_converter, typename=converter) else: ... # current body ``` Alternatively, make `typename` an attribute of the converter class -- then `register_converter` takes a single argument and can trivially be used as a decorator. Making the name accessible in the converter is probably better anyway, for error-reporting in any non-trivial `to_python()` or `to_url()` method.
That is also consistent with `SlugField.allow_unicode` which defaults to `False`.
Please remove empty line.
I had to change this to `template_params['subquery'], sql_params = self.subquery.query.get_compiler(connection=connection).as_sql()` in order to compile correctly when using a database other than the `DEFAULT_DB_ALIAS`.
Ok I get it, `compiler.compile(Value(5))` would return something like `'%d', (5,)`.
I had to change this to `template_params['subquery'], sql_params = self.subquery.query.get_compiler(connection=connection).as_sql()` in order to compile correctly when using a database other than the `DEFAULT_DB_ALIAS`.
In the `exit_json`, you should also return `changed` and `state`.
It would be fine to call the function with `None` since `r` isn't used. Again, use `self.settings` to verify that `settings.LANGUAGE_CODE` is returned.
In the `exit_json`, you should also return `changed` and `state`.
In the `exit_json`, you should also return `changed` and `state`.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Maybe this should be a class docstring :thinking:
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
In the `exit_json`, you should also return `changed` and `state`.
Maybe this should be a class docstring :thinking:
remove extra newline
remove extra newline
I don't have a strong opinion on this. When it was like that before, I didn't really like the blank browser popping up before the tests started to run. If we change it though, we need to include the original exception in the error message that's reraised. I think the current simple approach is okay.
I think I'd make this an `Error` - I don't think translation works at all if this is wrong.
chop the blank lines before each attribute
Maybe this should be a class docstring :thinking:
Maybe this should be a class docstring :thinking:
alphabetize g before o also I would combine with the "from" imports below
Instead of calling `get_capabilities` twice in the module, maybe make it an attribute for `FactsBase` class in the `__init__` method and reuse? `self._capabilities = get_capabilities(self._module)`
Maybe this should be a class docstring :thinking:
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
ternary isn't available in python-2.4 If the freeipa module works on python2.4 then this will need to be expanded into a regular if-else.
Can we make these multi-line, such as... ``` 'SELECT "postgres_tests_hotelreservation"."id", "postgres_tests_hotelreservation"."room_id", ' '"postgres_tests_hotelreservation"."datespan", ...' '...' ``` ...and so on.
Please update as per https://github.com/ansible/ansible/pull/31930/files ``` required_together=[['grafana_user', 'grafana_password', 'org_id']], mutually_exclusive=[['grafana_user', 'grafana_api_key']], ```
Minor consistency nit- our stuff seems to be using `[action]_[backend]()`, where these aliased imports have that reversed. I'd vote for `[action]_[backend]()` over this- makes the code a little easier to read...
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`try` block should contain fewer statements. `Exception` should be replaced with a more precise exception type.
`raise` is missing. Call to `str` is useless there.
Maybe this should be a class docstring :thinking:
Yes. Adding `?:` makes it a non-capturing group which allows for use of `m.groups()` below. Otherwise it'd need to be `... = m[1], m[2], m[4]`.

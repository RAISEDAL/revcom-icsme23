```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
Maybe use ```suggestion type: path ``` instead? Then Ansible will replace things like `~` IIRC.
```suggestion - Required when I(release_state) is set to C(present) ``` Use `I(...)` for option names, `C(...)` for option values.
Yes, but this module doesn't run on machines where ansible is installed...
Afaik the `version_added` line is not necessary for new modules
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
This class isn't really providing any value. Usual practice is to create the client in main and then call a describe_task_definitions method.
Is there a case to be made for `task_definition` being optional, and if not present, returning task definitions for all tasks. Furthermore, I think I'd consider extending this module to become ecs_task_facts, and return the task data along with the task definition and then describing one or more tasks as options.
Thanks for the contribution! Since new AWS modules are required to just use boto3, you can remove this. Your exception handling can also be updated to be for boto3. Each boto3 call should be in a try/except. There's some helpful info here: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md
This is slightly confusing to me since there is no word of pulling in the task itself. I'd probably rename to > Pull an image if it's not present locally and run a container
this is probably wrong ```suggestion ```
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
This should be botocore.exceptions.NoCredentialsError.
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
As per other PRs, you don't need to repeat the option name.
As per other PRs, you don't need to repeat the option name.
"Path to an ssh key used to authenticate..."
As per other PRs, you don't need to repeat the option name.
You don't need to repeat the option name with I() when describing that option. "User to authenticate..."
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
No need to set `have`, `want` explicitly as it is always be empty dict if not resource is given/present.
You can use `module.deprecate` to throw a deprecation warning.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
Please remove `force:`
Since the module makes no changes, it's safe to claim support for check mode: ```suggestion supports_check_mode=True, ) ```
The cast to `int` shouldn't be needed, as `p.info['pid']` should already be an int. ```suggestion return [p.info['pid'] for p in psutil.process_iter(attrs=['pid', 'name']) if name == p.info['name']] ```
The `module` parameter is unused. ```suggestion def get_pid(name): ```
Use the following try/except, which is fairly standard for Ansible modules: ```python try: import psutil HAS_PSUTIL = True except ImportError: HAS_PSUTIL = False ``` This will also fix the test errors, as the existing code sets `HAS_PSUTIL` to `True` and then `False` when the import succeeds, but leaves it undefined when the import fails.
The `sys` import is unused. ```suggestion ```
Change description to match `enable` and `disable` dvSwitch.
period at the end of statement.
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
This is not required if using `super`
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Yes, 'msg' key and value should always present on *_exit() calls
Okay. the default recursionlimit in python is 100 levels. (But it might be set lower if someone has optimized their python build for low memory situations). We'll just have to wait and see if we get any bug reports and fix this then.
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
use `missing_required_lib` from `ansible.module_utils.basic`
If you use `to_text(xxx, errors='surrogate_or_strict')` it won't throw exceptions.
To make it reliable, please record the time when the module started and pass it here, so we always list only relevant events.
I've meant that you should call `self._connection.system_service().events_service().list(max=1)` at the begging of the module, and then list the events only from that specific event ID like `search="from_=%s" % event.id`. You can check `wait_condition` in `check_for_upgrade` for an example.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Yes. Either to_native or to_text would be fine in this case.
also need to check whether the workspace is name or resource id
yes, it's ok to iterate and change, as long as users will get simpler structure :-)
instead of example now we need proper description of returned values, please check facts modules like azure_rm_webapp_facts or azure_rm_containerregistry_facts as a reference
remove the register line, kind of confused
maybe also should be described
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
Use the ec2 helper function `ansible_dict_to_boto3_tag_list`
Define separate checks for json and boto3
There's a new AWS Retry generic handler that you can use here. Check out the ec2 shared code in module_utils
Handle boto3 exceptions as per the guidelines. E.g. ```module.fail_json(msg=e.message, **camel_dict_to_snake_dict(e.response))```
Not required - added by doc fragement
I would switch the statements, test for dict, test for list, else raise error.
`if credential and ...` could be used here. With Python 3.5, the call to `endswith` raises an exception: `TypeError: endswith first arg must be bytes or a tuple of bytes, not str`.
Unnecessary blank lines here, removing these blank lines is preferable.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
we want want -> we want
Again, the name for that task was a copy-and-paste from the integration tests. It would probably better to use, eg. ```yaml - name: Enable 'telnet-client' windows feature ```
Ah, I think it's a copy-and-paste error from the integration tests. Good catch :-)
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
If a parameter is not required, we don't have to state that explicitly. It is implicit. Only when parameters are required, you need to add `required: yes`.
This can be removed. If a parameter is required, there is no default.
We should probably also include a sample and/or doc note that shows that the route table is associated via `azure_rm_subnet` - was definitely the simpler choice to implement that way, but we need to tell people where that happens.
Probably best to add an entry saying the location is derived from `C(resource_group)` if not specified
Can you differentiate between the named route not being present in the rout table and other exceptions to avoid log spew in the normal situation in which the route does not exists for that route table.
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
```suggestion "Cannot change option from (%s) to (%s) for an" ```
You can remove these imports except ec2_argument_spec
snake_dict_to_camel_dict can be removed.
This line doesn't need to be in the try/except.
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` and here as well
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` Here this var needs to stay as you had it originally - ansible prefers snake cased but boto typically needs camelcase. `instance_parameters` will be passed into the boto connection so needs to match what the API expects, both here and later when you access the returned parameters. https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationSubnetGroup.html#API_CreateReplicationSubnetGroup_RequestSyntax
You should always have `type='str'` (or whatever type you have) in all of argument spec.
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
specifying `type='int'` removes the need for this, so you only need to check the range.
(Additional whitespaceânumber of spaces not multiple of 4.)
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
Should set `no_log=True` for fields like this, this stops Ansible from logging secret information to plaintext sources.
You would need to set `changed` if `force_update` is set even in check mode.
CamelCase for consistency? This one could go either way since it's a new arg, but would depend on if there's a bigger plan to move everything else in this module toward snake_case
```suggestion if type is not None: ```
There could be a check in here to prevent both label and label_id from being specified if state is absent.
Please remove `required=False`.
Please remove `required=False`.
even cleaner ```yaml - include_vars: "{{ item }}" when: item is file loop: - "{{ ansible_os_family | lower }}.yml" - "{{ ansible_distribution | lower }}.yml" - "{{ ansible_distribution | lower }}-{{ ansible_distribution_major_version | lower }}.yml" - "{{ ansible_distribution | lower }}-{{ ansible_distribution_version.replace('.', '-') | lower }}.yml" ```
you have to add 'vars/' to the find then, my option is not meant to work in all the same cases, but it is cleaner (IMHO) for the case presented.
This is not a good example, you don't need a loop if you are just going to do 'first found'. The `vars_files` is better in these kind of contexts as it already has a built in 'first found', which this example is not even using as you are really looking for each file alone and merging them all in the end via the loop.
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
should be `type='path'`
TODO add Exception handling for login error
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
probably want a to_text and u prefix.
Is this even needed, we will be dropping py2 and `to_text` does not call `__unicode__`. You may as well just put this in `__str__`.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
but to_boolean doesn't convert values to booleans. It's really normalize_options(). It's just that the only implemented normalization at the moment is for boolean values.
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
yes, as well as `None`
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ``` (https://github.com/ansible/ansible/pull/41158#pullrequestreview-128452262)
`for k, v in opt.items():` <-- gives you key-val pair
This should be a @staticmethod and self removed.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
Make this a regular function
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Incorrect description; "If remote gateways can be used on this virtual network."
that should be example of module usage, not return value
security group -> security groups
That's fair enough, the code should be split out into a generic function so it can be used by other modules. There is nothing AWS specific about the camel_dict_to_snake_dict and the reverse function, it was only used there because on AWS had a need for it.
@gustavomcarmo please check my pr #39722 , i have 2 options now, raw and curated
use ```from ansible.module_utils.vmware import get_parent_datacenter```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import find_obj```
+1 for to_text
Strange default. I would simply remove it.
This is implicit for parameters. Unless it is required, you don't have to add anything.
Why would you default to an empty string here ? Is an empty string actually useful ? The default is None, which is a good default so you know it was set or not. Simply remove this for the "default" default.
Please remove this. It is wrong. Don't add a default in this case.
Remove this. But do add: ```yaml choices: [ absent, present ] ```
Ok, not sure why this one is still open.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
You can remove this line
No need to have the `required: false` lines, it's implicit.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
Please separate this clause into separate lines for maximum readability (like above).
Please separate this into separate lines for maximum readability. Something like: ``` if inst.image is not None: image = inst.image.split('/')[-1] else: image = None ```
Please separate this clause into separate lines for maximum readability (like above).
Please separate this clause into separate lines for maximum readability (like above).
Use whatever fixture names make sense. Personally I'd probably name the fixture `XenAPI` since that's the import it is replacing. Then there's no need to assign `XenAPI = fake_xenapi`. Setting `autouse=True` only loads the fixture for the test automatically. If you want access to that fixture as a local, it still needs to be a function parameter. The benefit to autouse is that it guarantees the import will be mocked, even if the test doesn't require a reference to the fixture. However, there's nothing wrong with specifying an autouse fixture as a function parameter. Doing so simply makes the auto-instantiated fixture available as a local within the test function. To guarantee correct fixture order, declare that the `fake_xenapi` fixture is used by the fixture providing `ansible.module_utils.xenserver`. Modifying `sys.modules`, or making other changes to global state, outside of a test fixture or function will apply those change to all unit tests (everything under `test/units/`) when pytest collects the tests before they are executed. Since we run unit tests with the pytest `--boxed` option, each test is run in a separate Python process after the initial collection is performed. This means that any global state changes made in-process by a test function are discarded at the end of that test function, but all changes made during collection are shared. Imports handled during collection will result in changes to `sys.modules` that will be shared across all tests. This is fine for regular imports. However, the mocked import for `XenAPI` is specific to the tests in `test/units/module_utils/xenserver/`, so it should be restricted to those tests. If another test, such as one for a xenserver module were to also mock `XenAPI` they would conflict.
This needs to be in a fixture so it doesn't affect all unit tests. To avoid the need to reference the fixture on each test you may want to use `@pytest.fixture(autouse=True)` on the fixture. Perhaps something like this: ```suggestion @pytest.fixture(autouse=True) def fake_xenapi(): xen_api = importlib.import_module('units.module_utils.xenserver.FakeXenAPI') sys.modules['XenAPI'] = xen_api return xen_api ```
You shouldn't need to assign `XenAPI = fake_xenapi`. What mocker.patch calls are you trying to make that require that? To have access to `ansible.module_utils.xenserver` in tests without importing it in each test function, you could wrap it in a fixture.
You could even rename the fixture to something other than `fake_xenapi` if desired.
Add - ``` from __future__ import absolute_import, division, print_function __metaclass__ = type ```
One last thing I thought of: it may be good to catch `AttributeError` and `ValueError` if an invalid value is passed for `namespace`. Otherwise we get a stacktrace. ```suggestion try: uuid_namespace = uuid.UUID(namespace) except (AttributeError, ValueError) as e: raise AnsibleFilterError("Invalid value '%s' for 'namespace': %s" % (to_native(namespace), to_native(e))) ```
```suggestion return to_text(uuid.uuid5(uuid_namespace, to_text(string))) ```
The other unit test failure is due to a difference between `uuid5` on Python 2 and Python 3. In Python 2, `uuid5()` needs `bytes`: ```python def uuid5(namespace, name): """Generate a UUID from the SHA-1 hash of a namespace UUID and a name.""" from hashlib import sha1 hash = sha1(namespace.bytes + name).digest() return UUID(bytes=hash[:16], version=5) ``` In Python 3, it converts to `bytes` so you can pass in `bytes` or text: ```python def uuid5(namespace, name): """Generate a UUID from the SHA-1 hash of a namespace UUID and a name.""" from hashlib import sha1 hash = sha1(namespace.bytes + bytes(name, "utf-8")).digest() return UUID(bytes=hash[:16], version=5) ``` ```suggestion # uuid.uuid5() requires bytes on Python 2 and bytes or text or Python 3 return to_text(uuid.uuid5(uuid_namespace, to_native(string, errors='surrogate_or_strict'))) ```
I think this will be ok since `to_uuid()` is returning a string. But this does look wrong on first glance.
this changes the return value and is not backwards compatible
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
Omit these lines please.
Please revise to "This is a feature of the Ansible Engine, rather than a module, and cannot be overridden like a module."
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
please use explicit imports `from ansible.module_utils.basic import AnsibleModule`
please use explicit imports
please wrap in `IF` block
please use explicit imports .... `from ansible.module_utils.basic import AnsibleModule` ... etc
please wrap in block ``` if __name__ == '__main__': main() ```
```suggestion special_num = [3, 6, 15, 28, 51] ```
```suggestion if 'name' in opt and opt['name'] not in special_options: ```
```suggestion if 'num' in opt and opt['num'] not in special_num: ```
Yes, that file has moved in the meantime. That's also why we have that conflict.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
This won't work if 'name' is an alias, rather than the parameter name.
This was very specific to ACI, I don't see a good reason to repeat this here.
I would do this in a more pythonic way like, `'/organizations/{0}/networks'`
No need for the 'else' here either. The 'if' is the exit statement.
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
See my point in the non facts module around snake_case.
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
Should also be "path"
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
Nowadays we list all the functionality we use from a specific library explicitly. So: ```python from ansible.module_utils.basic import AnsibleModule ```
oh I see, it makes sense then.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
```suggestion from ....config import ( ```
```suggestion from ....util import ( ```
Tag a `1.0.0` release of the container and use that version here instead of `latest`.
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
Use `self.assertEqual(d, d)` instead of `self.assertTrue(d == d)`.
this is not in core and will result in exceptions if not present, use same pattern as we do with boto
replaced is not a good state, it should be part of present (would be 'changed' return status)
Please use `load_provider()` defined [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network_common.py#L340). You can refer [this](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L48) action plugin.
Oh, and `args[0]` is the module, so you want to look at `args[1]` for the url.
This doesn't match because your test uses `http://` instead of `https://`.
I think this may be confusing to a reader now. They should be the same
The alternative would be to always report `changed=False` in check mode, but that could result in an unexpected change during normal execution when you were expecting no change. I would rather Ansible report a change in check mode, but do nothing in normal mode to be on the safe side.
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
examples. - Remove space before full stop
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
```suggestion b_colldirs = list_collection_dirs(coll_filter=coll_filter) ```
^ that seems to be an expression not really a data type issue (sorting keys, this is another known json issue), in any case, there is also an existing `jsonify` in module_utils.
a simpler fix i was already working on: `+ display.display(json.dumps(text, cls=AnsibleJSONEncoder, sort_keys=True, indent=4))`
this is too aggressive as it removes all ACLs, not just the ones we added take into account that directories can have 'default acl' to be added to all new files in a directory, this would wipe those along with the one we added to copy the file into place
Please an alias allowing `password_expiration_days`
Same here - add an alias allowing `password_...`
Same here - add an alias allowing `password_...`
Because these have hard defaults (`False` rather than `None`) this module would not always be idempotent if all options aren't provided. I think it should only alter options that the user passes to the module, rather than resetting to defaults.
This can all be replaced by `module.client('iam')` or `module.resource('iam')`, but module.resource doesn't support the aws_retry feature.
Connection plugins return bytes for stdout and stderr (the callers are responsible for transforming to text or not). So this needs to remain with to_bytes().
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
You might want to specify a different error handler here. The default handler is surrogate_or_replace. When non-utf8 byte sequences are encountered, it either uses surrogateescape if available or replace. This can munge output on python2. Since we're sending this to json.loads (rather than displaying it to the user) it might be better to use surrogate_or_strict as the error handler here.
It would be awesome if buildah supported copying from a container.
and convert filename to bytes again.
@marcin-sucharski check against current development, I've merged stringification at run_command so you might not need to do this anymore.
How about adding `to_text(value)` in next loop where we are iterating on options ? ```python for key, value in options.items(): if value is not None: if key == '802-3-ethernet.mtu' and conn_type != 'ethernet': continue cmd.extend([key, to_text(value)]) ```
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
Just a thought, and this was a problem I created, `user` was meant to be used of the repository that needs to be accessed, not for auth. I think we should change `repo` to be the full path of the repository (`username/repo`) and then we can split it for use later on.
A lot of this code is duplicated between this `gitlab_tag` module and the `gitlab_hook` module that you've also submitted: https://github.com/ansible/ansible/pull/19093 I think you should extract the common code into a class that goes into `ansible.module_utils`.
I think `gitlab` would be a better name for this variable than `git`.
Change `should` to `would`.
I would use `module.fail_json` here to properly indicate failure.
```suggestion elif docker_object == 'networks': ```
```suggestion if self.client.module.params['disk_usage']: ```
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
I think this description is off :)
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
So maybe `list(dict)` is a better match for the current implementation, and then we can use `len(a) == len(b)` shortcut safely.
And this is not about the order, as we're comparing it in O(n^2), ordering does not matter here.
Oh I don't thinks this is a set, if it is, we should use `set_a = set(a), set_b = set(b)` for comparison. If we can't do this, then this should be `list(dict)` and compared by list match.
Ah, maybe `list(dict)` will be a more suitable type name for this. And we can add a shortcut for `len(a) == len(b)`, which I think will make the logic a bit clear, like this: ```python if len(a) != len(b) and method == 'strict': return False for av in a: for bv in b: # the compare logic, no need to another iteration for bv in b and av in a
I think this is overkilled if `devices` and `ulimits` are both lists of `str`
`{}` is not compatible across python versions that support format, use `{0}` or `%` instead
should be moved after line 205 (otherwise the error message is reporting None).
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
`delete` and `create` are not valid states
a module should never end in exception, it should use fail_json instead (you can pass traceback info if needed in 'exception' key)
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
Suggest adding a combined example that also uses win_credential.
The results of vmdk_disk_path_split are not used anywhere here (they are used inside find_vmdk, but it calls the routine directly.
This fails when disk_size is defined as int
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
`if unit in disk_units:` is case sensitive already, the `unit = unit.lower()` should be done before the if statement. ```python In [24]: unit = 'Gb' â â In [25]: disk_units = dict(tb=3, gb=2, mb=1, kb=0) â â In [26]: if unit in disk_units: â ...: print 'Found' â ...: else: â ...: print 'Not Found' â ...: â Not Found ``` (done in `ipython`)
`def get_recommended_datastore(self, datastore_cluster_obj=None):` â `def get_recommended_datastore(self, datastore_cluster_obj):`
``timeout`` is passed, but never used ``module`` is passed, but never used Judging by the actual function, it's a bit confusing. The return data (dict) appears as if it was designed to be used as ``**kwargs`` for the ``fetch_url`` function, but you're accessing the dict directly. As such I would recommend either returning a tuple, and passing the data that way, or using the ``kwargs`` approach.
there is no need to version params for new modules
`default: null/None` is the default, it can be omitted
`required: false` is the default, can be omitted
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
as in modules, we do not wan't to print/exit, capture the missing library in a variable and report it missing in a fail_json call.
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
`PY2` and `PY3` are booleans importable from `ansible.module_utils.six`
this should be moved into the run method, as we only want this to error on running, not on loading, which will always happen if this is included in ansible. or in the hasivault class init, which gets called from run.
It should not only give an example. But some yaml files, you can refer the servicebus moduleâs doc
You can, just put it last. ``` (python2.7) shertel-OSX:ansible shertel$ git diff diff --git a/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py b/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py index 9eb27ef79e..2db590d6d1 100644 --- a/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py +++ b/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py @@ -142,7 +142,7 @@ class GlacierVaultManager(object): vault = self.get_vault(self.name) # Vault exists, no change to do - self.module.exit_json(vault=camel_dict_to_snake_dict(vault), tags=self.list_tags(), changed=changed) + self.module.exit_json(tags=self.list_tags(), changed=changed, **camel_dict_to_snake_dict(vault)) ```
This structure seems wrong to me. I'd rather have all the properties at the same top level. One way to do that without having to change your implementation too much would be to ``` module.exit_json(**vault, tags=self.list.tags(), changed=changed) ```
Missed this one in my first review: ```suggestion - Valid Azure location. Defaults to location of the resource group. ```
```suggestion - Valid Azure location. defaults to location of the resource group. ```
In order to improve readability (meaning the change described below isn't required): * `delete_cert`, `import_pkcs12_path`, `import_cert_path` and `import_cert_url` never return (either `exit_json` or ` fail_json` are called) * it's quite disturbing that `changed` isn't set (and it doesn't need to be set) when `delete_cert` is called then i would rather call `module.exit_json(changed=changed)` here (then keep `module.exit_json(changed=False)` unchanged at the end the file.
You're right, it always returned `True` before. There's a difference to before, though: before, `db_create` *always* returned `True`. Now, it only returns `True` if creating all DBs succeeded. So the `if changed:` can be removed in line 426, and the `if` block can always be executed. As long as `db_create` didn't result in an exception (in which case the module dies), all DBs should be there anyway.
```suggestion module.exit_json(changed=bool(non_existence_list), db=db_name, db_list=db) ```
Should not that be: ```suggestion msg="Using 'cert_content' argument requires 'cert_alias' argument.") ```
Should have been module.fail_json
please add the version added ~~~diff + version_added: "2.10" ~~~
As Will recommends, paginators will simplify this code very much. There's a hidden gem in paginators called `search` that will also let you pull out all of one key and merge those lists: ``` pg = self.connection.get_paginator('list_gateways') return list(pg.paginate().search('Gateways[*]')) # or, if the result will only be used in a for loop return pg.paginate().search('Gateways[*]') # will return an iterator that will build results on the fly ``` This would grab the paginated list of all gateways and merge them all, or if there were no gateways it would return an empty list. Example (cloudformation module, but all paginators have this) https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudformation.py#L294
boto3_conn, ec2_argument_spec, get_aws_connection_info are not needed with AnsibleAWSModule
Same here: paginator please http://boto3.readthedocs.io/en/latest/reference/services/storagegateway.html#StorageGateway.Paginator.ListVolumes
You'll need to handle pagination if there are a lot of APIs. Should probably handle rate limiting here too https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#api-throttling-rate-limiting-and-pagination
This isn't really how we usually go update operations in Ansible. Is there way of checking if a change needs to occur and then making or rather than making a request and seeing if it was changed. The benefit of the former approach is that when running in check mode you can see if a change needs to happen while in this scenario you wouldn't know.
No need for the try/except, `get_resource_group` already handles this.
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
Use kwargs instead of positional args
If `read_scale` was a bool you could do `ev = "Enabled" if kwargs[key] else "Disabled"
Mind putting this magic value into a constant with a descriptive name? I'd read much better if it was ```suggestion sys.exit(RC_CLI_INIT_FAILURE) ``` or something like that.
Alternate suggestion "name of the compute instance"
Please format this like this: ```python ANSIBLE_METADATA = { 'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community' } ```
This doesn't have to be quoted.
please update to 2.10
instead of: ``` for host in self.hosts: â¦ ``` I would have write: ``` for host in self.hosts: firewall_system = host.configManager.firewallSystem if firewall_system is None: continue results['rule_set_state'][host.name] = dict() for rule_option in self.rule_options: rule_name = rule_option.get('name', None) if rule_name is None: self.module.fail_json(msg="Please specify rule.name for rule set" " as it is required parameter.") if rule_name not in self.firewall_facts[host.name]: self.module.fail_json(msg="rule named '%s' wasn't found." % rule_name) rule_enabled = rule_option.get('enabled', None) if rule_enabled is None: self.module.fail_json(msg="Please specify rules.enabled for rule set" " %s as it is required parameter." % rule_name) current_rule_state = self.firewall_facts[host.name][rule_name]['enabled'] if current_rule_state != rule_enabled: try: if rule_enabled: firewall_system.EnableRuleset(id=rule_name) else: firewall_system.DisableRuleset(id=rule_name) fw_change_list.append(True) except vim.fault.NotFound as not_found: self.module.fail_json(msg="Failed to enable rule set %s as" " rule set id is unknown : %s" % (rule_name, to_native(not_found.msg))) except vim.fault.HostConfigFault as host_config_fault: self.module.fail_json(msg="Failed to enabled rule set %s as an internal" "error happened while reconfiguring" " rule set : %s" % (rule_name, to_native(host_config_fault.msg))) results['rule_set_state'][host.name][rule_name] = dict(current_state=rule_enabled, previous_state=current_rule_state, desired_state=rule_enabled, ) ``` @Akasurde what do you think ? It's more readable and it returns an helpful error if the rule name is set but not found.
```suggestion - "Name of VM group to use with rule." ```
Same classname as with the vm-vm rules, not sure if it might conflict/cause issues
I() for key and value
`type='str'` and `required=False` are both defaults, and neither is required in the argument spec (this applies anywhere either might occur)
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
Remove the two extra double-quotes here.
`delete` and `create` are not valid states
Not required with AnsibleAWSModule
I think the general idea (at least how I see it) is that there are doc fragments (quasi-)standardizing the attribute names, and assuming attribute users (i.e. modules) don't supply required arguments such as `description`, ansible-test does some validation by making sure that you only use attribute names that come from docs fragments you include. If the turbo fragment lives next to the turbo code, and everyone using the turbo code uses that docs fragment, the name (and description) of the attribute(s) in there is basically standardized.
The additional fragments in here need to get backported to make the compatibility shims in stable-2.9, stable-2.10 and stable-2.11 working properly.
```suggestion description: Action returns an C(ansible_facts) dictionary that will update existing host facts ```
IMO this really should be defined in action_common_attributes, to help ensuring that all collections use the same description there.
```suggestion description: Supports being used with the C(async) keyword ```
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
Don't add `required: false`. It is implicit.
Why did you introduce a space here? The original expression looks better to me. ```suggestion - For example in AWS and GCP, 169.254.0.0/16 is used for storing instance metadata. ```
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
Should also extend ec2
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
```suggestion description: when true, include all available nodes metadata (e.g. Image, Region, Size) as a JSON object named C(docker_machine_node_attributes). ```
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
This has to be done only once, since the binary is always the same (`docker-machine`).
On IRC, @bcoca mentioned that this should be doable with `construct`. It is currently not possible, though, but it is better if this can be solved in a plugin-independent way in the future, than now having plugins do it differently. @ximon18 do you mind removing this? Or is this a feature you absolutely need? With `construct`, you can do essentially the same, but not for arbitrary key-value pairs, but only for keys you know about in the inventory config. If that's ok, removing this probably speeds up getting this merged :)
Line is too long.
Line is too long.
This line is too long. Max line length allowed in Ansible is 120 characters.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
Too long line.
even better would be to show what specific operation we were attempting, but that does not seem clear w/o parsing the uri itself (for that, the caller should be processing the exception)
Same duplication of functionality as with `post_request` function.
Resource path should not be manipulated by hand, since we should only use paths that Redfish API returns (with one exception that has been actually removed from the latest version of the Redfish standard).
As before, this will not catch non-200 statues of response.
This will fail if there are no systems present (`data["Members"]` is empty list).
One way to do this is something like: ```yaml unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
If parameters are not required, you do not have to add `required: false`. This is the implied value, so it is easier to see what is required if only the required parameters have this option.
Please add `type="str"`, and maybe list the possibilities as `choices=`.
Please add `type="str"`
type should be a 'int'
It used to confuse me too, but I think I now got used to it after a (long) time ;)
This should be required (also need to update docs).
You should mention instead of this that the required API version is 1.24. ```suggestion - "Docker API >= 1.24" ```
Also, let's continue the discussion in #51939.
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
No, the default is None. So you can tell if the parameter was set or not.
Please test if `default=False` is the default value when using type `bool`.
`default=None` is the default, it's not required.
Change the default to `yes` to preserve existing behavior.
The `default` here previously was `True` now `None`. The docs state that this is boolean, and the default is `True`. I assume setting it to `None` changes the behavior in a non-backwards compatible way.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
there is no need to version params for new modules
there is no need to version params for new modules
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
Include a trailing comma at the end of this line.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
this got named use_backend
How can we hardcode this here? This means that ansible.netcommon namespace is now locked into our codebase.
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
We should be able to merge the two cases with something like this? ``` if collections is None and collection_from_task: collections = [collection_from_task] ``` Now `collections` is either the non-None contents of `collections`, or the task's collection, or `None` if neither exist, which means we can drop the `collections` check from the `all()`s and just use `collections` regardless
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
If self.desired_state is 'present' and all the ntp servers are already present (so host_ntp_servers == []), state take the value "absent"â¦ so self.results[host.name]["current_state"] = "absent"â¦ which is not what's expected.
instead of: ``` for host in self.hosts: â¦ ``` I would have write: ``` for host in self.hosts: firewall_system = host.configManager.firewallSystem if firewall_system is None: continue results['rule_set_state'][host.name] = dict() for rule_option in self.rule_options: rule_name = rule_option.get('name', None) if rule_name is None: self.module.fail_json(msg="Please specify rule.name for rule set" " as it is required parameter.") if rule_name not in self.firewall_facts[host.name]: self.module.fail_json(msg="rule named '%s' wasn't found." % rule_name) rule_enabled = rule_option.get('enabled', None) if rule_enabled is None: self.module.fail_json(msg="Please specify rules.enabled for rule set" " %s as it is required parameter." % rule_name) current_rule_state = self.firewall_facts[host.name][rule_name]['enabled'] if current_rule_state != rule_enabled: try: if rule_enabled: firewall_system.EnableRuleset(id=rule_name) else: firewall_system.DisableRuleset(id=rule_name) fw_change_list.append(True) except vim.fault.NotFound as not_found: self.module.fail_json(msg="Failed to enable rule set %s as" " rule set id is unknown : %s" % (rule_name, to_native(not_found.msg))) except vim.fault.HostConfigFault as host_config_fault: self.module.fail_json(msg="Failed to enabled rule set %s as an internal" "error happened while reconfiguring" " rule set : %s" % (rule_name, to_native(host_config_fault.msg))) results['rule_set_state'][host.name][rule_name] = dict(current_state=rule_enabled, previous_state=current_rule_state, desired_state=rule_enabled, ) ``` @Akasurde what do you think ? It's more readable and it returns an helpful error if the rule name is set but not found.
`continue` isn't necessary
you should set the default state to "list" at argument_spec, not here.
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
also extends `azure_tags`
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
I think we need to expand a bit on the description here. From the outset it seems like this is a dict but the examples show it is a list of dicts. Can you expand on what `linux_profile` is, whether it is a list of options or just a dict of options. The other point is that this is not `required: true` as it isn't needed when state == absent. The same applies for `agent_pool_profiles` and `service_principal`.
Should add a point here saying not allowed with `I(identity)`. Should also say the value is the `C(distinguishedName) of the path to search from.`
Shouldn't be needed
Should add a point here saying not allowed with `I(identity)`
This should use the proper LDAP attribute name for DN ```suggestion - This value is either the C(distinguishedName) or C(objectGUID) or the AD object to lookup. ```
I would also add to `identity`, `filter`, and `ldap_filter` some form of text saying one of the 3 must be set
Please also replace the `raw_cloud_env` this in the following context
Will the azure API always return a non-zero list or could this result in an `IndexError`? (If so, please wrap in `try`/`except`)
not removed, and getvm is not static
Does the result provide any insight into if anything's changed? Looks like put and delete are currently both hard coded to return ``changed=True``
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
shouldn't this be like the following? ~~~python if rule == _rule['rule'] or rule == _rule['id']: ~~~
This thing is also repeated.
Please rewrite dict creation using literals (with curly braces)
Well, this is also very boilerplate, which you could deduplicate.
This snippet looks just like one in `role_find`. It probably deserves being moved into a reusable function.
```suggestion except (OSError, IOError): ``` Since you are not using `e`.
Use same `env_fallback` as `X_AUTH_TOKEN`
We generally don't mask the usernames, just passwords.
I don't see the point ;-)
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
This change is not valid. It is only updating a single word within the license, and not updating the full license header. Additionally, in order to do this, you will need to get approval from the following additional authors to relicense the code: Qalthos ganeshrn
This should be GPL Can you also please update `enos.py`
I think there will be a problem with the license. IIRC modules in Ansible ought to be GPLv3+ in order to ship with Ansible. The other problem is that you add copyright to other people from the ACI team, and that code is GPLv3, so whatever copyright is held from there, cannot be turned into BSD.
Forget about my statement, the module_utils is BSD ! I was confusing the modules with module_utils. Nevermind.
Please update as below in sync with other community supported platforms. (c) 2017 Red Hat Inc. # (c) 2017 Lenovo, Inc.
I'd like to see us not pass the results of `load_options_vars` into `VariableManager`. Instead we should just use `load_options_vars` directly in `VariableManager`, and handle whatever complications there may be with using `CLI.version_info` from `VariableManger`.
use `unfrackpath(filename)` to ensure we get something the user can always use
if you are using loader, just use `get_file_contents`
I'm pretty sure this can use `is_sequence()`.
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
While we're at it: please add a trailing comma, that makes it easier to add another option (if we ever need to) :)
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
I don't think this nets the functionality of `check_mode`, the idea is to return `changed: True` if a change would have otherwise taken place if the task was run not in check mode.
create/remove are not really states, use 'present' and 'absent'
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
set type to 'path'
use a list type .. since that is what you want
Could as well drop this now: ```suggestion if not context and arg == 'state': ``` because the intersection with an empty set is always an empty set which will result in no iterations of that for-loop
After the refactoring, it's probably okay to inline it back since it's used in one place now: ```suggestion bad_states = {'list', 'info'} & set(data.get('choices', set())) ```
Ah. I thought you're talking about `dict.get()` being not enough for the validator.
I wonder if there are more correct than wrong uses of `get` :) I mainly know its use in `route53`, where it shouldn't be a state.
(if that doesn't work, change `&` with calling `set.intersection()`)
Thanks for the PR! The top level spec actually needs to removed from example as we have deprecated them.
it absolutely is but "New in version 2.3." so I didn't make use of it yet.
this is actually incorrect, ansibile_ssh_host will reflect 'localhost' not the var associated with 'inventory_hostname' .. which is why this should use `connection: local`
local_action has same issue as it is an alias to `delegate_to: localhost`
Well this would be for 2.4 so maybe that is the better path
Again, the else here is unneeded and unwanted.
Again, the else here is unneeded and unwanted.
Should you not be able to enable_vlans support, and update the network ? So I was expecting an `if` instead of an `elif`.
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
You'll need to define `info` for both code paths.
Ditto about the deprecation notice
Ditto about the deprecation notice
`required: false` is not needed.
Ditto about the deprecation notice
```suggestion - To remove only resources that were automatically created while provisioning the VM being removed, set to C(all_autocreated). ```
```suggestion - Canary settings for the deployment of the stage. ```
```suggestion - Type of endpoint configuration, use C(EDGE) for an edge optimized API endpoint, - C(REGIONAL) for just a regional deploy or C(PRIVATE) for a private API. - This flag will only be used when creating a new API Gateway setup, not for updates. ```
Unless it is an actual value omit the `default`, I see the description already contains what it defaults to in this case.
You also need to add the choices in the `argument_spec`.
`across` has broken into two separate lines.
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
Empty proxy-init doesn't make sense and should be removed.
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
specifying `type='int'` removes the need for this, so you only need to check the range.
This will not be idempotent, is that intended? We should try to support `present`, or if this is not possible warn users that there is no idempotency.
Ok then we should have a message in the docs then to warn users that this module/option will not be idempotent, so that it doesn't catch them unawares.
I don't like the `new` state too. This will be confusing for the users since it's a rather non-standard behaviour. And worst, this breaks the idem-potency of the module. May I suggest something like: ```yaml - name: Set the disk of the VM vmware_guest_controller: name: test_VM controllers: - state: present type: sata - state: present type: sata - state: present type: nvme - state: present type: usb3 ```
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
```suggestion result['command'].append(to_native(command)) ```
```suggestion result['stderr'] += to_native(stderr_data) ```
please wrap in block ``` if __name__ == '__main__': main() ```
please use explicit imports `from ansible.module_utils import AnsibleModule`
Same here, move it down the stack.
Here as well: ```python console=( otypes.Console(enabled=self.param('serial_console')) ) self.param('serial_console') is not None else None, ```
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
This is just integer in MB so: ```python memory=numa_node.get('memory'), ```
this should be just: ``` numa_node_pins=[ otypes.NumaNodePin( index=numa_node.get('numa_node_pin') ) ] ``` In API it's designed as list, so shouldn't it be `numa_node_pins`? And something like: ```python numa_node_pins=[ otypes.NumaNodePin( index=pin ) for pin in numa_node.get('numa_node_pin') ] if numa_node.get('numa_node_pin') is not None else None, ```
please use here self.param('version').get('base_template')
Don't specify this. It's implicit.
The standard parameter for this is **use_ssl*, please change this.
I would expect a proper default here, probably `default: 'yes'`
I'd rather have the standard behavior from other modules, which is to specify **use_ssl**. Check **uri** module.
So we have a default way of doing proxies. Normally it picks up the system settings, unless **use_proxy** is set to 'no'. The format of this parameter is best kept in line with other modules for simplicity.
tempted to have no default and make it 'yes|no' boolean, use 'default' behaviour when `None`
Please remove this line, for various reasons. - We use examples to showcase possible values - It shows the old key=value syntax If you remove this, you also do not need to quote the whole paragraph.
Must be in Sentence case, and IP needs bee upper case. Also it should mention that the default is to be both ipv4 and ipv6.
```suggestion - 'If a I(checksum_algorithm) is passed to this parameter, the digest of the ```
Default was $null, which means unset. No need to add this. ```suggestion ```
you can use `state` to avoid the 'or' to the user
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
Lowercase this one too, please.
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
I'd argue that most content developers also don't need to be running devel, maybe something like this? ```suggestion 'you are actively modifying the Ansible engine, or trying out features under development. This is a rapidly changing source of code and can ' ```
```suggestion # try to get collection world name first ```
this whole section is not needed, just use `self._plugin_options[<option name>]`
its new in 2.4 so it doesn't apply to older versions
Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
Can we rephrase it as "Host should support C(atomic) command"
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
Required is by-default set to False, no need to specify.
Would prefer the `per_host` default to be `no`
It requires `botocore>=1.13.21`
is the `any` required here - `if metrics_to_disable:` should suffice, I'd think
Please use [standard exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2)
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
Also, this will mean you need to `import traceback`
I would omit the 3, it seems like in the internal API you can set as many recovery actions as you want. It's just the GUI that limts to 3.
I would simplify this by saying the list order is the order of actions to take, i.e. first entry is the first action and so on.
In the code, you enforce setting all 3
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
If you enclose this in `EXAMPLES = r'''` you don't need to escape the `\`. Standard practice for all module doc blocks is to use `r''' '''`
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
specifying `type='int'` removes the need for this, so you only need to check the range.
Since this is the current option being described, I think I would leave the `I(..)` out here. ```suggestion - The kind of storage. ```
If you pipe this through to the URL, then this should really be "resource". In Kube "kind" is the schema, "resource" is the thing you access via a client. Kind is always a constant (uppercase), resource is always the lowercase RESTful name. I would recommend `resource: service` (if you're doing discovery) or `resource: services` (if you're hardcoding). Mapping `kind` to `resource` is something we explicitly do on the client by looking up a Kind in the discovery doc, so overlapping them can be dangerous.
Same thing here - otherwise we would end up with I(....) everywhere. ```suggestion - If no blob_cors elements are included in the argument list, nothing about CORS will be changed. ```
Really like this raw access to the kubernetes yaml, personal preference I don't want a layer of declarative config on top of a layer of declarative config so it's great to see this available.
```suggestion - Allows https traffic only to storage service when set to C(true). ```
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
It would be nice to see the same msg in exit_json.
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
Move this to line 175
Should be specific about what's being forced in the arg name, something like: `force_removal_with_mapped_luns`. These tend to grow over time, and generic names like `force` are problematic for someone just reading the playbook to know what it does without consulting the docs.
use `choices`, ditch inline "possible values" text
Yes, you can- so long as a default is not specified, an unset value will still be `None`
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
this could probably be simplified with using a dict of dicts: ``` power_policies = { 'high-performance': { 'key': 1, 'short_name': 'static' }, 'balanced': { 'key': 2, 'short_name': 'dynamic' }, 'low-power': { 'key': 3, 'short_name': 'low' }, 'custom': { 'key': 4, 'short_name': 'custom' } } ``` Then it is just a matter of using `power_policies[policy]['key']` and `power_policies[policy]['short_name']` Not really worth a lot of worry over, just a suggestion
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
Perfect, we should keep msg as well with message.
It would be good to call out a reboot is required to make it active
Something similar - https://github.com/ansible/ansible/blob/fb72a5424cab097d28670d00cf107fd515cee3f0/lib/ansible/modules/cloud/vmware/vmware_host_lockdown.py#L114
`Specify authentication algorithm.` No need to repeat what's in `choices:`
`VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_.)`
Please remove this line, it's a duplicate of `choices:`
`The value C( _public_) is...`
`The value C( _public_) is...`
Using AnsibleAWSModule also means you can remove importing HAS_BOTO3 and the HAS_BOTO3 check, as the module checks it.
boto3_conn() now handles NoRegionError and ClientError so you can remove that here.
This needs to be `class CloudFrontOriginAccessIdentityServiceManager(object):` to use new-style 2.7 classes.
To share code between modules, please use module_utils instead of importing other modules directly.
BotoCoreError should be caught here as well and all other places catching ClientError https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-1 BotoCoreError does not have a .response, so using AnsibleAWSModule will cut down on exception handling logic as I suggested above.
`version_added` is not needed, because the module itself will be added in `2.10`.
what is TLV? it might be good to describe it at least once.
iirc other platform use `enable` option to enable/disable lldp
Applicable for other iosxr resource modules as well
`speed` should be `int`
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
Line 355 to 368 are unused.
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
```suggestion def _post_request(self): ```
If the result was a 4xx or 5xx then I think this fails.
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
Would be great to give a brief spiel about the 2, I know `windows` doesn't support explicit credentials so maybe say `password` is not required for that. I would also put this in a new list entry and start with a capital and end with a full stop.
Each option entry should be a full sentence, i.e. it starts with a capital and ends with a full stop.
Change to source and remove the alias
This supports more than just URLs, I would add more points talking about what it actually supports.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
we should also return if we both delegate executions and delegate_facts
This should probably be in the same if statement as `if self.state == 'present'`, this way you know the disk exists and so the initial present check is not required and you never really want to run this additional operation if `state: absent`.
Here only detect adding change
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
ditto multiple ip configurations
Can you differentiate between the named route not being present in the rout table and other exceptions to avoid log spew in the normal situation in which the route does not exists for that route table.
`read-onYly` should probably be `read-only`
Ansible 2.7 dropped support for Py2.6
Presumably you want `It *will* always use`, or something to the effect
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
+1 to `psexec_command` just for clarity...
Never waste a good opportunity for improving this too :-)
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
This argument falls under the same guideline requirements as explained for `protocol_mappers`, this needs to be a more explicit argument, and not an arbitrary field.
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
No need to compile explicitly, `re` will hold compiled cache internally anyway.
you should probably put these check even before `super()` line
You use `re.match` which already checks the beginning of a string. So caret `^` is not needed. https://docs.python.org/3/library/re.html#search-vs-match
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
```suggestion sample: true ```
```suggestion returned: success and I(ev_eligible) is C(true) and I(domain_status) is C(APPROVED), C(RE_VERIFICATION) or C(EXPIRING). ```
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
Please add dot at the end.
The `RepoIDs` is not the module option and therefore it should not be decorated in `C()`.
This is indented only by one character. Please indent it by two chars like elsewhere.
The list of option could be ordered alphabetically.
Please change the indentation to 2 characters to have the same formatting like above.
```suggestion short_description: Login to the CloudGenix API endpoint ```
This is not a correct English sentence. Maybe do: `The DNS can only be...`
For the author information we normally only keep name and GitHub handle.
```suggestion - Login to the CloudGenix API endpoint, to obtain an AUTH_TOKEN for use in later calls. ```
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
I'm going to add a commit to do `if os.path.exists(module.params.get('cert')):` instead of try/except.
This module doesn't support check mode. I'm not sure if this is the best method to do this either though.
PyVmomi helper class already calls `connect_to_api`
Set self.is_group by default to False
Elaborate more on case - what happens if state is set to absent. Also, other conditions like if permission does not exists.
required=False is default so no need to add.
`required: False` is default so need to add. Same for other.
check is redundant as you already flagged as 'required'
set this as the default, then you dont need to do checks yourself
again, this is not required, since the key IS REQUIRED you never get to this point
i recommend using the ansible json encoder as it deals with 'special' types and will avoid a lot of serialization errors you'll get with the stock json.
Used by the base class to be able to handle all ansible data https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/callback/__init__.py#L123
For this failure, can you include the exception? Something like `module.fail_json(msg="Couldn't connect to AWS: %s" % e.message, exception=traceback.format_exc())`
The parens around `connection,changed` aren't needed here
These parens aren't necessary, please remove them.
Same here - when this call fails it should surface a nice error message to the user.
Please use a try/except or the AWSRetry decorator here, since this call should provide a nice message to the user about where it failed and what actions they can take.
Yes, this should use `AnsibleUndefined` in order to get the recursive Undefined behavior introduced in that class.
Should we use `AnsibleUndefined` here instead? I know there is likely circular imports due to `AnsibleUndefined` existing in `lib/ansible/template/__init__.py`, but I've wanted to move it to `lib/ansible/template/undefined.py` to allow it to be imported more freely.
You may want to drop the `2` from the function name to match the YAML tag
Remove unsafe from the function signature since it's handled by the decorator.
There shouldn't be any difference between octal, hex, and decimal for this case....
```suggestion - Note, when the interface changes namespace it loses ```
```suggestion into namespace I(netns). ```
```suggestion - Removing aliases from an interface is not currently supported. ```
```suggestion - To identify an existing interface within a namespace, use the I(namespace) option. ```
```suggestion the I(group_id) parameter. ```
Or did you mean ```suggestion raise exc from None ```
I'm fine with the change in message, just noting that this test needs to be fixed up to check the new assertion https://github.com/ansible/ansible/blob/cf39d9de258cb9c47de9043e1a85e327e177dba7/test/integration/targets/ansible-galaxy-collection/tasks/install.yml#L43.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Is this even needed, we will be dropping py2 and `to_text` does not call `__unicode__`. You may as well just put this in `__str__`.
```suggestion url = "/".join([base_url, index_set_id]) ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion type: str choices: [ absent, present ] ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion version_added: '2.8' ``` This is a required fix as it states the first version this module ships with.
```suggestion mode: '0644' ```
```suggestion - name: Change login times for user ```
I know. There's an alias for 'server'. Calling it `host` keeps it consistent with the modules and Python client. As a user, you can use `server` or `host`. The Python client calls it `host`, and uses `HOST` in the env variable.
Bump this to `"2.5"` please.
I think we need more info here what are possible choices.
Do we still need kind? For service I think it should always be v1
Space missing before `(megabytes)`.
Also, you should reorder this to first have `description`, then `type`, then `default`, then `choices`, then `version_added`. I've changed all options in all docker_* modules accordingly (in #52422), which unfortunately requires you to rebase (together with some other PRs which got merged today).
Adding this here, and to the other examples should fix CI ```suggestion default: 0 version_added: "2.8" ```
```suggestion - Number of containers instantiated in the service. Valid only if I(mode) is C(replicated). ```
The numbers should be in C(...), I think.
There's no need to wrap this in a `try`/`except`.
If we allow non-Mutable mappings here, then we need to put a try: except around the call to reduce in the if recurse: later as giving it two non-mutable mappings will throw an error. I dislike that non-mutable mappings would be accepted with recurse=False but cause an error with recurse=True so perhaps we should track down why we're getting non-mutable mappings or perhaps we should enhance merge_hash to be able to operate on non-mutable mappings.
If this is needed, just replace MutableMapping with Mapping. (MutableMapping is a subclass of Mapping that adds additional features). OTOH, I wonder why we're dealing with something that's just a Mapping instead of a Mutable Mapping in the first place....
I would switch the statements, test for dict, test for list, else raise error.
These 2 lines can probably just be collapsed into an `elif`
I think we should add an `allow_overwrite` or similar param.
I would insert one new line in front of this.
Remove this. But do add: ```yaml choices: [ absent, present ] ```
Why would you default to an empty string here ? Is an empty string actually useful ? The default is None, which is a good default so you know it was set or not. Simply remove this for the "default" default.
This is implicit for parameters. Unless it is required, you don't have to add anything.
Strange default. I would simply remove it.
I have had a look at the description and the [failed tests in shippable](https://app.shippable.com/github/ansible/ansible/runs/120738/5/console), my understanding for checking that is that this is because the `ensure_libs` function was changed but the tests were not updated. What I am suggesting above is not to change the `ensure_libs` function but to simply use it. This will mean that we won't have two functions `ensure_libs` and `ensure_required_libs` that contain the same logic.
So the suggestion I added above (copied below) works around this, if we add the following change we don't need to add the `ensure_required_libs` function or make any changes to `ensure_libs`. ```suggestion try: ensure_libs(sslrootcert=module.params.get('ca_cert')) except LibraryError as e: module.fail_json(msg=str(e)) ```
Would it be better to reuse the existing `ensure_libs` function here? ```suggestion try: ensure_libs(sslrootcert=module.params.get('ca_cert')) except LibraryError as e: module.fail_json(msg=str(e)) ```
ð, this is a nice little refactor.
there is a helper in `AnsibleModule` for mutually exclusive params: ~~~diff module = AnsibleModule( argument_spec=argument_spec, + mutually_exclusive=(('positional_args', 'named_args'),), supports_check_mode=True, ) ~~~
Somehow this (+ the following line) doesn't work and prevent the module from working.I haven't digged deeper yet,
Can we remplace this line by the following three lines: ``` p = subprocess.Popen(['acme-tiny', '--account-key', self.accountkey, '--csr', self.csr_path, '--acme-dir', self.challenge_path], stdout=subprocess.PIPE) crt = p.communicate()[0] open(self.dest, 'w').write(str(crt)) ```
Read operation: ditto
backupdest isn't defined anywhere
Read operation: ditto
This isn't really how we usually go update operations in Ansible. Is there way of checking if a change needs to occur and then making or rather than making a request and seeing if it was changed. The benefit of the former approach is that when running in check mode you can see if a change needs to happen while in this scenario you wouldn't know.
No need for the try/except, `get_resource_group` already handles this.
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
Use kwargs instead of positional args
If `read_scale` was a bool you could do `ev = "Enabled" if kwargs[key] else "Disabled"
+1 for this.
Add a sample dict returned by module.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
This is probably also broken for the same reason as the one above.
2.6 or 2.7? Also you `requirements` listed here and the modules.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
parent name also needs to be 'safe'
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
It would be awesome if buildah supported copying from a container.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
and convert filename to bytes again.
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
I prefer this: ```python host=dict(type='str', default='api.meraki.com'), ```
I'd go for: ```python output_level=dict(type='str', default='normal', choices=['normal', 'debug']), ```
Doesn't need to be quoted. We tend to only quote strings when it is required.
Lowercase yes :-)
No worries- we assumed it was an oversight. ;)
Apparently, Python 2 does not have a `TimeoutError`
```suggestion assert isinstance(wrap_var(b'foo'), type(b'')) ```
It's unclear from the name what this is (or even that it's supposed to be a URL). Please rename.
shouldn't this line and the one below just not be here, and the loop be `for arg, version in self.DEFAULT_DEPRECATED_ARGS` (though those aren't really a default either, so `DEFAULT` is a bit of a misnomer)
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion url = "/".join([base_url, index_set_id]) ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
It looks like there may be an issue with the tests. I've restarted the failed test.
Why a 1 second sleep here, I had this removed in my testing and was fine without it. 1 second is a long time for each command, especially since tasks can execute more than 1.
With the removal of `$?` this shouldn't be needed.
Use `to_text(line)` instead.
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
Because this parameter was added for backward compatibility with **vmware_dns_config**. We could add it as an alias and keep it forever, but I am not in favor of keeping lots of aliases for the same purpose.
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
If we are creating a new module then why to add old parameters which we don't want in first place.
add an alias to `domain` as `domainname`
It would be good to call out a reboot is required to make it active
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
```suggestion destination_vcenter_password=dict(type='str', required=True, no_log=True), ```
``` if not vm: module.fail_jsonâ¦ try: â¦ ``` But that's for cosmetic.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
Remove the 'a'.
you should note that the default changes in 2.4 and why
Rather than change the default, the module needs to account for the different binary name of different Elasticsearch versions. I have a [version of this module that does that](https://github.com/samdoran/ansible-role-elasticsearch/blob/master/library/elasticsearch_plugin.py). I'll clean it up and submit a PR.
```suggestion type: str required: true ```
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
If one of both is required, it is better to force this as part of the argspec.
I mean not to actually shrink it but doing a "no-op" but showing a warning to the user, that volumes can not be shrinked.
~~~diff - if self.hcloud_volume.size <= size: + if self.hcloud_volume.size < size: if not self.module.check_mode: self.hcloud_volume.resize(size).wait_until_finished() self._mark_as_changed() + elsif self.hcloud_volume.size > size: + self.module.warn("Shrinking of volumes is not supported") ~~~
Unessecary blank line
The API currently allows multiple groups with the same name. Do we need some logic similar to the logic in `cloudscale_server` to detect this? Otherwise this could lead to surprising results... And tests for this case would be nice too.
`shlex.join` was added in Python 3.8, so an alternative is needed here.
Python 2.6's `re.sub` doesn't accept `flags` -- but `re.compile` does.
print statement can be removed
It probably makes sense to clean-up flags before exiting this method.
Please only import what you need, rather than `*`
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
I know this is what it done in `load_platform_subclass()` but that looks incorrect as well.
I'll have to look into this more. I'll find out more tomorrow when the author gets back from PTO.
I don't believe this is correct. `args` and `kwargs` need to be passed to class when it is instantiated. This should probably be `*args, **kwargs`, though.
This should reflect `2.8` as we're currently in the [Ansible 2.8 development cycle](https://docs.ansible.com/ansible/devel/roadmap/).
This is now `'2.10'`
since the plugin is called `aws_ssm`, I'd change this to `ansible_aws_ssm_retries`
nope, looks like you missed this one.
Add the `r'''` to https://github.com/ansible/ansible/pull/49652/files/6dc61c94e3abd3cf74998b78f4fa08956a95c269#diff-1c417562a0944ee1362da84b93d9695dR56 to avoid it. We do this for all our module examples so we don't have to worry about escaping these values.
Right now read_timeout will always be set as there's a default value. You either need to remove this or remove the default value on the read_timeout doc entry.
Similarly, this option is highly `network_cli`-specific, so much that I'm pretty sure `netconf` doesn't even need it. This should go back to `network_cli`
should probably be `message_encryption` just to be clear
"message encryption settings"
Maybe `ignore_env_proxy`? Granted, it's Friday and it's been a long week, but `no_proxy: no` (but ignored if proxy is set) made me a little https://media2.giphy.com/media/l2JegIy7RlfhNVsli/200.webp
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
In the "Generate privatekey6 - standard - with non-ASCII passphrase" test, this fails with `'ascii' codec can't decode byte 0xc3 in position 16: ordinal not in range(128)`. Stacktrace: ``` File "/tmp/ansible_openssh_keypair_payload_kCnMbD/__main__.py", line 193, in generate tf.write("#!/bin/sh\necho %s" % quote(self.passphrase)) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 706, in write return self.writer.write(data) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 369, in write data, consumed = self.encode(object, self.errors) ``` It seems to fail in all Python 2 tests; in Python 3 it seems to work.
You should use `module.add_cleanup_file()` (somewhere above) instead of manually trying to clean up.
This can be set, but not in the netflow/ipfix, config. It can be set on the dvSwitch itself using its configSpec: https://code.vmware.com/apis/358#/doc/vim.DistributedVirtualSwitch.ConfigSpec.html#switchIpAddress
```suggestion - The name of the distributed vSwitch to manage. ```
```suggestion if host_network_info.atBootIpV6Enabled: if host_network_info.ipV6Enabled: ... elif host_network_info.ipV6Enabled is False: ... else ```
What you just said is the same as saying it is okay to add technical debt to the project. There's no excuse for repeating those large code blocks. It impacts future sustainability.
Curious that the inputs are dictionaries, but the outputs are not.
This could use more explanation.
Required: false is implicit and not required
This shouldn't be `required: True` since realm may be provided instead.
This seems to be a leftover, there is no state "updated" anywhere else in the code.
When required is false, it can be left out (since it is the default).
we have existing byte/bit functions in module_utils
no need for is_x, online: yes|no is already clear
Docs uses `512emulation`: add an alias if you like to keep the code as is ~~~python enable512e=dict(type='bool', aliases=['512emulation']), ~~~
please remove logging due security concerns
Call out default? If you set a default here, don't forget to update the spec above.
Small typo here probably: `Retreived -> Retrieved`
I think that wildcard imports are generally discouraged, because it makes it difficult to refactor and determine the origin of a function or class. For example, at first the `boto3_conn` function used in the constructor seemed undefined.
I like that you've put some reusable functions in module_utils. I'm still reviewing this, but one thing I've noticed is that this module always shows changed=True and e_tag is always modified. When I run ``` - name: try one cloudfront_distribution: state: present enabled: false e_tag: "E3OUIFFZ9OWBTR" ``` Running that once does modify the expected distribution. But running a second time, a new distribution is created and e_tag disregarded (since with the first run e_tag is modified regardless of whether or not changes should be made). That seems unexpected.
This module is not idempotent if you can't run it twice with the same arguments. If you have to know the distribution ID to update it, but not create it, then this is not going to work as it should. Really it should be searching for a distribution that matches the unique distribution properties (presumably the origins of the distribution)
You don't need to specify required=False or default=None or type='str' for any of these as it is the default.
If you check for the folder path here [compile_folder_path_for_obj] (before breaking) you could return the result and ignore all the other strategies.
@Akasurde Is it possible to have `len(temp_vm_object.propSet) != 1` ? Has I understand it temp_vm_object.propSet will only contain the name of the temp_vm_object.
`continue` not `break` (with `break` we can miss some VM). Or `fail_json(â¦`, because a VM object without name shouldn't exist.
Everything from `for vm in vms:` to line 957 can be moved outside of the loop. Also, instead of computing user_desired_path (which is a bit complex and error-prone IMHO) what do you think of: ``` if not actual_vm_folder_path.startswith("%s%s" % (dcpath, user_defined_dc): continue if user_folder in actual_vm_folder_path: vm_obj = vm break ```
> For example, user_folder is '/DC0/vm' and actual_vm_folder_path for two VMs with same name is '/DC0/vm/finance' and '/DC0/vm/marketing' and user wants VM with '/DC0/vm/finance' path. So there are chances that user might end up in getting wrong VM if we just use user_folder. I think computation of user_desired_path might decrease this chance. How can you only get the VM in '/DC0/vm/finance' if `user_folder` is '/DC0/vm' ? If `user_folder` is `/DC0/vm` we fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So you get both VM from '/DC0/vm/finance' and '/DC0/vm/marketing'. ################ If you mean to write `/DC0/vm/finance`: If `user_folder` is `/DC0/vm/finance`, we still fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So using `user_desired_path` or `user_folder` is exactly the sameâ¦ I don't get your example.
Since it's Py2, and controller, we should just ignore py2.
use to_text on the return, then all cases will be covered
Since toml doesn't support any configuration for unicode, I wouldn't worry with it either way.
This looks like it would throw an exception on Python3 (because yaml.dump will return a text string and you can't decode a text string on Python3). Since what we want to do is make sure that it is a text string on both Python2 and Python3, what we should do is use to_text here to transform it into a text string: ``` python from ansible.module_utils._text import to_text [....] dumped += yaml.dump(to_text(abridged_result, allow_unicode=True, width=1000, Dumper=AnsibleDumper, default_flow_style=False)) ```
I missed where you're doing the .decode.... the new version of the line should look like this: ``` python dumped += to_text(yaml.dump(abridged_result, allow_unicode=True, width=1000, Dumper=AnsibleDumper, default_flow_style=False)) ```
```suggestion version_added: "2.8" ```
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
While I think this is correct I'm not sure if it uses no proxy or the default proxy configured in the IE settings. I don't have easy access to an environment with a proxy configured so I can't test this assumption.
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
`required: false` is the default, can be omitted
```suggestion description: Returns a dictionary for every extension OID ```
I don't like the `: ` here
```suggestion - "Specify certificate options when signing a key. The options that are valid for user certificates are: ```
This will probably not be formatted as you intend it. How about: ``` - "Specify a certificate options when signing a key. The option that are valid for user certificates are:" - "C(clear): Clear all enabled permissions. This is useful for clearing the default set of permissions so permissions may be added individually." - "C(force-command=command): Forces the execution of command instead of any shell or command specified by the user when the certificate is used for authentication." - "C(no-agent-forwarding): Disable ssh-agent forwarding (permitted by default)." ... ```
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
This is also not needed, idem for all other parameters.
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
I blame my `black` setting.
No need to import boto3
Should be able to remove this import and just use `fail_json_aws`
Once you use `module.client`, `boto3_conn` and `get_aws_connection_info` are no longer required
Remove this line
AnsibleAWSModule incorporates ec2_argument_spec so you could remove this import and specify the arg spec as a dict.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
Wondering what the advantage is to do it this way, or just have: ```python if ...: return True return False ```
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
Again, the name for that task was a copy-and-paste from the integration tests. It would probably better to use, eg. ```yaml - name: Enable 'telnet-client' windows feature ```
Ah, I think it's a copy-and-paste error from the integration tests. Good catch :-)
If a parameter is not required, we don't have to state that explicitly. It is implicit. Only when parameters are required, you need to add `required: yes`.
This can be removed. If a parameter is required, there is no default.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
I'm not familiar with CE, though is this correct? ``` if mode == "mode-l3": ... mode = "mode-l2" cfg_xml = CE_NC_MERGE_NVE_MODE % (nve_name, mode) ... self.updates_cmd.append("undo mode l3") ```
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
The value in `msg` should be wrapped in `to_native()` to ensure it is the correct string type based on the Python version. `from ansible.module_utils._text import to_native`
It would be helpful to display valid values here.
no need to specify required=False or type=str as these are defaults
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
I don't see this change in latest commit.
Add a blank after this to notify that these are two separate tasks.
It is not mandatory to have return but I would recommend to add one, from UI/UX point. :)
Add github handle as well
```suggestion host = find_obj(self.content, [vim.HostSystem], name=esxi_host_name) if host is None: self.module.fail_json(msg="Unable to find host system %s in the given configuration." % esxi_host_name) ```
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
excellent handling of congestion control
```python if dcb_mode != current_dcb_mode or weight != current_weight: self._commands.append( 'interface {0} {1} traffic-class {2} dcb ets {3} {4}'.format(if_type, if_id, tc, dcb_mode, weight)) ```
This may apply to some of the other PRs in flight, as well as some of your existing modules.
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
Typo. "Allows you to setup rules to quickly and easily block sets of ip addresses."
Typo. Should be "Automates ipset".
create/remove are not really states, use 'present' and 'absent'
This claims support of `check_mode` but then never checks for it in order to call `module.exit_json` without actually making changes.
There's no strict standard about that. Everyone is allowed to have their own mess :) You asked about example of how it might be done. I can't remember any module around here of the top of my head and it's kinda hard to analyze 2k modules just to answer you. But I recall someone in our internal slack mentioned that they were doing similar things, so it must be something in this repo if you're up to spending time to search for it. Anyway, it's just an example of how my ideal module should look like based on principles I want to apply. It doesn't mean that it's the only true way of doing things. But I still think that it's a good architectural example of how one can organize module's control flow and dispatching actions.
Okay, if it's used by lots of modules it should go to the other PR.
I think this var needs a more specific name. Like `generic_vmw_errors`, if I understand correctly. Because now it's not clear for me what exactly you're generalizing.
It looks like you put trailing period here, while you use different style for other lines. Could you please keep consistent style? :)
You should state `Raises: TaskError` separately, because it's not a return value
I'd also explicitly state that it returns a tuple. With current wording it seems like it returns just `True` in a certain case.
too many apis
Please split into under 160 character length lines
All `description:` MUST be full sentences (capital letter and full stop)
you really dont need 2 datas here, a type='json' will take both a data structure or json doc
It would be good to combine these before the module gets released to avoid changing the module interface after release.
we might want different types of lock, exclusive, read_shared, etc
file itself wont use them, they can be in their own vars LOCK_ARGs for file modules that want to use them We actually want to move away from most of these that are 'module specific' and leave backup/unsafe_writes/etc other generics in a FILE_MODIFY_ARGS or some other structure
I would default to None and allow the 0 to be immediate, vs no timeout .. possibly -1 or any negative value for 'no timeout'
You can move this check to `module_utils` as well.
In python we tend to add a trailing comma, also for the last item in a multi-line dict or list. This is explicitly allowed by PEP8 and ensures that if any items are added, only one new line is added (and not the previous line needs a change). So it keeps the origin of lines (blame) clean. And it's also much more convenient.
self.zone += '.'
Yeah, I think one squashed commits makes the most sense here.
`delete` and `create` are not valid states
CI failure due to python 2.4 syntax error: ``` 2017-02-07 17:14:00 Compiling ./lib/ansible/modules/network/nsupdate.py ... 2017-02-07 17:14:00 File "./lib/ansible/modules/network/nsupdate.py", line 178 2017-02-07 17:14:00 except binascii_error as e: 2017-02-07 17:14:00 ^ 2017-02-07 17:14:00 SyntaxError: invalid syntax ```
Required option according to the docs.
useless try/except, several of these in the code
throw seems unused
Check if self.dc_obj is not None. We have seen "AttributeError" failures in past related to this.
Use [find_obj](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L57) instead.
use `isinstance(obj, type)`
Missing doc string for 'labels'
For options, use C(absent) instead of I(absent)
Unneeded, the default is null, so you don't have to explicitly mention that.
No need for quotes here.
There is no need to do `- >` here, just like a bit higher up, list items can be multiline.
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
```suggestion - List of Role Definition permissions. ```
```suggestion - List of assignable scopes of this definition. ```
This one is correct.
```suggestion - List of denied data actions. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
Set required=true in the argument_spec ```ip_address=dict(required=True)```
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
It looks like there may be an issue with the tests. I've restarted the failed test.
Why a 1 second sleep here, I had this removed in my testing and was fine without it. 1 second is a long time for each command, especially since tasks can execute more than 1.
C/P error, should be `AWS ElastiCache is down`? Same on L450
Is this call redundant? The manager already calls this earlier, so seems like it shouldn't need to happen again (plus we're ignoring its result).
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
Probably need a third clause on this for `aws_security_token`- IIRC that can be specified alone.
the cache will be by 'plugin/source' initially it will be globally enabled, but i hope to implement per plugin and even per source settings
```suggestion description: If promiscuous mode is enabled. ```
```suggestion description: Administrative state of the interface (C(up) or C(down)). ```
```suggestion description: If multicast is enabled. ```
```suggestion description: L2 address (may be C(None), if the interface does not have one). ```
```suggestion description: L2 Broadcast address (may be C(None) if the interface does not have one). ```
...right, we're already in netcommon. Carry on, then.
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
no real docs, but you can look at other modules that do it, i.e copy
the module can run on systems in which Ansible itself is not installed, that is why you should always put any 'non core' python library in requirements, even if you alert later on it is 'nicer' to inform the user when he reads the docs vs only when executing the plugin.
You are missing 'pyyaml' and vdo CLI tool (as much as it should be obvious) as a part of 'requirements'. modules are not guaranteed to run on the controller, so you cannot expect pyyaml
This is not a good practice, use module.debug or module.log , you can even check module.verbosity to figure out the level you want.
you dont need to include most of the defaults here (nor in docs), `default=None`, `type=str` and `required=false` are all redundant
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
Yes, you can- so long as a default is not specified, an unset value will still be `None`
doesnt --> does not
@carchi8py : enable/disable UDP protocol It would be nice to have a default of 'enabled'
use `choices`, ditch inline "possible values" text
```suggestion if fail_on_autoremove: fail_on_autoremove = '--no-remove' else: fail_on_autoremove = '' ```
Shouldn't the default for autoremove be "False" rather than "None" ? (just nitpicking)
```suggestion cmd = '%s -y %s %s %s %s %s %s' % (apt_cmd_path, dpkg_options, force_yes, fail_on_autoremove, allow_unauthenticated, check_arg, upgrade_command) ```
"manual" is a recent occurrence, for older versions it was 'unmarkauto' iirc
```suggestion upgrade(module, 'yes', force_yes, p['default_release'], use_apt_get, dpkg_options, autoremove, fail_on_autoremove, allow_unauthenticated) ```
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
`type='int'` You can then remove your code to check that this is an int.
dont use yaml direclty, use `from_yaml` as it will handle prioritizing C libyaml and other things (like always being safe)
another reason for dataloader is path magic, but that is not needed here.
use `from_yaml` function
It should probably be plural to indicate there can be more than one. Though if you have `argument_specs['main']` most of the time, I can see that looking a bit funny. But I think it would server as a good reminder there can be additional specs.
Does this need to be a nested function? The overall cyclomatic complexity of this method is 8. I bet it could be reduced by removing this nested function. It would also make this method (and the function) easier to test.
Please remove the `else: changed = False`. That doesn't make sense. Instead, de-indent the `changed = True` above. Once `are_dicts_different(expect, current_state)` is `True`, `changed` should be set to `True` no matter if check mode is active or not.
I'm not big on returning `Exception` here I'd rather be specific to JSON-ish exceptions, like: ``` try: pass # blah blah code # on Python 3+, json.decoder.JSONDecodeError is raised for bad # JSON. On 2.x it's a ValueError except getattr(json.decoder, 'JSONDecodeError', ValueError) as e: module.fail_json(...) ```
And then for requests-status issues, have a separate clause.
This will raise a TypeError: `exceptions must derive from BaseException`
```suggestion "Cannot change option from (%s) to (%s) for an" ```
Right -- but is it the same format as os-release? If it's not the same format you'll need to add different parsing rules for that file below.
Ugh -- so this is where I look at the code and think, this needds to be refactored to make this new case sane :-). If you don't want to refactor, here's some pseudo-code for how to do it hackily: ``` python # Try to handle the exceptions now ... if self.facts['distribution_name'] == 'Debian': try: self.get_lsb_facts() self.facts['distribution_release'] = self.facts['lsb']['codename'] except: pass for (path, name) in Facts.OSDIST_LIST: [...] if self.facts['distribution'] in ('Fedora', ) or (self.facts['distribution'] == 'Debian' and self.facts['distribution_release'] != 'NA': ``` Like I say pretty hacky. But the code needs a refactor anyway. And we aren't putting false values into the data if we do it this way so future programmers won't try to figure out what debian-version is doing in OSDIST_LIST.
Please keep the mock data files and add `/etc/products.d/baseproduct` file content in `input` section. Something like ... ``` "input": { "/etc/SuSE-release": "SUSE Linux Enterprise Server 12 (x86_64)\nVERSION = 12\nPATCHLEVEL = 2\n# This file is deprecated and will be removed in a future service pack or release.\n# Please check /etc/os-release for details about this release.", "/etc/os-release": "NAME=\"SLES_SAP\"\nVERSION=\"12-SP2\"\nVERSION_ID=\"12.2\"\nPRETTY_NAME=\"SUSE Linux Enterprise Server for SAP Applications 12 SP2\"\nID=\"sles_sap\"\nANSI_COLOR=\"0;32\"\nCPE_NAME=\"cpe:/o:suse:sles_sap:12:sp2\"" "/etc/products.d/baseproduct": ... }, ```
Since this is duplicated code, I wonder if it could be consolidated with the `Kali` branch.
This could use `get_file_lines()`. ```suggestion distdata = get_file_lines(debian_version_path) for line in distdata: m = re.search(r'(\d+)\.(\d+)', line.strip()) if m: debian_facts['distribution_minor_version'] = m.groups()[1] ```
I think it's better to set them to null if they always existed before - unknown key would behave differently than a key that exists but is set to a null value and we don't want to break things for people if possible. Thanks very much for diving in to this.
AnsibleAWSModule automatically adds ec2_argument_spec() so you can simplify 213 through 219 ``` argument_spec = dict( route_table_ids=dict(default=[], type='list'), filters=dict(default={}, type='dict') )
```suggestion description: The ID of a NAT instance owner in your VPC. returned: when NAT instance owner is available ```
Actually caught by AnsibleAWSModule
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
It's worth catching BotoCoreError rather than NoCredentialsError (as that will catch ParameterValidation exceptions too).
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
Once you use `module.client`, `boto3_conn` and `get_aws_connection_info` are no longer required
No need to import boto3
You just need to catch ClientError and BotoCoreError. If you want, you can rebase on devel and use the pattern ``` from ansible.aws.core import is_boto3_error_code try: return client.get_application(applicationName=name) except is_boto3_error_code('ApplicationDoesNotExistException'): return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, "Could not get CodeDeploy application.") ``` Note: BotoCoreError does not have a .response so if you don't want to use the pattern above you should add ``` except BotoCoreError as e: ``` on line 169
How about I just want to list all LB in this subscription? It can accept None value
See my point in the non facts module around snake_case.
We may need at least the following features here: - [ ] `list_keys()`: Show the SAS policies of the Event Hub, so that we can have connection string - [ ] `list_consumer_group()` We usually add these with a flag to avoid network overhead. refer: https://github.com/ansible/ansible/blob/1dc8436ed91ef25748dd270c289c05f893cca6e3/lib/ansible/modules/cloud/azure/azure_rm_servicebus_facts.py#L55-L60
Mention the unit (seconds), same for the same for `wait_sleep_time`.
that should be example of module usage, not return value
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
```suggestion sample: false ```
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
botocore.exceptions.PartialCredentialsError can also occur on connection creation.
boto3_conn now handles region problems, no need to do it in the module
You should handle check mode here!
This check is no longer required with AnsibleAWSModule
This will be falsy in case of `0` values which is probably not exactly what you want. Maybe you want this? ```suggestion if params['blkio_weight'] or params['blkio_weight'] == 0: ```
also, stick to one quotation style. here you use double and single quotes, a few sections above it's single quotes.
This is unnecessary, just use a fallback value: ```suggestion for host_n_ip in params.get('etc_hosts', {}).items(): cmd += ['--add-host', ':'.join(host_n_ip)] ```
Based on convention, `cmd` should instead be `b_cmd` to indicate it is meant to hold byte strings.
this also deserves more spacing ```suggestion if action == 'stop': ```
Those lemurs at shippable sure need to work harder! ;-)
here too: pysopenssl --> pyopenssl
Should be "Can't detect any" rather than "none" I think.
```suggestion description: Returns a dictionary for every extension OID ```
A sample would be nice I guess, so I know if it is `sha256` or `SHA256` for example.
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
task_uuid seems unused
this got named use_backend
Meh, what you have is fine for now- they're basically singletons already, so that constructor arg is probably superfluous, but I don't think there are any active plans to kill it... Just IIUC whatever reason it existed for in the first place doesn't exist anymore. So this looks good to merge to me.
Yes, but we can address this in another release.
see previous discussion on renaming idempotently
definitely seems like there should be an else with an error here...
Not possible to glean the volume type from the result of get_volume and choose the right operation automatically? If not, these admonitions need to be in the docs, not in the code...
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
For the author information we normally only keep name and GitHub handle.
Here add: ```yaml type: list ```
We prefer that examples show sensible values, so people understand what is expected. If you add variables like this, there's no clue what the actual content would be.
Note: you don't have to use set explicitly here. The set methods can work with an iterable (which tuple is)
but you dont have full args till you read the file. I becomes specially fun when the from itself is a template
this does not seem like the correct change, instead we need to make sure that the vars_from are loaded before pasisng to param hashing
I haven't looked at this PR in depth yet, but the first thing I notice is that this should use `original_task.copy()` instead of `deepcopy`. Our `copy` methods are specifically designed for copying these objects. We will also need to closely monitor memory usage due to any changes that make copies of objects.
I'm pretty sure this can use `is_sequence()`.
If a parameter is not required, you don't have to add `required: false`. It's implicit unless you state `required: true`.
If a parameter is not required, you don't have to add `required: false`. It's implicit unless you state `required: true`.
All descriptions start with uppercase and end with a point. Please follow the used standards for consistency.
Again, this should become: ```yaml type: bool ```
Get rid of this.
No, you still have to check `HAS_BOTO3` (imported [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L229) and checked [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L558) )
No wrap needed.
No wrap needed.
Unnecessary line break
No wrap needed.
That issue is for relative import support in the `import` sanity test. If we're fixing the `module_utils` matching in `validate-modules` then it should take into account all of the necessary patterns.
Just to clarify, even if a module is in a collection, it is still value to import from `ansible.module_utils`, right? For example ```python from ansible.module_utils.six.moves.urllib.parse import urlencode ``` I think this is still allowed by this PR (because of the `or`), so ð
There is an issue for allowing relative imports at #61884, so-far, this PR does not claim to handle that.
This probably needs to accept any `module_utils` import that Ansible recognizes as a new-style Python module: https://github.com/ansible/ansible/blob/e4eea0510cd89124c3a20f4d9937e7c015a46597/lib/ansible/executor/module_common.py#L423-L440
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
You forget to make the change.
`def get_recommended_datastore(self, datastore_cluster_obj=None):` â `def get_recommended_datastore(self, datastore_cluster_obj):`
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
This should be `type: bool` IIRC.
Not required ? Don't say so. This is implied.
Not required ? Don't say so. This is implied.
If a parameter is not required, you don't have to add this. This is implied, `required:` is only needed for parameters that are required.
Do this as a list, unquoted: ```yaml author: - Richard Levenberg (@richardcs) ``` Your email can go at the top of the file for the copyright.
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion - David Taylor (@djtaylor) ```
```suggestion version_added: "2.8" ```
```suggestion ANSIBLE_METADATA = {'metadata_version': '1.1', ```
Needs to include the platform. This string is used on https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html
The `basedir` path will need to be bytes to avoid unicode errors. Something like this: ```suggestion b_basedir = to_bytes(context.CLIARGS['basedir']) collections_search_paths.update([b_basedir]) default_collections_path = [b_basedir] + default_collections_path ``` I did not test this. I'm just guessing from looking at the test failure.
I'd like to see us not pass the results of `load_options_vars` into `VariableManager`. Instead we should just use `load_options_vars` directly in `VariableManager`, and handle whatever complications there may be with using `CLI.version_info` from `VariableManger`.
use `unfrackpath(filename)` to ensure we get something the user can always use
you want to put basedir first to match normal precedence
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
@s-hertel using client exceptions rather than botocore exceptions is nicer when they actually exist (which they do here for a kms client): ``` except connection.exceptions.NotFoundException: return None except (botocore.exceptions.ClientError, botocore.exceptions.BotoCoreError) as e: # Legitimate failure module.fail_json_aws(e, ... ```
You don't need this conditional, since Ansible enforces that these are the only choices.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
Not required with AnsibleAWSModule
Ok, that makes sense. Thanks for the great explanation.
Do we want errors with this? ```suggestion compiled = compile(parsed_tree, to_native(expr, errors='surrogate_or_strict'), 'eval') ```
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Not necessary but this map and the one on 690 are better written as: ``` python elif LooseVersion('.'.join(to_native(ver_field) for ver_field in etree.LXML_VERSION)) < LooseVersion('2.3.0'):
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
`You must set C(PUREFA_URL) and C(PUREFA_API) environment variables`
`ManageIQ username. C(MIQ_USERNAME) env var if set. otherwise, it is required to pass it.` and delete the `default:` line. This applies to the remainder of this file
For consistence please ensure all `description:` lines are full sentences (capital letters + full stop at the end)
This doesn't seem to read right with present vs absent
To make this a clickable link please do `'manageiq-client U(https://github.com/ManageIQ/manageiq-api-client-python/)'`
ah, for some reason i thought 'True' was default, ignore me. ....
On my systems, `stat` shows inode 256 for all subvolumes, not only the first created. Moreover, any subvolume may be mounted on `/`, not only the first one.
we already have chroot detection, which covers more cases tha this test Also, you can have chroot and still have a service mgr as proc 1, depends on the host configuration and how you create the chroot/jail.
move this to under the If
`0o600` is more readable than `384`.
would you mind minimalizing the example for state=absent to the things required: ~~~yaml - name: Remove a vpc offering local_action: module: cs_vpc_offering name: my_vpc_offering state: absent ~~~
would you mind change this to the following? ~~~ 'roleid': 'role_id', ~~~
shouldn't this be like the following? ~~~python if rule == _rule['rule'] or rule == _rule['id']: ~~~
there is a helper function `has_changed()` for that, which also handles --diff https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/cloudstack.py#L149
This and the following update should only be executed if there is a change.
```suggestion into namespace I(netns). ```
```suggestion - Note, when the interface changes namespace it loses ```
```suggestion - To identify an existing interface within a namespace, use the I(namespace) option. ```
```suggestion - Removing aliases from an interface is not currently supported. ```
```suggestion support (for example 'type vcan'). ```
I believe the previous 3 lines can be deleted.
it looks to me this module supports check mode, but it is says not
Call out default? If you set a default here, don't forget to update the spec above.
Docs uses `512emulation`: add an alias if you like to keep the code as is ~~~python enable512e=dict(type='bool', aliases=['512emulation']), ~~~
as explained in related ticket, catchall exceptions are not the best way to handle user errors
Total time, in UNITS, to run stress for.
timeout isn't defined in `argument_spec`
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
Don't add `required: false`. It is implicit.
I don't think this will work the way you expect with Python 2/3. I don't *think* we'll ever get `unicode` inputs, but if someone did a `!!python/unicode sometext` in their play it would show as unicode.
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
`required=False` is not needed as it's the default
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
Just put this on one line (or two if needed for line lengths) ``` from a.b.c import x, y, z from a.b.c import u, v, w ```
this is too aggressive as it removes all ACLs, not just the ones we added take into account that directories can have 'default acl' to be added to all new files in a directory, this would wipe those along with the one we added to copy the file into place
Handle NoCredentialsError as well
```suggestion pass # Handled by AnsibleAWSModule ```
Looks like this is used now, yay :-)
Never raise an exception, fail the module instead
Spurious `else:` Breaking the tests.
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
should be `type='path'`
TODO add Exception handling for login error
As far as I can tell, the 'in_use' is never used.
Missing from docs
Missing full stop.
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
we should also return if we both delegate executions and delegate_facts
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
Can `_state_*` be changed to the class methods as it invokes methods from within the class? I don't see a reason to have these methods as `staticmethod`
The subset type has to be of type `frozenset` as the `minimal_gather_subset` is of type frozenset `runable_subsets = self.gen_runable(legacy_facts_type, frozenset(fact_legacy_obj_map.keys())`
With all I saw I think that you need to extend your schema: 1) have a string `msg` key, because I saw you putting strings instead of dict there sometimes 2) some structure for extra info: either one dict with all data or a set of separate scalar keys (which is probably easier to manage) Think of it as a public API: whoever will run your module will register the result and this whole structure will be available to them to use/inspect. Try to think of the most useful way to reuse this data you return.
msg should be smth added by you, while there should also be a dict with server response separately.
Then, this return schema should be updated. It's currently completely different from what you describe. I guess it should be: ```yaml --- msg: type: string ... returned: always sample: <actual string message> ... update_status: type: dict ... returned: success sample: CompletionTime: ... Id: ... ... ```
(return value is a _nested_ structure, so you don't have to try putting everything in one key: different data should go to different keys)
I think example needs some actual value examples, because it's a module-specific data. It's not a jinja tutorial.
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
type='str' is a default value, not require to explicitly mention it
type='str' is a default value not required to mention in separately.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
```suggestion - List of paths to include. ```
```suggestion - List of paths to exclude. ```
```suggestion short_description: Local Backup Utility for Alpine Linux ```
Unless I am mistaken, this doesnt actually do anything. I do not believe it's possible to have an 'absent' flag to remove an entire stanza. `chsec` can only remove given attrs/options from a given stanza, it cannot remove the entire stanza. This code block is just 'unsetting' all of the given attrs/options and ignoring the value assigned to them. These two YAML examples behave exactly the same way even though one has state=present and the other state=absent: ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=LDAP,registry=LDAP state: absent ``` ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=,registry= state: present ``` HOWEVER, if there are other attrs set on that user stanza, the *stanza will still exist*. You need to specify every single user attr/option on that stanza to remove the stanza. Adding a 'true' state=absent will mean going through the given `file`, finding the stanza, getting all of the key:value pairs in that stanza, and then running chsec key=null to every one of those. That's a loooot more work.
```suggestion query=dict(type='list', elements='str'), ```
```suggestion self.module.fail_json(msg="The role ID isn't valid %s" % to_native(not_found)) ```
```suggestion "on the root node: %s" % to_native(admin_permission) ```
role_name can be lower case as well. For example, user can provide admin for `Admin` value, then this function will return None.
```suggestion "4. The account cannot be removed due to permission issues : %s" % to_native(security_error.msg) ```
no need for another loop you can check this in the previous loop
Do not change the variable name throughout the code. That is not necessary.
According to https://setuptools.readthedocs.io/en/latest/setuptools.html#using-a-src-layout, the old version should be enough... Does it cause problems for you? ```suggestion package_dir={'': 'lib', ```
Hm.. This looks wrong
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Don't quote strings when that's not necessary, and add spaces in Jinja variables for readability. ```suggestion msg: TCP port {{ item.port }} by pid {{ item.pid }} violates the whitelist ```
```suggestion RETURN = r''' ```
Add a few more examples of just listing the ports: ```suggestion when: tcp_listen_violations - name: List TCP ports debug: var: ansible_facts.tcp_listen | map(attribute='port') | sort | list - name: List UDP ports debug: var: ansible_facts.udp_listen | map(attribute='port') | sort | list - name: List all ports debug: var: (ansible_facts.tcp_listen + ansible_facts.udp_listen) | map(attribute='port') | unique | sort | list ```
Please remove the "required: false", you only have to add `required: true` if it is required.
Please remove the "required: false", you only have to add `required: true` if it is required.
`validate_certs` and default should be `true`
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
> it's dangerous to set subscription_id only since azure credential is a set of subscription id, service principal credential. There is a difference between the credentials a user needs to have in order to work on some object and the the identification of the resource being created. As far as I understand the implications of this change, it allows one to explicitly specify under which `subscription_id` some resource should exist/must be created. eg. An availability set has an id like: `/subscriptions/<subscription_id>/resourceGroups/<resource_group>/providers/Microsoft.Compute/availabilitySets/<name>`. In this case there is a `subscription_id` but no service principal specification. I think it's fair to argue that one should also be able to explicitly specify the credentials that need to be used for that specific resource access/creation. Though a sensible fallback to the first matching credentials for that specific `subscription_id` would work in most cases. Edit: hit update too soon, mainly grammar fixes
We have exactly the same use case and are running into this exact same problem. We have multiple subscriptions (for split billing and authorizations) and having to set environment variables or perform 'az account set -s' commands is very prone to human error. The fact that hosts and related resources belong to specific azure subscriptions is mostly a detail that our operators aren't concerned with during their work.
ContainerInstance doesn't support profile, it's why it doesn't have a `models` method
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_API_VERSION') ``` Will not work for azure-mgmt-resource before 1.3.0 if you want multi-api support there as well.
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_PROFILE') ```
`result['changed']` must be set to `False` before the loop, then result from previous iteration must not be lost, use something like `result['changed'] |= False`
It's nicer and less error prone to send a list to module.run_command than a string.
Note, it's inefficient to do this inside of the loop. Better to call get_bin_path once outside of the loop and save the path to a variable for use inside.
Am not talking about `check_mode`, but about `change=True` / `changed=False`.
Will this parsing also work when gluster isn't installed at all? In that case any meaningfull message would be nice.
Why uppercase? I think the standard is to use lowercase. It's bad practice to pass args through that use * and ** to unpack. Better to be explicit about what arguments are being passed in.
Purestyle note: add a blank line between python stdlib imports and ansible imports
Unnecessary blank lines here, removing these blank lines is preferable.
Okay, so to implement the examples like this: ``` with_cyberark_password: appid: 'Application1' query: 'safe=...;' output: 'password ....' ``` We'll want to take the dict from terms instead of from kwargs. terms will hold the dict that the user passed in so you should be able to drop in replace it in your constructor like so: ```CyberarkPassword(**terms)```
Maybe think about doing: ``` '-o', 'self.output', '-d', 'self.delimiter', ] ``` instead, this is a very long list, and making these changes is likely to make it more readable.
I am pretty sure this will fail to run, since concatenating strings and arrays is not something python supports. You will need to add a loop over the `self.systems_uris` and then incorporate all of the responses into final result.
I would leave `get_storage_controller_inventory` function largely intact in this case, since it already sort-of works for single system. The only thing that I would change is to replace `self.systems_uri` with an explicit function argument to decouple it from the global state. Then I would introduce another function like `get_multi_storage_controller_inventory` that just loop over the `self.systems_uris`, calls `get_storage_controller_inventory` and merges results. How to merge results is something that maintainers should guide you through since this will also affect the final result format and maintainers are the ones who should define that.
```suggestion disk_result[property] = device[property] ```
Not catching non-200 responses.
Not catching non-200 responses.
This is probably more a bigger-picture usability thing with inventory plugins, but it seems like making the plugin do this validation is error-prone, and potentially opens the door to malicious or poorly-written plugins to consume stuff they shouldn't. A realistic setup might have multiple cloud inventory plugins enabled (eg, I'd argue that all the ones we ship in the box should be enabled), which means there's a lot of refusal going on. Regardless, it seems like for config-based plugins like this, that this should be handled by the engine, not the plugin itself. Topic for broader discussion, I'm sure.
the cache will be by 'plugin/source' initially it will be globally enabled, but i hope to implement per plugin and even per source settings
Is this call redundant? The manager already calls this earlier, so seems like it shouldn't need to happen again (plus we're ignoring its result).
Probably need a third clause on this for `aws_security_token`- IIRC that can be specified alone.
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
To be consistent with other modules, this should be validate_certs, not validate_cert.
"This should only set to no used on" - sounds awkward. I also don't recommend reasons for when to turn this off. I'd just warn them it's not recommend. Even personally controlled sites using self-signed certs can fall victim to MITM attacks.
Please remove `required: false`
``` default: true type: bool ```
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
You can import HAS_BOTO3 from ansible.module_utils.ec2 below, instead.
Same here - please include a traceback.
Traceback please ð
Say "botocore/boto3" since boto isn't used in this module.
Please use the camel_dict_to_snake_dict to fix the camelcase in the boto3 responses here.
```suggestion query = '%s=%s' % ('UUID', uuid) ``` Since single quotes are used everywhere else.
Probably the same with `--label` instead of `--uuid` here.
```suggestion result = self._run_command([self._blkid_bin, '--uuid', uuid]) ``` According to `man blkid` on my system, it is `--uuid` and not `--uid`.
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
Need to `return bind_mounts` here
I think this validation can be dropped too. it's only `name` which is required=True. (plus we wouldn't even reach this function without finding a definition by name)
no, this refers to the standard `changed=True` / `changed=False` and `msg="..."` results returned by ansible modules.
I think this is a typo - `changed` should be `changes`
may be nice to support description in addition to name.
Perhaps `required_if` can help.
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion required: false type: str ```
```suggestion - Will also define the VMs hostname. ```
```suggestion - The VM to use as the source (template). ```
This increases the chance of collision and should be changed back to 9999.
I think these `randint` calls should be removed entirely, all the increase in the `randint` range does is reduce the chance of collision not remove it. Some poor user will get their build failing randomly because of collision, which is a risk that increases with every device the user adds. The docs suggest that it just needs to be a unique negative number which will get replaced when the device is actually created. I suggest putting a `device_key` attribute on the `PyVmomiHelper` object, with a getter function that on each call will decrement and return a negative integer (.e.g. -1,-2,-3). This would remove any chance of collision, and fulfil the requirement of giving every new device a unique, negative temporary id.
Rather than raising error, please use `module.fail_json`
`if unit in disk_units:` is case sensitive already, the `unit = unit.lower()` should be done before the if statement. ```python In [24]: unit = 'Gb' â â In [25]: disk_units = dict(tb=3, gb=2, mb=1, kb=0) â â In [26]: if unit in disk_units: â ...: print 'Found' â ...: else: â ...: print 'Not Found' â ...: â Not Found ``` (done in `ipython`)
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
For these to be a tuple you need a trailing comma, like `opsworks_fields = ('layer_id',)` for all single-item tuples.
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
Same - please use `len`
Same - please use `len`
inventory plugin, not module ... also we can use 'short form' for licenses now
Ok, so long descriptions are not a good idea. Best practice is to do: - First line is a short description of what the parameter is - Subsequent lines for additional information on behaviour, or what different possible values mean
`short_description` without full stop. All other `description:` with full stop
This should be: "Gather facts about self-heal status" It is not facts about Gluster hosts.
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
Same, `device-mac` or `device-mac-address`.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
I think something like `device-name` would be more descriptive.
Find a better name.
```suggestion precedence over statically-configured ones. Only C(networkd) backend and C(dhcp4) ```
The current behavior is: * if the user did not specify `env` (i.e. `self.env is None`), don't compare. * if the user did specify `env`, compare user's `env` to the service's `env`. * if the service's `env` is empty, treat it as `[]`: this simply means that no env variables have been set for the service. So this does not ignore empty lists, but treats them correctly. (What it doesn't do is consider order - you're totally correct on that one.)
(Same for the comparisons below.)
(But that's already what you implemented. So it should be fine.)
A better version would be: ```suggestion if has_list_changed(self.env, os.env): if self.env is not None and has_list_changed(self.env, os.env or []): ```
If the new list is `[]`, you should compare. The user explicitly requests an empty list in that case. If the new list is `None`, don't compare, the user is saying "I don't care".
Add Python3 boilerplate ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ```
`You must set C(PUREFA_URL) and C(PUREFA_API) environment variables`
Please use `to_native(e)` [1] instead of `str(e)`. [1] `from ansible.module_utils._text import to_native`
Do you want the same example for all modules? Normally we don't put any examples in `docs_fragment`
'fail_json' takes 'msg' otherwise it will raise error ``` module.fail_json(msg="YOUR MSG") ``` '+' is redundant in round brackets.
This should also accept the deprecated args.
Easier to read if written like this: ``` python VALID_ARGS = tuple(frozenset(BASE + FROM_ARGS + OTHER_ARGS)) ```
And the same here
That's a really interesting piece of information I did not know.
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
Don't add this, if the parameter is not required.
AFAIR the flag is `failed`, not `fail`
```suggestion self.container = PodmanContainer(self.module, self.name) ```
Please stop calling `get()`
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
'auto' is not a valid value to return from this fact
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
Add a break after setting pkg_mgr_name (and the same for dnf)
I think this should be using mock.patch? iirc, this can leave ansible.module_utils.facts.system.pkg_mgr monkeypatched to be a mock for the rest of the tests.
this got named use_backend
You should handle the case that `time_str` is not actually a string.
This is a private function, so its name should start with a `_`.
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
SD is per DC, so cluster will work as well, but still you don't have `cluster` param specified by user, only SD.
We need to make sure that the host is in the same data center as the storage.
I think it's better to use something like: ```python host = search_by_attributes(connection.system_service().hosts_service(), status='up') host_param = host.name if host is not None else None ``` In case there is lot of hosts, it would perform faster.
Ah, sorry, you are right. It's actually sending: ``` DELETE /ovirt-engine/api/storagedomains/123?host=myhost ``` Not the XML data.
This must be a proper Python SDK object, so: ```python host=otypes.Host( name=host_param ) if host_param is not None else None, ```
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
`msg="'%s' device group not found in Panorama. Is the name correct?" % devicegroup)`
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
`policy` should be added to `argument_spec` to be usable.
Fair enough. It is not a hard requirement.
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
`descriptions:` should end with a full stop
missing full stop
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Are these the only valid options, in which case you should add `choices: ['SG_TYPE_STRING', 'SG_TYPE_KEYVAL'] and similar in `argument_specs`
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
This should be a string. ```yaml version_added: "2.3"
Example appears to add, rather than delete.
I think this needs to move out one indentation level to match `Field`
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
So this should extend the argument_spec that you define in `module_utils/nso.py` (which in turn should match whats in the docs fragment)
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I don't see the point ;-)
update description, remove dump
```suggestion version_added: "2.10" ``` The current devel version is 2.10, so I think `version_added` is `2.10`. https://github.com/ansible/ansible/blob/devel/lib/ansible/release.py
Thanks for the quick fix :)
```suggestion version_added:'2.10' ```
Ok, my bad. Thanks for clarification! :)
basic is now a real import, since ansiballz were introduced
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
Yes, please remove the return and update the caller.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Should the `continue` be here? The following 3 lines will never get evaluated.
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
I think this description is off :)
```suggestion if self.client.module.params['disk_usage']: ```
```suggestion elif docker_object == 'networks': ```
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
```suggestion if not HAS_OVH: self.fail_json(msg=missing_required_lib('python-ovh'), exception=OVH_IMPORT_ERROR) ```
```suggestion import traceback ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
```suggestion - ovh_monthly_billing: project_id: 0c727a20aa144485b70c44dee9123b46 instance_id: 8fa89ad2-8f08-4220-9fa4-9695ea23e948 ```
```suggestion - ID of the instance, get it with U(https://api.ovh.com/console/#/cloud/project/%7BserviceName%7D/instance#GET) ```
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
Just making a note that we should probably restrict this to the exceptions that will likely occur and call fail_json instead of raising an Exception again.
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
I'm not sure the `if seconds` makes sense here since we'll never get to this point if `seconds` is defined.
Wouldn't this be handled by the branch above? ``` if hostname.count(':') > 1: ```
Situations where the v6 string in question doesn't actually specify a port, e.g., 2001:db8:0:1 See: ``` def test_parse_ip_host_and_port_v6_with_brackets ```
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
this got named use_backend
what if empty result ? This should be tested also we can have a different TTL per record value, not only per record if i'm correct
CI failure due to python 2.4 syntax error: ``` 2017-02-07 17:14:00 Compiling ./lib/ansible/modules/network/nsupdate.py ... 2017-02-07 17:14:00 File "./lib/ansible/modules/network/nsupdate.py", line 178 2017-02-07 17:14:00 except binascii_error as e: 2017-02-07 17:14:00 ^ 2017-02-07 17:14:00 SyntaxError: invalid syntax ```
Because this parameter was added for backward compatibility with **vmware_dns_config**. We could add it as an alias and keep it forever, but I am not in favor of keeping lots of aliases for the same purpose.
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
If we are creating a new module then why to add old parameters which we don't want in first place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
catchall exception handling is generally not a good idea as it neither gives a better user message nor aids in debugging. If you feel you must do it this way, be sure to return the stacktrace (retrieve that using raceback.format_exc() and put it into the exception parameter to fail_json).
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
`self` is no need
How about the rest items of `spnprofile`
`self` is no need
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
What if the rest service_principal missing client/secret field
note, this is not a blocker but you can use a generator expression here instead of a list comprehension. it could save on some system calls (calling os.path.exists) but I doubt that will be a noticable optimization so it's really just style.
There is no need to make an api call just for checking that the zone exists. The ovh python package raise a ResourceNotFoundError that can be caught in the next api call to check if the zone exists.
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
the module in general is just a thin api wrapper, not really that useful for users, I'm not against having an 'expert mode' but this is in addition to actual options usage.
cacertpath should be cacert_path
in any case, deprecations should always be a list, unsure how a dict is making its way here
ah, nvmd, misread the code, thought you were operating on the 'top level' ... yes it is a list of dictionaries but we allowed for pre-existing string cases
unsure why we need mapping, need to look at original bug, the self.deprecate(d) should be able to handle dicts already
what if msg does not exist?, shouldn't it also be a get
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
```suggestion assert isinstance(wrap_var(set(['foo'])), set) ```
```suggestion assert wrap_var(dict(foo=None))['foo'] is None ```
```suggestion assert isinstance(wrap_var(('foo',)), tuple) ```
```suggestion assert isinstance(wrap_var(('foo',))[0], type('')) ```
```suggestion assert wrap_var(None) is None ```
Use `mocked_generic_connection_modify` fixture.
You can place fixtures into a conftest.py file and then they will be loaded automatically instead of needing an implicit import.
This doesn't check that a failure occurred because both `module.fail_json` and `module.exit_json` mpdules raise `SystemExit` exception. In order to check that, either use [`capfd`](https://github.com/ansible/ansible/blob/c53e3ca8e9834259b79c6b8dec9cf8219c4ae113/test/units/modules/packaging/os/test_rhn_register.py#L91) fixture or mock [`AnsibleModule`](https://github.com/ansible/ansible/blob/c53e3ca8e9834259b79c6b8dec9cf8219c4ae113/test/units/modules/source_control/test_gitlab_hooks.py#L72). * [X] Done
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
I'd be expecting some assertion here, like in the follow-up test, otherwise you're just assigning result but never using it.
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
This should just be `name` since `pubnub_blocks: block=foobar` is a bit redundant.
To import urlencode, you can use this line: ``` from ansible.compat.module_utils.six.moves.urllib.parse import urlencode ``` Then for the rest of the file just use `urlencode` as normal.
To get urlencode, please use `six.moves` instead.
Ah, I see. Thanks for clarifying!
I wonder if there are more correct than wrong uses of `get` :) I mainly know its use in `route53`, where it shouldn't be a state.
(if that doesn't work, change `&` with calling `set.intersection()`)
Ah. I thought you're talking about `dict.get()` being not enough for the validator.
Looks like the CI failure is caused by the set literal under Python 2.6: ```suggestion bad_states = set('list', 'info') & set(data.get('choices', set())) ```
After the refactoring, it's probably okay to inline it back since it's used in one place now: ```suggestion bad_states = {'list', 'info'} & set(data.get('choices', set())) ```
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
This line is too long even by the Ansible code style guide. It should be under 120 chars per line. Please format it like this: ``` module.exit_json( changed=has_changed, state=p_state, id=p_id, enabled=changed_repos['enabled'], disabled=changed_repos['disabled']) ```
There should be two blank lines between top level functions.
It would be awesome if buildah supported copying from a container.
use this instead ``` module.get_bin_path('yum', required=True) ```
Can we have a list of packages which can be locked/unlocked? just like yum module does.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
I wouldn't call `module.params` as `packages` since it will hold also other parameters, not only the packages
Add absent as well.
that depends on the plugin, it should not be required by the common code .. though those plugins should not be calling this method either
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
No need to compile explicitly, `re` will hold compiled cache internally anyway.
You use `re.match` which already checks the beginning of a string. So caret `^` is not needed. https://docs.python.org/3/library/re.html#search-vs-match
Yeah, but does this code works well, when updating some attribute via that? As far as I read it correctly it doesn't.
So we don't wait for empheral VM? I think we should
Also we should still call this in case of check mode, and say whether it will be changed
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
I think it make sense to support running state for ephmeral VM, as well as stopped and absent. which would be same. The code will be more straighforward then without not needed ifs
add_group creates and returns a 'sanitized' group name, to avoid warnings you might want to use `self._sanitize_group_name(name)`
@gaudenz for those that really want it, there will be global toggle available, you CAN add toggle at plugin level to do same
+ type: int
+ type: str
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
```suggestion - name: Ensure that /exports/nas key in auto.direct map is absent ipa_automountkey: ```
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
add a sample here - ``` sample: { ... } ``
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
```suggestion description: State to ensure. ```
Shouldn't be needed
Should add a point here saying not allowed with `I(identity)`. Should also say the value is the `C(distinguishedName) of the path to search from.`
```suggestion filter: "sAMAccountName -like 'test*'" ```
```suggestion filter: "sAMAccountName -like 'test*'" ```
```suggestion search_base: "OU=Users,DC=contoso,DC=com" ```
You don't have to inherit from object if you have the boilerplate ```__metaclass__ = type```
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
Instead of type checks like this, use the `isinstance` operator like: ``` if isinstance(new_value, str_to_type[modifiable_params[parameter][1]]):` ```
The `.key()` call here isn't needed, dictionaries respond to `in` checks by looking at their keys, and calling `keys()` will create a list (Python 2) or generator (Python 3) that will have membership checks run on it.
Again, `six.text_type` instead of `str`
Be more specific in this message about what was happening when the exception happened, and remember to include the `exception=traceback.format_exc()` argument to fail_json to include the stacktrace.
For this case, the user may just want the parameter group to exist, but not care about what the params are set to (if they have some other tool to set them, for example) so instead of failing, this case should just exit as a success with the current values of the group (since you already got the info above).
I don't see this change in latest commit.
Add a blank after this to notify that these are two separate tasks.
It is not mandatory to have return but I would recommend to add one, from UI/UX point. :)
```suggestion host = find_obj(self.content, [vim.HostSystem], name=esxi_host_name) if host is None: self.module.fail_json(msg="Unable to find host system %s in the given configuration." % esxi_host_name) ```
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
That is a limitation but there is a workaround (see #22630)
i thought i had asked to remove this option in favor of keep remote files
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
Could you please use `AnsibleAWSModule` instead? We didn't have a lot of the aws utils we do now when this was first PRd, it will save having to port it later on. https://docs.ansible.com/ansible/devel/dev_guide/platforms/aws_guidelines.html#creating-new-aws-modules
The things being set here are the manager network protocols, so I think a better name would be something like `SetManagerNetworkProtocols`. Though that is a bit long. But since the category is already `Manager`, that part of the name could be eliminated. That would leave `SetNetworkProtocols` (and `GetNetworkProtocols` in redfish_info).
Even though the only Chassis commands currently are the LED ones, I think it would be good to set up the above code block to handle multiple commands (similar to how the Systems and Accounts blocks are structured). i.e. Have a `for command in command_list:` block so that if and when new Chassis commands are added, the new code would just be an additional `elif` block within the existing `for` loop. Hope that makes sense.
I'd convert `name` just one time instead of doing it on each iteration.
For the command name, since there are several AccountService properties that users may want to set and not all of them may be considered password policies, I think it would be better to use a more general name. Something like `UpdateAccountServiceProperties`.
i cannot imagine people look at deprecated files first for examples ...., but they do see changes to them and then try to use those to justify subsequent changes.
If you turn this into ```suggestion if not os.path.exists(collection_output): _build_collection_tar( collection_path, collection_output, collection_manifest, file_manifest, ) return ``` you could reduce some nesting which improves readability.
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
But since Python 2 doesn't support the `default` keyword argument, here's a cross-compatible shim for you: ```suggestion try: return max(v for v in self.versions if v != '*', key=LooseVersion) except ValueError: # ValueError: max() arg is an empty sequence return '*' ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
Thanks, you can create a new PR using the code available in #47271, test it and let me know.
period at the end of statement.
Make this a proper YAML list: ```yaml author: - Joseph Callen (@jcpowermac) ```
Indent is required here and below line.
Do we know other supported vendors? (Don't think there are others than VMware currently in vSphere 6.7, but there were others like Cisco and IBM in the past)
Could you please changes these to 'present' and 'absent'? then state will match to all other modules and will not cause any confusion with customer/user.
Use `I()` around parameter names. ```suggestion - I(url) and I(host)/I(port)/I(user)/I(pass)/I(vhost) are mutually exclusive, use either or, but not both. ```
the code in module_utils is BSD licensed, to allow for 3rd party module redistribution w/o having these to be GPL
as in modules, we do not wan't to print/exit, capture the missing library in a variable and report it missing in a fail_json call.
Could we included the word `Droplet Sizes`? That will clear up any confusion on what sizes.
There is no need to add quotes here. Please remove them from all modules.
Use URL instead of Url. ```suggestion - The URL of the Gitlab server, with protocol (i.e. http or https). ```
This needs to be C(validate_certs) which is the standardized parameter name.
Please don't add any aliases except for backward compatibility. We don't want to offer more choice than necessary.
Quote are not required here ```suggestion default: yes ```
@felixfontein Maybe this could be moved to `AnsibleDockerClient.__init__()`? Let it accept minimum api / docker-py versions as parameters.
this should be a common function in basic.py (i think there is this one or the reverse there already)
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
```suggestion for key, value in client.module.params.items(): ```
While working on #53906, I explored the docker client creation process a bit more in detail. You can use `self.dclient = DockerClient(**self.client._connect_params)` to initialize the client with the same arguments as `self.client` is initialized. Relying on a Ansible docker internal API should be safer than relying on docker-py internal API.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
Why add this? Unless I'm missing something, `interface_table` isn't used at this point
Please add `mutually_exclusive = [['name', 'interface_type']]` in aggregate spec dict. This ensure the mutual exclusion is applied for each item in aggreaget list
Why the loop here? `if match` should be sufficient
This break will be unnecessary if the loop gets dropped
Why don't you just encode suffix like `u'-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8'.encode('utf-8')` and for the no_temp_unicode override just do `suffix = b'-ansible'`? No need for this check which is arguably more confusing.
If the lockfile has gone away while you were attempting to read it, wouldn't you want the ansible module to continue instead of failing? Related, if the lockfile disappears at any time while we're attempting to decide if it's valid, we likely want the module to continue. So we probably want to ```try-except``` around the body of this function and return False if the exception tells us that the lockfile no longer exists.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
Note: this is usually expressed as: ``` python if not full_version: ```
I would make it a list so user can pass more versions
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
it should be `minor_vers = int(version[1])`
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
dont do this, now we have 3 parsers, we shoudl move parsing/json to module_utils and use from there
```suggestion Test that the returned value for timezone consists of only uppercase ```
I think it's nicer to have trailing commas: ```suggestion ], indirect=['mapping'], ```
```suggestion assert ansible_json_encoder.default(m) == expected ```
If this test won't be implemented it should be removed.
The standardized parameter is **validate_certs**. I'd rather stick to the standards for this one. If you use the internal urls API, this would automatically be covered.
```suggestion type: str default: https://intersight.com/api/v1 ```
```suggestion type: path required: yes ```
There is an inconsistency here, I actually prefer this over the implemented **ucs_port**.
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
This doesn't have to be quoted.
This string doesn't have to be quoted.
No need for the `M(..)` here as that will just generate a link to the same page.
The list of options should be in alphabetical order.
I'm not sure if we can also use the words "packages" or "updates" in their to make it a little more obvious.
Can be simplified if you do `type='int'`.
Can be simplified if you do `type='int'`.
You've named this check_params in other modules. Not a major issue.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
set the type to list then
Sorry it's now 2.10
set the type to list then
a teeny typo: ipvr_addresses -> ipv4_addresses
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
Needs a metadata block ``` ANSIBLE_METADATA = { 'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community' } ```
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
aws_ip_ranges -> aws_service_ip_ranges
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
This syntax is not supported in python2.6. You will need to index your format like {0}
Only the type is needed here, not the default value, so just `:type cmd_verbosity: int` is needed.
Only the type is needed here, not the default value, so just `:type cmd_verbosity: int` is needed.
@mattclay what do you think of this? I think it's okay but I didn't trace through and see how stdout_text and stderr_text are used later to make sure.
also worthy noting, -G won't show actual ssh options used, just those configured
Add `cmd_verbosity` to the docstring.
shade isn't gonna be here anymore - see recent changes to the module utils. we have an sdk module returned now. That said - 2.6 and beyond have a hard requirement on openstacksdk - so we can probably skip this version check.
The old comparison is doing <=, not just <. So we need min_version='1.9.0' I believe.
Another <= comparison, so min_version = '1.10.0'.
Change `should` to `would`.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Easier to read if written like this: ``` python VALID_ARGS = tuple(frozenset(BASE + FROM_ARGS + OTHER_ARGS)) ```
Note: you don't have to use set explicitly here. The set methods can work with an iterable (which tuple is)
I think this is acceptable for now, but for the future, I think we should see if we can make use of post validating to cover all arguments in a single standard way.
And the same here
no, if the variable is set but empty, you should empty out the options
values in choices and default for bool should be `yes/no` according doc of ansible. it is a convention by Ansible. `required` should be true/false as it is a flag to show it is required.
I() for key and value
Debugging, I assume, but should be limited before merging.
`ip_range=dict(default='0.0.0.0/0', type=lambda x: to_text(ip_network(to_text(x)))),` could be used in `argument_spec` instead of this method: * inner `to_text` required because `ip_network` requires unicode in input * outer `to_text` required because `module_utils` [doesn't handle parameter which aren't basic type](https://github.com/ansible/ansible/blob/83ec4184701f77d4de68d0c52946fd80a13fbe0a/lib/ansible/module_utils/basic.py#L504) (except `datetime`) (`to_text` comes from `from ansible.module_utils._text import to_text`)
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
```suggestion except (OSError, IOError): ``` Since you are not using `e`.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
I don't see the point ;-)
Use to_native instead of str
Yeah, the way kubectl did it was to allow the user to specify a condition in the status field of an object. I think (even if we don't add this now) we'll end up needing to allow some flexibility in the wait condition. We could also ignore kubectl wait and just allow the user to provide a JSON path and value, and we could just wait for the path to equal the value in the requested object. Regardless we should still have good defaults for the most common resources, so if we end up needing that flexibility we could probably just add another `wait_condition` object down the line.
Is there any kind of generic predicate we could insert here? We could also allow the user to specify a predicate, as the `kubectl wait` command now does. We could also implement a wait function that attempts parity with `kubectl` in the client and just make use of it here, if you think that would make sense.
methods `start_server`/`stop_server`/`restart_server` are almost the same and could be factorized.
test of `wait` parameter could be moved inside the `wait_to_complete_state_transition` method.
Also we should still call this in case of check mode, and say whether it will be changed
`validate_certs: no` is less secure and so, we should avoid to use it in our example.
@phemmer , We've discussed this in the weekly Ansible VMware meeting. In my opinion, having a dict is useful, IF the key is useful: * The reason to have facts is to use them in a task later on * With a list, to find the proper disk, it is harder to find the item you want to match on ( `{{ (disks | selectattr('label', 'search', 'Hard disk 1') | list | first) }}` for instance) * With a dict, if the key is useful, it doesn't require that. If you want to match on another criteria, the loop is still a possibility. Proposal is to have the label as the dict key as it is what is visible in vCenter and is orderable, does that make sense to you? Any other criteria you might find easier? (disk.key is another possibility, but less 'visible' in vCenter)
I learned yesterday that nowadays we can simply do `import json` as we no longer support Python 2.4
Nothing specific, wanted to match other module style.
```suggestion ansible_vmware_validate_certs: False # default is True ```
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
This is always a tough question, and I'm not sure what's the best solution :) In Ansible, things are usually lower-case. I guess you have to decide what you want in the end :)
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
As mentioned before, the correct parameter is `state ` not `status`. Please correct this example.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
That's required. `0o600` works starting python 2.6. If authorized_key still wants to support 2.4 (not sure when this will die) one can do `int('600', 8)`, but that's probably not more readable than your suggestion.
`0o600` is more readable than `384`.
set type to 'path'
I'd move this block into it's own method since fetch_file will likely need it as well.
also need to return AnsibleOptionsError if the value of the config is incorrect
i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
Values we return are in bytes.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
I prefer `if not module.check_mode and change_string:`.
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
Use `elif` instead of `if`.
This statement seems useless.
Please remove the `else: changed = False`. That doesn't make sense. Instead, de-indent the `changed = True` above. Once `are_dicts_different(expect, current_state)` is `True`, `changed` should be set to `True` no matter if check mode is active or not.
And then for requests-status issues, have a separate clause.
I'm not big on returning `Exception` here I'd rather be specific to JSON-ish exceptions, like: ``` try: pass # blah blah code # on Python 3+, json.decoder.JSONDecodeError is raised for bad # JSON. On 2.x it's a ValueError except getattr(json.decoder, 'JSONDecodeError', ValueError) as e: module.fail_json(...) ```
This will raise a TypeError: `exceptions must derive from BaseException`
```suggestion "Cannot change option from (%s) to (%s) for an" ```
boto3_conn now handles region problems, no need to do it in the module
Not required with AnsibleAWSModule
If this is set to type='int' this should avoid the later type conversion
This logic seems ignore the use case of removing all tags.
Catch botocore.exceptions.ClientError instead of Exception here too.
```suggestion - Status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - Status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - URLs to retrieve a public I(blob), I(queue), or I(table) object. ```
I'd remove "Gets" from all of these descriptions, so they would read "The primary blob endpoint and connection string." etc.
```suggestion - Allows https traffic only to storage service when set to C(true). ```
It took me a while to figure how 'name' could be in DOCKER_RESERVED_IMAGE_NAMES. And then it hit me, `docker_container`, and probably `docker_image`, split the `image` parameter on ':', and assume that the first element is 'name', and the second element is a 'tag'. I think it would be preferable to have the code recognize when it receives an ID or partial ID value, and search accordingly. It would be nice if this could work with partial IDs, but this code will not support that.
`docker_py` use `id[:10]` as `short_id`, but `docker images` shows a 12-char version. I think there's no "standard" short version of `image[Id]`. "Registry returned more than one result for sha256:8fc" should be good enough. Users know what they're doing.
> I feel like a [WARNING] should pop up when you do that When specify a hash string that matches more than one image? We should `fail` immediately, this is users' fault.
No need to wait twice - the below lines do the same "wait" while respecting max wait time.
Leftover reference to `vcenter`.
Since this is a new module, this should be fixed from its beginning: ```suggestion supports_check_mode=True, ```
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
Use **digital_ocean_argument_spec** form DO utils.
Remove this because is already inside DO utils
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
```suggestion - Must be in the same resource group as VPN gateway when specified by name. ```
```suggestion - Can be the resource ID of the virtual network. ```
```suggestion - Can be a dict which contains I(name) and I(resource_group) of the virtual network. ```
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
```suggestion description: String that represents the octal permissions of the destination directory. ```
```suggestion description: Name of the group that owns the destination directory. ```
```suggestion description: Name of the user that owns the destination directory. ```
```suggestion description: Numerical ID of the group that owns the destination directory. ```
```suggestion description: numerical ID of the user that owns the destination directory. ```
this should note the version on which these requirements were added
state: type: str choices: ['present', 'absent']
use full names read-only, read-write
Python 3 versions are packaged in `python3-libselinux` and `python3-policycoreutils`. But the module needs just `selinux` and `seobject` python modules and version depends on the current interpret version. I don't know how to make it understandable and correct. On lines 267 and 270 I'd probably use module names could be used instead of package names: ```` module.fail_json(msg=missing_required_lib("selinux"), exception=SELINUX_IMP_ERR) module.fail_json(msg=missing_required_lib("seobject"), exception=SELINUX_IMP_ERR) ````
Ah, sorry I missed that earlier: ```suggestion default: yes ```
incorrect with `default` specified; remove
use `choices`, ditch inline "possible values" text
doesnt --> does not
I would prefer to say name. But Iâm ok if you want to stick with this here. Or maybe client_config_name.
"Whether the specified user is locked"
You can remove the brackets here.
This has been resolved.
I would remove this blank line.
I would remove this blank line.
The `type` value should be quoted: ```python force=dict(type="bool", default=False) ```
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
Remove this as it is already declared above.
```suggestion - The application key to use. ```
The description needs to have a trailing dot. (The short_description does not)
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
Same here, trailing do required.
Not required ? Don't say so. This is implied.
This should be `type: bool` IIRC.
@pierremahot we'll need a test for this
It's not the most ideal code that I wrote, so if you feel you could improve things, especially function and variable naming â go for it :) For example, function names normally designate actions and start with verbs (like `get_logical_rows()` or `extract_logical_rows()`), as opposed to variables, which are typically names of some things / nouns. Keep in mind that I did a very quick sketch, so I might've missed some things, I rely on you here to check whether it fixes the issue and doesn't cause new problems.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
You can completely drop this conditional, since iterating over empty iterable produces the same effect.
Actually, you can replace this dancing around if+for+append+extend (lines 245->250) with a simple list comprehension, which would look better readable: ```python obj['interfaces'] = [i.replace('Gi', 'GigabitEthernet') for i in interfaces] ``` It will produce the very same result.
Is there a reason why this can't be a bool option, most modules just have `validate_certs` as a boolean option for this behaviour and it would be nice to be similar.
that is why database_name is not a common arg
it may be possible that each module will override it inside by under argument_spec.update()by adding database_name
i suggested same fix to lib/ansible/module_utils/influxdb.py some time ago in PR #31566
So, this means if no database is given, database is None. The common args does not have to match the args in the influxdb-python lib. If we add a `database_name` to the common args, it means that in the module influxdb_user, we can pass a database_name which is not handled at all and does not make sense.
```suggestion allow_downgrade: true ```
The reason I mentioned this to be discussed is: https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-basics > Use lowercase âtrueâ or âfalseâ for boolean values in dictionaries if you want to be compatible with default yamllint options. But if maintainers prefer `yes/no` feel free to ignore my suggestion.
```suggestion fail_on_autoremove: yes ```
s/run the/run in the/
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
This note probably no longer applies, unless you'll be making a Windows version. Since this module will not work on Windows, it should be noted. (at least I think it won't? All the windows modules use powershell so Â¯\\_(ã)_/Â¯
Should note about `is_dir` and `is_link` here.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
There is a default value for `executable` module parameter: then `get_bin_path` will never be called.
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
same here, we really dont want to test the particular setting, just that both the default (dynamic template) and the nii entry are correctly parsed.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Yes. Either to_native or to_text would be fine in this case.
You can remove this. If there isn't a specified return, None is returned.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
We don't need tags in this function, I think.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
So we tend to not do the else if the previous if-block returns from the function. The else is unneeded.
Beware that the fourth positional argument has shifted, so if people used this interface using positional arguments it may break. (I don't think there's a risk, as we can safely assume you're the only user of the interface...)
I think this would be more readable if you do: ```python org_id = self.get_org_id(org_name) net_id = self.get_net_id(org_name, net_name, data) path = '/organizations/{org_id}/networks/{net_id}'.format(org_id=org_id, net_id=net_id) ``` So using positional arguments where there's no discussion, moving different operations in separate steps, and bring the information together at the very end. The path-string could be coming from somewhere else (if this is something that is being reused, but probably not relevant here).
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
Looking at the code now, it's wrong. You don't have `self.error` anymore. And the KeyError will never hit, so you surely didn't test these failures. (integration tests !) There's also no difference between `>= 300` and `>= 400` so I guess `>= 300` only would do (but I don't know if that is intentional).
Since you return above, unnest the `raise` here.
`del` is a builtin, not a function. These parens don't have to be here
This feels to me like it would be better as a function that would take a dbinstance and convert it to the facts dict, then a separate one to diff dictionaries rather than a class.
Missing HostedZoneId here which is important if you want to set a route53 ALIAS record later
I think this needs to be a dict since it's used as-is in the call to ansible_dict_to_boto3_filter_list().
The routing file should be parsed once per invocation of validate-modules instead of once per module.
```suggestion parts = to_native(date.strip()).split(':', 1) ```
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Same as for the updated, I'd rather say `has been deleted`
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
```suggestion ansible_vmware_validate_certs: False # default is True ```
Nothing specific, wanted to match other module style.
It is available in PR. Added on https://github.com/ansible/ansible/pull/55059/files#diff-2c15779308a54e8ac33b5eba806f6e5bR84
```suggestion - Password for the user in guest operating system. ```
```suggestion action: remove ```
VM or VirtualMachine
```suggestion library_id: '13b0f060-f4d3-4f84-b61f-0fe1b0c0a5a8' ``` This will hint user that, user is expected to enter something similar.
This should be "Delete a tag"
```suggestion content_lib_details: ```
The next `if` should come first. The module should die if not all DBs exists no matter whether it's in check mode or not.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
```suggestion module.exit_json(changed=bool(non_existence_list), db=db_name, db_list=db) ```
You're right, it always returned `True` before. There's a difference to before, though: before, `db_create` *always* returned `True`. Now, it only returns `True` if creating all DBs succeeded. So the `if changed:` can be removed in line 426, and the `if` block can always be executed. As long as `db_create` didn't result in an exception (in which case the module dies), all DBs should be there anyway.
While you can create dict comprehensions in python 2.6, you don't need to here: > tags (dict or list) â Either a dictionary containing name/value pairs or a list containing just tag names. If you pass in a dictionary, the values must match the actual tag values or the tag will not be deleted. If you pass in a value of None for the tag value, all tags with that name will be deleted. ``` tag_remove_list = [x for x in tagdict if x not in tags] ``` The 2.6 equivalent, for reference, is ``` dictremove = dict((x, None) for x in tagdict if x not in tags) ```
can probably remove the `tagger = ` here, as nothing is using it
This logic seems ignore the use case of removing all tags.
Same order, type first.
`policy` should be added to `argument_spec` to be usable.
You could even rename the fixture to something other than `fake_xenapi` if desired.
This needs to be in a fixture so it doesn't affect all unit tests. To avoid the need to reference the fixture on each test you may want to use `@pytest.fixture(autouse=True)` on the fixture. Perhaps something like this: ```suggestion @pytest.fixture(autouse=True) def fake_xenapi(): xen_api = importlib.import_module('units.module_utils.xenserver.FakeXenAPI') sys.modules['XenAPI'] = xen_api return xen_api ```
Use whatever fixture names make sense. Personally I'd probably name the fixture `XenAPI` since that's the import it is replacing. Then there's no need to assign `XenAPI = fake_xenapi`. Setting `autouse=True` only loads the fixture for the test automatically. If you want access to that fixture as a local, it still needs to be a function parameter. The benefit to autouse is that it guarantees the import will be mocked, even if the test doesn't require a reference to the fixture. However, there's nothing wrong with specifying an autouse fixture as a function parameter. Doing so simply makes the auto-instantiated fixture available as a local within the test function. To guarantee correct fixture order, declare that the `fake_xenapi` fixture is used by the fixture providing `ansible.module_utils.xenserver`. Modifying `sys.modules`, or making other changes to global state, outside of a test fixture or function will apply those change to all unit tests (everything under `test/units/`) when pytest collects the tests before they are executed. Since we run unit tests with the pytest `--boxed` option, each test is run in a separate Python process after the initial collection is performed. This means that any global state changes made in-process by a test function are discarded at the end of that test function, but all changes made during collection are shared. Imports handled during collection will result in changes to `sys.modules` that will be shared across all tests. This is fine for regular imports. However, the mocked import for `XenAPI` is specific to the tests in `test/units/module_utils/xenserver/`, so it should be restricted to those tests. If another test, such as one for a xenserver module were to also mock `XenAPI` they would conflict.
You shouldn't need to assign `XenAPI = fake_xenapi`. What mocker.patch calls are you trying to make that require that? To have access to `ansible.module_utils.xenserver` in tests without importing it in each test function, you could wrap it in a fixture.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
The use of 'no' is problematic in YAML since it must be quoted to be a string. If it is not quoted it turns into a boolean False, which is not an accepted value according to `choices`. So we may want to use a different value to disable this. ```yaml master_use_gtid: disabled ```
Impossible, the value is a string, so it will translate to 'False', which I'd rather not add to the `choices` list as well. Using `no` or `yes` as a string value is problematic, best to avoid.
Sure, I can do that. Thought it might be related since those features are typically used together.
This mixture of snakecase and camcelcase for method names seems a bit strange and divergent from typical python best practices. A bit of syntactic nitpick but it is nice to follow standard practice.
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
```suggestion - Network backend to use for this definition. Currently supports `networkd` (default) and `NetworkManager`. ```
Unless it's a specific value, leave the default out and put it in the description like you have done.
Thanks for that clarification. Upon reviewing the code, it wasn't obvious to me that this module is actively using both connection paths (to the k8s API and also to the Upload Proxy.) I've taken your word for it and updated my related PR.
not a blocker: `required: false` is the default, can be omitted
@zikalino Are you able to confirm this, my assumption is that we needed to pin the modules to a specific version.
It seems network integration test is failing because of PR #47345, hence reverting the PR
```suggestion else: ``` I'm trying to make sure I understand what's happening here, will this change have the same intended effect? (I don't know if anyone else likes for-elses as much as I do, but it would allow you to get rid of the `ignore_line` sentinel variable)
I think this should be 'exit' instead of 'abort'
What is the reason to add second while loop here? Does the call to `recv_ready()` increase the delay amount. How about chaging it to ``` while True: if self._ssh_shell.recv_ready(): data = self._ssh_shell.recv(256) <--snip--> ```
It is not recommended to log commands executed on the remote device due to security reasons.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
I'd recommend adding a main() and a 'if __name__ == __main__: main()' here, but thats optional.
You can remove the `required: false` lines, it's implicit
Please remove `required: false`
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
In addition to the error message from boto, can you include a nice message like "ClientError while listing SSH public keys" for users? Also, please catch a generic exception and fail with the traceback, like `module.fail_json(msg="Could not list SSH public keys", exception=traceback.format_exc())`
Can remove this one. If there is a credentials issue it should happen when the connection is created, I think.
This line doesn't need to be in the try/except.
botocore.exceptions.ProfileNotFound may also be raised
These tests are made redundant by mutually_exclusive, required_one_of and required_together below.
Can get rid of required=False.
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
I think this logic should be handled by service instead of ansible client side
What if the rest service_principal missing client/secret field
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
`self` is no need
Note -- Looks like you have 'min' as a valid subset but in this current version of the code it's not being used to control whether this is run. Either need to make use of it or remove 'min' as an option so that it's clear that this portion of fact gathering is always run.
Better to do this transformation into a list via the setup module's argument spec rather than here.
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
Change this to `self.ansible_facts['ansible_net_gather_subset'] = list()` as it is `ansible_net_gather_subset` in legacy facts module.
The name as per conventions can be `existing_lag_interfaces_facts` and `get_lag_interfaces_facts`
connection = module.client('storagegateway')
AnsibleAWSModule checks this
Same here: paginator please http://boto3.readthedocs.io/en/latest/reference/services/storagegateway.html#StorageGateway.Paginator.ListVolumes
Use a paginator
Use a paginator: boto3.readthedocs.io/en/latest/reference/services/storagegateway.html#paginators https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#api-throttling-and-pagination
It would be great to see an example rather than just None
Use an informative key instead of `instance` for example `network_protocol_profile_info`
Use existing methods from `module_utils/vmware.py`
```suggestion self.module.fail_json(msg=to_native(e)) ```
```suggestion ip_pool_assoc = vim.vApp.IpPool.Association() ```
`import_role` supports those keywords, but for inheritance, for include it applies to the task itself, the original phrasing was more accurate
`until:` is the proper keyword for those loops
These lines should probably be moved to `notes:` and not just deleted.
Omit these lines please.
Easier to read if written like this: ``` python VALID_ARGS = tuple(frozenset(BASE + FROM_ARGS + OTHER_ARGS)) ```
Yes, present usually is the default state. In some cases there is no default state (which means the user is expected to provide it explicitly).
Strings don't need to be quoted in YAML.
Typo: persent Also, I find it strange to have values surrounded by round brackets.
A golden rule I use is to alphabetically sort items in a list if the order is of no importance. It helps compare lists or finding items in a list more easily.
You can use `L(UCS Platform Emulator,https://communities.cisco.com/ucspe)` to get named links.
As per naming convention, the name is `get_lldp_global_facts`
Name as per convention can be `lag_itnerfaces_facts`
The name as per conventions can be `existing_lag_interfaces_facts` and `get_lag_interfaces_facts`
Same as above and applicable at other places as well
like diff = load_config(self._module, config_xml, [])
Maybe even better: ```suggestion new_item['aliases'] = sorted(new_item['aliases'] or []) ``` To convert `None` to an empty list.
```suggestion old_item['aliases'] = sorted(old_item['aliases']) ```
Also note that simply sorting does not necessarily give the correct result for lists of dicts. So this change could actually recreate/update services where nothing changed.
```suggestion zip_data = zip(sorted(new_list), sorted(old_list)) ```
I spent more time than I care to admit to understand what was going on here... What would you think of removing the keys from the newly created dictionaries instead of creating new ones? ```suggestion for key in ignored_keys: old_publish_item.pop(key, None) publish_item.pop(key, None) return publish_items != old_publish_items ```
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
```suggestion - name: list hooks for a repository on GitHub enterprise (token auth) github_webhook_facts: ```
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
Sounds a strange behavior to me to apply the change only on the first matched NICÂ when the definition does not indicate a single object. Either apply change on all matched NICs or fails sounds more logical to me.
I think this description is off :)
```suggestion - Number of containers instantiated in the service. Valid only if I(mode) is C(replicated). ```
The numbers should be in C(...), I think.
```suggestion if self.client.module.params['disk_usage']: ```
is there a reason why you have a native str, I would have assumed it was a byte str beforehand for a reason. I know the tarfile is very particular about the type of string being used.
This should probably mention both slash and no-slash paths...
Probably a typo here? ```suggestion shutil.rmtree(b_path) ```
I'd do this unconditionally.
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
Not possible to glean the volume type from the result of get_volume and choose the right operation automatically? If not, these admonitions need to be in the docs, not in the code...
Any way to block/poll for completion on this? Otherwise this is a built-in race condition for anyone that wants to do anything with a renamed infinite volume from Ansible...
docs should probably specify that deleting an infinite volume is not synchronous
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
see previous discussion on renaming idempotently
This block would be a bit more legible, if you checked use_hostnames, then assigned to a temp variable whichever label the user has requested, and then appended that. Something like (pseudopython): ``` this_host = host if not use_hostnames: this_host = ip if frontend: frontends.append(this_host) else: backends.append(this_host) ``` This is admittedly a style thing, but I think it would be more readable/shorten a few lines.
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
Please add `, no_log=True`
Please rewrite as ``` if __name__ == '__main__': main() ```
just call scaleway.ini we are in ansible conflict should not occur
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
All the more reason to not use key=value format in the samples; works fine with YAML
You're correctly using `type='list'` in the arg_spec, so probably better if at least one example used the native YAML format and showed multiple values as list elements. The arg validator will properly handle coercion of a single value to a list (as the current examples show).
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
Again, suggest rewording this as suggested for win_http_proxy.
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
Add "- Works only with >= Zabbix 3.2" same probably goes for other arguments related to `recovery_*`
```suggestion if self.state == "present": ```
Remove parans for every if ```suggestion if find_vm_by_name(self.content, self.name, folder=folder_obj): ```
```suggestion if not dcpath.endswith("/"): ```
```suggestion if not datacenter: ```
```suggestion changed = False ```
add an alias to `domain` as `domainname`
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
Because this parameter was added for backward compatibility with **vmware_dns_config**. We could add it as an alias and keep it forever, but I am not in favor of keeping lots of aliases for the same purpose.
If we are creating a new module then why to add old parameters which we don't want in first place.
```suggestion if host_network_info.atBootIpV6Enabled: if host_network_info.ipV6Enabled: ... elif host_network_info.ipV6Enabled is False: ... else ```
What's the point of this change. I can't see any other usage of `delegate_args` below in this method.
not a blocker, but a small optimization, `elif` will avoid the check if fail_msg was `None`, since you are hardcoding to string you should not need to do this
also worthy noting, -G won't show actual ssh options used, just those configured
the shell itself would have done it before. but might have done it slightly differently.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
String or list are allowed here so no change is required.
1) There is rarely more than one author. 2) The same principle is used elsewhere in Ansible that you can use either string or list.
`author` is a list, so it should be: ```yaml author: - Kairo Araujo (@kairoaraujo) ```
The value doesn't have to be quoted.
```suggestion short_description: Manages AIX devices ``` The short description has no trailing dot, all other descriptions do.
Shouldn't be required.
You can import HAS_BOTO3 from ansible.module_utils.ec2 so you don't need to set the value here or in the except ImportError.
can delete this line
ansible.module_utils.ec2 sets HAS_BOTO3 to the correct value.
```suggestion pass # Handled by AnsibleAWSModule ```
I think this should be 'exit' instead of 'abort'
I don't really like storing flags on the instance level. I think it'd be cleaner if this var was scoped to this method. Or maybe even factor out state store into a separate class (w/ Enum values maybe).
Do you really need this extra var? Maybe just save stuff there right away? ```suggestion b_output, b_tmp_stdout = self._examine_output('stdout', b_tmp_stdout, sudoable) ```
```suggestion self._connection.queue_message('warning', 'Unable to configure cli columns, command responses may be truncated') ``` And then remove the `Display` import above.
It probably makes sense to clean-up flags before exiting this method.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
```suggestion Test that the returned value for timezone consists of only uppercase ```
If self.desired_state is 'present' and all the ntp servers are already present (so host_ntp_servers == []), state take the value "absent"â¦ so self.results[host.name]["current_state"] = "absent"â¦ which is not what's expected.
It looks like this is just a serial upload, how is this faster than the current S3 module? I definitely see the benefit of the glob & sync strategies, but it seems like this would be just as fast.
Maybe? ```suggestion self.facts[host].update(value.get('ansible_facts', {})) ```
For EOS, following line is also required after this line: ``` commands.append( 'no switchport mode trunk') ```
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
Please include an aggregate example
Perhaps change to `ONLY` to make that statement stand out a bit more
There's some mixed spaces and tabs here, please remove the tabs and use spaces only.
It's not the most ideal code that I wrote, so if you feel you could improve things, especially function and variable naming â go for it :) For example, function names normally designate actions and start with verbs (like `get_logical_rows()` or `extract_logical_rows()`), as opposed to variables, which are typically names of some things / nouns. Keep in mind that I did a very quick sketch, so I might've missed some things, I rely on you here to check whether it fixes the issue and doesn't cause new problems.
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
@sivel Maybe we should have a check for this in Shippable CI, as I see more and more modules using requests. ``` [dag@moria ansible.git]$ grep -rlE '(import requests|from requests)' lib/ansible | wc -l 35 ```
We do actually, it's done in validate-modules. However `validate-modules` doesn't do a verification in `module_utils`. A code-smell may not be bad. However there is also strange logic for checking this, as a few modules snuck in after the re-combining core and extras into the main repo, when validate-modules had some broken functionality. So we would have to add skip lists. There are also a few modules which by extension of another dependency use requests, such as some cloud modules, so they import to get access to exceptions.
We tend to use HAS_REQUESTS as a standard way of doing this, but... We actually prefer that modules use *lib/ansible/module_utils/urls.py*, specifically **fetch_url()** or **open_url()** for anything HTTP/REST based.
Whoaw, I knew there was an impact, but did not suspect this. This is ugly. cc @kbreit Opened a ticket for this. https://github.com/ansible/ansible/issues/52717
Needs to include the platform. This string is used on https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
```suggestion - Name of the domain to be managed. ```
```suggestion - The desired state of the domain. ```
```suggestion - Size of the domain. ```
Why do we have `default: ""` here ? The default is `None` but that doesn't have to be exposed. I would leave the default out of this.
+1 to adding that note :)
`If not specified, will fall back to the C(MCP_USER) environment variable or credentials specified in C(~/.dimensiondata).`
Please update formatting as per `mcp_user`
No full stop needed on `short_description`. All other `description:` fields should be full sentences.
Actually, the `dimensiondata_network` module already has metadata: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/dimensiondata/dimensiondata_network.py#L25
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
Hmm, nevermind. It seems that if I remove the `resource_pool` argument altogether then everything works fine. Previously this value was set to `Resources` even though we don't have any explicit resource pools, but without the value an error was thrown previous to this commit.
you can remove this condition as the previous condition already handle other cases
There are other parameter to find an existing VM using `get_vm` API such as `moid`, `uuid` and a helper parameter `use_instance_uuid`, it would be great if we can implement these parameters as well. This will make all guest module parameters equal and this module future proof.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
You can raise from here.
I think this would be more elegant with `any()` semantics + as efficient because of generator: ```python if not any((s in return_tuple[1]) for s in NOT_SSH_ERRORS): raise AnsibleConnectionFailure("Failed to connect to the host via ssh: %s" % to_native(return_tuple[2])) ```
or ```python if all((s not in return_tuple[1]) for s in NOT_SSH_ERRORS): raise AnsibleConnectionFailure("Failed to connect to the host via ssh: %s" % to_native(return_tuple[2])) ```
Instead of doing a conversion here, just modify the NOT_SSH_ERRORS structure to contain byte strings instead: ``` NOT_SSH_ERRORS = (b'Traceback (most recent call last):', # Python-2.6 when there's an exception # while invoking a script via -m b'PHP Parse error:', # Php always returns error 255 ) ```
This was already in pre-existing code, but it doesn't seem like the 'else:' is necessary here, and the rest of the method can lose an indention level.
Your module is named `gitlab_project_variable` don't use plural in your example
Change this parameter for a more explicite one : `project` This one should handle project `path` or `id`
Since each of your attributes have only one attributes, what's the point of making a list ? Usage of a simple dictionary should be more easier to understand. ```yaml vars: ACCESS_KEY_ID: abc123 SECRET_ACCESS_KEY: 321cba ```
Use best practice to handler this error : ```python GITLAB_IMP_ERR = None try: import gitlab HAS_GITLAB_PACKAGE = True except Exception: GITLAB_IMP_ERR = traceback.format_exc() HAS_GITLAB_PACKAGE = False ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
Requires a trailing dot.
`Manage Cisco NSO configuration and service synchronization`
This should be quoted.
Fixed in https://github.com/ansible/ansible/pull/34186
Could you please use `AnsibleAWSModule` instead? We didn't have a lot of the aws utils we do now when this was first PRd, it will save having to port it later on. https://docs.ansible.com/ansible/devel/dev_guide/platforms/aws_guidelines.html#creating-new-aws-modules
Please remove choices for `type='bool'`, as `bool` accepts yes,1,true, etc.
For things with this many arguments, I'd really like to see keywords used to avoid any order mixups in the future.
It would be good to have some tests for check mode too.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
For this failure, can you include the exception? Something like `module.fail_json(msg="Couldn't connect to AWS: %s" % e.message, exception=traceback.format_exc())`
I think things like this will traceback in check-mode because changed hasn't been set to a default value (Should default to True). Also, for this particular module, check_mode doesn't seem to be doing anything so you probably just want to say supports_check_mode=False when creating the AnsibleModule.
When a module does not support check mode, ansible always reports that it would have changed something which is the safest assumption for the user.
I think it should look like this: ``` python from ansible.module_utils._text import to_native [...] def enable_ds(module, array): """Enable Directory Service""" try: array.enable_directory_service() changed = True except Exception as e: module.fail_json(msg='Enable Directory Service failed: Check configuration: %s' % to_native(e)) module.exit_json(changed=changed) ``` One thing I'm not sure about is how we tell if array.enable_directory_service() made a change or not. Our users generally define Ansible's idempotence as: * they describe the state they want in a playbook task * the module makes the state match what is in the playbook * the module returns changed=True if something had to be changed to achieve the desired state or changed=False if the state was already as desired. This code probably does the first two but it's not doing the last one. I'm not sure how to fix it because I don't know what array.enable_directory_service() does. If it returns a specifc exception if the directory_service was already enabled, then we catch that specific exception and set changed=True for that. If it returns a status code telling whether it had to make a change or not, then we can use that to set changed. If neither of those, we would have to query the current state of the toggle first. If the toggle is already enabled, then set changed=False and call module.exit_json(). If the toggle is not yet enabled, call array.enable_directory_service(), set changed=True, and then call module.exit_json(). (Also note, these notes on changes also apply to the other verbs you have in this module: disable_ds, delete_ds, and create_ds)
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Same typo as above
```suggestion return to_text(v.ip) ```
If the previous condition catches size=2, would this ever reach this condition for size==2? ```suggestion if v.size > 2: ```
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_USER']), ```
i would mention this plugin is Windows specific
```suggestion short_description: Execute tasks inside a VM via VMware Tools ```
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion - pyvmomi (python library) - requests ```
`Public key to add to .ssh/authorized_keys.` Missing full stop May not be run as root
If I'm reading the code correct, does this only work on proxmox 4.2+? If so may be worth stating that here.
As this option has been added since the module was released, please add `version_added: "2.3"` under `unprivileged:`
this would make it incompatible with the service interface
```suggestion - Path of the authentication file. Default is ``${XDG_RUNTIME_DIR}/containers/auth.json`` ```
Default type is `str` so you don't have to set it explicitly. Just use `size=dict(),` instead. The same bellow.
use python bool for the default `default=False`
Too long line.
Line is too long.
Line is too long.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
For `mode == 'persist'`, you have to both check the current value *and* the value in the `mysqld_auto` config.
I wouldn't emit this warning. After all, the warning is just saying "the module is doing its job, nothing out of the ordinary".
Why not ```suggestion if mode in ('global', 'persist'): ``` ? :)
How about moving this in the main `if:` branch above? Then there's no need to do funny tricks for `mysqlvar_val` in the `elif:` branch.
I would remove the previous and the current line. If you write `persist_only`, you want to make sure that the variable is set in he `mysqld_auto` config. If it is not set there (but it is set in the running instance), you still want to execute the query.
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
timeout isn't defined in `argument_spec`
Total time, in UNITS, to run stress for.
if requied is true, default does not make sense
Don't add `required: false`. It is implicit.
use `choices`, ditch inline "possible values" text
Should be specific about what's being forced in the arg name, something like: `force_removal_with_mapped_luns`. These tend to grow over time, and generic names like `force` are problematic for someone just reading the playbook to know what it does without consulting the docs.
@carchi8py it's declared at int below, so this should be a safe change.
`type: bool`? `default: false` (and remove the redundant default text)
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
Just style, there should be a blank line between stdlib imports and the next set of imports (in this case, imports from ansible)
Just style again. We use this style for most identifiers (including function names): ``` def user_details(module): ``` For classes we use CapWord like: ``` python class PasswordSession: pass ``` We don't use initial-lower camelCase anywhere.
There should be an example of ```cyberark_session``` somewhere. So that users know what to put in it.
Note that there are other pieces of code that need this same fix.
If we don't know whether a change would be made or not, we should always return changed=True. It's better for a user to run their playbook unnecessarily than for a user to miss out on running a playbook to make changes because check_mode reported False.
actually .. uptime is a bad check then, since you get a race condition in the case of 'chained reboots' not something that will happen often, but you can get to the point in which the previous uptime < current uptime even though you rebooted. You should check the uptime vs the time since you started the reboot.
I'm wondering if we should just switch to using this command rather than `who -b`, then `uptime-s`, then `cat ...`. Since this is Linux specific, it doesn't work on FreeBSD/Darwin/Solaris, so we would have to implement a lookup dict for boot time commands as well.
The `uptime -s` (and `who -b`) command return a string that is the time the last system was booted, different than what `uptime` is normally used for, which is reporting _total_ system up time. The plugin doesn't do anything more than look for the output of this string to change. If it has not changed, it assumes the system has not been rebooted. Since it is not doing `timedelta` comparison on the uptime output, I do not believe we will hit the scenario you describe.
My next question was going to be if the random boot ID is widely available. I guess I'll have to do some research to see when it was added. I created a WIP PR (#45656) exploring what it would look like to add platform and dist to the plugin. I'm not terribly happy with it, but it's a start (and it accounts for Alpine, which is particularly annoying since it lacks both `who` and `uptime` for no good reason (IMO)). That PR also changes to using the random boot ID by default rather than `who -b`. That has the nice side effect of being able to remove the `uptime -s` command for systems that lack a RTC, but at the cost of all the added complexity of platfrom and dist checking.
I would aggregate both errors here, both 'uptime' and 'cat /proc..'
need a `version_added`
I think it's better to refrain from abbreviations in formal/written text. (At least that's what we learned at school) So make that: ```python module.fail_json(msg="DNA Center did not return JSON compatible data")` ``` So it doesn't look like nested quotes.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
I don't see the point ;-)
When required is false, it can be left out (since it is the default).
This seems to be a leftover, there is no state "updated" anywhere else in the code.
space looks unnecessary
This shouldn't be `required: True` since realm may be provided instead.
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
The `: ` is confusing the yaml parser, you can remove it or quote the whole line.
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
Read operation: ditto
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
This one will fail, since selfsigned_notBefore and selfsigned_notAfter have changed their meaning from the initial draft and don't have default values any more.
okay, but it still find it misleading from reader's point of view. i think, it's important to make it better maintainable. P.S. I've hid concat based implementation, once noticed that it's not only about lists (which was not obvious).
Oh, and it's `KeyError` for dict.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
This is more efficient: ```suggestion key = next(iter(old[0]) ```
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
```suggestion - C(number_of_workers), number of workers for app service plan. ```
```suggestion - C(name), name of app service plan. ```
Are all five parameters required for the dict to work? ```suggestion - Can be a dict containing five parameters, defined below. ```
```suggestion - Can be the resource ID of an existing app service plan. For example, ```
```suggestion - Resource id, eg. /subscriptions/<subs_id>/resourceGroups/<resource_group>/providers/Microsoft.Web/serverFarms/<plan_name>) ```
This one will fail, since selfsigned_notBefore and selfsigned_notAfter have changed their meaning from the initial draft and don't have default values any more.
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
Should have been module.fail_json
This could move even more down. After listing apps.
Various modules allow to specify the name of the executable in order to use a binary from a non-standard location (i.e. a binary not located in the PATH). Look at e.g. the isoextract on how to do this.
No need to split the line.
Not sure if this piece is doing exactly what you expect in all cases.
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
As per naming convention, the name is `get_lldp_global_facts`
Not tested, though this may lead to a similar issue as https://github.com/ansible/ansible/issues/20391 due to `timeout` having a default value
You can use `module.deprecate` to throw a deprecation warning.
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
This condition can be removed
This currently does not handle lists of items. We need to support it here.
just a small typo, serached->searched
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
```suggestion out = run_gluster(['volume', 'heal', name, 'info'], environ_update=dict(LANG='C', LC_ALL='C', LC_MESSAGES='C')) ```
If rc != 0 it is always err. You don't need out or err.
This will throw an exception every time when a server is down. When glusterfsd is down the output looks like this: Brick 10.70.43.200:/mnt/engine Status: Transport endpoint is not connected Number of entries: - And you'll be trying to do int('-') which will throw ValueError. And the module throws error: fatal: [10.70.42.25]: FAILED! => {"changed": false, "msg": "Invalid heal status option."} in the function main.
Where are we checking if the GlusterFS version is indeed > 3.2 Refer the peer module.
s/status is/facts are/ Since we are returning the facts, which also includes status.
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
`def get_recommended_datastore(self, datastore_cluster_obj=None):` â `def get_recommended_datastore(self, datastore_cluster_obj):`
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
```suggestion if not all([hostname, username, password]): ```
```suggestion username = self.params.get('username') ```
`Current host '%s' can not be rebooted...`
```suggestion def state_update_library(self): ```
`Current host '%s' can not be %s...`
use `get_best_parsable_locale` instead `from ansible.module_utils.common.locale import get_best_parsable_locale` though you might need to set it in `main()` after instantiating the `module`
also you might want to wrap `respawn_module` call
I think this should be more distinct: ```suggestion except ImportError: HAS_DNF = False else: HAS_DNF = True ```
I don't mind the current structure. I'd even be ok with setting `HAS_DNF = True` outside the `try` `except`. `Â¯\_(ã)_/Â¯`
We might want to introduce new/old git dir path in the result.
Why uppercase? I think the standard is to use lowercase. It's bad practice to pass args through that use * and ** to unpack. Better to be explicit about what arguments are being passed in.
Purestyle note: add a blank line between python stdlib imports and ansible imports
Unnecessary blank lines here, removing these blank lines is preferable.
@pilou-, cyberark-bizdev I had a chance to talk to bcoca today and he said the best way to do this is to pass a list of dicts to the lookup. Then either of these playbook constructs can be valid: ``` with_cyberaskpassword: - {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'} - {'appid': 'Application2', 'query': 'safe=Safe2;Folder=root;Object=User2', 'output': 'password,passprops.username,passprops.address'} with_cyberarkpassword: {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'} - debug: msg='{{ lookup('cyberark_password', {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'}) }}' ``` Implementing that will take a little restructuring. I'll go into that in the run method below.
Okay, so @cyberark-bizdev take out my first example. The last two are what we're shooting for. (The middle one is the same as bcoca's example, just in compact yaml instead of "readable" yaml ;-)
I would split these ('install' and 'install --offline -p -r etc') into two separate tests so any failures are more specific and granular.
@webknjaz we have no gaurantees that the artifacts are being built from a git checkout.
I think this may read better: ```suggestion if missing_keys: ```
I'd do ```suggestion if not ignore_errors: raise ```
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
You could probably do something like ```diff - self.dns4=' '.join(module.params['dns4']) + self.dns4=' '.join(module.params['dns4'] or []) ``` This works fine for me.
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
Meh, what you have is fine for now- they're basically singletons already, so that constructor arg is probably superfluous, but I don't think there are any active plans to kill it... Just IIUC whatever reason it existed for in the first place doesn't exist anymore. So this looks good to merge to me.
this got named use_backend
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
Add that the user can specify the backend to use via the ```use``` parameter.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
we want want -> we want
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
probably should just be an error as we won't be able to find the role and later on we'll fail with 'role not found'
use display.warning instead (has internal dedupe to avoid warning spam)
> Are you suggesting to just duplicate the code from build_summary() within each for loop? Nope. It just seems like this nested function could be a method or a standalone function. > I don't see how having the nested function within _create_role_list() makes testing harder, In order to unit test `build_summary()` you would need an instance of `RoleMixin`, then call `_create_role_list()`, and then write the test in such as way as to only run `build_summary()`. It just makes it harder to get to _just_ `build_summary()` for testing, which makes it harder to throw tons of varying inputs at `build_summary()`.
Does this need to be a nested function? The overall cyclomatic complexity of this method is 8. I bet it could be reduced by removing this nested function. It would also make this method (and the function) easier to test.
How about: ```suggestion if not os.path.exists(file_path): continue ```
`A list of virtual machine names starting with the given regex`
Period at end.
A sample of output would be helpful.
Can be removed, indeed, check other newer modules :)
Period at end.
Since all of these appear to be constants, it seems to me that making them tuples instead of lists would be good to avoid accidentally modifying them.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
For these to be a tuple you need a trailing comma, like `opsworks_fields = ('layer_id',)` for all single-item tuples.
Generally I'm not so happy with this long list of if statements. What I would rather have is a set of named objects (like the `eg.policy`) and a set of lists of relevant parameters (`eg_policy_params=['policy_name', 'namespace....`) and then iterate through the list to build the object from the original policy object. I think this would be easier to maintain in future.
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
You can actually skip all the expanduesr business by using `type='path'` instead, then Ansible will parse out a fully qualified path automatically.
You can avoid the need to import boto3 by just importing HAS_BOTO3 from module_utils.ec2
There are a lot on non PEP8 assignations here. Basically, in a dictionary or method call, there shouldn't be a space around the `=` operator. For assignments, there should be a space around the `=` call. So line 171 here is wrong, lines 168 and 172 are right
everything below here should be in a create_api_gateway_deployment function. That function should only be called if state is present. Might be worth raising a NotImplementedError if state is absent (or just failing with a similar message)
`ClientError` often has useful info in e.response: ``` module.fail_json(msg=msg, exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response)) ```
Small merge error - need to delete these 2 lines: ``` elif command == "GetPsuInventory": result["psu"] = rf_utils.get_multi_psu_inventory() ```
Even though the only Chassis commands currently are the LED ones, I think it would be good to set up the above code block to handle multiple commands (similar to how the Systems and Accounts blocks are structured). i.e. Have a `for command in command_list:` block so that if and when new Chassis commands are added, the new code would just be an additional `elif` block within the existing `for` loop. Hope that makes sense.
See suggestions above about naming and using 'dict' type to avoid the use of ast.literal_eval(). ```suggestion result = rf_utils.set_network_protocols(module.params['network_protocols']) ```
Not all chassis will have a `Power` property. Should check for `if 'Power' in data:` before proceeding with this line.
The value in `msg` should be wrapped in `to_native()` to ensure it is the correct string type based on the Python version. `from ansible.module_utils._text import to_native`
This should also support whether a regions were limited via `RAX_REGIONS` or `~/.pyrax.cfg`
I think I would prefer that this file didn't get dumped into a tmp directory.
The cache path used by DO and ec2 is configurable. I am in the process of adding a config file for `rax.py`. The default in `ec2.ini` is `~/.ansible/tmp` in `digital_ocean.ini` it is `/tmp`. I'm still not a huge fan of the default being `/tmp` Perhaps for now we can just hard code it to `~/.ansible/tmp` and make it configurable later.
just call scaleway.ini we are in ansible conflict should not occur
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Use [`fetch_url`](https://github.com/ansible/ansible/blob/240d1a6afb43982f16acebef16778d17aab58160/lib/ansible/module_utils/urls.py#L1197) instead of `requests.get`
This might shadow built-in `format`
Is there a particular reason for this change in behaviour? More just curious because I see the other `auth_*` methods have a default mount_point as well.
It would be awesome if buildah supported copying from a container.
`then` -> `the`
```suggestion - The name of content library to manage. ```
`Name of the datastore cluster from which all child datastores need to be managed`
```suggestion - content library id for which details needs to be fetched. ```
```suggestion - The content library description. ```
Follow pattern as above. And revert to the correct spelling of `transmitted`.
Original spelling of `transmitted` was correct: ```suggestion - Threshold for defining a lossy connection by packets not transmitted due to window size. - A client connection is considered lossy when percentage of times a packet could not be transmitted due to TCP zero window is above this threshold. ```
```suggestion - Threshold for defining a lossy connection by packets that time out and get retransmitted. - A connection between client and Avi is considered lossy when more than this percentage of packets are retransmitted due to timeout. ```
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
```python for line_number, line in enumerate(lines, 1): ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Make this a regular function
```suggestion label support, respectively to identifiy the container by label on later usages. ```
```suggestion - "This option allow the user to create a LUKS2 format container with ```
```suggestion with label support, respectively to identify the container by ```
```suggestion - "With this option user can identify the LUKS container by UUID. ```
```suggestion label on later usages." - "Will only be used on container creation, or when I(device) is not specified." ```
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
```suggestion self.container = PodmanContainer(self.module, self.name) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
No need for params: * they are accessible via module * they aren't used here at all ```suggestion def __init__(self, module, name): ```
```suggestion iap_port=dict(type='int', required=True), ```
```suggestion password=dict(type='str', required=True, no_log=True), ```
@gundalow Removed the remark. Thanks again.
Assuming IP address can also work: ```suggestion - Provide the FQDN or IP address for the Itential Automation Platform ``` FQDN should be in caps
```suggestion author: "Itential (@cma0) <opensource@itential.com>" ```
Indentation level of `return` statement need to be increased.
Would it be better to change the logic here to be: ```python query = "CREATE EXTENSION \"%s\"" % ext if cascade: query += " CASCADE" ```
Would it be better to change the logic here to be: ```python query = "DROP EXTENSION \"%s\"" % ext if cascade: query += " CASCADE" ```
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
`close` isn't called when `fail_json` is called.
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
```suggestion - Name of the domain to be managed. ```
```suggestion - The desired state of the domain. ```
```suggestion - Size of the domain. ```
@tzurE In a follow up PR could you please update all your modules to be in the form `- Tzur Eliyahu (@tzurE tzurE)` This allows Ansibulbot to know who to contact if their are follow up issues or PRs
As far as I can tell, the 'in_use' is never used.
Missing full stop.
You can removed all the `required: false` it's implicit
should be `type='path'`
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
You are taking me wrong here. I am just saying that adding additional library will add overhead to people who are using this module and people who will maintain it. I am not saying to port other GitHub modules to use `PyGithub`. One way could be using GitHub REST APIs directly rather than relying on any third party Python modules.
Making this as resolved.
``` aliases: ['repo'] ```
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
Looking at the boto3 docs, it looks like cluster ID is required for the describe_cluster call you are making. list_clusters would be a call you could use if no cluster_id is provided. required: false is also the default, so if this remains to be true you can remove this line.
Use a `seealso:` sections for external information.
The module can be used for more than archiving (which is just a use-case). So I would make this more generic.
Please don't start every description with "This is", simply state what it is used for. ```suggestion - The ID of sheet to append columns to. ```
Make this two items in your description. ```suggestion - The value should end with C(.apps.googleusercontent.com). ```
If it is not required, don't add it.
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
Not required with AnsibleAWSModule
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
Here be dragons. I don't see check-mode being tested anywhere in the module. So I expect the module to perform a reboot in check-mode. Probably not what people expect.
This should probably just be `required_if`
That's def cheap enough :)
instead of example now we need proper description of returned values, please check facts modules like azure_rm_webapp_facts or azure_rm_containerregistry_facts as a reference
yes, it's ok to iterate and change, as long as users will get simpler structure :-)
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
This needs to be updated to reflect the actual return values.
yeah, to_native is the way to do this correctly. Otherwise sooner or later we will end up with UnicodeErrors being thrown. Gotta start somewhere so might as well start with new code.
use `str(e)` (this is not the optimal, but that is true for most of this file) cc @abadger
Yeah -- just for info, to_native() is preferable because, with default arguments, it won't traceback if non-ascii values end up in the exception message. In some cases, non-ascii will traceback with str() and with ```'%s' % e```.
```suggestion self.queue_message('vvv', "ESTABLISH GRPC CONNECTION FOR USER: %s on PORT %s TO %s" % (self.get_option('remote_user'), port, host)) self._channel = implementations.Channel(channel) ``` This to be consistent with other connection plugins (netconf, paramiko_ssh, etc.)
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import find_obj```
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
Can `state` default to `present`? I usually expect this, I'm not sure if the flaw is with me or not :)
Could add the expected keys to the error since CamelCase may be unexpected.
Add traceback here as well (for line numbers).
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Enable or disable the MULTICAST flag on a device. ```
```suggestion - Enable or disable promiscuous mode for interface. ```
```suggestion security_groups=dict(type='list', elements='str'), ```
don't set a default here, or this won't work with `< 1.8.4`
boto3_conn handles this for you. You can remove this, as well as the try/except around boto3_conn. It handles ProfileNotFound. Since you're using AnsibleAWSModule you can replace this entire try/except with: `connection = module.client('application-autoscaling')`.
```suggestion ) ```
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
You seem to have gone through the process of making this class a context manager, but don't use it as a context manager.
Currently this file is created in the folder that you are running the playbook from. I can make the opt-in feature.
What is the need here for writing and reading from a JSON file? Seems this file would be created during execution, but in a temporary directory, and deleted immediately. Not sure what benefit there is to doing this, as opposed to just storing in a variable for use.
This file will be kept locally and will not be deleted. It's to reduce amount of API calls during the execution.
How is that? ``` self._arg_spec_filename = "FortiosAPIArgSpecs.json" ``` That defines the path to that filename as relative, which will be relative to the executing script. modules are executed in a temp dir that is then deleted, so this file should be deleted. If the file is kept around, I would be concerned with that. This is force creating a cache file without telling the user you are doing it, or giving them a way to opt out. The default should be no cache, and a user must opt-in, should this feature really need to exist.
I don't see any check_mode related code.
Start by not using `\` and use proper indent
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
Please don't use `\`, there are better ways
use `isinstance(obj, type)`
Same for other description.
```suggestion - The certificate in PEM format. ```
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
For an info module you will only need the name as this will be the identifier. Please remove the other options
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
Please add `monitoring` and pass this argument to the request.
Not a blocker, but I would append an alias `server_uuid` ~~~diff - server_uuids=dict(type='list'), + server_uuids=dict(type='list', aliases=['server_uuid']), ~~~ This allows to have a bit more syntax sugar for the users for attaching volume to a single server: ~~~yaml # Attach an existing volume to a server - name: Attach volume to server cloudscale_volume: uuid: my_ssd_volume.uuid server_uuid: ea3b39a3-77a8-4d0b-881d-0bb00a1e7f48 api_token: xxxxxx ~~~
When `hostname_preference` is equal to `name`, there is no need to define `ansible_host`.
not a blocker, I would probably not error out here, instead you could print out a warning message, up to your decision: ~~~python module.warn(warning='Cannot change type of an existing volume.') ~~~
And if you are using `insert` together with `insert_relative_to` then `insert_position` will be calculated automatically
I see you point from detailed code review. But what if we have two variables? `insert`, type: `boolean` - defining do we need to insert the rule with default `false` `insert_position`, type: `int` - insert as a specified rule number with default `0`
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
You will need to remove these and below as we are moving away from setting the invocation parameters.
You can delete this line.
I've been thinking that it would be a good idea to prefix parameters with the subcomponent they belong to (with the exception of metadata fields). So anything under spec, could be spec_<field name>
It would probably be good to expose api version, even if it is just locked to a single version for the time being.
I think having a parent class in module_utils for each of namespaced and non-namespaced services would make sense, which namespace handling happening at that level.
This seems like a good candidate for module_utils, since it will be needed for other conversions as well.
Can you name this a little more verbosely? I can't unsee "get best"
I you want to catch all exceptions and do not need to do something with the exception, do it like this: ``` python except: self.user = u'Anonymous' ``` If you do need to do something with the exception, do it like this: ``` python except Exception as e: do_something(e) self.user = u'Anonymous' ``` BaseException should almost never be used in user code as it will catch things like sys.exit().
user will be a byte string here. You probably should be using text strings everywhere and transforming into a byte string only if sending it over the wire. On python3, user will still be a byte string (because it's part of what's returned from subprocess) but string literals and many APIs will be text strings. Combining those will cause tracebacks. So it's best to convert that here: ``` python from ansible.module_utils._text import to_text [..] self.user = to_text(username[0].rstrip(), errors='surrogate_or_strict') ```
Note that format strings changed in python-2.7 So things like "{} {}".format() needs to change to "{0} {1}".format() for python-2.6 compatibility.
Instead of 'string'.encode() (or str('string') or bytes('string') ), use these ansible functions which are safer: ``` python from ansible.module_utils._text import to_bytes config_file = os.path.join(to_bytes(playbook._basedir, errors='surrogate_or_strict'), b'slack.json') ``` Some additional notes on that: * to_bytes uses 'utf-8' by default which will handle more cases than 'ascii'. * 'ignore' is not safe to use with filesystem paths. A path is a sequence of bytes. if you leave some of those bytes out then you end up with the name of a different file. 'surrogate_or_strict' will raise an exception if the bytes are not valid utf-8 which is unfortunate but better than using the wrong file. * I marked the second string, 'slack.json' explicitly as a byte string. On python3, string literals which are unmarked are text strings so you need to be explicit when writing most string literals.
no need to do this check, the plugin never gets called if disabled
This can be a key-value map with key as the fact name and value as the pattern to be searched for
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
type='str' is a default value not required to mention in separately.
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
As noted in the PR summary, the condition you're attempting to check against is `KeyError`. What's the motivation to cast the net wider and catch all exceptions and pass when one is caught? I'd prefer this to narrow the scope of the exception catching just in case some other exception were to occur, it isn't hidden from the user unless there's a reason for this. Thanks!
I would remove the following newline.
I think that makes me even more concerned. You are saying that the argument spec that ansible will use becomes dynamic based on responses of APIs? I'm pretty sure that's not going to be allowed.
That is correct, argument spec is dynamic. If it is not dynamic, then any change to the API would render this module useless. Also, it would require me to write modules for every single API endpoint. There are some specific modules - https://github.com/willwagner602/ansible/tree/will-devel/lib/ansible/modules/network/fortios but there are a lot more of endpoints. So it made sense to let this core module build dynamic argument spec based on the data received from the API.
How is that? ``` self._arg_spec_filename = "FortiosAPIArgSpecs.json" ``` That defines the path to that filename as relative, which will be relative to the executing script. modules are executed in a temp dir that is then deleted, so this file should be deleted. If the file is kept around, I would be concerned with that. This is force creating a cache file without telling the user you are doing it, or giving them a way to opt out. The default should be no cache, and a user must opt-in, should this feature really need to exist.
```suggestion - Either I(template_link) or I(template) is required if I(state=present). ```
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
s/will created/will be created/
avoid putting quotes around values unless they are really needed
this line isn't needed
The whole block need to moved outside the `if state:` condition, otherwise autostart parameter won't be updated when `state` option isn't used. In case `autostart` couldn't be used without `autostart`, add a `required_if` parameter to `AnsibleModule`.
[Virt.autostart](https://github.com/nerzhul/ansible/blob/f38cfdee6c9329ce4ea09ea9983796fcfc3e36f0/lib/ansible/modules/cloud/misc/virt.py#L347 ) returns either `False` or `True`, I would strongly prefer `if autostart:`.
`res['changed']` and `res['msg']` values will be lost/overwritten when the current state isn't the wanted state.
import module in head section of module (just below `libvirt` import).
You are not returning ansible_facts here. This will break backward compatibility.
This `version_added` is global for the module, not the last change to the module and should remain 2.3
heh, in fact, shippable caught this: ``` ERROR: lib/ansible/modules/cloud/amazon/s3_sync.py:0:0: E309 version_added for new option (cache_control) should be 2.4. Currently 0.0 (75%) ```
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
Python 3 versions are packaged in `python3-libselinux` and `python3-policycoreutils`. But the module needs just `selinux` and `seobject` python modules and version depends on the current interpret version. I don't know how to make it understandable and correct. On lines 267 and 270 I'd probably use module names could be used instead of package names: ```` module.fail_json(msg=missing_required_lib("selinux"), exception=SELINUX_IMP_ERR) module.fail_json(msg=missing_required_lib("seobject"), exception=SELINUX_IMP_ERR) ````
Should we add here that the win_copy module is not a very efficient transfer mechanism and if possible using HTTP downloading using *win_get_url* or *win_uri* is preferred.
```suggestion required: false type: str ```
```suggestion required: false type: str ```
I am afraid but this is a blocker: an action option should not be necessary, because ansible should handle this by itself. This is why we usually have a `state` option with (at least) two options `absent` and `present`. While absent is self explaining, the present option should handle the necessary steps (create or update) to get into the state declared and return changed if action has been taken. In any case a `list` state (or action) is not accepted, instead implement it in a separate module as an `_info` module.
```suggestion required: false type: str ```
```suggestion required: false ``` ```suggestion required: false type: str ```
```suggestion version_added: '2.9' ```
Spaces ! ```suggestion choices: [ absent, present, query ] ```
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
So I am interested to know the difference between PUT and POST. And highlight that here.
You are taking me wrong here. I am just saying that adding additional library will add overhead to people who are using this module and people who will maintain it. I am not saying to port other GitHub modules to use `PyGithub`. One way could be using GitHub REST APIs directly rather than relying on any third party Python modules.
Making this as resolved.
``` aliases: ['repo'] ```
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
Looking at the boto3 docs, it looks like cluster ID is required for the describe_cluster call you are making. list_clusters would be a call you could use if no cluster_id is provided. required: false is also the default, so if this remains to be true you can remove this line.
So I would get rid of these.
Please don't add `default: null`, that's implicit and adds no value. (Especially since it is a required parameter)
Empty aliases is not needed. Keep it simple.
Please don't add `default: null`, that's implicit and adds no value. (Especially since it is a required parameter)
We do not typically have a parameter that can be one of many things. Mostly because it makes the argument_spec hard to design. What you should be doing here is make different (mutual exclusive) parameters for a string, file or command using **mutual_exclusive** and **required_together**. and then you don't need a type selector parameter, the used options will make clear what the user wants.
i removed this as even if you respect the play's no_log there is no current way to respect the module spec's no_log
User should be able to delete key. Keys with `None` value could be deleted.
User could set `user_data` parameter to `None`, in such case exception still occurs.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
I cannot add commits to this PR to fix this myself, so I'm updated this to request changes.
I think this should be: ``` python values = map(lambda x: x.strip(), tags['Value'].split(',')) ``` Basically the same as it was before this change but with `tags['Value']` instead.
may be blind, but think this will never get fired if v is empty. you create an empty list, which will be skipped in the for loop.
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
It'd be probably better readable with ```suggestion cmd.extend(('-c', communities_tempfile.name)) ``` instead
package is a special case, note this is a "wrapper" of the underlying package manager. Some may not have a default defined for state (present). requried=true is a safe fallback.
its required as that is the 'lowest common denominator' for package modules, otherwise it will 'fail sometimes'.
Hmm, since this has been the recommended way of writing things for a long time now, how about making `I(...)` more intelligent so that it formats `{var}={value}` in a different way, maybe using italics for `{var}` and teletype for `{value}`? So something like: *state*=`present` or *state=*`present`
That's much too jumbled. I still think the whole thing should be inline code since both the parameter name and the value will be used in code. Bold and italic are meant used to emphasize words for the benefit of the reader to know they have increased importance. Inline code indicates to the reader these are vales that will be used in code. Using italic to indicate values used in code sends confusing messages to the reader, IMO. > Hmm, since this has been the recommended way of writing things for a long time now, It's never too late to change things for the better. ð
Indentation doesn't look right here.
Can be removed, indeed, check other newer modules :)
A sample of output would be helpful.
`A list of virtual machine names starting with the given regex`
Period at end.
Period at end.
Create vm pool and override the pool values.
I don't like the `: ` here
Not required - added by doc fragement
please fill this in
```suggestion to iterate use a C(with_) directive. ```
I think it should look like this: ``` python from ansible.module_utils._text import to_native [...] def enable_ds(module, array): """Enable Directory Service""" try: array.enable_directory_service() changed = True except Exception as e: module.fail_json(msg='Enable Directory Service failed: Check configuration: %s' % to_native(e)) module.exit_json(changed=changed) ``` One thing I'm not sure about is how we tell if array.enable_directory_service() made a change or not. Our users generally define Ansible's idempotence as: * they describe the state they want in a playbook task * the module makes the state match what is in the playbook * the module returns changed=True if something had to be changed to achieve the desired state or changed=False if the state was already as desired. This code probably does the first two but it's not doing the last one. I'm not sure how to fix it because I don't know what array.enable_directory_service() does. If it returns a specifc exception if the directory_service was already enabled, then we catch that specific exception and set changed=True for that. If it returns a status code telling whether it had to make a change or not, then we can use that to set changed. If neither of those, we would have to query the current state of the toggle first. If the toggle is already enabled, then set changed=False and call module.exit_json(). If the toggle is not yet enabled, call array.enable_directory_service(), set changed=True, and then call module.exit_json(). (Also note, these notes on changes also apply to the other verbs you have in this module: disable_ds, delete_ds, and create_ds)
When a module does not support check mode, ansible always reports that it would have changed something which is the safest assumption for the user.
I think things like this will traceback in check-mode because changed hasn't been set to a default value (Should default to True). Also, for this particular module, check_mode doesn't seem to be doing anything so you probably just want to say supports_check_mode=False when creating the AnsibleModule.
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
@sdodsley sounds good, thank you for the clarification
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
These values should all be type `int`
Should be type `int`
Should be type `int`
This is not a correct English sentence. Maybe do: `The DNS can only be...`
For the author information we normally only keep name and GitHub handle.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
Here add: ```yaml type: list ```
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
use ```from ansible.module_utils.vmware import find_obj```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
Please remove this line.
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion version_added: "2.10" ```
```suggestion module: zabbix_host_events_info ```
```suggestion zabbix_host_events_info: ```
```suggestion - alias: Account who acknowledge ```
Duplicate occurence of zabbix-api requirement ```suggestion ```
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
```python def toml_dumps(data): return toml.dumps(convert_yaml_objects_to_native(data)) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
`str` -> `six.text_type` I guess? cc @abadger ^
Please use `module= AnsibleModule(` I guess it is a convention
Not necessary to add "version_added" to all return values because it is a new module. Only need for "new" return values above 2.6
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
oh I see, it makes sense then.
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
Only those two lines are required, and it works for me with it
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
CI is failing here, you need `version_added: "2.8"`
You beat me by 30 seconds ;-)
This needs to be added to the `update_failure_action ` choices in `argument_spec` as well. Usage of the `rollback` choice also needs to be checked in `option_minimal_versions`. See how `publish_mode` is implemented.
There's no need to wrap this in a `try`/`except`.
The numbers should be in C(...), I think.
This wouldn't be possible with the patch if lets say _Visible name_ is set to `examplehost1` as it would return OK: ```yaml zabbix_host: server_url: "{{ zbx_server }}" login_user: "{{ zbx_user }}" login_password: "{{ zbx_pass }}" host_name: "examplehost" visible_name: "examplehost" ``` I see no point in checking _Host name_ at all. Zabbix API will feed `host['name']` with actual _Host name_ instead of _Visible name_ if there is none defined so lets try it like this instead (merge line 492 into 491): ```suggestion if visible_name and host['name'] != visible_name: ```
imho there should be no else here, otherwise no description param would not keep the current description, wouldn't it
as a response to your question: change this condition to check for not None. So an empty str will be handeled. ``` if description is not None: ```
I am curious, what was your test case? AFAICS it is only relevant if you like to clear an existing description. I don't know the api that well and if this is even supported, etc.
It would be good to call out a reboot is required to make it active
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
`final_interface = dict((k,str(v)) for k,v in final_interface.iteritems())` seems to be required here since the values from new_interface may contain non-strings while the values returned by the API are always strings. With this added line, the module becomes idempotent with passive proxies.
```suggestion zabbix_host_events_info: ```
Fair enough, I'm good with that.
I think this can just be `name`
don't use print, display.error or raise an AnsibleError exception, Ansible already does not fail due to an Exception from a callback event.
its new in 2.4 so it doesn't apply to older versions
this whole section is not needed, just use `self._plugin_options[<option name>]`
~you don't seem to use 'cli' why import it? also the base class does this already.~ v1 compatibility it seems.
missing ini option for host
Should match the variable registered in the preceding task. ```suggestion spot_price: "{{ spot_prices.ec2_spot_pricing_history.0.spot_price }}" ```
Wrong module name. ```suggestion - ec2_spot_pricing_history_info: ```
spec is also returned
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
Since all of these appear to be constants, it seems to me that making them tuples instead of lists would be good to avoid accidentally modifying them.
Please remove `required=False`.
Please remove `required=False`.
Please do not add `required=False`, it is implicit.
Please remove `required=False`.
Please remove `required=False`.
It might also be no IGWs found here.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Technically this will never be `None` because of the defaults.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
It would be good to have some tests for check mode too.
If module-level version_added is 2.5 this can be deleted
If module-level version_added is 2.5 this can be deleted
Well, then they will never really know and think they always have to quote. I don't think it's better to teach them to always quote, and certainly not using double quotes. Besides, you're not being consistent, you're not quoting the task name value and delegate_to.
This should get imported from ansible.module_utils.six
Presumably you want `It *will* always use`, or something to the effect
```suggestion if not six.PY2: ```
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
```suggestion """Test that a new lock can be created within a Process.""" ```
Having such complex logic inside of tests makes them fragile. You may want to consider just using `@pytest.mark.skipif(six.PY2)`.
I don't think another var is necessary. If the first iteration to start the processes succeeds and won't interrupt the control flow, all of them will be active. ```suggestion processes = [ Process(target=_run_threads, args=(_,)) for _ in range(1, 6) ] for t in processes: t.daemon = True t.start() for t in processes: t.join() ```
DO NOT AUTOINSTALL use the HAS_LOGDNA variable as a flag and return an error with the requirement when the plugin is invoked, plugins should NOT autoinstall libraries, also pip might not be installed on target systems and is also a possible error point. you can look at other lookups (like consul_kv) for how to deal with this issue
2.0 is what you want here
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
check is redundant as you already flagged as 'required'
you should not need to checked disabled, as the plugin itself wont be called at all if true
I mean: the current error isn't reported back (`e` is unused). I just pointed out that `display` is available and could be used to report the error.
I mean: ``` try: [use connection] finally: connection.close() ```
There still are some references to `ampq`
still: https://github.com/ansible/ansible/pull/44070#discussion_r212981844 https://github.com/ansible/ansible/pull/44070#discussion_r213508181
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
You could move this a couple lines above and remove the two in the elifs below.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
You can remove this (and the import) now that this uses AnsibleAWSModule.
Should probably check if region exists before this line.
This fails the whole fact gathering if missing, i would just add an `if sysctl_path:` instead
It's on my list to fix those, not asking you to do that, just this case so i have less work later (im selfish like that!). I would say an empty string would be less error prone for uses so they don't have to check if the variable is defined.
use an else here and you can have only 1 return at the end (even that is not needed)
Use `get_bin_path()` to ensure we always can find the command in case the path changes. ```suggestion vm_stat_command = get_bin_path('vm_stat', True) rc, out, err = self.module.run_command(vm_stat_command) ```
before continuing here, check that fields is actually populated as a list, or try/except the following code
```suggestion - Resource pool is required if vmotion is done between hosts which are part of different clusters or datacenters. ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion - Whether to power on the VM after cloning. ```
```suggestion - The state of Virtual Machine deployed. ```
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
Nice! Thanks for remembering this :) Oh, I think you just copied this from below!
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
This is still something we shouldn't really want to explicitly support.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Please add an example below that shows you how get the newer NuGet provider version.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
I don't think it's safe to change when we use the yum api, however I don't remember the specifics. I would not change this behaviour just to change this as I think it exists for some cornercases.
This line is too long even by the Ansible code style guide. It should be under 120 chars per line. Please format it like this: ``` module.exit_json( changed=has_changed, state=p_state, id=p_id, enabled=changed_repos['enabled'], disabled=changed_repos['disabled']) ```
There should be two blank lines between top level functions.
Please add spaces around the equal sign.
This applies to the other functions where a list is the default value as well.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
Not necessary but this map and the one on 690 are better written as: ``` python elif LooseVersion('.'.join(to_native(ver_field) for ver_field in etree.LXML_VERSION)) < LooseVersion('2.3.0'):
This needs to be 'rb' so that it's bytes just like the BytesIO above.
Here please use C(custom_compatibility_version) instead of `custom_compatibility_version`.
Same for VMs.
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
Add a `required_one_of` for name/uuid (the mutually exclusive is good, but this adds in module robustness as well)
Do not use default value for folder. This has caused lot of troubles in the past. It will be easy to fail rather than assuming something about user environment.
I get it now, so adding diff as part of `prepared` key results is rendering diff in a readable format in output logs. The only concern I have here is this change might break backward compatibility for playbook that depend on `diff` key
Note that this line was only added recently (https://github.com/ansible/ansible/pull/41846/files) for Ansible 1.7 development branch, i.e. it has not been added to a release. So your change should be safe.
this breaks showing diffs from loop items
This can be changed to `commit_configuration(module, check=True)`
`read_config_from_file` could return the content of the file or `None` if the file doesn't exist (instead of a tuple).
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
Can you test this on python3 please? I think python3 needs bytes.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
@bcoca yes, it would - but it's not worth fixing that underlying issue, since we don't really need a link there at all
I normally split this sort of statement onto multiple lines. Something similar to... ``` description: - The boto profile to use. - This plugin supports boto3-style... - See U(... ```
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
Ah, sorry. I mean `split_tags` and `split_separator`.
On IRC, @bcoca mentioned that this should be doable with `construct`. It is currently not possible, though, but it is better if this can be solved in a plugin-independent way in the future, than now having plugins do it differently. @ximon18 do you mind removing this? Or is this a feature you absolutely need? With `construct`, you can do essentially the same, but not for arbitrary key-value pairs, but only for keys you know about in the inventory config. If that's ok, removing this probably speeds up getting this merged :)
``` author: - Chad Norgan (@BeardyMcBeards) ```
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
Reading description ( which is same as short description) I am not clear what does this module do unless I look at code. Probably adding some more details would help new user .
not a blocker but `required: false` is the default and can be omitted.
`Manage Cisco NSO configuration and service synchronization`
```suggestion - Only used for images that contain the Windows Server operating system. ```
```suggestion - To remove only resources that were automatically created while provisioning the VM being removed, set to C(all_autocreated). ```
```suggestion - To remove all resources related to the VM being removed, including auto-created resources, set to C(all). ```
```suggestion - Use with I(virtual_network_resource_group) to place the virtual network in another resource group. ```
```suggestion - The virtual network to use when creating a virtual machine. - If not specified, a new virtual network will be created and assigned to the first virtual network found in the resource group. ```
This should probably mention both slash and no-slash paths...
How about: ```suggestion if not os.path.exists(file_path): continue ```
I'd do this unconditionally.
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
maybe just ```suggestion part_boundary, b"--", ```
Since this is setting data, you also want to use an error handler like this: ``` python from ansible.module_utils._text import to_text [...] for resource in json.loads(to_text(response.read(), errors='surrogate_or_strict'))['resources']: ``` The default error handler is replace which is good for things displayed to the user but not good for preserving data.
Probably need to use to_native() (from ansible.modoule_utils._text) to make sure that body is a native string type on both python2 and python3.
This is wrong. Do it like this: ``` python raise AnsibleError('Kind %s requires a namespace.' ' None provided' % kind) ```
You could just do this as: ``` python values = [search_response] ```
@davidharrigan Nice spot, thanks. From a quick Google I've found * https://github.com/TAXIIProject/libtaxii/commit/59e18912e90550e2248779518fb63fac77d2f5a1 * https://bugs.python.org/issue4773
Once we have a client, I don't think we need to handle this exception again.
If `ports_expand` took a rule rather than the value of its `ports` key this entire function could be replaced with ``` return [ports_expand(rule) for rule in rules] ``` Edit: of course `ports_expand` returns a list, so you need to flatten the result: ``` return [rule for expansion in ports_expand(rule) for rule in expansion] ```
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
yes, this was 'old' way when they were not real imports, now they can be moved to top of file and used like normal python imports.
Can we somehow implement behavior of specify storage_domain for all disks? If I understand the code correctly, it not currently.
Better to use ```get_id_by_name``` it get proper error message if storage is not found
I think it's `disk.disk.id`
Can you move this logic to `__get_storage_domain_and_all_template_disks` and just call: ``` return otypes.Vm( ... disk_attachments=self.__get_storage_domain_and_all_template_disks() ... ) ```
call create, so we are sure the disk is up to date with parameters provided by user.
s/write target file {0}/fetch file to {0}/
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
Please, at most one alias, even better none. Having a long list of aliases is really bad UX IMO.
The corresponding option for restart is called `force_restart`. Calling this one `force_recreate` would be much better.
Space missing before `(megabytes)`.
This should really be a `dict` with `suboptions`.
This should also be a `dict`.
Another variable with value using `special characters outside of AâZ, aâz, 0â9` and enclosed with quotes might be added there.
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
One odd thing that has come up with the os-release parsing code in module_utils/facts/system/distribution.py is the quoting of some of the right hand side of lines. I'll track down the bug momentarily, but at least one distro did odd things about what was/wasn't quoted (either VERSION wasnt quoted or ID was quoted?). The lsb/os-release spec is kind of vague on that, and different '/bin/lsb_release' tools seemed to do different things. This isn't something that has to be addressed since I don't think there was a clear correct answer, but just mentioning it for context.
Not sure what "This one go down into the class tree" means. I know it's from the original method, but see if you can improve this language so it's more clear.
This should be ` facts['gather_subset'] = list(runable_subsets)`
It may be better to define only one required authentication param like authentication_method with choice between shared and radius Then add a line in required_if for username and password in case of shared auth.
remove required: false It's implicit
Prefer use require_one_of in module_spec
I would suggest 'except Exception as e' unless there is a reason for the sys.exc_info()
split headers and/or payload to different items in the fail_json? ``` python fail_json(msg='asfad', headers=headers, payload=payload) ``` Suppose that depends if it would ever be useful on its own instead of part of the error msg.
Typo in `aggressive`
Typo in `aggressive`
`across` has broken into two separate lines.
A minor typo in `address`.
Looks like a split line.
I guess the only reason would be if we'd rename something in the future. But yeah, a list is probably better.
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
We can reduce the level of indents: ```python elif option == 'test': elif option == 'retries': else: result[option] = self.healthcheck.get(option) ``` And I don't thinks someone will be bored enough to specify a `test: ""` to get into the `elif self.healthcheck.get(value): ` check
Just add return here, no need for break and creating resp variable. ```python version = module.params.get('version') templates = templates_service.list() for template in templates: if version.get('number') == template.version.version_number and module.params.get('name') == template.name: return template raise ValueError( "Template with name '%s' and version '%s' in cluster '%s' was not found'" % ( module.params['name'], module.params['version']['number'], module.params['cluster'], ) ) ```
Please ignore, this is called when non-existin number is passed. So it's ok
If user don't specify `template_cluster`, and template is not found in `cluster`, we should fallback to global search
data is too generic, and template_json was the first thing that came to mind. I'm not married to it though.
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
I"m probably making it harder to merge my PR so this might be best left for later update, however we should we take the opportunity to improve fix it properly. Assigning local vars for cert and key since they now get read several times from modules.params Only checking if the file exists or trying to read the string if the values exist. Otherwise rstrip will fail on a None. ``` cert = module.params.get('cert') if cert: if os.path.isfile(cert): cert = open(cert, 'r').read().rstrip() else: cert = unicode(cert.rstrip()) ```
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
This is nicer wrapped without line continuation markers: ``` orig_cert_names = [ctb['server_certificate_name'] for ctb in iam.get_all_server_certs().list_server_certificates_result.server_certificate_metadata_list] ```
'Use "sudo pip install --upgrade avisdk" to install Avi SDK'
You've specified the default here and in `argument_specs` which doesn't seem right
the module in general is just a thin api wrapper, not really that useful for users, I'm not against having an 'expert mode' but this is in addition to actual options usage.
you really dont need 2 datas here, a type='json' will take both a data structure or json doc
It would be good to combine these before the module gets released to avoid changing the module interface after release.
```suggestion - Specify attributes for this device. - The value is a dictionary of attributes with values. type: dict ```
```suggestion - The name of the device. ```
```suggestion - Use C(all) to rescan all C(present) devices (AIX cfgmgr command). ```
```suggestion version_added: '2.8' ``` Update to new release.
```suggestion required: true type: str ```
Please use just a single space. If another option is added in the future this will not align ```suggestion required: true ```
```suggestion description: If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. ```
I'd reword this as `Verify SSL certificate when HTTPS is used`
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
```suggestion - content library id for which details needs to be fetched. ```
How about using `LooseVersion` from `distutils.version`? It usually handles version numbers pretty well. (Grep for `LooseVersion` in the modules directory to see plenty of examples.)
@mrdrogdrog great! Once you made the adjustments and someone else also tested it (just to be sure), I'll merge it and create a backport PR. If this gets done by the end of next week, it should make it into the 2.9.2 release.
Their are built in helpers for argspec for the this, have a look in other modules for "exclusive"
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
You can use [`env_fallback`](https://github.com/ansible/ansible/blob/8f41270a010c00d058c70bdccdc611df8b454139/lib/ansible/module_utils/basic.py#L726)
I believe this isn't needed - this was in there for a previous version of the fix IIRC.
Shouldn't be required.
```suggestion pass # Handled by AnsibleAWSModule ```
`import botocore` will make this code a lot more consistent with most other boto3-based ansible modules
`Ansible uses the boto configuration file (typically C(~/.boto) or C(~/.aws)) if no`
Making the new behavior the default is not backwards compatible. The new behavior should be opt-in rather than opt-out to avoid causing problems with existing playbooks during an upgrade.
Be sure to include a changlog entry explaining the backwards compatibility issue.
```suggestion pre 2.8 behavior of automatically fixing the hostname by removing the invalid chars and domain name.' ```
I suggest a rephrasing here, because: - Even in the old approach (force=True) you are not actually dropping individual characters, and that's what it sounds to me. - Citing RFC 952 does not seem to me to be of much help to the module user, IMHO. ```suggestion and minus (no dots allowed, VMware guest customization for linux does not support receiving a FQDN name). From Ansible 2.8 onwards, this is a required parameter. ```
I would not advertise space-delimited lists as this is only for backward compatibility. We don't want to offer people this choice, only support people that did not have the choice before. I would even deprecate space-delimited lists over time.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Should have a default set to `present`.
This should be enforced by the argument_spec, not sure how this would happen.
yes, this was 'old' way when they were not real imports, now they can be moved to top of file and used like normal python imports.
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
SubnetIds expects a list `[result['subnets'][0]]`
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
Do you need that step? `clients = client_list` should be enough
maybe you add the type `type='path'`
Please add the module as a function parameter and maybe replace `dest `trough the `filepath` in the error message error: global name 'module' is not defined
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
I would name the method `passwd_check`.
I would name the method `passwd_set`.
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
You can remove `type='str'` as that's the default type.
I would rather remove this exception here and put it around the `ldap.initialize()` and `self.connection.passwd_s()` above with a more specific error message.
i was even thinking of making it top level in argspec and not in the type itself, but either way works, as long as each alias can have their own version/msg
alternatively a dict of dicts, with key being teh deprecated alias and the other 3 keys as subdicts
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
this should be a common function in basic.py (i think there is this one or the reverse there already)
Not pep8, if a user wants to clear variables by providing a emtpy dict, `if variables:` would be false while `if variables is not None:` wouldn't. I don't know if this is a use case, that is why I am asking.
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
Just curious, why do you want the error message twice? Anyway msg would be printed.
ok, missed that!
That's not how `diff` should look like. It should be a `dict` with elements `before` and `after`. These will be converted (depending on the callback plugin, i.e. JSONify or YAMLify) and then diffed.
IMHO this should be just as follows because check mode is not relevant if no action is taken. ~~~python if user['enabled'] == args['enabled']: return(retvals) ~~~
There is a small difference: if `_set_password` is `True`, the module should set the password and not return here. Setting the password is done later in the code. It's probably better to not return here at all, neither in check mode nor outside check mode, since otherwise `changed` is not set correctly. After all, `update_password` has check mode support built in.
Probably best to add an entry saying the location is derived from `C(resource_group)` if not specified
We should probably also include a sample and/or doc note that shows that the route table is associated via `azure_rm_subnet` - was definitely the simpler choice to implement that way, but we need to tell people where that happens.
name of the `route`, not virtual network
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
Is this always avaliable? If not, try ```suggestion tags = self.node_attrs['Driver'].get('Tags') or '' ```
How about ```suggestion kv_pairs = [kv_pair.strip() for kv_pair in tags.split(',') if kv_pair.strip()] for kv_pair in kv_pairs: ``` That avoids empty strings showing up in the result, and also allows users to separate with `, ` instead of `,`.
If `tags` is the empty string, you will get one `kv_pair` which equals the empty string. That's probably not what you want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
You may want to drop the `2` from the function name to match the YAML tag
Should we use `AnsibleUndefined` here instead? I know there is likely circular imports due to `AnsibleUndefined` existing in `lib/ansible/template/__init__.py`, but I've wanted to move it to `lib/ansible/template/undefined.py` to allow it to be imported more freely.
Yes, this should use `AnsibleUndefined` in order to get the recursive Undefined behavior introduced in that class.
You need to handle unsafe in the else branch.
There shouldn't be any difference between octal, hex, and decimal for this case....
```suggestion parsed_network['options'] = clean_dict_booleans_for_docker_api(network['options']) ``` While this also accepts `True` and `False` (and converts them to `"true"` and `"false"`), it makes sure that all keys and values are strings.
Use ansible. module_utils.to_native or to_text here. To_Native converts to the str type (which is bytes on Python2 and text on python3). To_text converts to text type (Unicode on Python2. Str on python 3). Which you choose depends on what the rest of the module uses..
So removed `required=False` and add `type='str' instead. Do this for the others as well.
I would say `Deploy key has been updated` instead of `should have been updated`
Please use 'msg' for returned messages, this is a standardized return value.
This doesn't remove any orphan, it only checks whether there are any.
please use explicit import statements
please use explicit imports `from ansible.module_utils.basic import AnsibleModule`
please use explicit imports
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
Same as in the doc
It seems like no_log and deprecation are separate things and should be handled in separate functions.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Note that str() can fail if the object's __str__ method returns non-ascii characters. You probably control the objects being used here so you know whether that's the case or not. I usually use ```to_native(self.change_relelvant_keys, nonstring='simplerepr')``` in similar situations so I don't have to worry about it.
@bcoca noted the use of state=info in today's meeting... I think a year ago, or so, we discussed using a separate module named with an _info suffix (like sophos_utm_info.py) for things that are just for gathering info about something which doesn't relate to the host it is run on. (You also thought you might turn that portion into a lookup plugin. That would also be fine. The difference is just that a lookup can only be run o nthe controller whereas a module can be used on either the controller or a remote host).
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
remove the register line, kind of confused
instead of example now we need proper description of returned values, please check facts modules like azure_rm_webapp_facts or azure_rm_containerregistry_facts as a reference
there is no need to set a temp variable for `images`
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
You should keep the `HAS_LDAP = True` here and remove the import for it. The same in all other files.
Exactly. The new line should be right after the import and not after the global variable.
I like this simplification but I believe that it should done somewhere in the core (suggestion for another PR) and not on per-module bases.
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
I would name the method `passwd_check`.
better way is 'have no hardcoded exceptions', one way to do that is make it 'property based' on the modules, but that would require reading them on controller side.
This doesn't actually address this `FIXME`. The `FIXME` indicates that `('creates', 'removes', 'chdir', 'executable', 'warn')` should be moved somewhere more global. This change refactors one function, into 2, which is not bad, but doesn't satisfy the `FIXME`.
I don't think we want 2 `elif` statements here. Maybe just `elif any((async_val, poll)):`
I would reverse order and have parse_kv go first, since it will also still be the most common usage, also the current detection will create many issues, we have used it before (still do for safe_eval). Use a try/fail approach on parse_kv to try yaml parsing afterwards and error out if all fail the module_require_args check should not be limted to kv, but also force skip yaml attempt
There is a much easier way to do this, by using the index in the list. Something like: ```python unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
`_get_fs_size` method need to be modified in order to handle `pvdisplay` tools. It would be better to use a method instead of a string for the `fsinfo` value.
yes, type=raw will avoid type enforcement, but it is not normally a good interface
so the 'is' will only work with boolean values so you cannot set a jobs = 5 nor jobs = '', the original was not completely correct either: ``` if p[flag]: args.append(arg + to_native(p[flag]) ``` ^ this should work for all cases .. except 0 values
use to_native (module_utils._text) instead of str, it deals with py2/py3 compatiblity
At the point it is 'clear' i'm fine with either way, i am not going to force a style unless the code need de-obfuscation.
My suggestion would be: ~~~ - To change the password of an existing user, you must also specify C(force=yes). - Since 2.4, C(force=yes) is optional with RabbitMQ 3.6.5 and later. ~~~
there is no need to version params for new modules
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
Please add spaces around the equal sign.
Please add spaces around the equal sign.
Please add spaces around the equal sign.
I used to do a lot of Perl before as well. You can take that as a good opportunity to get into the Python programming. I think it would be worth using the Python module instead of calling the shell command.
Please add spaces around the equal signs.
there is a helper function `has_changed()` for that, which also handles --diff https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/cloudstack.py#L149
This and the following update should only be executed if there is a change.
IMHO this should only be required if `state=present`
be careful with defaults, if this is not "specified" by the user it would get updated to False if it was True before. If we keep this "None" it would be like "keep it as it was before".
would you mind minimalizing the example for state=absent to the things required: ~~~yaml - name: Remove a vpc offering local_action: module: cs_vpc_offering name: my_vpc_offering state: absent ~~~
Parse the version without using `packaging`, since it is not part of the Python standard library. You could probably use this function: https://github.com/ansible/ansible/blob/13aef3c2e591631440830b6a023e90292a11392b/test/lib/ansible_test/_internal/util.py#L868-L870 However, that will need to be backported as well.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
No need to parametrize with just one case.
Mind putting this magic value into a constant with a descriptive name? I'd read much better if it was ```suggestion sys.exit(RC_CLI_INIT_FAILURE) ``` or something like that.
Mark any string that you are going to call encode on as a ```u"string"```. Otherwise you can run into problems on Python2.
Same here. Looks like some strange linewrapping is going on.
This isn't used in the examples. Is it possible to do this by name instead of URL? It seems a little complex to have to provide a full URL to use non-default networks.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
I think changed needs to be set to True here.
why is 1 allowed? afaik this indicates an error in ssh-keygen
**sigh** i really hate compensating for these types of bugs .... but I don't see we have much of a choice. tempted to add a warning "your ssh is broken".
Unless I am mistaken, this doesnt actually do anything. I do not believe it's possible to have an 'absent' flag to remove an entire stanza. `chsec` can only remove given attrs/options from a given stanza, it cannot remove the entire stanza. This code block is just 'unsetting' all of the given attrs/options and ignoring the value assigned to them. These two YAML examples behave exactly the same way even though one has state=present and the other state=absent: ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=LDAP,registry=LDAP state: absent ``` ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=,registry= state: present ``` HOWEVER, if there are other attrs set on that user stanza, the *stanza will still exist*. You need to specify every single user attr/option on that stanza to remove the stanza. Adding a 'true' state=absent will mean going through the given `file`, finding the stanza, getting all of the key:value pairs in that stanza, and then running chsec key=null to every one of those. That's a loooot more work.
This could be `elif`.
This could be `elif`.
Python 2.6's `re.sub` doesn't accept `flags` -- but `re.compile` does.
`shlex.join` was added in Python 3.8, so an alternative is needed here.
It probably makes sense to clean-up flags before exiting this method.
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
You should not use `curl` as the alias for `Invoke-WebRequest`. Use the full cmdlet name to avoid confusing people whether it's actually using curl or a PowerShell cmdlet.
please add `no_log=True` to avoid leaking the password in the logs.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
seems sys is nowhere used later in the code
please add `no_log=True`
OK, leaving it this way is fine then, since it's functionally no different that before.
@dagwieers this module deprecated in 2.7 so we haven't been looking at any of the issues with the deprecated modules and just pointing people at using the supported version. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/storage/netapp/na_ontap_aggregate.py
I thought this initially too, looks like @sbj-ss is relying on the `if e.response['Error']['Code'] == 'NoSuchEntity'` for that use-case
`User has been created`
replace with fail_json() to show a user friendly error message
Too long line.
Line is too long.
Default type is `str` so you don't have to set it explicitly. Just use `size=dict(),` instead. The same bellow.
use python bool for the default `default=False`
Line is too long.
Also defaulting to `True` will always override the value, even if it was not specified. This is probably not what we want here.
I wonder if this should be a boolean, or a list of options. My worry is that in the future this gets extended to more than two options, and we're stuck with having it as a boolean.
Yes, that file has moved in the meantime. That's also why we have that conflict.
Oops, missed something. I think this should still return the describe_db_clusters call so changed is accurately reflected by whether or not the cluster exists. No changes are being made by that call so it's fine and you're checking for module.check_mode in delete_cluster().
`Current host '%s' can not be %s...`
Tag a `1.0.0` release of the container and use that version here instead of `latest`.
needs a space before the quote here too
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
You can replace this line through line 363 with simply: `client = module.client('es')`
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
`'required': False` is the default so you can omit that. Same for any of the following.
Formatting nitpick. You can add this to the line above.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
changed is displayed as False by default so you don't even need to specify it at all. Can delete this line.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
`deepcopy` is unused
Should be type `int`
These values should all be type `int`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
This isn't your name
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
`author` is a list, so it should be: ```yaml author: - Kairo Araujo (@kairoaraujo) ```
String or list are allowed here so no change is required.
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
C/P error, should be `AWS ElastiCache is down`? Same on L450
self.get_stack_info returns a string. I don't think this will work as expected. You probably want it to return a list.
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
You don't need this conditional, since Ansible enforces that these are the only choices.
Could you please update `lib/ansible/utils/module_docs_fragments/docker.py` to mention these variables, see `lib/ansible/utils/module_docs_fragments/vmware.py` to an example
The fallback env variable is called `DOCKER_TLS`, not `DOCKER_TLS_VERIFY` (that's the one below).
Use the existing `DEFAULT_DOCKER_HOST` constant.
this should be a common function in basic.py (i think there is this one or the reverse there already)
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
We generally put the choices in lower case, though I guess you want this to be consistent across all your modules
This isn't really needed - the task should already be returning changed==[true | false], so users interested in whether the resource was altered can just check that property instead.
Well, then they will never really know and think they always have to quote. I don't think it's better to teach them to always quote, and certainly not using double quotes. Besides, you're not being consistent, you're not quoting the task name value and delegate_to.
Python 2.6 is minimum requirement for Ansible >=2.4 targets
Default not set in argspec.
Yeah, I had the same problem. I tried changing the exception type raised in `templar.template()` and catching that here, but still couldn't get it quite right. Seems like putting it in `-v` is an improvement over what we have now until we can come up with something better.
I think it would be more helpful to the user to show them both errors by default rather than hiding one in `-v`. Ideally we could have templating errors take precedence over loop errors and only display the templating error first, but that may not make sense in all situations. If we don't want to display both as was done originally, then I'm fine with the current use of `-v` rather than using debug since debug is information overload for users.
instead of these 2 this patch should take care of it: ``` diff --git a/lib/ansible/executor/task_executor.py b/lib/ansible/executor/task_executor.py index 0e34938..3bee47a 100644 --- a/lib/ansible/executor/task_executor.py +++ b/lib/ansible/executor/task_executor.py @@ -419,6 +419,9 @@ class TaskExecutor: if self._task.notify is not None: result['_ansible_notify'] = self._task.notify + # preserve no_log setting + result["_ansible_no_log"] = self._play_context.no_log + # and return debug("attempt loop complete, returning result") return result ```
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
Could we included the word `Droplet Sizes`? That will clear up any confusion on what sizes.
`This module can be used to manage maintenance mode of a datastore` (small change: remove 'for', add 'a')
I always sort alphabetically if the order has no meaning.
VM or VirtualMachine
`Name of the datastore cluster from which all child datastores need to be managed`
is_vapp_changed = False
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
move this line 1028
``` â¦ + + is_vapp_changed = True + + new_vmconfig_spec.property.append(new_vapp_property_spec) + + if is_vapp_changed: + self.configspec.vAppConfig = new_vmconfig_spec + self.change_detected = True ``` â ``` â¦ + + is_vapp_changed = True + if is_vapp_changed: + new_vmconfig_spec.property.append(new_vapp_property_spec) + if new_vmconfig_spec.property: + self.configspec.vAppConfig = new_vmconfig_spec + self.change_detected = True ```
If you check for the folder path here [compile_folder_path_for_obj] (before breaking) you could return the result and ignore all the other strategies.
That's not how `diff` should look like. It should be a `dict` with elements `before` and `after`. These will be converted (depending on the callback plugin, i.e. JSONify or YAMLify) and then diffed.
```suggestion - I(update_password) must be C(true) for an existing user's password to be updated. ```
There is a small difference: if `_set_password` is `True`, the module should set the password and not return here. Setting the password is done later in the code. It's probably better to not return here at all, neither in check mode nor outside check mode, since otherwise `changed` is not set correctly. After all, `update_password` has check mode support built in.
IMHO this should be just as follows because check mode is not relevant if no action is taken. ~~~python if user['enabled'] == args['enabled']: return(retvals) ~~~
Just curious, why do you want the error message twice? Anyway msg would be printed.
```suggestion except (OSError, IOError): ``` Since you are not using `e`.
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
No, the previous formatting was much better here for this block, much more readable.
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
I think it would be better to use `MiqServer.my_server.add_settings_for_resource(â¦)` here. This will queue a settings reload for all workers running on the target server after save.
The root cause: since requester_pays defaults to `False` it can never be `None`. Just stumbled over that as well.
current_encryption will only exist if `hasattr(s3_client, "get_bucket_encryption")` is True. You could add an `else` on line 267 to default the value.
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
If we allow non-Mutable mappings here, then we need to put a try: except around the call to reduce in the if recurse: later as giving it two non-mutable mappings will throw an error. I dislike that non-mutable mappings would be accepted with recurse=False but cause an error with recurse=True so perhaps we should track down why we're getting non-mutable mappings or perhaps we should enhance merge_hash to be able to operate on non-mutable mappings.
If this is needed, just replace MutableMapping with Mapping. (MutableMapping is a subclass of Mapping that adds additional features). OTOH, I wonder why we're dealing with something that's just a Mapping instead of a Mutable Mapping in the first place....
I would switch the statements, test for dict, test for list, else raise error.
These 2 lines can probably just be collapsed into an `elif`
I think we should add an `allow_overwrite` or similar param.
/me retires very old vm images We should be OK with anything added before v240 (and that is already ancient).
need to check, but I'm not sure all options are backwards compatible across most systemctl versions
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
This line is too long. Max line length allowed in Ansible is 120 characters.
This check always fails on my machine: `self.principals == None`, `principals == ['(none)']`
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
Pretty sure catching/failing here overrides the awsretry.backoff above.
Same here. Also, the individual `describes` should be in separate retries from the list describe, since a throttle here would cause the whole function to re-execute. Really we'd want an individual throttle to just keep retrying that call, not start over completely.
Can that raise a ClientError? I don't think boto3 verifies the connection like boto does when it's first created.
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
```python elif max_num is not None and () ```
```python if size_pct is not None ```
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
please give more description about the structure of the upload url: ` protocol://username[:password]@server/path `
nevermind- I see we added the isa check to deepcopy those for specific cases
This should be `isa='percent'` (just like _max_fail_percentage above it).
should you have to explicitly default to the class? I think this might be a bug in the FA code
we might want to make this a list, so both an actual yaml list and , separated string will work. the code works because `in` also works on strings, but part of it assumes it always as a list, we should make sure it always is in case future changes keep the assumption but hit the issue here as it CAN be a string.
How about - ```suggestion _gather_subset = FieldAttribute(isa='list', default=(lambda: C.DEFAULT_GATHER_SUBSET), listof=string_types, always_post_validate=True) ```
Please add example of these newly added keys in EXAMPLES section.
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
add and else branch here and tell the user they specified too many disks
You forget to make the change.
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
Again, the name for that task was a copy-and-paste from the integration tests. It would probably better to use, eg. ```yaml - name: Enable 'telnet-client' windows feature ```
Ah, I think it's a copy-and-paste error from the integration tests. Good catch :-)
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
If a parameter is not required, we don't have to state that explicitly. It is implicit. Only when parameters are required, you need to add `required: yes`.
This can be removed. If a parameter is required, there is no default.
@s-hertel FYI I've reworked the test suite in #62955 to make sure we test the current expected behaviour and test a few other things more thoroughly.
Please remove the default here. ```suggestion iam_type=dict(required=True, choices=['user', 'group', 'role']), ```
Please remove this default too ```suggestion policy_name=dict(required=True), ```
I thought this initially too, looks like @sbj-ss is relying on the `if e.response['Error']['Code'] == 'NoSuchEntity'` for that use-case
Same order, type first.
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
Looks like `monitoring:` has been added.
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
Only one space after periods.
Raise `AnsibleCallbackError`, which can be imported from `ansible.errors`.
it should also check if it can write there
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
you should not need to checked disabled, as the plugin itself wont be called at all if true
`import_role` supports those keywords, but for inheritance, for include it applies to the task itself, the original phrasing was more accurate
`until:` is the proper keyword for those loops
These lines should probably be moved to `notes:` and not just deleted.
Please revise to "This is a feature of the Ansible Engine, rather than a module, and cannot be overridden like a module."
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
I'm not sure about adding aliases when no user has become familiar with anything and can learn it the correct way from the beginning.
```suggestion - Corresponds to the C(--allow-downgrades) option for I(apt). ```
Nevermind me, I follow. Your control flow is better :+1:
This should be: ```yaml type: bool ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
No need to import HAS_BOTO3 now.
sample should just be the content of `gateway_id`, not the whole dict.
BotoCoreError does not have a .response attribute so this may throw an AttributeError.
Seems this is only returned when state=present.
I'm working on a PR to update CI for these tests right now. :)
```suggestion type: str choices: [ absent, present ] ```
```suggestion - The full path to a list of block devices such as hdd, nvme or nvme. ```
```suggestion - Whether to enable or disable automatic pool expansion when a larger disk replaces a smaller disk. ```
Why only autoexpand and autoreplace are added as an option? I can see a value of having all or nothing and just use sets.
```suggestion - Automatically replace a bad device in pool using a spare device. ```
Oh I see :)
Same order, type first.
can be ignored
can be ignored
Is it better to validate the parameters in the collection? Logic [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_user.py#L183-L186) can be used as a reference.
@nerzhul this 'feature' predates the RFC that introduced SRV and was used as a 'cheap' load balancing trick
i really don't like a such crap in DNS nsupdate should take care about all DNS implementation , and bind9 is the reference and doesn't support a such thing
depends ... some DNS servers allow multiple entry as a way to skew the load, i.e: ``` www.example.com 10.10.1.1 www.example.com 10.10.1.1 www.example.com 10.10.1.2 ``` ^ will send 2/3 of traffic to first IP and 1/3 to the last .. so technically it should be accepted .. but that depends on the server software (some do this, some ignore, some error out).
what if empty result ? This should be tested also we can have a different TTL per record value, not only per record if i'm correct
`delete` and `create` are not valid states
Thanks for confirming
Is the default false, if so needs adding here and in the docs
Please add `, no_log=True`
Why are username and password define here, though should be in the docs_fragment.
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
It requires `botocore>=1.13.21`
is the `any` required here - `if metrics_to_disable:` should suffice, I'd think
Please use [standard exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2)
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
Do note that this only looks at the primary credential cache. This means that if you use a collection credential cache such as DIR, KEYRING or KCM (default in most distributions these days), you might not see a ticket that exists in a non-primary credential cache. Maybe consider using `klist -A`, or try a `kswitch -p <principal>`? The latter is easier to parse, but might break stuff if people are still using the old krb5 APIs (rather than GSSAPI) and were using the primary credential that you just made secondary.
Let native speakers correct me if I'm wrong, but I think `a` article should be moved to before `package` and before `version`.
Remark: with regexp factored out this could become just ```python from functools import partial ... _is_vcs_url = partial(re.match, _VCS_RE) """Test whether a name is package name or version specifier.""" ``` (But I bet Toshio would blame it for being unreadable, so don't do it :smile:)
I wouldn't write a function which was itself a single function call ;-)
Lists also have .extend() which might be what you need here
`list`s have `.append()` method. You probably don't want to re-allocate a new instance on each iteration of the loop.
```suggestion - name: Reset the nimclient ```
```suggestion - name: Deallocate all resources from the nimclient ```
```suggestion - name: Update all filesets to latest level from lpp_source lppsource_aix6109-06 ```
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
"state" is required or you should set a default.
you should set the default state to "list" at argument_spec, not here.
`vmware_host_config_facts` â `vmware_host_config_manager`.
vmware_host_config_facts â vmware_host_ntp
`vmware_host_config_facts` â `vmware_host_config_manager`
yes, I don't think we need another field.
should probably specify that this is only used for deletion
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
`PyOpenSSL>= 0.15` seems only required for `SelfSignedCertificate`, with other providers older PyOpenSSL versions should work fine: this information could be added here.
Maybe add an empty line above this one and give it a name, it seems like the `assert` task is just a parameter of the `openssl_certificate_info` one.
```suggestion description: Returns a dictionary for every extension OID ```
as this is the default, it can be left off
Use `U()` for `acme`.
you probably need to add shell and become plugins also
First, this is not the cannonical info for the user info anymore, you should use the connection plugin itself (which now includes vars specific to the plugin and not present in MAGIC_VARIABLE_MAPPING. Second, this should not be restricted to remote_user but 'all connection information' as port, host, etc can change per iteration see the `_set_plugin_options` and `_set_conneciton_options` functions for details.
They're not being added in _get_loop_items, it seems like they're added in the internal execution so this may be the easiest way to clean them up.
```suggestion "Error: " + to_text(err)) ```
> I feel like a [WARNING] should pop up when you do that When specify a hash string that matches more than one image? We should `fail` immediately, this is users' fault.
I(....) adds the highlighting that this is an argument name.
```suggestion - Either I(tag_keys) or I(tags) is required when the state is absent. ```
```suggestion type: list elements: str ``` It's helpful to define that the list is a list of strings (or what ever).
```suggestion - A list of tags to be remove from the resources. ```
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
The other option is to strip the arguments and keep it as a list
Authentication should be handled here and not inside of the class
Simplify this by not adding required=False, and always starting with the type. Since every parameter has a type, starting with this adds consistency.
On all your parameters, if there are not required, there is no need to specify the `required=False`. But if they are, you should speficy `required=True`
`api_token` is a required parameter
use `to_text()` instead of `str()` as its py2/3 portable
I did think about that yesterday, but since that's called only once, that should be ok. But it could be a good idea to handle the case, in case the code start to do use extract_name more than once.
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
`filter(lambda x: x, map(self.validate_query_parameters, self.query_filters))` could be used here (in order to avoid calling twice `validate_query_parameters`).
`str` isn't needed here.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Why add another level of nesting with a list? Just have a dict comprehension.
Oh, I see it's addressed now.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
Probably should be 'One and only one of name and nacl_id is required'
The original phrasing is more complete
`required: false` already denotes `optional`, but I'm not against this update
```suggestion - The privilege of the dashboard administrator on the network. ```
```suggestion - Note that to use dedicated tenancy you MUST specify a I(vpc_subnet_id) as well. ```
Not needed with AnsibleAWSModule
could add HAS_BOTO3 to the imports from ansible.module_utils.ec2 instead of manually setting
Is there another option than this? If I give the parameters: ``` elb_target_group_facts: names: - validtargetgroup - notatargetgroup ``` and validtargetgroup exists and notatargetgroup doesn't, I'll get back no facts. Not sure if that's desired behavior or easily fixed if not.
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
Would be good to have a better description.
be consistent with other connection plugins ```suggestion - name: ansible_user - name: ansible_vmware_tools_user ``` edit: updated to show `ansible_user` as default if `ansible_vmware_tools_user` not defined.
`ansible_user` should win, I think, if it's defined, to be consistent w/ other plugins
```suggestion - "ESXi Host Example: C(ha-datacenter/vm/testVM)." ```
```suggestion - Must include VM name, appended to 'folder' as would be passed to M(vmware_guest). - Needs to include C(vm) between the Datacenter and the rest of the VM path. - Datacenter default value for ESXi server is C(ha-datacenter). - C(vm) is not visible in vSphere Web Client but necessary for VMware API to work. ```
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
This should be a @staticmethod and self removed.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
I see you fixed this one. :+1:
Should the `continue` be here? The following 3 lines will never get evaluated.
Missing space in front of `1`. I strongly recommend to use `flake8` tool on your code before you submit it. It significantly improve the code formatting which has direct influence on the readability of the code.
No need to wrap.
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
what happens if it's not `> 0`? There will be a lot of `IndexError`s in the following code. We should set `launch_config = launch_configs[0]` if we know there is a result.
`dict((k, v) for k, v in launch_configs[0].items() if k not in ...)` is probably a bit more readable.
Random musing. I wonder why boto3 isn't returning CreatedTime sometimes. I made a launch configuration in us-east-1 with ami-9be6f38c. It has a creation time in the console. Hm.
```suggestion version_added: "2.8" ```
You could add the minimum required version (`>= 1.0`) here too.
Sound, sound sensible
`IP` `Netscaler` - Applies to a number of places `Nitro` - Applies to a number of places
`Ansible control node` (Capital and remove double space)
It's more about doing it step-by-step. It should be the first step, yes. Yet, it now feels like the entry point got spread out across multiple places. It's fine to keep it here for now. I don't want to be overly nitpicky. It's probably good enough for the first iteration.
AFAIR the flag is `failed`, not `fail`
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
```suggestion self.container = PodmanContainer(self.module, self.name) ```
@rafaeldriutti Yes please on the test case
Looks like this is used now, yay :-)
self.ec2 still needs to be defined here. Also, AnsibleAWSModule lets you do `self.ecs = module.client('ecs')` and `self.ec2 = module.client('ec2')`, so you could remove the imports get_aws_connection_info and boto3_conn.
Debugging, I assume, but should be limited before merging.
SubnetIds expects a list `[result['subnets'][0]]`
Is this (and `providers:` below) part of `property_attributes:`? Dedent if you want them to be example of top-level `providers` and `services` args.
may be nice to support description in addition to name.
Perhaps `required_if` can help.
I think this is a typo - `changed` should be `changes`
no, this refers to the standard `changed=True` / `changed=False` and `msg="..."` results returned by ansible modules.
You can remove the brackets here.
This has been resolved.
I would remove this blank line.
I would remove this blank line.
Here should be two blank lines.
i meant that maybe you don't need serialize_vm function at all, you could just use as_dict() which is available from vm object
ah, ok... yes, i think when original azure_rm_virtualmachine was done, as_dict() was not available yet. that's why there's serialize_vm function in there. I will actually try to check how it differs from raw REST API response....
This is handled by the Azure module utils so isn't needed in the module arg spec
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Can you test this on python3 please? I think python3 needs bytes.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
In case this pattern is used in other modules as well, moving it into `exec_sql` is probably a good idea. Also, adding a new argument to `exec_sql` with a default value shouldn't affect the other users.
Why not pass `check_mode` into `exec_sql` and let it (if set to `True`) simply not execute the command? Then you don't have to repeat the pattern `if not check_mode: / exec_sql(...) / else: / self.executed_queries.append(...)` all over the module.
Why not also do this when `module.check_mode` is `True`? Then the check mode behavior is closer to the real thing.
This function looks like it should be in `module_utils`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
align is always lowercase.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
None is the default.
This can also be an ARN, right? In which case the length can be up to 140 characters.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
`vmware_host_config_facts` â `vmware_host_config_manager`
`vmware_host_config_facts` â `vmware_host_config_manager`.
`vmware_host_config_facts` â `vmware_host_config_manager`
As I understand it, this module isn't about gathering facts.
vmware_host_config_facts â vmware_host_ntp
```suggestion description: If multicast is enabled. ```
```suggestion description: If promiscuous mode is enabled. ```
```suggestion description: Administrative state of the interface (C(up) or C(down)). ```
```suggestion description: L2 address (may be C(None), if the interface does not have one). ```
```suggestion description: L2 Broadcast address (may be C(None) if the interface does not have one). ```
I would rename this to vdevs and add "vdev" as alias.
```suggestion - Full path to list of block devices such as hdd, nvme or file. ```
```suggestion - Alignment shift can be used to improve performance and is set once during the creation. type: int ```
```suggestion - Set options for existing pools. ```
Please provide a default for autoreplace.
sorry, but if i have a template debian 8 and debian 9 is released, maybe i prefer to create debian 8 from debian 9 and change guestid. It's not the good solution. I think it's better to check the guestId value
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
Chances of not finding datastore is also possible even when user passes the datastore name. Change the error message
ah, my bad.
The default here is to use 'yes'. That's how all modules work, by default they take the system configuration.
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
not needed with AnsibleAWSModule
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
No need to check `region` before using `boto3_conn` - `boto3_conn` will handle a `NoRegionError` for you.
change this to return `customer_gateways`
```suggestion description: Numerical ID of the group that owns the destination directory. ```
```suggestion description: Path to the destination directory. ```
```suggestion description: Name of the group that owns the destination directory. ```
```suggestion description: String that represents the octal permissions of the destination directory. ```
```suggestion description: Name of the user that owns the destination directory. ```
Original spelling of `transmitted` was correct: ```suggestion - Threshold for defining a lossy connection by packets not transmitted due to window size. - A client connection is considered lossy when percentage of times a packet could not be transmitted due to TCP zero window is above this threshold. ```
Follow pattern as above. And revert to the correct spelling of `transmitted`.
```suggestion - Threshold for defining a lossy connection by packets that time out and get retransmitted. - A connection between client and Avi is considered lossy when more than this percentage of packets are retransmitted due to timeout. ```
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
`wait_for=dict(type='list'),` (remove waitfor)
You should probably use `transform_commands` from `ansible.module_utils.network.common.utils` instead.
Please remove this line. `waitfor` was used in older modules, we've since standardized on `wait_for`
resue the function here https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L73 to avoid code duplication
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
``` pbm_object_ref = pbm.ServerObjectRef(key=str(virtual_machine._moId), objectType="virtualMachine", serverUuid=self.vc_si.content.about.instanceUuid) ```
rule_number += 1
Use [find_obj](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L57) instead.
Please don't use `\`, there are better ways Also use proper indent
Please don't use `\`, there are better ways
Please don't return different types of data from a function. It should always be consistent and discourage checking the return value. Unlike low-level C-code, Python provides you with a variety of handy ways to communicate failures to the calling code (like exceptions).
also, please use dict literal instead of constuctor (`{'key': 'val'}` instead of `dict(key='val')`)
you can probably move this statement outside of with-block
wrap these pieces of code into two try/except statements to be precise with what you're trapping. 1) one around with-block (with readfp call) catching `IOError` 2) the other one around creds dict constuction catching `configparser.NoOptionError`
refactor: ```python additional_kwargs = ( {'showAuthenticationRestrictions': True} if authentication_restrictions_supported else {} ) result = db.command( 'rolesInfo', role, showPrivileges=True, **additional_kwargs ) ```
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
This file consists of texts from previously copyrighted file. You should respect the original copyright.
The original modules have this: ```yaml # (c) 2016, Peter Sagerson <psagers@ignorare.net> # (c) 2016, Jiri Tyr <jiri.tyr@gmail.com> ``` Peter is the original author, I'm the person who polished and published his module. You are another contributor, so you should be at the end of the list.
I would format this like this: ```python ANSIBLE_METADATA = { 'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community' } ```
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
You don't have to quote this string.
Same here: ``` + for _ in range(0, 2): + try: + task = self.host.ReconnectHost_Task(**reconnecthost_args) + success, result = wait_for_task(task) + return success, result + + except TaskError as task_error_exception: + + task_error = task_error_exception.args[0] + if self.esxi_ssl_thumbprint == '' and isinstance(task_error, vim.fault.SSLVerifyFault): + # User has not specified SSL Thumbprint for ESXi host, + # try to grab it using SSLVerifyFault exception + reconnecthost_args['cnxSpec'].sslThumbprint = task_error.thumbprint + else: + self.module.fail_json(msg="Failed to reconnect host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) + self.module.fail_json(msg="Failed to reconnect host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) + + else: try: task = self.host.ReconnectHost_Task(**reconnecthost_args) success, result = wait_for_task(task) return success, result - except TaskError as add_task_error: - # See add_host_to_vcenter - ssl_verify_fault = add_task_error.args[0] - reconnecthost_args['cnxSpec'].sslThumbprint = ssl_verify_fault.thumbprint - - task = self.host.ReconnectHost_Task(**reconnecthost_args) - success, result = wait_for_task(task) - return success, result + except TaskError as task_error_exception: + task_error = task_error_exception.args[0] + self.module.fail_json(msg="Failed to reconnect host %s to vCenter due to %s" % (self.esxi_hostname, task_error.msg)) ```
I would have write: ``` - try: - task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) - success, result = wait_for_task(task) - return success, result - except TaskError as add_task_error: - # This is almost certain to fail the first time. - # In order to get the sslThumbprint we first connect - # get the vim.fault.SSLVerifyFault then grab the sslThumbprint - # from that object. - # - # args is a tuple, selecting the first tuple - ssl_verify_fault = add_task_error.args[0] - host_connect_spec.sslThumbprint = ssl_verify_fault.thumbprint - - task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) - success, result = wait_for_task(task) - return success, result + for _ in range(0, 2): + try: + task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) + success, result = wait_for_task(task) + return success, result + + except TaskError as task_error_exception: + + task_error = task_error_exception.args[0] + if self.esxi_ssl_thumbprint == '' and isinstance(task_error, vim.fault.SSLVerifyFault): + # User has not specified SSL Thumbprint for ESXi host, + # try to grab it using SSLVerifyFault exception + host_connect_spec.sslThumbprint = task_error.thumbprint + else: + self.module.fail_json(msg="Failed to add host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) + + self.module.fail_json(msg="Failed to add host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) ``` It seems vim.fault.SSLVerifyFault and other vim.faultâ¦ are always packed in a TaskError.
```suggestion if host_network_info.atBootIpV6Enabled: if host_network_info.ipV6Enabled: ... elif host_network_info.ipV6Enabled is False: ... else ```
Move import statements after Line 81 or after RETURN
```suggestion folder=dict(type="str"), ```
This method will retrieve only inventory of the last system that Redfish API returned in `_find_sytems_resource`.
Not catching non-20x responses.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
Not catching non-200 responses.
Not catching non-200 responses.
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Sorry, was out all of last week. I'm looking for my reproducer right now.
Here is my reproducer, consistently fails: ``` --- - hosts: localhost connection: local vars: elb_app_lb_name: "{{ elb_app_lb_name }}" tg_name: "{{ tg_name }}" tasks: - name: create an application lb elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 listeners: - Protocol: HTTP Port: 80 DefaultActions: - 'Type': 'forward' 'TargetGroupName': '{{ tg_name }}' - name: update subnets elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-cbdf56ae - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 ``` Traceback: ``` TASK [update subnets] ************************************************************************************************** task path: /Users/shertel/Workspace/ansible/my_playbooks/elb_application_lb/iterate_over_NoneType.yml:22 Using module file /Users/shertel/Workspace/ansible/lib/ansible/modules/cloud/amazon/elb_application_lb.py <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: shertel <127.0.0.1> EXEC /bin/sh -c 'echo ~ && sleep 0' <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" && echo ansible-tmp-1499709521.38-260285283136193="` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" ) && sleep 0' <127.0.0.1> PUT /var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/tmpiiu8JI TO /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/ /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py && sleep 0' <127.0.0.1> EXEC /bin/sh -c '/Users/shertel/Workspace/ansible/venv/python2.7/bin/python /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py; rm -rf "/Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/" > /dev/null 2>&1 && sleep 0' The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1005, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1000, in main create_or_update_elb(connection, connection_ec2, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 895, in create_or_update_elb listener_changed = create_or_update_elb_listeners(connection, module, elb) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 704, in create_or_update_elb_listeners listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 487, in ensure_listeners_default_action_has_arn for listener in listeners: TypeError: 'NoneType' object is not iterable fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1005, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1000, in main\n create_or_update_elb(connection, connection_ec2, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 895, in create_or_update_elb\n listener_changed = create_or_update_elb_listeners(connection, module, elb)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 704, in create_or_update_elb_listeners\n listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get(\"listeners\"))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 487, in ensure_listeners_default_action_has_arn\n for listener in listeners:\nTypeError: 'NoneType' object is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ************************************************************************************************************* localhost : ok=1 changed=1 unreachable=0 failed=1 ```
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
`commands` should always be a list.
This should be handled in the method where commands are being generated.
Write a method to generate final diff so it can be used anywhere in the code when required.
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
remove `required=False` and `default=None`
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
`IGNORE[xxx]` is used as something iterable, and I don't think any of the calling code wants a list of letters :)
That's a really interesting piece of information I did not know.
If you turn this into ```suggestion if not os.path.exists(collection_output): _build_collection_tar( collection_path, collection_output, collection_manifest, file_manifest, ) return ``` you could reduce some nesting which improves readability.
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
I think we should guard against an `IndexError`. Even if Linode guarantee us some value, given programming error and such, I'd like to guarantee users of this module error messages that lead them in the right direction.
I don't understand why we would `return False` here. This function is about giving back an instance based on the public IP address or failing gracefully with an error message for the user. If this `return False` is happening, we need to write code to handle that in all places it is called within the module. This can lead to extra `if/else` which we should avoid for maintainability purposes.
We could merge the two `_get_instance*_ip` functions with something like? ``` def _get_instance_by_ip(self, instance, is_private=False): """Returns the IPv4 address of the instance.""" if instance.ipv4 and len(instance.ipv4) > 0: for ip in instance.ipv4: parsed_ip = ipaddress.ip_address(ip) if parsed_ip.is_private and is_private: return ip if parsed_ip.is_private and not is_private raise AnsibleError('Expected public IP not found') return parsed_ip raise AnsibleError('Instance IPv4 address is missing or empty') ``` Less code :rocket:
Ah, right, got it :+1:
No need for this var actually: ```suggestion ```
`file_copy` â `copy`.
recurse (boolean): Not required, default (false)
version_added and default value can be dropped as this is new module.
Should not return a fail, just a `changed=False`
recurse = bool(module.params['directory']['recurse'])
What is `purged_vars`, BTW? I now saw that this is not an option for this module.
indentation here seems different. I think there are extra spaces then rest indentation above
```suggestion - Create or delete project variable. ```
```suggestion - Gitlab access token with API permissions. ```
Change this parameter for a more explicite one : `project` This one should handle project `path` or `id`
```suggestion variables = {} ```
I'd probably still want to see `.absolute()` in the end
well, maybe. I haven't checked what `.absolute()` does.
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
I wouldn't exactly call a dictionary `list`.
Use `get_bin_path` instead of this function.
Add absent as well.
it would require to have the content into a var e.g like with the slurp module.
This needs to be `2.5` or `2.6` depending on when the changes come in for the merge window. If you can get the changes in today, we should be good for the `2.5` merge window (apologies for the late review).
~~~ - name: Ensure a network is present cs_physical_network: ~~~
This docstring should be used for the `CallbackModule` class instead of the module.
Can you please rewrite the examples with a `name:` and multi line statements using `key: value` We are in the process of standardising all the modules to use that format.
So by default Ansible modules use the system-configured proxy settings, unless you set **use_proxy** to **no**.
I'd rather have the standard behavior from other modules, which is to specify **use_ssl**. Check **uri** module.
I would expect a proper default here, probably `default: 'yes'`
So we have a default way of doing proxies. Normally it picks up the system settings, unless **use_proxy** is set to 'no'. The format of this parameter is best kept in line with other modules for simplicity.
The standard parameter for this is **use_ssl*, please change this.
The return msg should be indentical in normal and check mode
Use `msg` instead of `result` attribute ```suggestion msg='Successfully updated service %s' % service) ```
Use `msg` instead of `result` attribute ```suggestion msg='Successfully created service %s' % service) ```
Use `msg` instead of `result` attribute ```suggestion module.exit_json(changed=True, service=remote_service.attributes, msg='Successfully deleted service %s' % service) ```
The return msg should be indentical in normal and check mode
```suggestion - Certificate content to load. One of I(cert_url) or I(cert_path) or I(cert_content) is required to load certificate. ```
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
This is also not needed, idem for all other parameters.
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
Go ahead and use `b_dest` in the function signature also.
@tstoner I am curious why you are raising `TypeError` if capabilities cannot be fetched. Given that the new options added in this PR are not the required options for `nxos_nxapi` module, I don't think we want to fail the module if `device_info` is None. Same for `os_version` and `os_platform`. The module can simply ignore the task and pass when these parameters are used with a warning message if capabilities isn't available instead of failing/raising exception.
Note that fail/exit_json should be handling bytes or text; making them the proper string type for that python version before passing them in to the stdlib's json.dumps().
```suggestion result = self._run_command([self._blkid_bin, '--uuid', uuid]) ``` According to `man blkid` on my system, it is `--uuid` and not `--uid`.
Beware that the fourth positional argument has shifted, so if people used this interface using positional arguments it may break. (I don't think there's a risk, as we can safely assume you're the only user of the interface...)
It would be awesome if buildah supported copying from a container.
use `with` statement
kushal found that check_call is 2.5 ; check_output is what is 2.7.
No longer using a temporary file. This issue is resolved
s/write target file {0}/fetch file to {0}/
```suggestion feed_client_cert: version_added: 2.10 ```
You should mention that the default value is taken from `client_cert` if that's specified, and that this will change in Ansible 2.14.
I would add this to a new paragraph, so it will be easier to read (and harder to miss). ```suggestion - If not specified the default value will come from client_cert. Which will ```
```suggestion - The certificate in PEM format. ```
```suggestion - Optionally enable encryption. ```
Add an example for this in EXAMPLE section.
My bad. Didn't see if in later stages.
You are not executing command returned by `modify_conn_disable_ipv4` so I am sure that it has no effect.
My bad. Didn't see if in later stages.
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
if you are using loader, just use `get_file_contents`
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
Could maybe use self.find_file_in_search_paths(variables, ['templates', 'vars', 'files'], fn) here.
get_basedir should not be needed, the ansible_search_path should include the correct one
this should be prepended, as the list controls the priority in which the search happens, the template itself should be the first location scanned
C/P error, should be `AWS ElastiCache is down`? Same on L450
@s-hertel I believe this is actually incorrect. I must omit the `cluster_id` parameter to get the ElastiCache service to take a snapshot of a replication group. In the next few days, I'll get my changes put into a PR and I can show you. I've also added features for optionally waiting until a snapshot is in the "available" state.
This line has trailing whitespace, and is causing the shippable PEP8 checks to fail.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` and here as well
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Shippable doesn't like this line for whatever reason.
The value should not be quoted.
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
Missing period at the end of the sentence.
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
Maybe it makes sense to prefix the label-based groups by something like `docker_swarm-label-` or so, so that short/generic labels don't overwrite existing groups. Or maybe also make this prefix an option for the inventory plugin so users can overwrite it or leave it away if they don't think there will be collisions.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
don't raise errors on import, expose them on `parse` see developer docs for examples
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
This is wrong, already explained.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
```suggestion choices: [ full list, top sites ] ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
This was actually a bug to use new_destination, as it prevents idempotency. In this case, it's simpler to break existing playbooks, as they are already broken if they were using new_destination.
It's a change in semantics. Before we were using name/new_name for rename operations, and name for everything else. Now, name always indicates the end result, and from_name is used for rename operation. This solves idempotency issues, and makes the module more declarative.
Maybe add that no checksumming of the content is performed in this case.
an extra line
```suggestion - The state of Virtual Machine deployed. ```
Move this line after 250. You won't need to deepcopy unless you are actually creating a request.
If the VLAN exists, you should check the name and state to make sure they are same as requested.
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
Thanks for the changes! Looks good.
`commands` should always be a list.
Please order the options alphabetically.
This will not render correctly. If you use multiple dashes for the same sentence, they will end up being different paragraphs in the description. You don't need those subsequent dashes.
Please clarify the description
Makes this `Whether compatibility checks should be ignored.`
```suggestion description: State to ensure. ```
the shell itself would have done it before. but might have done it slightly differently.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
this is incorrect, the caller is specifically asking to use shell
No longer using a temporary file. This issue is resolved
Full stop, rather than comma at the end.
Missing full stop.
You can removed all the `required: false` it's implicit
You can remove the `required: false` lines, it's implicit
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
No action needed here - just wanted that note on the PR record.
You know you have a real problem when CI fails and people are discussing why that might be :-P
I suspect this line is the problem with the yaml validation failure as \ indicates to yaml a line continuation, I think. To use a \ like this it would need to be inside single quotes. Likely the same issue on lines 72, 74 and 75
The problem is the fact that we are missing an `args:` key.
If `date` and `time` is not added as part of a file name (in case of a configurable backup path option) `date` and `time` logic can be changed to fetch from the file information probably using os.stat()
It might also be useful to print login response code to supplement earlier login method debug. white testing this patch I felt login did not go through
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
This can be converted to return True. No need of new variable retry_request
This statement seems useless.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
`timeout` and `username` aren't the same thing.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
You don't need to state default=None as this is the default value.
You can remove `required=False` as that's the default.
You don't need to state `default=None` as this is the default value.
I think removing the `:` will fix the CI failure. However, I find this line confusing too. Are the ranges shown here examples of what not to do? What to do? Could we remove them altogether? ```suggestion - Cannot overlap with other address ranges within the same virtual network. ```
This should `subnet` with type `complex` and `contains:` the rest of the information
It looks to me like these URLs are better suited for a `seealso` section.
Is the docsite bug that causes strangeness when rendering complex types resolved? I don't recall the issue number, but I think @willthames pointed it out.
``` cd docs/docsite; MODULES=ec2_vpc_subnet make docs ```
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
Manages bundles on Clear Linux systems
I'm not sure if we can also use the words "packages" or "updates" in their to make it a little more obvious.
This doesn't have to be quoted.
No need for the `M(..)` here as that will just generate a link to the same page.
This string doesn't have to be quoted.
Write a method to generate final diff so it can be used anywhere in the code when required.
`commands` should always be a list.
This should be handled in the method where commands are being generated.
This isn't necessary as facts will always be empty if running-config has no lldp config.
No need to set `have`, `want` explicitly as it is always be empty dict if not resource is given/present.
By the way, you don't need `else:`, since this will be evaluated anyway.
Look what I've found: ```python $ ipython Python 3.7.0 (default, Jun 28 2018, 11:18:11) Type 'copyright', 'credits' or 'license' for more information IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import pkg_resources In [10]: ipdst = pkg_resources.get_distribution('ipython') In [11]: ipdst Out[11]: ipython 6.4.0 (/home/wk/.pyenv/versions/3.7.0/envs/ansible-py3.7.0-pyenv-venv/lib/python3.7/site-packages) In [15]: ipdst.as_requirement() Out[15]: Requirement.parse('ipython==6.4.0') ``` This probably can completely eliminate need for doing `pip freeze` and parsing it! @HD650 please investigate this.
Why don't you do this right in the `return` line? If you think it's going to be too long, be aware that you can break the line by wrapping it with braces: ```python def _is_valid_distribution_name(name): return ( not name. lstrip(). startswith(('>=', '<=', '!=', '==', '>', '<')) ) ``` (you can put `not` outside of brackets if you like it more this way)
This is tricky. It should probably return false because there's no way of knowing whether it's the same version, so we'll need to invoke pip to reinstall it as it does when you run it manually
I'd probably add `distribution_parts = []` after yield inside of `if` block and then you'd only need `distribution_parts.append(name)` outside of if-block without a need to have diverse code or `else`-block.
I have already cleaned that up in a follow-on that I was going to submit after this..
Please remove the raising of an exception and properly fail the module.
Please remove the raising of an exception and properly fail the module.
The results of vmdk_disk_path_split are not used anywhere here (they are used inside find_vmdk, but it calls the routine directly.
```suggestion [datastore_name] path/to/file.vmdk ```
```python # warn when failing to skip due to lack of support for skipping only some versions display.warning('Including test "%s" which was marked to skip for --windows %s but not %s.' % (target, ', '.join(skip_valid), ', '.join(skip_missing))) ```
```python for line_number, line in enumerate(lines, 1): ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Bump this to `"2.5"` please.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
```suggestion - User specified via name or UID which is used to execute commands inside the container. If you ```
```suggestion specify the user via UID, you must set C(ANSIBLE_REMOTE_TMP) to a path that exits ```
Yeah, a list is fine.
should replace 'Udp' with C(udp), etc...
No in docs
Please only import what you need, rather than `*`.
Please only import what you need, rather than `*`.
Please add docs on what this module returns.
This is wrong, already explained.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
This should be ``` 'supported_by': 'community' ```
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
Period at end.
`Manage Cisco NSO configuration and service synchronization`
> would it make sense to publish this module as is (with dependency on unicon library and support for local connection type) as a short term solution and plan how to replace it with network_cli connection as a long-term plan and do it as a part of the next release? Yes, that should work IMO. FYI Ansible follows 4 version deprecation cycle that is if the code (options) available in a stable release is deprecated it can be removed after four releases, typical Ansible release cycle is around 4 to 6 months.
Maybe add `register: result` to one of the examples and then a `debug` task to view the result (or parts of it). That makes it easier for not so experienced people to use the module.
```suggestion - name: show configuration information ```
@sdodsley sounds good, thank you for the clarification
There seems to be an assumed structure of what is returned by the API endpoint, operating under the pretense that the structure won't change since the API is versioned, is there any chance that this assignment could fail and cause an unhandled exception? (similar question for other functions doing similar things below)
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
All AWS calls should be wrapped in a `try`/`except` block
I'm fine with this being a followup PR. Error handling needs to be added, but that'd increase the diffstat of this PR pretty significantly, and since the handling wasn't there before I wouldn't block the merge over it.
Should this be a call to a function that does handle retries (all the other API calls in this function seem to at least be capable of that)
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
This should be `else`, looks like the logic got inverted accidentally.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Since we aren't sending the errormsg to an exception, we want to use to_unicode rather than to_bytes. to_bytes won't cause any problems with the code here in python2 but it will fail in python3 (because the string literals will be of the text type and so it won't match with errormsg as bytes then.)
There is a small difference: if `_set_password` is `True`, the module should set the password and not return here. Setting the password is done later in the code. It's probably better to not return here at all, neither in check mode nor outside check mode, since otherwise `changed` is not set correctly. After all, `update_password` has check mode support built in.
IMHO this should be just as follows because check mode is not relevant if no action is taken. ~~~python if user['enabled'] == args['enabled']: return(retvals) ~~~
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
Are there any other IDs/names that a url_map would be known by? If so, we should call this "url_map_name" or something.
Fair enough, I'm good with that.
I think this can just be `name`
Please remove this property since ansible already exposes `changed` so users can see whether a resource was altered during a task.
Python 2.6 is minimum requirement for Ansible >=2.4 targets
However your descriptions for the last 2 commits are reversed. Should be: ``` # * https://github.com/SethMichaelLarson/selectors2/commit/f0c2c6c66cfa7662bc52beaf4e2d65adfa25e189 # Fix use of OSError exception for py3 and use the wrapper of kqueue.control so retries of # interrupted syscalls work with kqueue # * https://github.com/SethMichaelLarson/selectors2/commit/6f6a26f42086d8aab273b30be492beecb373646b # Fix formatting of the kqueue.control patch for pylint ```
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
`descriptions:` should end with a full stop
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
You shouldn't even need to try it again- the only case we want to recover from is if another worker already created it, so if we got this error, just ensure that it exists and continue on happily, otherwise re-raise the original exception. I guess there might still be a tiny remaining race condition in that case, since `os.makedirs` is unlikely to be atomic, but adding a retry makes it more possible for workers to trip on each other, and could ultimately repeat a different incarnation of the same race for each level of the path (though *far* less likely). If we really want to solve that potential problem, either the $controller_term_replacement_tbd needs to create the cache dir in a serialized pre-fork code path, or we'll need a dedicated lock for the creation of the tempdir. I'd probably vote for the former, since adding a new resource lock makes deadlock possible (and managing more locks is ultimately a lot more expensive than a tempdir creation).
Yeah, that works too- just gotta find a good place that's ideally specific to the Python module subsystem that's already running pre-fork.
Since we're intending to backport this fix, it'll have to remain a `try/except OSError:` with a double-check in the exception handler. Once it's landed in devel and our CI is able to handle py3-only controller tests (which is still WIP), we can update to use py3-only bits.
in [py3](https://docs.python.org/3/library/os.html#os.makedirs) we can use `os.makedirs(lookup_path, exists_ok=True)`. With that we can get rid of the try/except and check condition, condensing everything here into a single line.
@cloudnull see `makedirs_safe` for older python compatibility (probably will be in backport), but since we require python >=3.8 on controller, `exist_ok=True` should be good enough
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
```python def toml_dumps(data): return toml.dumps(convert_yaml_objects_to_native(data)) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
`str` -> `six.text_type` I guess? cc @abadger ^
Please ignore, the param will be set to False when not specified
There are other parameter to find an existing VM using `get_vm` API such as `moid`, `uuid` and a helper parameter `use_instance_uuid`, it would be great if we can implement these parameters as well. This will make all guest module parameters equal and this module future proof.
```suggestion destination_vcenter_password=dict(type='str', required=True, no_log=True), ```
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
the module will always fail. Use `module.exit_json` and `module.fail_json` based on `result`
not sure if this is useful
throw seems unused
Great, thanks for putting this check in here.
Add more description about module and other things like warnings, recommendation etc.
too many apis
I don't like the `: ` here
Please remove this line.
Please remove this line.
Please remove this line.
Presumably you want `It *will* always use`, or something to the effect
```suggestion required: false type: str ```
```suggestion required: false type: str ```
```suggestion choices: [ create, update, list, delete, query_index_sets ] type: str ```
```suggestion required: false type: str ```
```suggestion required: false type: str ```
This should have a try/except around it as well, since `dateutil.tz` isn't in the standard library.
After looking at this more closely I realized that boto3 does use local time here instead of UTC. However, boto3 is using `dateutil` instead of `tzlocal`. So this will work without any additional requirements: ```python import dateutil.tz value = datetime.datetime(2019, 4, 4, 11, 41, 0, 878000, tzinfo=dateutil.tz.tz.tzlocal()) ```
CI failure due to syntax error (missing `:`).
These tests now run on python 2.7 (though fail on python3 still). I think if we're moving toward using placebo rather than just mocking, it may make more sense to do that here, especially since integration tests won't be run with CI (and running them manually may not happen terribly frequently). Shippable will notice if the placebo recordings lose compatibility with changes made in a PR.
This is weird: you import pytest but then use unittest. FWIW the general consensus in the core team is to use pytest whenever possible, especially for new things.
Yes, `YYYY-MM-DD` should be perfect. Thanks for the xkcd link ;-) @lolcube I'm still curious where `:` is used; I'm really not aware of anything where it is used (or I completely forgot :) ).
There are indeed, but this is not about i18n; Ansible should not use the date format of some random locale, but something which is common (to the area where the module belongs to, or something from a RFC). I've never seen this notation, but maybe I'm missing something, that's why I'm asking :)
LOL ok :) Good luck on getting it back...
Why are you using `:` for date formatting? To me, that's highly unusual and something I would not expect.
I just don't ask questions about date formatting anymore, there are way too many locales :joy:
```suggestion - To identify an existing interface within a namespace, use the I(namespace) option. ```
```suggestion support (for example 'type vcan'). ```
```suggestion into namespace I(netns). ```
```suggestion - The broadcast (L2) address for the interface. ```
```suggestion - Note, when the interface changes namespace it loses ```
If we do add something like this, three thoughts on the formatting the string: - Use clean_args since that will have had private parameters stripped out. - What's PERM? Should this be ARGS instead? - Use to_native(e) and to_native(traceback.format_exc()) instead of str(). (clean_args should be a native string so it shouldn't need to be coerced here).
note: You can combine these loops to be more efficient: ``` python ppaths = [p for p in ppaths if not p.endswith('/ansible_modlib.zip') and not p.endswith('/debug_dir')] ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
Probably should also check and fail for `self._connection.transport == 'local'` - no need to go nutty trying to figure out if they're rebooting the controller via a more circuitous route, but at least cover the easy one.
This is the old ANSIBLE_METADATA stub. CI will fail.
The author string should be formated like `<name> (@<githubhandle>)`
Parameters that are not required don't need `required: false`.
If there's no default, `None' is implicit. (It means parameter undefined) So this is not needed.
Make this a separate item in the list.
Sorry, my bad. I didn't see the implementation of `_run`.
Might want to check `rc` status before return output.
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
This is new lookup so no need to add `version_added`
```suggestion version_added: "2.8" ```
I think it is better to pass module as argument to build_xml() and handle lxml install check-in module_utils instead of having it in each module
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
Missing `=dict` on this and the next few lines
Need a colon at the end here
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
The value should not be quoted.
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
It would be easier if RPM and DEB were to give the same structured reply, or having an agnostic module would not be very useful (in cases like "if upstream version is greater than x.y"). Comparing versions is a complex operation and there is no filter around `dpkg --compare-versions`. Also having the full version (epoch+upstream+release, following the standard distro notation) along with the upstream version would be useful I think.
Shippable doesn't like this line for whatever reason.
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Not sure how the lazy loading of variables, the example would be simpler to just have the one task instead of 2 in the examples. ``` - name: Get 2 messages off a queue debug: msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}" ```
Best to not link to a versioned doc but the stable/latest branch https://pika.readthedocs.io/en/stable/.
There still are some references to `ampq`
`required: False` is the default and usually we just omit it.
`default: All messages` still there
Including values in the sample code would be great, I didn't see the version and in this case maybe just a sentence to tell people where you could find the value, like what you suggested.
updated or created isn't needed
s/createMode/I(create_mode)/ When referencing other options, enclose it in `I()` and the docs will do the formatting for you.
You should set the default value for this like ``` create_mode: description: - ... choices: - ... - ... default: default ```
Are you able to expand on this a bit further, you should state that when it is true and the database does not match the config, then it is deleted and recreated.
We should disable pylint's check for this one line rather than doing this. doing this defeats part of the purpose of having a compatibility library.
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
I suspect you actually want 'to_text' as bytestrings are not going to be very usable in jinja2 context
Since this module no longer depends on boto, you should update the [unit tests](https://github.com/ansible/ansible/blob/devel/test/units/modules/cloud/amazon/test_s3.py#L4) to reflect that. You'll also want to remove `boto` from the [unit test requirements](https://github.com/ansible/ansible/blob/devel/test/runner/requirements/units.txt#L1).
You can place fixtures into a conftest.py file and then they will be loaded automatically instead of needing an implicit import.
redis is good example, https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/lookup/redis.py in any case it is ts simple: ``` ini: - section: consule_kv_lookup key: validate_certs ```
env var or ini entry, just like you do for host
forgot that part, still it seems that rest of options can be set in other ways also, why force user to always set in kwargs
TBH I prefer `cert_validation` as it uses namespace prefixes (and related options sort together). Maybe we ought to fix the **httpapi** connection plugin instead ? ;-)
For the **httpapi** plugin the parameter is `validate_certs` and config item `ansible_httpapi_validate_certs`.
You're right: when `import_failure` is `True`, `FW_VERSION` could be not `None`. `import_failure` must be checked at the end, nothing needs to be changed here.
Error messages (here and below) should mention `FW_VERSION` value.
`distutils.version.LooseVersion` must be used instead of string comparison.
distutils version comparison in broken in Python 3
Oh, Cool. Thanks for information. Then we can use LooseVersion.
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
Can you use here: ```python host_id = get_id_by_name(hosts_service, host_name) ``` you won't have to check if host exists and it raises the exception for you. And you are insterested in host id only anyway.
Same for VMs.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
host_storage.type == otypes.StorageType.FCP
I think it's not necessary to mention the `.ini` here.
```suggestion - This parameter is required if you are not using the C(copr) parameter. ```
Or a facts plugin would also work.
Listing data should be in a lookup plugin, not a module.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
Look up "Rule of Three" and "Don't Repeat Yourself" to improve the code duplication situation here.
This could be refactored into a method, since the logic is identical. Same for the next two large blocks.
There are no assertions in the integration test to ensure this message is correct.
I was suggesting the ansible core could add an ipaddr argument type and validate it early enough that the concern from @pdellaert would be addressed both here and elsewhere in an easier way for everyone. It doesn't have to be done as part of this PR.
Input validation should be done before doing API calls to fetch information (you already fetch the hosts and the network stacks before we hit this). It's better to fail early and quick...
Use `to_native` for wrapping error message.
There doesn't appear to be any way for `sha1sum_old` to be `None`.
Why not simply compare contents, instead of computing sha1 of both first? Since you read both into memory, that's more efficient :) Also: it currently fails under Python 3: ``` Traceback (most recent call last): File "../bin/dump_config.py", line 84, in <module> sys.exit(main(sys.argv[:])) File "../bin/dump_config.py", line 72, in main sha1_old = sha1(open(output_name).read()).hexdigest() TypeError: Unicode-objects must be encoded before hashing ```
Also: since you're not closing the file, this might break under strange file systems (such under Windows -- no idea if anyone ever tries to do that, tough :) ).
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
In Python, we avoid adding unnecessary brackets.
Returning "magic" status variables, which need checking is required if you write in `C`, but Python has better mechanisms for communicating errors. In Python this is not a good API. Please raise exceptions and do proper processing with try/except.
You can just `return` without `else`.
You don't need to create a `list()` and then mutate it. Instead, you can turn it into a list comprehension, making the whole function shorter and better readable: ```python try: return [Package(name) for name in _recover_package_names(names)] except Exception as e: # includes RequirementParseError, but also other errors, which might occur, and would need fail_json anyway module.fail_json(msg=str(e)) ```
I'd also turn `name` into `names` because it's a list and variable name should reflect this detail.
Do you have any references for the inline if being discouraged? If you don't like the inline if, then I'd go with the normal if block.
Ping @willthames - other than this validation fix this is good to go.
It would be nice to return the object you created too: `res['provider'] = self._get_saml_provider(self._get_provider_arn(name))`
pep 8 wants all imports at the top
This is handled by `AnsibleAWSModule`.
Handle NoCredentialsError as well
facts modules can trivially support check mode (#23107)
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
Can that raise a ClientError? I don't think boto3 verifies the connection like boto does when it's first created.
diff cache, I was talking about ConfigManager, see my PR/diff post for details
The consistency is about 'paths taken' to load a plugin, of which you have several, of which this is but one. By modifying the common function as i did, it covers all paths that need it
It seems like the above 5 lines or so could just be replaced with a call to `self._clear_caches()`
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Use `get_bin_path` instead of this function.
```suggestion aws_organization_units: ```
```suggestion description: The Organizational Unit details. ```
```suggestion - State of the organizational unit. ```
```suggestion - Name of the organizational unit. ```
This is correct.
Actually, even more than +1 to changing this to packages because this is in the error messages which we return to the user, not just about variable naming. Everyone will understand what packages means in this context but sysadmins who just need to translate a script to setup the production environment their dev team gave them won't understand "distribution".
Well, it was used to be known worse a while back. They've started working on that tutorial not long ago. Old users don't rush to reread those. That's why I prefer combo compromise to be as explicit as possible. Python packaging is in a weird state for a long time now. I don't want to add any more confusion.
I would call them `packages` instead of `distributions`.
FWIW, +1 to package. Distribution is only applicable to python, making it harder for people outside of that ecosystem to work on this module.
I think you could go for `elif:` here.
Remove as not needed (default)
Remove as not needed (default)
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
This isn't really the case, the module seems to be installing the feature so I would mention that. Also mention that if a reboot is required then it will fail.
I think `state` is more ansibley
How about the rest items of `spnprofile`
`self` is no need
`self` is no need
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
What if the rest service_principal missing client/secret field
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
change this to return `customer_gateways`
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
No need to set this, or check it.
Catch botocore.exceptions.ClientError instead of Exception here too.
This should be botocore.exceptions.NoCredentialsError.
If this is set to type='int' this should avoid the later type conversion
I think it might be good to have a `purge_roles` option to be able to only enable role_to_remove if desired. I think it's a little confusing that both state: absent and state: present can be used to remove roles. I like the logic in this section (particularly if there was a purge_roles option that works like purge_tags does for other AWS Ansible modules) better than for state absent.
This line doesn't need to be in the try/except.
The docs say this should be `servers`, I'm ok with either but it should be consistent.
You should fail here with `self.fail`. Currently you'll have `account_keys` as undefined if this exception is thrown.
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
there is no need to set a temp variable for `images`
This no longer accepts `VMWARE_TEST_PLATFORM=''`. The var be unset or set to worldstream or govcsim. This is probably fine, just want to note the change.
Traceback in CI here: ``` 04:41 Traceback (most recent call last): 04:41 File "/root/ansible/bin/ansible-test", line 28, in <module> 04:41 main() 04:41 File "/root/ansible/bin/ansible-test", line 24, in main 04:41 cli_main() 04:41 File "/root/ansible/test/lib/ansible_test/_internal/cli.py", line 128, in main 04:41 args.func(config) 04:41 File "/root/ansible/test/lib/ansible_test/_internal/executor.py", line 391, in command_posix_integration 04:41 command_integration_filtered(args, internal_targets, all_targets, inventory_path) 04:41 File "/root/ansible/test/lib/ansible_test/_internal/executor.py", line 1028, in command_integration_filtered 04:41 remote_temp_path=remote_temp_path) 04:41 File "/root/ansible/test/lib/ansible_test/_internal/executor.py", line 1334, in command_integration_script 04:41 env_config = cloud_environment.get_environment_config() 04:41 File "/root/ansible/test/lib/ansible_test/_internal/cloud/vcenter.py", line 256, in get_environment_config 04:41 vcenter_username=self._get_cloud_config('vcenter_username'), 04:41 File "/root/ansible/test/lib/ansible_test/_internal/cloud/__init__.py", line 271, in _get_cloud_config 04:41 return self.args.metadata.cloud_config[self.platform][key] 04:41 KeyError: 'vcenter_username' ```
```suggestion self.vmware_test_platform = os.environ.get('VMWARE_TEST_PLATFORM', '') ```
line is too long
I suggest: if parser.get('DEFAULT', 'vmware_validate_certs').lower() in ('no', 'false'):
Please don't repeat the previous sentence, better: `- This can be a list (since 2.2) and contain version specifiers (since 2.7).`
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion replace: ```
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
use `required_one_of` kwarg when creating AnsibleModule instead
```suggestion to iterate use a C(with_) directive. ```
wrap exceptions in `to_native` when stringifying them
no, host_list and advance_host_list use an 'inventory string' , which is why they dont call super version of verify_file as 'its not a file'
We use `aep` as the default parameter in other modules and we never used `AEP`, `AEP_name` or `attached_entity_profile`. So please use the same parameter name as the **aci_aep** module !
I wonder if this wouldn't be better named `lag_type` either as the default name, or an alias. As LAG seems to be a common term (at least I know this term). cc @rsmeyers @jmcgill298
Start with a capital.
Do the same for other descriptions.
End with a dot.
I think `if props is not None` is more conventional :smile:
Casting to list isn't needed here ```suggestion elif any(fnmatch.fnmatch(item, pattern) for pattern in ignore_files): ```
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
'readme' is required. Galaxy artifact import enforces that the field exists when validating the galaxy.yml. Later in the import process, it's verified that the file 'readme' points to exists in the archive (https://github.com/ansible/galaxy/blob/devel/galaxy/importer/collection.py#L102)
Either 'license' has to exist (and be a non-empty list) or non-None 'license_file' is required. https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L236-L247
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
```suggestion - Note that to use dedicated tenancy you MUST specify a I(vpc_subnet_id) as well. ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
Really not convinced by `show` Might be better to have an ssm_parameter_store lookup plugin for this need.
Not convinced we need this example, particularly with `with_` going away.
Yes, they were.
`a['adress']` could be used instead of `(len(a['address']) > 0)`.
The method does nothing, should not this method be removed ? * [X] Done
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
```python def toml_dumps(data): return toml.dumps(convert_yaml_objects_to_native(data)) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
`str` -> `six.text_type` I guess? cc @abadger ^
I'm ok with this change, however the additional formatting changes should be reverted. The current formatting meets our code standards.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Do you need that step? `clients = client_list` should be enough
In other modules that support `authorize` we have some code here to check we are in the right context (privileged shell vs non-privileged). If you were to test the code with a task that requires privileged then one that requires non-privileged then I believe the current code would fail. `ios` supports `authorize` as well: https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L72-L86
Use module.fail_json_aws(e), which will handle calling ansible.module_utils._text.to_native() on e for you.
If this is set to type='int' this should avoid the later type conversion
You can make use of some of the helpers in AnsibleAWSModule ```suggestion connection = module.client('cloudwatch') ``` This then moots the pieces below.
Not necessary but this map and the one on 690 are better written as: ``` python elif LooseVersion('.'.join(to_native(ver_field) for ver_field in etree.LXML_VERSION)) < LooseVersion('2.3.0'):
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
``` ttl=dict(type='int', default=0), ```
Remove this as it is already declared above.
please create a list: e.g. ~~~ yaml author: - "Amel Ajdinovic (@aajdinov)" - "Ethan Devenport (@edevenport)" ~~~
set required: false
I've set `required: false`. Thank you.
I've updated `required` to `false`.
`required` is now `false`. Thanks.
Can we have a list of packages which can be locked/unlocked? just like yum module does.
use this instead ``` module.get_bin_path('yum', required=True) ```
Please add an example below that shows you how get the newer NuGet provider version.
How about 'absent' as state, which make this module complete.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
I know this is what it done in `load_platform_subclass()` but that looks incorrect as well.
I don't believe this is correct. `args` and `kwargs` need to be passed to class when it is instantiated. This should probably be `*args, **kwargs`, though.
I'll have to look into this more. I'll find out more tomorrow when the author gets back from PTO.
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
That's def cheap enough :)
That's fair enough, the code should be split out into a generic function so it can be used by other modules. There is nothing AWS specific about the camel_dict_to_snake_dict and the reverse function, it was only used there because on AWS had a need for it.
@gustavomcarmo please check my pr #39722 , i have 2 options now, raw and curated
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
`username` should still work, the only case where it wouldn't AFAIC is if the username is a valid sid string. If that is the case they would have to do `.\` and they probably deserve their punishment for doing something so silly.
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
Parentheses around `e.message` are useless.
Nowadays we do: ```yaml type: bool default: 'yes' ```
Wouldn't the choice be [ 'yes', 'no' ] as you'd expect from a boolean ? As per previous remark, this would become: ```yaml type: bool ```
to *be* assigned
s/will be used/will be used by default if not otherwise specified/ - or could be handled like `scope` (no default, must be specified on new group)
This should be: ```yaml type: bool ```
One way to do this is something like: ```yaml unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
Please add `type="str"`, and maybe list the possibilities as `choices=`.
Please add `type="str"`
type should be a 'int'
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
I don't think we should be referencing a private attribute/variable here in any case. We have no guarantee that it will exist in any future release either.
Well, the reason I'm asking is that by using something which is present on only new envs you're adding an implicit dependency and we have to maintain backwards compatibility we committed to maintain.
Oh, I've got an impression that you're using pip's importables. In this case it's fine.
Cross-compability, backwards compatibility, command line compatibility, ease of discovery. * Other packaging modules support comma separated package entries. * The pip module itself supports comma separated package entries * pip supports single string entries as valid packages * comma separated list entries are the natural way to write lists on the commandline. * error messages if people were to violate these rules (for instance: ```ansible localhost -m pip -a 'names=django>=1.11.0,<1.12.0'``` wonn't point to the actual solution unless we implement this sort of detection for creating the error message... in which case we might as well do the right thing.
I usually pre-compile regexes into a global variable so that it only has to be done once. ``` _VCS_RE = re.compile(r'(svn|git|hg|bzr)\+') [...] def _is_vcs_url(name): """Test whether a name is a vcs url or not.""" return re.match(_VCS_RE, name) ```
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
and convert filename to bytes again.
s/2.6/2.7/ We passed the freeze date for 2.6
Short description shouldn't have a period.
```suggestion - Manages Bitbucket pipeline known hosts under the "SSH Keys" menu. ```
`memlimit` and `memswaplimit`: allowed units could be mentioned.
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
``` distributions.extend(self.list_streaming_distributions(False))``` ```+=``` may be fast , `extend` bring clarity.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Please put these back.
Most other modules default to yes so I would do the same here
I think you can just say '...input as a list of key value pairs' since these are not module options. But can tags just be a dict? You could then use ansible_dict_to_boto3_tag_list(). It feels like some functionality is being duplicated.
```suggestion commit: no ```
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion - name: Install latest version of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion EXAMPLES = r''' ```
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
You can use this shim instead: ```python from ansible.module_utils.six import configparser ```
Add this snippet at the top of the module: ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ``` Then, you won't have to inherit from `object`.
Just use ` and ...` instead of nesting. Less indentation == better readable.
The json library entered the python stdlib with python-2.6. Code that runs on the controller (which includes dynamic inventory scripts) need python-2.6 or greater. So there's no need to fallback to simplejson here. the json stdlib library should always be available.
This doesn't really matter since only a single instance of ForemanInventory is created in this script but config_paths should really be an instance attribute (created and given an initial value in ```__init__```) rather than a class attribute. Class attributes exist a single time per class. All instances of the class would share the same instance of that attribute. Instance attributes exist, one per instance and thus can change independently. Modifying config_paths later in the code is a tip-off that this should be an instance-attribute rather than a class-attribute. Also, you can probably move the setting from an environment variable to be with this code when you do that. It would seem to make sense to keep that all together.
in [py3](https://docs.python.org/3/library/os.html#os.makedirs) we can use `os.makedirs(lookup_path, exists_ok=True)`. With that we can get rid of the try/except and check condition, condensing everything here into a single line.
@cloudnull see `makedirs_safe` for older python compatibility (probably will be in backport), but since we require python >=3.8 on controller, `exist_ok=True` should be good enough
Since we're intending to backport this fix, it'll have to remain a `try/except OSError:` with a double-check in the exception handler. Once it's landed in devel and our CI is able to handle py3-only controller tests (which is still WIP), we can update to use py3-only bits.
It involves `unfrackpath` among other things ... :fearful:
Yeah, that works too- just gotta find a good place that's ideally specific to the Python module subsystem that's already running pre-fork.
Need to ensure that the group actually exists - currently when using this, the inventory plugin fails here because the previous code containing ``` if group_name not in self.inventory.groups: self.inventory.add_group(group_name) ``` has not been added here.
Should likely be `prefix, sep, key`
parent name also needs to be 'safe'
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
Also, you could go for a generator comprehension with extending the command: ```python cmd += ''.join(' "%s"' % dist for dist in distributions) ```
```python cmd += ''.join(' "%s"' % d for d in distributions) ```
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
I'd prefer ```python # a generator expression: cmd.extend(str(p) for p in packages) # or: cmd.extend(map(str, packages)) ```
```suggestion self.module.fail_json(msg="Invalid start VLAN id %s." % vlan_id_start) ```
Yeah, i understand the backward compatibility, can you add in the description of `port_binding` that it takes precedence over the deprecated `portgroup_type` value? That way people understand the precedence.
So if both `portgroup_type` and `port_binding` are defined, it ignores `port_binding`? I think it should check for this and if they are not the same from the API perspective, it should fail with an error
Ah, so the goal is to do a back/forth translation between the values you want the user to use/see, and the actual API values. Sure Could probably be improved by just using dicts instead of all the if/else clauses, but that's just details
Been thinking about this, the easiest solution would probably be a dict: ``` port_binding_modes = { 'earlyBinding': 'static', 'static': 'earlyBinding', 'lateBinding': 'dynamic', 'dynamic': 'lateBinding', 'ephemeral': 'ephemeral' } ``` It's not a lot better, but it gets rid of those if/elif statements
```suggestion 'G': 2 ** 30, ```
I think it'd read better if you did ```suggestion 'K': 2 ** 10, ```
```suggestion 'T': 2 ** 40, ```
And so on
```suggestion (u'1PB', 1125899906842624), (u'1E', 1152921504606846976), (u'1EX', 1152921504606846976), (u'1Z', 1180591620717411303424), (u'1ZB', 1180591620717411303424), (u'1Y', 1208925819614629174706176), (u'1YB', 1208925819614629174706176), ```
I prefer `if not module.check_mode and change_string:`.
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
Use `elif` instead of `if`.
This statement seems useless.
`A regular expression or pattern`
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
`target_string` is missing.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
```suggestion replace: ```
I wonder if ansible itself has something for this in its `authorized_keys` module.
It might be better to use a similar regex that awx itself uses: https://github.com/ansible/awx/blob/devel/awx/main/validators.py#L51 Maybe just validate the format of the first line? ```python if re.search(r'^(?P<dashes>-{4,}) *BEGIN (?P<type>[A-Z ]+?) *(?P=dashes)', ssh_key_data): ```
You're correct. I misread that this `if` statement is indented. Looks good!
I would also add the deprecation warning here in addition to the failure.
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
CI failure due to PEP 8 issue: ``` 2017-01-28 07:29:47 ERROR: PEP 8: lib/ansible/module_utils/azure_rm_common.py:177:135: W291 trailing whitespace (legacy) ```
Not needed as it is already set to False
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
trivial but you can just do: ``` python path = expanduser("~/.azure/credentials") ``` so that you only allocate a string once instead of three times. (+= creates a new string)
Will the azure API always return a non-zero list or could this result in an `IndexError`? (If so, please wrap in `try`/`except`)
I saw the same problem. However we constrained because "no_extra_spaces" is already in use (ini_file). If we go with a better name here, we should deprecate no_extra_spaces in in_file and replace it with the better name as well.
`notes:` is wrongly indented and looks like an option, rather than it's own list of notes. And that is why CI fails.
Use the following to format his as code: `C({"key":"value"})`
Missing boto3 will be automatically handled by AnsibleAWSModule, this should just be: ``` try: import botocore.exceptions except ImportError: pass ```
The way to do examples changed. Now your EXAMPLES section can simply be a list of tasks, or a play.
```suggestion self.module.fail_json(msg="The role ID isn't valid %s" % to_native(not_found)) ```
Rather than raising Exception that isn't caught anywhere, fail_json should be called.
```suggestion "on the root node: %s" % to_native(admin_permission) ```
a module should never end in exception, it should use fail_json instead (you can pass traceback info if needed in 'exception' key)
as explained in related ticket, catchall exceptions are not the best way to handle user errors
equal to dest, i always expect it to be equal to itself
Clarified in f1a3251fe1303fb8d28536dbee7ac7382fad518d and 593d8231cd69e2e331a948efdbd0b26e8e4e3894.
```suggestion description: Destination file/path, equal to the value passed to I(path) ```
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
Move this outside the loop.
Append outside the loop.
`Could not recursively set attri...`
I think `if props is not None` is more conventional :smile:
Casting to list isn't needed here ```suggestion elif any(fnmatch.fnmatch(item, pattern) for pattern in ignore_files): ```
> ['host_default_vnc_port_start','host_default_vnc_port_end'] `['host_default_vnc_port_start',<missing space here>'host_default_vnc_port_end']` should be: `...nc_port_start', 'host_de...`
regarding question number 3, I think it's okay to remove it - this has only been merged for 3 days, and wasn't in any released version of ansible (afaik), so it's unlikely that anyone is relying on it anyway.
I am OK with either of the solution.
I would write this as ``` if current_values.get(key, "").lower() != val.lower(): ```
vnc_port can be of type `int` so `type='int'`
The author part is a list now, so it should be: ```yaml author: - cytopia (@cytopia)
`Manage Cisco NSO configuration and service synchronization`
```suggestion version_added: '2.8' ```
I'd move this into an example
Not sure if this will get rendered correctly, from the root of your checkout please do `make webdocs` Then check the HTML that's generated
I think some other changes to the config have landed that should certainly eliminate the need for this, in particular the `TowerModule` class.
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
This should be supports_check_mode=False.
chack -> check
Try except blocks souls he as small as possible
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
we should also return if we both delegate executions and delegate_facts
many modules have the default of `state=present`. consider this as a default if you feel it make sense.
vtf has `required=True`, so they Playbook writer will always have to specify a vrf, so I'm not sure what this note means.
Not sure if this line is needed as `vrf` has `required: true`
Is there a way to find this out by introspecting in boto3 instead? Manually updating this is kind of a pain.
could add boto3 and botocore to the docs as requirements
@ossark Thanks for the PR, just one change then I can get this merged. Thanks :)
@ossark Could you please address this then we can get this merged. Thanks for your fixes.
The rebase brought the default back. This just needs deleting, then I think we're ready.
this should be a common function in basic.py (i think there is this one or the reverse there already)
Use `required_if(['state', 'present', ['recipients', 'actions']])` in the `AnsibleModule` arguments
Add the `r'''` to https://github.com/ansible/ansible/pull/49652/files/6dc61c94e3abd3cf74998b78f4fa08956a95c269#diff-1c417562a0944ee1362da84b93d9695dR56 to avoid it. We do this for all our module examples so we don't have to worry about escaping these values.
No need to quote the path, not using double quotes also means you don't need to double up on `\`, e.g. just do `path: C:\Windows\temp`.
nope, looks like you missed this one.
since the plugin is called `aws_ssm`, I'd change this to `ansible_aws_ssm_retries`
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
default is missing to allow skipping this param
Just an idea. Wouldn't you get the same result if you simply have ```suggestion port_ordered = [sorted(d.items()) for d in port[key]] ``` ? `OrderedDict(sorted(a.items())) == OrderedDict(sorted(b.items()))` should be true if and only if `sorted(a.items()) == sorted(b.items())` (for `dict`s `a` and `b`).
Ansible has allowed 160chars per line, I think it's OK to have this on single line.
So if both `portgroup_type` and `port_binding` are defined, it ignores `port_binding`? I think it should check for this and if they are not the same from the API perspective, it should fail with an error
Yeah, i understand the backward compatibility, can you add in the description of `port_binding` that it takes precedence over the deprecated `portgroup_type` value? That way people understand the precedence.
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
If you provide non-existing DVSwitch then `self.dvs` will be `None` and module will fail with error saying ``` "'NoneType' object has no attribute 'EnableNetworkResourceManagement'" ```
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This is handled by `argument_spec`
This is not required if using `super`
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
```suggestion result['last_modified'] = mtime = date_to_timestamp(info['last-modified']) ```
Since this is now common code and `win_reboot` also accepts `post_reboot_delay_sec`, we also need to loo for that key here.
Same thing here: need `post_reboot_delay_sec` here since `win_reboot` accepts that.
Sorry, I've been staring at this too long. :)
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Parameters that are not required don't need `required: false`.
Make this a separate item in the list.
This could be less nested once you apply `choices`.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
its fine to have a 'separate pre-existing file', I would just use it as a fallback if other methods are not populated and i would not create one if it were not already standard.
It also might be good to compare these options to the options in https://github.com/ansible/ansible/blob/cdd21e2170b9a47d84624c8c2f792a66f2b0fe57/lib/ansible/utils/module_docs_fragments/tower.py#L23-L42
i actually don't think you should force having the `tower_config_file` entry, but it could be posed as an option and default to the 'normal location'
you are missing 'requirements' section, requests lib is not part of stdlib in python
How is this required if it can also be specified by the environment variable? Compare to openshift plugin via `ansible-doc -t inventory tower` ``` api_key: description: - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable. ```
```suggestion - When the webhook does not exists in this GitLab project, it will be created. ```
GitLab prefer to be called `GitLab` (with a capital `L`)
```suggestion - When the webhook does exists and C(state=absent), the webhook will be deleted. ```
I'd reword this as `Verify SSL certificate when HTTPS is used`
This isn't valid yaml ` : `
Same for other description.
```suggestion - The certificate in PEM format. ```
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
This string doesn't have to be quoted.
The list of options should be in alphabetical order.
Please remove this. It is wrong. Don't add a default in this case.
use the `missing_required_lib` function from `ansible.module_utils.basic`
use `missing_required_lib` from `ansible.module_utils.basic`
Authentication should be handled here and not inside of the class
I find this error message very hard to understand. I don't have any experience with GitLab servers, though :) If the other gitlab_* modules have the same text, we should probably keep it here as well. Changing it could be done in another PR once this is merged.
Use `missing_required_lib` from `ansible.module_utils.basic`
I think it's `disk.disk.id`
Can you move this logic to `__get_storage_domain_and_all_template_disks` and just call: ``` return otypes.Vm( ... disk_attachments=self.__get_storage_domain_and_all_template_disks() ... ) ```
What if the template is already registered? We shouldn't fail, but rather exit with `changed=False`
call create, so we are sure the disk is up to date with parameters provided by user.
Better to use ```get_id_by_name``` it get proper error message if storage is not found
This can also be an ARN, right? In which case the length can be up to 140 characters.
None is the default.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
You don't need to be an AWS module to use the ec2 module utils. Just do the following ``` from ansible.module_utils.ec2 import camel_dict_to_snake_dict camel_dict_to_snake_dict(vm_info) ```
@gustavomcarmo please check my pr #39722 , i have 2 options now, raw and curated
That's fair enough, the code should be split out into a generic function so it can be used by other modules. There is nothing AWS specific about the camel_dict_to_snake_dict and the reverse function, it was only used there because on AWS had a need for it.
Yeah, it's only AWS-specific because we only use it in AWS. I'm not sure what to name the new file it would be moved to (`dict_transformations.py`?) but moving it out then re-exposing in the AWS utils for backwards compatibility seems like a good idea.
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I think this would be more readable if you do: ```python org_id = self.get_org_id(org_name) net_id = self.get_net_id(org_name, net_name, data) path = '/organizations/{org_id}/networks/{net_id}'.format(org_id=org_id, net_id=net_id) ``` So using positional arguments where there's no discussion, moving different operations in separate steps, and bring the information together at the very end. The path-string could be coming from somewhere else (if this is something that is being reused, but probably not relevant here).
Beware that the fourth positional argument has shifted, so if people used this interface using positional arguments it may break. (I don't think there's a risk, as we can safely assume you're the only user of the interface...)
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
No need for the 'else' here either. The 'if' is the exit statement.
So this is not required, if payload=None it will work fine.
probably not related to this PR but if someone will be doing future refactoring, please replace this with `with` block using a context manager.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
Also note that simply sorting does not necessarily give the correct result for lists of dicts. So this change could actually recreate/update services where nothing changed.
recurse = bool(module.params['directory']['recurse'])
Could you please handle basic exception for this operation and other file_manager methods as suggested in [docs](https://code.vmware.com/apis/196/vsphere#/doc/vim.vm.guest.FileManager.html#makeDirectory)
Should not return a fail, just a `changed=False`
Same as above, can be done with sub options
It people are trying to download a non-exiting file, the execution should fail, because this is unexpected behaviour and should clearly be mentioned.
values in choices and default for bool should be `yes/no` according doc of ansible. it is a convention by Ansible. `required` should be true/false as it is a flag to show it is required.
I() for key and value
please quote version_added as well to not be a float.
the `f.close()` is implied as part of the with block. Also, I don't think this should be in the module since it looks like a debug statement.
Looks good. You can test this by specifying one but not the other in a task and ensuring you get a sensible error
```suggestion C(absent) to delete dhcp-filter and C(update) to modify the dhcp-filter. ```
Add code to check for this and do `fail_json` if needed just after `argument_spec`
```suggestion - State the action to perform. Use C(present) to create dhcp-filter and ```
Type is missing.
Add code to check for this and do `fail_json` if needed just after `argument_spec`
For python3 compatibility, you will need to wrap `map` with `list` as python3 doesn't return a list. It would probably just be best to use a list comprehension instead.
Try this instead, to make sure that extra whitespace is handled correctly: ```python rc, stdout, stderr = module.run_command([command, name]) return [int(pid) for pid in stdout.split()] ```
You have a lot of spacing problems in the above three lines. Please install `flake8` on your machine (with `pip install flake8`) and run it for this module (`flake8 pids.py`), that will show you a lot of the errors much earlier. Also, `command` is a string, not an array, so you either need to write `command = [command, name]`, or you do `module.run_command([command, name])` in the next line.
Please move the last closing `}` into a new line (at same indentation level as `argument_spec`)
the comma should be before `or`, i.e. `list of none, one, or more process IDs`
should probably use `if stdout is not None:`
add `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` to ensure all commands have an expected LANG
This can be as `elif`.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
I'm not sure what the best solution is, but at the moment I would lean towards not supporting `.repo` files and asking people to specify the repo URL directly. To properly support `.repo` files we would have to download them, parse them and compare them to the configured repos, which is a lot of effort. Are you aware of a usecase that actually requires `.repo` files? I no longer use suse in my day job and all repo usage that I can remember also worked fine with pointing to directories directly.
yeah, even if just `- for a long time this was incorrectly labeled as a boolean`
just return pm.encrypt(password, user) != current_role_attrs['rolpassword']:
just return password != current_role_attrs['rolpassword']
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion - David Taylor (@djtaylor) ```
```suggestion version_added: "2.8" ```
This is new lookup so no need to add `version_added`
Despite the name (comes from the C API unfortunately), set_range() only locates the key or the next greatest key, it does not otherwise constrain the results produced by the cursor :) It needs to be something like: ````python prefix = term[:-1] # strip asterisk cursor.set_range(prefix) while cursor.key().startswith(prefix): ret.append(cursor.item()) cursor.next() ````
Chances of not finding datastore is also possible even when user passes the datastore name. Change the error message
```suggestion vm_folder = self.find_folder_by_name(content=self.destination_content, folder_name=self.params['destination_vm_folder']) ```
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
There are other parameter to find an existing VM using `get_vm` API such as `moid`, `uuid` and a helper parameter `use_instance_uuid`, it would be great if we can implement these parameters as well. This will make all guest module parameters equal and this module future proof.
Mark params as required=True which for the required params
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
set type to 'path'
use a list type .. since that is what you want
create/remove are not really states, use 'present' and 'absent'
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
instead of: ``` for host in self.hosts: â¦ ``` I would have write: ``` for host in self.hosts: firewall_system = host.configManager.firewallSystem if firewall_system is None: continue results['rule_set_state'][host.name] = dict() for rule_option in self.rule_options: rule_name = rule_option.get('name', None) if rule_name is None: self.module.fail_json(msg="Please specify rule.name for rule set" " as it is required parameter.") if rule_name not in self.firewall_facts[host.name]: self.module.fail_json(msg="rule named '%s' wasn't found." % rule_name) rule_enabled = rule_option.get('enabled', None) if rule_enabled is None: self.module.fail_json(msg="Please specify rules.enabled for rule set" " %s as it is required parameter." % rule_name) current_rule_state = self.firewall_facts[host.name][rule_name]['enabled'] if current_rule_state != rule_enabled: try: if rule_enabled: firewall_system.EnableRuleset(id=rule_name) else: firewall_system.DisableRuleset(id=rule_name) fw_change_list.append(True) except vim.fault.NotFound as not_found: self.module.fail_json(msg="Failed to enable rule set %s as" " rule set id is unknown : %s" % (rule_name, to_native(not_found.msg))) except vim.fault.HostConfigFault as host_config_fault: self.module.fail_json(msg="Failed to enabled rule set %s as an internal" "error happened while reconfiguring" " rule set : %s" % (rule_name, to_native(host_config_fault.msg))) results['rule_set_state'][host.name][rule_name] = dict(current_state=rule_enabled, previous_state=current_rule_state, desired_state=rule_enabled, ) ``` @Akasurde what do you think ? It's more readable and it returns an helpful error if the rule name is set but not found.
`continue` isn't necessary
you should set the default state to "list" at argument_spec, not here.
update_ntp_settings â update_ntp_servers (or re-change the update_ntp_servers method name)
Can you change the examples to use YAML rather than `k=v` shorthand? ```yaml - debug: var: lookup('cpm_status', 'temperature', validate_certs=true, use_https=true, cpm_url='rest.wti.com', cpm_username='rest', cpm_password='restfulpassword') ```
Combine this import with line 114.
Since this accepts a list of ports, change the type to `list`. This requires it to be transformed a bit, but would be a better UI. A `list` type parameter will accept a comma separated string as well as single items, which field validation will return as a string.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
```suggestion serial_port=dict(type='int', required=True), ```
(In general, I don't think modules should have such options.)
Is there precisely one time you can specify this? It sounds to me like this should be allowed to repeat multiple times. So this should be a `list`. Or maybe even better a `dict`, so people can specify things like ``` blkio_weight_device: /dev/sda: 100 /dev/sdb: 200 ```
A general remark: you should always use complete sentences. So this should end with a period.
Please use formatting like `C(<device-on-host>[:<device-on-container>][:<permissions>])`, and `(e.g. device C(/dev/sdc:/dev/xvdc:rwm))` in the line below.
I would remove this `device` here, and similar the option name in the examples for `device_read_bps`, `device_read_iops` etc.
This doesn't match docs and should still be singular certificate
not needed with AnsibleAWSModule
Use module.fail_json_aws(error, msg="Couldn't obtain private certificates")
Please add a `msg` value here e.g. "Failed to export certificates" just to make it a little clearer
`type='str'` is the default, so not needed here.
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
It would be easier if RPM and DEB were to give the same structured reply, or having an agnostic module would not be very useful (in cases like "if upstream version is greater than x.y"). Comparing versions is a complex operation and there is no filter around `dpkg --compare-versions`. Also having the full version (epoch+upstream+release, following the standard distro notation) along with the upstream version would be useful I think.
`str` isn't needed here.
I feel like this should be moved to `else:`
```suggestion - python >= 2.7 ``` Pyvmomi requires 2.7
I think user can specify specific host from cluster. Cluster and host both arguments should be allowed
Please can you rephrase this sentence? Something lile ```suggestion - Module doesn't reboot the host after changes, but puts it in output "rebootRequired" state. ```
```suggestion - Desired SR-IOV state on interface. ```
```suggestion num_virt_func: ```
```suggestion result['last_modified'] = mtime = date_to_timestamp(info['last-modified']) ```
Should be type `int`
These values should all be type `int`
Should be type `int`
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
This check (and _is_binary) seem like they belong in executor/module_common.py. Make modify_module responsible for detecting that this is a binary module and returning it unchanged. We might need to create a new module type so that the rest of the code in action/__init__.py knows it's dealing with a binary module but that shouldn't be a problem. We already have "old" and "non_native_want_json" which do nearly the same things.
community.general also contains some of the modules of the `k8s` module defaults group (the `kubevirt` modules), and some modules of the `ovirt` module defaults group (the deprecated `_facts` modules).
This does not belong in here. Since you took it out of a function in task_executor, it might belong in there.
Module arg building doesn't take place here. This file packages up a module. It doesn't handle construction of module parameters at all. Action plugins sit in between module arg construction and here.
```suggestion 'community.crypto': 'acme', ``` With this, my tests actually work :)
Looks like we have `distribution_release: Core` currently for CentOS. I think it would make sense to have that be `distribution_release: Stream`.
@relrod should we do the same for RHEL 8? seems to use the 'version name' right now
Rather than use a regexp, split the string and get the digit: ```suggestion version = [n for n in data.split() if n.isdigit()] ```
We always want to return something for distribution version: ```suggestion amazon_facts['distribution_version'] = 'NA' if version: ```
```suggestion amazon_facts['distribution_version'] = version[0] ```
please keep line length pep 8 compliant
This is no longer relevant.
fObj => f_obj please to respect PEP
`dcpath` probably got to the incorrect context scope
Sorry, hadn't seen this else here, and it's fine to have it like now.
I also found `n_url` to be a bit confusing and collide with our string type prefixes for bytes, native, and unicode. It would be good to change `n_url` to something more descriptive, but probably in a separate PR.
I've been meaning to ask... what's the deal with n_url? I thought at first that it needed to be a native string for the APIs it's being used with but the more places I see it, the less that looks like the case. Is it "normalized_url"? If so, could you start using that? We do not want to use `n_` or `b_` prefixes for anything other than variables containing native strings and variables containing byte strings. It will defeat the purpose if we start doing this in other places.
``` diff diff --git a/lib/ansible/galaxy/collection.py b/lib/ansible/galaxy/collection.py index caa22308eb..52272cde52 100644 --- a/lib/ansible/galaxy/collection.py +++ b/lib/ansible/galaxy/collection.py @@ -381,6 +381,12 @@ def publish_collection(collection_path, api, wait, timeout): :param timeout: The time in seconds to wait for the import process to finish, 0 is indefinite. """ import_uri = api.publish_collection(collection_path) + if 'v3' in api.available_api_versions: + parsed = urlparse(api.api_server) + import_uri = parsed._replace(path=import_uri).geturl() + else: + import_uri = import_uri + if wait: display.display("Collection has been published to the Galaxy server %s %s" % (api.name, api.api_server)) with _display_progress(): ```
That diff is a light reworking of this PR. When I made it I saw that it still had most of the problems of this one (to be fair, we probably can merge my changes with that initial attempt and fix some of those problems) and additionally split the responsibilty for compatibility between GalaxyAPI and the caller. So I discarded that and pushed most of the changes inside of GalaxyAPI instead. I did parse the data from the API and normalize it (as a task_id) before sending it into the class, though. That seemed like the best way to split the responsibility.... The caller ends up knowing about the information that was returned to it. The GalaxyAPI class knows how to turn the normalized data into a url on each of v2 and v3.
I think this var needs a more specific name. Like `generic_vmw_errors`, if I understand correctly. Because now it's not clear for me what exactly you're generalizing.
add `return self.remove_nic()`
no need to wipe `self.nic`, but return the nic you just have (or, in check mode, would have) removed. this functionality is required for integration testing.
missing `if not self.module.check_mode`
missing `if not self.module.check_mode`
I would suggest to set `type='int' for vlan.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
All new modules should include actual RETURN data.
Please make this oauth_token.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
Since this is a new module, this should be fixed from its beginning: ```suggestion supports_check_mode=True, ```
IMHO this is not python 2.6 compatible (https://docs.python.org/2/library/string.html#format-string-syntax). I usually avoid format at all and use the % syntax.
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
User should be able to delete key. Keys with `None` value could be deleted.
Use **digital_ocean_argument_spec** form DO utils.
```suggestion - List of paths to exclude. ```
```suggestion - List of paths to include. ```
```suggestion short_description: Local Backup Utility for Alpine Linux ```
Should be `type: str`
```suggestion Supports the querying and modification of the link-level attributes of interfaces such as ```
seems gateway and netmask are only required in case of state=present, are they? In this case i would suggest to: ~~~diff argument_spec.update(dict( network=dict(type='str', required=True), zone=dict(type='str'), start_ip=dict(type='str', required=True), end_ip=dict(type='str'), - gateway=dict(type='str', required=True), - netmask=dict(type='str', required=True), + gateway=dict(type='str'), + netmask=dict(type='str'), start_ipv6=dict(type='str'), end_ipv6=dict(type='str'), gateway_ipv6=dict(type='str'), vlan=dict(type='str'), state=dict(choices=['present', 'absent'], default='present'), domain=dict(type='str'), account=dict(type='str'), project=dict(type='str'), for_virtual_network=dict(type='bool', default=False), for_systemvms=dict(type='bool', default=False), )) module = AnsibleModule( argument_spec=argument_spec, required_together=cs_required_together(), mutually_exclusive=( ['account', 'project'], ), + required_if=(("state", "present", ("gateway", "netmask")),), supports_check_mode=True, ) ~~~
`zone` is returned, but not zoneid
This wil fail, as there are 2 actions in the same task.
For consistency, please use the `delegate_to: localhost` syntax.
I would suggest to set `type='int' for vlan.
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
`User has been updated`
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
Ok, so I may have given you the wrong advice before. I was under the impression that these modules were talking to a backend, but (at least) this module seems to run on the remote target (over SSH ?). So delegate_to: localhost` will not work correctly.
If it's not required, you don't have to state `required: false` That's implicit.
Quotes are not needed here. We tend to quote in YAML only when it is necessary (for true, false, null or colon/spac sequence).
Probably worth it to use `username`, `password`, `hostname`, etc in the examples instead of `config`
As mentioned on IRC, please remove this (from here and other examples) and update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 to be `password=dict(type='str', no_log=True),`
Wouldn't the choice be [ 'yes', 'no' ] as you'd expect from a boolean ? As per previous remark, this would become: ```yaml type: bool ```
Nowadays we do: ```yaml type: bool default: 'yes' ```
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
How about ``` self.params.get('cdrom', None): ```
`if self.params["cdrom"].get('type') not in ['none', 'client', 'iso']:`
You can just use initialize `ide_device = None` and drop `ide_exist` variable.
Here too, I believe you don't need the `cdrom_exist` variable.
I believe you should be able to replace `of (not cdrom_exist or len(cdrom_devices) == 0)...` with just `if not cdrom_device and cdrom.get('state') != 'absent'`
unnecessary import - boto is not used in the script
unnecessary import - defaultdict is not used
Tell people where we are looking `CONFIG_FILES`
Make this a regular function
This should be a @staticmethod and self removed.
I wonder if there are more correct than wrong uses of `get` :) I mainly know its use in `route53`, where it shouldn't be a state.
(if that doesn't work, change `&` with calling `set.intersection()`)
Ah. I thought you're talking about `dict.get()` being not enough for the validator.
Looks like the CI failure is caused by the set literal under Python 2.6: ```suggestion bad_states = set('list', 'info') & set(data.get('choices', set())) ```
After the refactoring, it's probably okay to inline it back since it's used in one place now: ```suggestion bad_states = {'list', 'info'} & set(data.get('choices', set())) ```
```suggestion - When a value is masked, it must be in Base64 and have a length of at least 8 characters. ```
```suggestion - Support for protected values requires GitLab >= 9.3. ```
```suggestion - When you masked a value, the value must be base64 compliant and has at least a length of 8 characters. ```
You could simply only pass variables that are `True`, then you're on the safe side :) I.e. something like ```.py params = {"key": key, "value": value} if masked: params["masked"] = True if protected: params["protected"] = True return self.project.variables.create(params) ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
`then` -> `the`
VM or VirtualMachine
As I understand it, this module isn't about gathering facts.
```suggestion - content library id for which details needs to be fetched. ```
You should add datacenter and register to the example.
Look what I've found: ```python $ ipython Python 3.7.0 (default, Jun 28 2018, 11:18:11) Type 'copyright', 'credits' or 'license' for more information IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import pkg_resources In [10]: ipdst = pkg_resources.get_distribution('ipython') In [11]: ipdst Out[11]: ipython 6.4.0 (/home/wk/.pyenv/versions/3.7.0/envs/ansible-py3.7.0-pyenv-venv/lib/python3.7/site-packages) In [15]: ipdst.as_requirement() Out[15]: Requirement.parse('ipython==6.4.0') ``` This probably can completely eliminate need for doing `pip freeze` and parsing it! @HD650 please investigate this.
This is tricky. It should probably return false because there's no way of knowing whether it's the same version, so we'll need to invoke pip to reinstall it as it does when you run it manually
By the way, you don't need `else:`, since this will be evaluated anyway.
Also, it seems that you don't strip spaces, so if there will be leading spaces it would not match, for example.
Why don't you do this right in the `return` line? If you think it's going to be too long, be aware that you can break the line by wrapping it with braces: ```python def _is_valid_distribution_name(name): return ( not name. lstrip(). startswith(('>=', '<=', '!=', '==', '>', '<')) ) ``` (you can put `not` outside of brackets if you like it more this way)
` or result > 255`
0 is technically valid, so this should be `self.prefix_length is not None`
All of them should be is None IMHO.
remove `required=False` and `default=None`
Yes, but we can address this in another release.
Seems like filter can return partial matches: `foo` would match for an existing `foo-bar` service, and would fail with thinking it needs to be updated (which also seems to be deprecated. Maybe it's worth verifying with this condition and adding a workaround: ```python if len(raw_data) == 0 or not 'Name' in raw_data[0]['Spec'] or raw_data[0]['Spec']['Name'] != name: ```
Do a pull request.
The numbers should be in C(...), I think.
```suggestion - Number of containers instantiated in the service. Valid only if I(mode) is C(replicated). ```
AFAIR the flag is `failed`, not `fail`
I would add this to a new paragraph, so it will be easier to read (and harder to miss). ```suggestion - If not specified the default value will come from client_cert. Which will ```
You should mention that the default value is taken from `client_cert` if that's specified, and that this will change in Ansible 2.14.
```suggestion feed_client_cert: version_added: 2.10 ```
How about: ```suggestion module.deprecate("To specify client certificates to be used with the repo to sync, and not for communication with pulp.io, use the new options `feed_client_cert` and `feed_client_key` (available since Ansible 2.10). Until Ansible 2.14, the default value for `feed_client_cert` will be taken from `client_cert` if only the latter is specified", version="2.14") ``` (And something similar below.)
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
we try to use 'state' instead of action, as ti keeps with the declarative voice of Ansible vs an imperative approach from programming languages.
All `description` should start with a capital letter, and end with a fullstop.
I think this should be a separate command option - `delete` or `create`. `state` seems like something different. At a minimum, I think it should be more explicit - like `action: create | delete`
shouldn't be required, irrelevant for Amazon providers
Actually with the example you updated, this text is good enough. However we explain it, it won't be clear until one looks at examples... Perhaps slight tweak "A list of list of tags, grouped by category".
Please clarify the description
```suggestion - Network backend to use for this definition. Currently supports `networkd` (default) and `NetworkManager`. ```
Can we autogenerate it instead? If not, please provide a more useful description.
Simplify that description, it is too redundant as-is.
```suggestion - Control DHCP autoconfiguration for IPv4. Disabled by default. ```
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
Please use `has` in the beginning. Also, I feel like this should be a `@property`.
1. `@property`. 2. It's not an installation command, it's a version spec. 3. You don't need it, as it's stringified automatically during string interpolation, under 3.6.5: ```python In [3]: from pkg_resources import Requirement In [5]: rqc = Requirement('cherrypy') In [11]: '%s ' % rqc Out[11]: 'cherrypy ' ``` 2.6.9: ```python $ python Python 2.6.9 (unknown, Apr 10 2018, 17:32:50) [GCC 7.3.0] on linux4 Type "help", "copyright", "credits" or "license" for more information. >>> from pkg_resources import Requirement /home/wk/.pyenv/versions/2.6.9/lib/python2.6/site-packages/pkg_resources.py:17: DeprecationWarning: the sets module is deprecated from sets import ImmutableSet >>> rqc = Requirement('cherrypy') Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> rqc = Requirement.parse('cherrypy') >>> '%s ' % rqc 'cherrypy ' >>> ```
Apparently, it will not work well under Python 2.6.9. It seems to be requiring you to call `Requirement.parse()` to construct an instance of this class. So we'll need to shuffle a couple of things around to make it work.
please note that behavior for non-caught exceptions is to return `None`, so please add another `return False` in the end and maybe replace this one with `pass` or a docstrinig with the explanation.
You don't fetch anything here but reconstruct broken input. You return a sequence of data, just lazily. So name the function like it would return a list. I think you could go for `_recover_package_names` here.
Also, why do you need to call `db_exists` again at all? You already have `existence_list` and `existence_list`, that should be enough for the rest of the module.
Finally, `db_exists` checks whether **all** DBs in the list exist. This doesn't really help here. You really need to work with `existence_list` and `existence_list`.
The next `if` should come first. The module should die if not all DBs exists no matter whether it's in check mode or not.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
Summary option is available only in the latest versions. Let us not rely on that, please use heal info and check the count.
Nit: Do not capitalize Aborted. Keep the message like: "Operation aborted, self-heal in progress."
Nit - Change the message to: "Operation aborted, self-heal in progress." removing the capitalisations.
When reducing the replica count, the force option is mandatory. This will fail if force is not set. Also for remove brick can you check there are not pending heals. If we are removing a brick from a volume which has pending heals and if that brick had the only good copy, we have data loss.
@sabose we do not validate the bricks since validation is done by gluster. We'd be duplicating the efforts. Plain distribute is supported, data migration is triggered when we remove the brick. However, commit is tried 12 times with 10 second gap. If the data migration is not complete by then, we give up and it is upto the user to commit. This is because depending on the data migrated it might sometimes take days together to complete.
the order is incorrect, it probably 'works' if you don't have duplicate vars in inventories as the set_variable is overriding any cached vars you would have yet you do the reverse override here.
this seems to do the reverse of what you want
he, sadly most people do use duplicate names across hosts/groups ~no, just do line #120 and remove 121-122 as they become redundant~ nvmd, its host facts .. its ok as is .. for some reason i was confusing it with 'vars cache'
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
I don't mind. But I still don't understand why you think it's O(1).
I've even tried doing some benchmarking and the results are about the same.
we probably want to move this 'adhoc list' into constants.py anyways
this probably needs updating to ansible.legacy.X see constants.py for function that deals with the multiple possible names
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
not a blocker, but requried=false is the default and can be omitted.
New person will be confused when you refer to `msg`, adding a brief description will help.
Return is not compulsory but will help end user to understand return value of module.
"state" is required or you should set a default.
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` Here this var needs to stay as you had it originally - ansible prefers snake cased but boto typically needs camelcase. `instance_parameters` will be passed into the boto connection so needs to match what the API expects, both here and later when you access the returned parameters. https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationSubnetGroup.html#API_CreateReplicationSubnetGroup_RequestSyntax
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` and here as well
```suggestion for modulesubnet in modparams['SubnetIds']: ```
This one still needs to be swapped.
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
instead of forcing templating here, when you don't have task_vars yet, just set run_once based on 'bypass' and then template below in 890 with full task_vars. That way you avoid a 2nd very expensive call for vars and actually get the complete ones (with host).
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
The name of that parameter is bad, it's simply âDNS search domainsâ. Perhaps `search-domains`, or `resolvconf-domains` (but then rename `nameserver-addresses` to `resolvconf-addresses`)
Shorten to `mac` or use hyphens consistently (`mac-address`).
I think something like `device-name` would be more descriptive.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
Same, `device-mac` or `device-mac-address`.
I wouldn't exactly call a dictionary `list`.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
How about 'absent' as state, which make this module complete.
Period at end.
I've been thinking the same thing. Ideally it would be great if the validator raised exceptions, instead of passing back formatted errors, but I get the reasons why it is like it is currently.
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
May be true but this is general speaking. What behavior specific changes would you expect? Can we possibly test against those? I don't think it is meaningful to duplicate code in n modules when using OOP style.
In general argument_specs should be returned to the caller rather than subclassing AnsibleModule just to add it. AnsibleModule's behaviour could change in the future and subclassing makes it more likely that things would break than if you are simply passing an arg_spec to the module which it then uses to instantiate an AnsibleModule.
This should use the existing `AzureRMAuth ` rather than requiring these keyvault vars only. Then auth using alternative ansible support methods works too. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/azure_rm_common.py#L971 This is how the other azure plugins work already (e.g. inventory plugin https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/inventory/azure_rm.py#L274 )
Indentation doesn't seem quite right here.
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
You could add the minimum required version (`>= 1.0`) here too.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
spec is also returned
Wrong module name. ```suggestion - ec2_spot_pricing_history_info: ```
Don't add `required: false`. It is implicit.
Another (and possibly cleaner) way to do this is to use `pytest-mock`: ```python class SpiedOnTarget: @staticmethod def do_a_thing(): return None def test_empty_retry_iterator(mocker): decorate_with_no_retries = retry_with_delays_and_condition(backoff_iterator=[]) spyable = mocker.spy(SpiedOnTarget, do_a_thing) invoke_retriable = decorate_with_no_retries(SpiedOnTarget.do_a_thing) invoke_retriable() assert spyable.call_count == 0 ```
Always use raises with `match=` or you'll catch false positives. Especially because almost any exception is a subclass of `Exception`. ```suggestion with pytest.raises(Exception, match='Error'): ```
It'd be interesting to see a test case for something inheriting a `BaseException` too.
This should be using `module.fail_json()` instead.
You may try
`id` isn't used, it is sufficient to iterate on keys.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
When `hostname_preference` is equal to `name`, there is no need to define `ansible_host`.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
both forms are valid ... string is more descriptive to users (non programmers)
This one will fail, since selfsigned_notBefore and selfsigned_notAfter have changed their meaning from the initial draft and don't have default values any more.
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
Read operation: ditto
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
All the boto3 client methods in this module should handle BotoCoreError. There are a number of places that need this added.
You just need to catch ClientError and BotoCoreError. If you want, you can rebase on devel and use the pattern ``` from ansible.aws.core import is_boto3_error_code try: return client.get_application(applicationName=name) except is_boto3_error_code('ApplicationDoesNotExistException'): return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, "Could not get CodeDeploy application.") ``` Note: BotoCoreError does not have a .response so if you don't want to use the pattern above you should add ``` except BotoCoreError as e: ``` on line 169
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
Should be able to remove this import and just use `fail_json_aws`
AnsibleAWSModule incorporates ec2_argument_spec so you could remove this import and specify the arg spec as a dict.
I would expect a module to issue warnings only for something which the user needs to be warned about. If the user wants something to be absent and it already is absent, that's not something I would expect a warning about. You also don't issue a warning if the user has `state == 'present'` and the sequence is already there.
Yep, simply ignoring all other options when `state == 'absent'` is the easiest solution (that's what most other modules do, too).
Why have both `schema` and `newschema`? I would assume that if I specify another value for `schema`, that the schema will be changed.
```suggestion - If C(false) (NO CYCLE) is specified, any calls to nextval after the sequence ```
In `check_mode: yes` the returned query will always be `SELECT 1 FROM 'tablename'`. But this is not what I expected. Normally I like to see what query will be executed for that change. Please change this behavior to always return the query which will be executed even if it is not in `check_mode: yes`
Shouldn't have `required: true` for things that have a default.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
This isn't used in the examples. Is it possible to do this by name instead of URL? It seems a little complex to have to provide a full URL to use non-default networks.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Please rename it as `get_provider_argspec()` to be in sync with other platforms
This extra check is not required after above provider spec changes
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
This check is not required after above `provider` spec change as `no_log=True` in auth_pass and passwords sub-options will take care to mask password.
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
check e.response['Error']['Code'] here too
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
use `missing_required_lib` from `ansible.module_utils.basic`
Yes, we will remove old style while remove it all together. Let me know if it works for you.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
If a parameter is not required, no need to explicitly put this in. (If you would put in all possible values here, you'd be defining a handful of defaults)
Make these 2 seperate items in the description.
Make this two entries in your description. Especially because the first entry is the description of the option, the next entries are specifications or additional notes.
Don't add a trailing dot to the `short_description` ! Keep the index clean.
This should be indented by 2 spaces. The same bellow.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
This could move even more down. After listing apps.
Remove this since it doesn't do anything and `Mock` isn't defined.
This doesn't match because your test uses `http://` instead of `https://`.
Oh, and `args[0]` is the module, so you want to look at `args[1]` for the url.
You'll need to define `info` for both code paths.
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
also you might want to make this into an option, see ssh connection plugin's `reconnection_retries`
This is an unrelated change but I think this line should be ```suggestion module.fail_json(msg=missing_required_lib('ipaddress'), exception=IPADDRESS_IMP_ERR) ```
```suggestion import gi gi.require_version('NMClient', '1.0') ```
I think if you import this here, it will solve the CI problem.
```suggestion MessageStructure=module.params['message_structure'], ``` The final trailing comma is optional, yes, but it makes diffs cleaner.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
please use explicit imports `from ansible.module_utils.basic import AnsibleModule`
please use explicit imports .... `from ansible.module_utils.basic import AnsibleModule` ... etc
please wrap in block ``` if __name__ == '__main__': main() ```
please use explicit imports
please wrap in `IF` block
Ah yes sorry, ~~prefix~~ suffix
I would add a note saying this does not relate to the partitions file system formatting.
If we have an explicit map we should be using snake_case for this, e.g. `system_partition`, `microsoft_reserved`, and so on.
Would add a note saying this does not deal with disk initialization and file system formatting.
I think this should be a mandatory option when creating a disk and we don't randomly choose one.
It doesn't look like you're using `to_native` anymore. I wouldn't normally nitpick for leftover imports, but we'd like to discourage use of to_native without a pretty good reason, and removing the import would make adding it back just a little bit more work.
typo... It should be I(text)
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
...The remote host **MUST** support...
duplicated `type: ` line. I wonder if this is what's causing the CI failure.
```suggestion if not os.path.exists(to_bytes(ldir, errors='surrogate_or_strict')): ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Python 2.6 needs {0}, {1} - empty brackets in various other places too.
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
Default type is `str` so you don't have to set it explicitly. Just use `size=dict(),` instead. The same bellow.
You said line 91 & 92 that only reducing the disk size is not allowed. Maybe you should remove line 70.
`Care should be taken ...`
Cool. Thanks. Let me know once done.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Just an idea, Could we move this functionality to new module rather than putting in same module ? Same like `vmware_guest_disk_info` and `vmware_guest_disks` Nothing blocker as such.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
type='str' is a default value, not require to explicitly mention it
maybe should be converted to lower case just to keep the same as main module
```suggestion description: The ID of a NAT instance owner in your VPC. returned: when NAT instance owner is available ```
could add HAS_BOTO3 to the imports from ansible.module_utils.ec2 instead of manually setting
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
This supports more than just URLs, I would add more points talking about what it actually supports.
Change to source and remove the alias
Please add an example below that shows you how get the newer NuGet provider version.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
This expression do look a bit suspcious, can you explain a bit more what you try to achieve ? (cause that's if "A and B or A and B" and I am a bit unsure on the order to which I need to evaluate things)
`return not owner or owner == publication_info['owner']` could be used.
`current_version` could be mentioned in the error message.
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
For the author information we normally only keep name and GitHub handle.
Same for other description.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
```suggestion - The certificate in PEM format. ```
Period at end.
Period at end.
`A list of virtual machine names starting with the given regex`
A sample of output would be helpful.
Can be removed, indeed, check other newer modules :)
Method name is deceiving, since the body of the method will only set a single attribute.
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
Bad name again, since body of the method only sets one attribute.
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
Jobs seems to be Dell specific, since standard does not talk about jobs at all. What standard does talk about is that some actions may be asynchronous and that in such case `Location` header value points to the `TaskMonitor` for this action. And again, constructing OData ids using concatenation is just bad.
```suggestion - "zabbix-api >= 0.5.3" ```
Duplicate occurence of zabbix-api requirement ```suggestion ```
Extending of ZabbixAPI class was used with very old zabbix-api module versions. I am trying to get rid of this in #53334 as it is now working fine with just a base class. Please remove this as well. Your code will work fine without it :)
ZabbixAPISubClass import no longer needed ```suggestion from zabbix_api import ZabbixAPI ```
```suggestion zabbix_host_events_info: ```
Missed one.. Should just be as below unless you want to also pass module into the function. ``` if os.path.isfile(cert_chain): cert_chain = open(cert_chain, 'r').read() ```
Could probably get rid of the surplus required=False entries I seem to have missed as well
As previously discussed on https://github.com/ansible/ansible/pull/20787 I much prefer os.path.isfile That way it won't try to read a directory path.
if state is present but cert, key or chain is not passed in, then these variables won't be set at all. That is bad. Just get rid of the `if` statements.
I don't have the answer, but was hoping to prompt discussion about it and maybe get this moved along in the process.
This seems like it would break passwords with leading/trailing whitespace.
For context, this was proposed because the difference between trying to brute force the ciphertext and trying to brute-force the hash being used for the salt was brought up. The pbkdf function making it more expensive to generate the encryption key from the password rather than generating the hash was one difference that was brought up.
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
We use `aep` as the default parameter in other modules and we never used `AEP`, `AEP_name` or `attached_entity_profile`. So please use the same parameter name as the **aci_aep** module !
I wonder if this wouldn't be better named `lag_type` either as the default name, or an alias. As LAG seems to be a common term (at least I know this term). cc @rsmeyers @jmcgill298
Start with a capital.
Do the same for other descriptions.
End with a dot.
This is handled by `argument_spec`
If you provide non-existing DVSwitch then `self.dvs` will be `None` and module will fail with error saying ``` "'NoneType' object has no attribute 'EnableNetworkResourceManagement'" ```
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This is not required if using `super`
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
Fair enough, should have actually gone to that link and read it properly
'so this value may be overriden'
doc typo, s/funcition/function
This should just be `name` since `pubnub_blocks: block=foobar` is a bit redundant.
Doesn't seem to have been done
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
please remove version added here
Remove this line
Are these the only valid options, in which case you should add `choices: ['SG_TYPE_STRING', 'SG_TYPE_KEYVAL'] and similar in `argument_specs`
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
Here just check if VM has just single network, if yes, and it has also single VNIC, then set it. If it has multiple networks and user didn't set network fail. If it has single network and multiple VNICs and no vnic specified, fail.
Please ignore, this is called when non-existin number is passed. So it's ok
Ansible has allowed 160chars per line, I think it's OK to have this on single line.
That's OK, I just wasn't sure how it's working.
Then it's OK, I don't know the implementation, so I am unsure what really happens when your remove this configuration in runtime to the VM.
yes, this is equivalent to the 3 ifs that follow, there is no need for this duplication
this is not needed as each section checks for it's own parameter
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
You should mention instead of this that the required API version is 1.24. ```suggestion - "Docker API >= 1.24" ```
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
How about removing the `docker_` prefix from the return variables, and simplifying the names in general? I would use: - `swarm_facts` or just `swarm` - `nodes` - `services` - `tasks`
Also, let's continue the discussion in #51939.
Remove the quotes from around `%r` as that may cause a something like `''foo''` to appear in the output.
Please switch back to just using `%r` here instead of `'%s'` as that assists in providing more information about the original type.
Since we are updating this now, let's switch `'%s'` to `%r` for the default values.
IMO the previous block is not needed, and this error should become error 325.
But to be honest, the types should be identical, it shouldn't matter what it is.
Why the loop here? `if match` should be sufficient
This break will be unnecessary if the loop gets dropped
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
Why add this? Unless I'm missing something, `interface_table` isn't used at this point
excellent handling of congestion control
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
supported_by should be `community`
`short_description: Manage VLANs on VyOS devices`
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
I would format this like this: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.0' } ```
Tiny typo here 'Waitis' -> 'Waits'
required: false and default: None are implicit, you can remove both
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
Please remove this line.
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
Right but this seems arbitrary, cut off at 40 characters ? For readability I think it's better to not split lines if it is not required. But you are right, it's not mandatory. So you can ignore this :-)
Please put this on a single line. Lines can be 159 characters wide.
Net new tests should be `pytest` style tests.
```suggestion variables = {} ```
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
I think I'd trim it right here rather than in tests ```suggestion """.lstrip() # noqa: E501 ```
I think some other changes to the config have landed that should certainly eliminate the need for this, in particular the `TowerModule` class.
If the source is not provided, there is an endpoint that lets you update all inventory sources for an inventory (future enhancement, I would not suggest doing that here, just pointing it out)
chack -> check
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
It might be safer to perform the `sys.stdout` switcharoo *inside* the `try: finally`: ```python try: old_stdout = sys.stdout sys.stdout = captured_stdout = StringIO() ... finally: sys.stdout = old_stdout ```
I've tried your branch on my local grafana with the `json.loads` fix. If I import an existing dashboard (previously in general folder) it will be moved to the specified folder. but the module is not idempotent anymore. If I re-run the playbook the task will return a `changed` status even if the dashboard json file has no changes.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Uses of `{}` should be updated with positions as this will be incompatible with python 2.6. This applies through the code base. e.g. `'{0}'.format('foo')`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
I should have probably used the word 'check' rather than 'test'.
Same here - AnsibleAWSModule adds this itself.
Note: It's nicer code organization to do parameter validation and normalization upfront rather than at usage. So it would be better to move this version checking and default setting to somewhere soon after the KubernetesAnsibleModule is created.
print can be replaced using sys.exit Except this looks good to me.
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
Maybe C(.pem)? I'm not sure you need to specify that .pem is a file type since it's just the extension. @gundalow might know.
I think you can just say '...input as a list of key value pairs' since these are not module options. But can tags just be a dict? You could then use ansible_dict_to_boto3_tag_list(). It feels like some functionality is being duplicated.
Most other modules default to yes so I would do the same here
I think aliases are unique across AWS - so there's only one CF distribution allowed to have the fake.site.com alias at any given time. > You cannot add an alternate domain name to a CloudFront distribution if the alternate domain name already exists in another CloudFront distribution, even if your AWS account owns the other distribution.
Use `wait`, it's standard for similar modules. Requires a configurable `wait_timeout`. I'm not sure whether it's worse to have a default `wait` with a timeout in excess of 20 minutes so that it typically succeeds, or just no wait so that people at least knowingly set a long wait time. I'd think default to waiting off, but default to 30 minutes wait_timeout if people do set `wait`
Also, it would be better of the description is split up over multiple items. A long blob doesn't make it easier to read. Usually the first item is the "meaning", and subsequent items detail what happens in different cases, explain options, specify the format or add one or more notes.
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
We tend to not add quotes where they are no needed in YAML. Here they are not needed.
Please verify, before push. `required_of` -> `required_if`
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
Please remove whitespaces around the braces.
Please add spaces around the equal sign.
use an else here and you can have only 1 return at the end (even that is not needed)
before continuing here, check that fields is actually populated as a list, or try/except the following code
Is there a reason to sort this? Since we're just putting it into a set (to uniquify the list I assume) it doesn't seem necessary to sort. Since we're just iterating over sd_instances, a frozenset is more appropriate than a set.
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
Another regex that can be precompiled.
The same like above.
This should be indented by 2 spaces. The same bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
actually, after looking at code 'currently', include_vars always ovewrites as it does not use combine_vars at any point .. this might be a 'bug' in VarsManager on `set_host_facts` and `set_nonpersistent_facts` methods .. unsure if we need to fix considering upcoming deprecation.
I would add note (this falls back to the global hash_behaviour configuration).
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
...The remote host **MUST** support...
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
No in docs
`msg="'%s' device group not found in Panorama. Is the name correct?" % devicegroup)`
return value does not match RETURN doc string
not needed when `required=True` is specified
not needed when `required=True` is specified
s/user/caller/ (although user creation really is the only safe method if the file is in a world-writable directory).
This isn't true anymore.
Just a suggestion. We can rely on the GuestID here to set the default value: If the GuestId starts with "win" -> PowerShell, otherwise, /bin/sh.
missing ini/env var entries (to use global default)
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
That's not what the code says (where default is `zip`)
...The remote host **MUST** support...
Most other modules default to yes so I would do the same here
Ansible 2.7 dropped support for Py2.6
Should have a default set to `present`.
in all cases, I would default `group_contents.get('hosts', [])`
I would default vars to `{}`
I'm a little iffy about the ungrouped or all group here. I would skip ungrouped.
should this really be 'endswith' or more like equal? `path.strip() == '@tower_inventory'`
ah, its seeing it as a file name ... weird since host_list 'works' .. i should look into that
The additional fragments in here need to get backported to make the compatibility shims in stable-2.9, stable-2.10 and stable-2.11 working properly.
```suggestion description: Action returns an C(ansible_facts) dictionary that will update existing host facts ```
IMO this really should be defined in action_common_attributes, to help ensuring that all collections use the same description there.
```suggestion description: Supports being used with the C(async) keyword ```
```suggestion - Conditionals will work as if C(run_once) is being used, variables used will be from the first available host ```
This should be sufficient.
@sieben please include the BSD license header in this module_utils file in this PR.
Previous URLs didn't end with a slash, this might create double slash URLs.
Not sure if `module.debug` should be used instead.
To match the headers in https://github.com/sieben/ansible/blob/b119f2652a160707ee718566ad1e49a510935553/lib/ansible/module_utils/scaleway.py#L40 `Content-Type` must be `Content-type`
Just thinking that it would be better to keep the example with `http://` only because that's how it usually runs when you manage the Jenkins server directly. So the `validate_certs` is not required here. Moving the `url` param here is good, although not required if Jenkins runs on the default port (8080) as that's the default value of the parameter.
If you accessing service via localhost, there is no need to use SSL.
I would move the state one line below. First the selector, than the action, is what I usually do.
As on other PR, update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 and remove `no_log: true` from examples
I'm guessing this is because the module will manage one datacenter at a time/per resource declaration, and return that datacenter's data. For getting/querying multiple datacenters, likely the DatacenterFactsModule will be required.
Quoted mode starting with a leading zero is the best example to give. It allows the user to make one of two mistakes and the module will still do the right thing. Only if the user makes both of those mistakes would it come out wrong. If you feel the docs for the mode parameter should focus on quoted with leading zero, you could certainly make that PR.
We actually recommend quoting the mode everywhere. Docs should be updated accordingly. Also, there is no reason that when quoted you cannot include a leading 0.
There is an extra /a/ in this sample path.
This example is supposed to show the difference in single vs double quoting requirements in YAML, but it's incorrect. This like should be singel quoted but the `regexp` should be double quoted.
Why change the example docs? The yaml dict style is the preferred format for EXAMPLES
Rename this to `validate_certs`
```suggestion - The password of the account to login with. ```
```suggestion - Boolean of whether to validate SSL connections. ```
```suggestion - The email of the account to login with. ```
```suggestion - Login to the CloudGenix API endpoint, to obtain an AUTH_TOKEN for use in later calls. ```
@goneri [`vmware_guest_custom_attributes`](https://github.com/ansible/ansible/blob/14ab205ea26b99e4a33a092dedd2f5d6ad1ae7c9/lib/ansible/modules/cloud/vmware/vmware_guest_custom_attributes.py#L142) and [`vmware_guest_custom_attribute_defs`](https://github.com/ansible/ansible/blob/14ab205ea26b99e4a33a092dedd2f5d6ad1ae7c9/lib/ansible/modules/cloud/vmware/vmware_guest_custom_attribute_defs.py#L94) has the same code, so it would be great to fix those as well. I am OK with any implementation.
I think if you revert this part of the code and remove the getattr defaults below, it should be fine.
Looks like we could keep this pretty much as-is if you also remove the getattr() defaults. That will cause line 284/285 to throw an error, and then we can rely on later code to warn the user that the secrets.py file wasn't found.
It would be useful to tell the user which `key` is invalid.
recommend renaming to `config` with alias to `running_config` for consistency
Wouldn't this end up returning `changed=200` to callers? Usually we keep this a boolean.
Seems this is only returned when state=present.
sample should just be the content of `gateway_id`, not the whole dict.
BotoCoreError does not have a .response attribute so this may throw an AttributeError.
No need to import HAS_BOTO3 now.
Only slightly frustrated ;-) Thanks !
The default payload (when not provided) is None, so if you would truly prefer to be explicit, you'd be using my example instead of rewriting and duplicating the fetch_url statement. (Which I specifically wanted to avoid...) ```python if module.check_mode: url = "https://api.ciscospark.com/v1/people/me" payload = None else: url = "https://api.ciscospark.com/v1/messages" payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) response, info = fetch_url(module, url, data=payload, headers=headers) ```
In check-mode we would like to test as much as possible without inducing changes. So in this case I would expect to connect/authenticate to Spark, but not send a message. That would properly catch connectivity or login-errors in check-mode.
Right, would this work: ```python if module_checkmode: payload = None else: payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ``` I prefer to use the same paths for checkmode and without. I think it is more future-proof when changes are being made.
3rd attempt, it would help if you applied the concept to a working module instead of expecting a perfect example. Consider this pseudo-code instead. ```python if module.check_mode: url = "https://api.ciscospark.com/v1/people/me" payload = None else: url = "https://api.ciscospark.com/v1/messages" payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ```
It might be better to do this check at the beginning of the module, so that in case `list_role_tags` is not available but `module.params['tags'] is not None`, the module fails right away and doesn't start applying *some* changes.
@rafaeldriutti Yes please on the test case
ec2_argument_spec is no longer needed after moving to AnsibleAWSModule
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
Maybe ```suggestion return bool(self.info) ```
I recommend you reversing this into a "guard expression" style: ```suggestion if rc == 0: return json.loads(out)[0] ``` And then you can reduce the nesting of the whole block of code which improves readability.
Please use verbs in method names. Like ```suggestion def _perform_action(self, action): ```
Add spaces between if-blocks. It's quite painful to read it when everything is so dense.
Please don't use inconsistent return values throughout the function. Currently, you use `NoneType` and `bool`. Use just one type. This is unnecessary. ```suggestion ```
```suggestion - Will not be set for an existing user unless I(update_password) is set to C(always), which is the default. ``` (or ``I(update_password=always)``)
Can be removed after an alias for uidnumber is added.
Sorry it's now 2.10
s/fo/of/ + ('security' or 'distribution')
I wouldn't overload `state`, but add a new option, perhaps called `exclusive` (feel free to pick a better name)
We need to fix the `None` handling before merging this
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
```suggestion - Used only for Linux web apps. ```
Can be covered in the `AnsibleModule` instantiation by using `required_if`
`Host group` (copy/paste, i guess)
Can be covered in the `AnsibleModule` instantiation by using `required_if`
I think having a parent class in module_utils for each of namespaced and non-namespaced services would make sense, which namespace handling happening at that level.
I should have probably used the word 'check' rather than 'test'.
Same here - AnsibleAWSModule adds this itself.
Note: It's nicer code organization to do parameter validation and normalization upfront rather than at usage. So it would be better to move this version checking and default setting to somewhere soon after the KubernetesAnsibleModule is created.
print can be replaced using sys.exit Except this looks good to me.
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
```suggestion allow_downgrade: true ```
The reason I mentioned this to be discussed is: https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html#yaml-basics > Use lowercase âtrueâ or âfalseâ for boolean values in dictionaries if you want to be compatible with default yamllint options. But if maintainers prefer `yes/no` feel free to ignore my suggestion.
```suggestion fail_on_autoremove: yes ```
s/run the/run in the/
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
I don't think the new description is any more clear. The module does manage files, not just attributes. (So the original file module description is suboptimal IMO)
Nowadays, we do: ```yaml type: bool default: 'no' ```
Doesn't look like this got merged intime, so `2.8` here (and other places
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
Keep the `r`
Must be in Sentence case, and IP needs bee upper case. Also it should mention that the default is to be both ipv4 and ipv6.
Please do this for all parameters. ```suggestion - The iptables chain in which to insert the direct_rule, used with the C(direct_rule) option. type: str ```
Please remove this line, for various reasons. - We use examples to showcase possible values - It shows the old key=value syntax If you remove this, you also do not need to quote the whole paragraph.
The more I think about this the more I think this should be a list type where you can specify some the options `success` and `failure`. You can use a combination of both (`success and failure`) or just an empty list (`none`) for the other options. We should also decide on a default, potentially `none` is the default if it isn't set.
Is this required anymore now that it is removed from the module.
```suggestion - Access List Name. ```
```suggestion - This module can be used to create and delete an access list. ```
This block can be simplified as - ```Python results = dict( command=' '.join(cmd).replace(remove_cmd, ''), msg="%s operation completed" % command, changed=True ) if out: results['stdout'] = out.strip() module.exit_json(**results) ```
```suggestion - IP associated with the access list. ```
```suggestion - Access List Name. ```
If this can be added to the PR, then I'm happy to get it merged.
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
Also describe if it deletes the files or not
(Same for the related options.)
This should really be: ``` - Set custom DNS search domains. (Use I(dns_search) with C('') if you don't wish to set the search domain.) ```
You shouldn't need `get_connection()` for that, you can just make a new connection to the socket_path and let the gc pick it up it at the end of the scope like `exec_command()` does... there isn't any particular reason to care about which NetconfConnection instance gets the message as far as I can tell.
I _think_ we're on the same page now. I initially thought about it as a simple wrapper just as `exec_command` is, but in the end it would have the same signature as `send_request`, so keeping the name would remove a lot of changes from the modules. Then again, we don't have any external consumers of the netconf plugin to my knowledge, so we're not tied to names as much as with network_cli, and renaming the function to make ithe intent clearer might be beneficial.
`check_args` is present in other network platforms for legacy reasons and can be removed here if not used
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Chances of not finding datastore is also possible even when user passes the datastore name. Change the error message
Mark params as required=True which for the required params
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
Add code to support check mode.
the module will always fail. Use `module.exit_json` and `module.fail_json` based on `result`
I don't like to fail at this point. There are way better options to handle this, we could implement a new force param to let a user "remove and add" an new image store by the users intention and if not force, just show a warning message to the users that we can not change the image store, but would recreate on force. We already have such a logic for in the cs_instance module for changing the offering on a running instance.
Seems `image_store` will be `None` on the first create pass. Right? In this case, I would suggest: ~~~ res = self.query_api('addImageStore', **args) image_store = res.get('imagestore') ~~~
The module should return `changed=True` even in check mode.
`id`, `name` and `zone` (which should be 'zonename': 'zone') are returned by default. Can be omitted in modules,
The param `provider` is required when creating.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
`default=False` (same for others)
Please add `monitoring` and pass this argument to the request.
Tend to favour YAML data structures rather than JSON style ``` sample: - name: my_bucket creation_date: "2017-07-06T15:05:12+00:00" ```
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
No need to import HAS_BOTO3 now.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
Formatting nitpick. You can add this to the line above.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
`ip_range=dict(default='0.0.0.0/0', type=lambda x: to_text(ip_network(to_text(x)))),` could be used in `argument_spec` instead of this method: * inner `to_text` required because `ip_network` requires unicode in input * outer `to_text` required because `module_utils` [doesn't handle parameter which aren't basic type](https://github.com/ansible/ansible/blob/83ec4184701f77d4de68d0c52946fd80a13fbe0a/lib/ansible/module_utils/basic.py#L504) (except `datetime`) (`to_text` comes from `from ansible.module_utils._text import to_text`)
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
`creation_response.body` is empty I propose to use: ``` "%s: '%s' (%s)" % (creation_response.info['msg'], creation_response.json['message'], creation_response.json) ```
`organization` parameter is required
``` if module.params["state"] == absent: absent_strategy(pi=api, wished_ip=wished_ip) else: present_strategy(pi=api, wished_ip=wished_ip) ``` could be more readable.
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
Targeting 2.7.10. Updated to reflect that.
`{}` is not compatible across python versions that support format, use `{0}` or `%` instead
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
this is not good way to set 'changed', if user does not exist you are erroring out instead of returning 'ok' and `changed=False`
no need to specify required=False or type=str as these are defaults
fail if `scope=user`. (root and scope=user are incompatible)
yes, this is equivalent to the 3 ifs that follow, there is no need for this duplication
this is not needed as each section checks for it's own parameter
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
This has to be done only once, since the binary is always the same (`docker-machine`).
Message cleanup needed. Notice `installed installed`.
this should be a common function in basic.py (i think there is this one or the reverse there already)
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
@bcoca noted the use of state=info in today's meeting... I think a year ago, or so, we discussed using a separate module named with an _info suffix (like sophos_utm_info.py) for things that are just for gathering info about something which doesn't relate to the host it is run on. (You also thought you might turn that portion into a lookup plugin. That would also be fine. The difference is just that a lookup can only be run o nthe controller whereas a module can be used on either the controller or a remote host).
As I understand it, this module isn't about gathering facts.
`vmware_host_config_facts` â `vmware_host_config_manager`.
`vmware_host_config_facts` â `vmware_host_config_manager`
vmware_host_config_facts â vmware_host_ntp
`vmware_host_config_facts` â `vmware_host_config_manager`
They're not being added in _get_loop_items, it seems like they're added in the internal execution so this may be the easiest way to clean them up.
First, this is not the cannonical info for the user info anymore, you should use the connection plugin itself (which now includes vars specific to the plugin and not present in MAGIC_VARIABLE_MAPPING. Second, this should not be restricted to remote_user but 'all connection information' as port, host, etc can change per iteration see the `_set_plugin_options` and `_set_conneciton_options` functions for details.
you probably need to add shell and become plugins also
giving it more thought, the fix here might be to just remove the old code 9it is really not doing what it is supposed to, task_vars is not updated anymore then 'real fix' for the become issue is something like self.prompt = CLS.prompt in set_options before processing rest
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
```suggestion backing['port_index'] = port_index serial_port_info.append(backing) ```
Because it already checks the exclusivity of these 3 options in the module definition, this check can be minimized to `if self.vlan_id == 0:` (the other 2 will automatically be None)
I maybe wrong but we are getting user input for `yield_on_poll` but you are not using here.
```suggestion serial_port_info = list() ```
Ah, so the goal is to do a back/forth translation between the values you want the user to use/see, and the actual API values. Sure Could probably be improved by just using dicts instead of all the if/else clauses, but that's just details
``` python except KeyError as key_name: ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
Tell people where we are looking `CONFIG_FILES`
Please fix: '... if it doesn't exist:'
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
~I do not think so `check mode` is required for facts module.~
Make sense to me. Thanks for info.
Use same `env_fallback` as `X_AUTH_TOKEN`
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
```python mutually_exclusive=[ ['api_username', 'api_token'], ['api_password', 'api_token'], ], required_together=[ ['api_username', 'api_password'], ], required_one_of=[ ['api_username', 'api_token'] ], supports_check_mode=True, ```
Looking at this again, I would prefer even this: ```python if meraki.status != 200: meraki.fail_json(msg='Unable to get configuration templates') return response ``` So that the default flow returns the response, except if the status is not 200. I think that's more clear, exceptions go into if-blocks, default flow is to succeed.
Again, the else here is unneeded and unwanted.
Again, the else here is unneeded and unwanted.
Should you not be able to enable_vlans support, and update the network ? So I was expecting an `if` instead of an `elif`.
I'd use `elif` here.
botocore.exceptions.ProfileNotFound may also be raised
Can remove this one. If there is a credentials issue it should happen when the connection is created, I think.
This line doesn't need to be in the try/except.
@s-hertel I believe this is actually incorrect. I must omit the `cluster_id` parameter to get the ElastiCache service to take a snapshot of a replication group. In the next few days, I'll get my changes put into a PR and I can show you. I've also added features for optionally waiting until a snapshot is in the "available" state.
Can get rid of required=False.
recurse = bool(module.params['directory']['recurse'])
Should not return a fail, just a `changed=False`
Could you please handle basic exception for this operation and other file_manager methods as suggested in [docs](https://code.vmware.com/apis/196/vsphere#/doc/vim.vm.guest.FileManager.html#makeDirectory)
Same as above, can be done with sub options
Do we need to do any check on this? Can this fail due to permission issues, or due to the file already existing? I'm fine with this always overwriting the destination file, and coming up `changed=True` every time, i just wonder if there is a risk of exceptions (pretty sure both `fetch_url`, `open` and `write` can throw a bunch of exceptions.)
There is a deprecation marker, you could add here see Dag's PR
Since these modules are new in 2.4, do you need to add them at all? If this is needed then you can use `removed_in_version`
Oh, so these modules have existed for a while, we are just upstreaming them now, that makes sense.
@jedelman8 you're right. @schunduri ^
I have submitted a couple of modules with the new approach that takes care of check-mode. I am waiting to hear back from @schunduri that this approach is acceptable before continuing to enhance other modules being developed.
```suggestion - Can contain multiple entries if more than one node provided in I(name), or I(name) is not provided. ``` It could be that only one node exists of the ones specified :) And if `name` is not specified, all nodes will be returned.
I don't think this makes sense. If a node does not exist, its inspect output is not added to the result list. I guess you could simply leave away this line. ```suggestion ```
From the way the docker modules currently operate, it probably makes sense to add a `AnsibleDockerSwarmClient` to `module_utils/docker_swarm.py`, which extends `AnsibleDockerClient`. Then `docker_swarm`, `docker_swarm_facts`, `docker_node` and `docker_node_facts` could use `AnsibleDockerSwarmClient` instead of using `AnsibleDockerClient` directly.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
By the way, you don't need `else:`, since this will be evaluated anyway.
Look what I've found: ```python $ ipython Python 3.7.0 (default, Jun 28 2018, 11:18:11) Type 'copyright', 'credits' or 'license' for more information IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import pkg_resources In [10]: ipdst = pkg_resources.get_distribution('ipython') In [11]: ipdst Out[11]: ipython 6.4.0 (/home/wk/.pyenv/versions/3.7.0/envs/ansible-py3.7.0-pyenv-venv/lib/python3.7/site-packages) In [15]: ipdst.as_requirement() Out[15]: Requirement.parse('ipython==6.4.0') ``` This probably can completely eliminate need for doing `pip freeze` and parsing it! @HD650 please investigate this.
Why don't you do this right in the `return` line? If you think it's going to be too long, be aware that you can break the line by wrapping it with braces: ```python def _is_valid_distribution_name(name): return ( not name. lstrip(). startswith(('>=', '<=', '!=', '==', '>', '<')) ) ``` (you can put `not` outside of brackets if you like it more this way)
This is tricky. It should probably return false because there's no way of knowing whether it's the same version, so we'll need to invoke pip to reinstall it as it does when you run it manually
I'd probably add `distribution_parts = []` after yield inside of `if` block and then you'd only need `distribution_parts.append(name)` outside of if-block without a need to have diverse code or `else`-block.
the option was added in 2.3, its the new choices that were added in 2.4, make a note in the description, dont change the version_added for the option.
You may need to update `test/sanity/validate-modules/schema.py` to allow this if `ansible-test sanity` fails
ah, because this is `stable-2.4` and I think the stricter `version_added` checks were added in 2.5
```suggestion - Enable strict verification of CloudGenix API SSL Certificate. ```
I don't think installation should be covered by this modules, there are plenty of package management modules that are better suited for this, at worst a role that downloads and installs it
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
```suggestion version_added: "2.10" ```
```suggestion author: Edoardo Tenani (@endorama) <e.tenani@arduino.cc> ``` (Same for the other PR. This will make sure that you will be notified about issues / PRs for this plugin by ansibot.)
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
Indeed :) I totally missed that...
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
My bad. Didn't see if in later stages.
please use explicit imports
please wrap in `IF` block
``` The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1353, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1342, in main create_changed, asg_properties = create_autoscaling_group(connection, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 967, in create_autoscaling_group update_asg(connection, **ag) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_modlib.zip/ansible/module_utils/cloud.py", line 153, in retry_func botocore.exceptions.ParamValidationError: Parameter validation failed: Invalid type for parameter DesiredCapacity, value: None, type: <type 'NoneType'>, valid types: <type 'int'>, <type 'long'> ``` Even though this is prettier, I think we might need to do what you initially did by checking if not None: `desired_capacity = desired_capacity if desired_capacity is not None else as_group['DesiredCapacity']` etc.
This doesn't work as expected, unfortunately. ``` >>> test_dict = {'one': 1, 'two': None} >>> print(test_dict.get('two')) None >>> print(test_dict.get('two', 2)) None >>> print(test_dict.get('three', 3)) 3 ```
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
`required=False` and `default=None` are defaults so you can eliminate them in every case below
While I think this is correct I'm not sure if it uses no proxy or the default proxy configured in the IE settings. I don't have easy access to an environment with a proxy configured so I can't test this assumption.
Can you change the examples to use YAML rather than `k=v` shorthand? ```yaml - debug: var: lookup('cpm_status', 'temperature', validate_certs=true, use_https=true, cpm_url='rest.wti.com', cpm_username='rest', cpm_password='restfulpassword') ```
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
This is always a tough question, and I'm not sure what's the best solution :) In Ansible, things are usually lower-case. I guess you have to decide what you want in the end :)
```suggestion - There is a small delay (typically about 5 seconds, but can be as long as 30 seconds) before obtaining the random values when requesting a validation. ```
hmm, had not realized that, probably fine to just remove then, but docs should be kept in sync, specially if we want to backport
there is no need to version params for new modules
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
Can we just call this argument `lambda_alias` without the alias (just thinking about future proofing for other notification targets)
Looking at this from a future proofing point of view, I'm not sure `required` should be true here (that also helps if you just want to delete a notification with only `event_name` and `state`)
required=False is the default
I'd like to remove `lambda_function_arn` in case anyone ever wants to implement other notification types
Same way we do for stuff like iam managed policies, accepting whatever value (no type) and if it's a list assign a list of action perms or if it's a string coerce to a single-item list.
When failing, please include the traceback with the `exception` keyword arg to fail_json. `exception=traceback.format_exc()` so people know where the failure came from.
I think this was a typo- should be tags_to_match.items():
Another typo - should be match_tags(tags, cluster)
you could add supports_check_mode=True to AnsibleModule
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
There is a much easier way to do this, by using the index in the list. Something like: ```python unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
You could make the unit mandatory (which is what I would do), or you could allow no unit (which means in bytes) and in that case you will have to consider that case as well. (i.e.if unit is a digit)
The final command should probably return its stdout, stderr and rc back to the playbook.
The grow and shrink booleans are used for allowing to grow and shrink the image. (That is why they default resp. to true and false). So you have to compare the original size against the wanted size, and if it shrinks and shrinking is allowed, only then should it resize (otherwise it needs to escalate). Similar for the grow-case.
The mixup to me is that people using incorrect units will silently be using bytes, whereas it should report this as an error.
```suggestion - Can be a string, the name or resource ID of the network interface. ```
```suggestion - Can be a dict containing the I(resource_group) and I(name) of the network interface. ```
```suggestion - To create a new network interface, at least one Virtual Network with one Subnet must exist. ```
```suggestion - The resource group to use when creating a virtual machine. ```
```suggestion - The virtual network to use when creating a virtual machine. - If not specified, a new virtual network will be created and assigned to the first virtual network found in the resource group. ```
Import custom packages in try/except and handled with fail_json() in main() e.g.:: try: import foo HAS_LIB=True except: HAS_LIB=False
do not log due security concerns
please remove logging due security concerns
I believe the previous 3 lines can be deleted.
Call out default? If you set a default here, don't forget to update the spec above.
version added is 2.4
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
That is a limitation but there is a workaround (see #22630)
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
Could you please use `AnsibleAWSModule` instead? We didn't have a lot of the aws utils we do now when this was first PRd, it will save having to port it later on. https://docs.ansible.com/ansible/devel/dev_guide/platforms/aws_guidelines.html#creating-new-aws-modules
This should use the proper LDAP attribute name for DN ```suggestion - This value is either the C(distinguishedName) or C(objectGUID) or the AD object to lookup. ```
Should add a point here saying not allowed with `I(identity)`
No need to quote this line. Please add spaces around `>=`
Should add a point here saying not allowed with `I(identity)`. Should also say the value is the `C(distinguishedName) of the path to search from.`
No need to quote this string.
Ansible 2.8 isn't supporting Python < 2.6 anymore, so this line is no longer needed.
```suggestion version_added: '2.8' ```
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Shouldn't have `required: true` for things that have a default.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
Is there an example or doc someplace where that actually happens? If glob.glob() is really needed, perhaps a better approach would be to avoid running this function so much, rather than attempt to replace glob.glob()
A few stats with this change compared to devel and this PR (100 hosts and 1 debug using jinja2): ``` ==> devel.txt <== 765719 function calls (758704 primitive calls) in 4.990 seconds ==> 45568.txt <== 651530 function calls (644525 primitive calls) in 4.862 seconds ==> glob_get_paths.txt <== 651709 function calls (644704 primitive calls) in 4.881 seconds ``` ``` devel.txt 11: 3648 0.104 0.000 1.195 0.000 loader.py:423(all) 174: 2 0.000 0.000 0.030 0.015 loader.py:546(all) 45568.txt 16: 3648 0.069 0.000 0.734 0.000 loader.py:423(all) 218: 2 0.000 0.000 0.016 0.008 loader.py:549(all) glob_get_paths.txt 17: 3648 0.051 0.000 0.724 0.000 loader.py:423(all) 211: 2 0.000 0.000 0.017 0.009 loader.py:549(all) ``` ``` devel.txt 18: 2850 0.015 0.000 0.724 0.000 glob.py:9(glob) 45568.txt 451: 38 0.000 0.000 0.002 0.000 glob.py:9(glob) glob_get_paths.txt 426: 38 0.000 0.000 0.002 0.000 glob.py:9(glob) ```
I think the only change to glob in `_get_paths()` would be relatively simple: ```diff diff --git a/lib/ansible/plugins/loader.py b/lib/ansible/plugins/loader.py index d6cec2bf66..8611016adf 100644 --- a/lib/ansible/plugins/loader.py +++ b/lib/ansible/plugins/loader.py @@ -161,15 +161,15 @@ class PluginLoader: # look in any configured plugin paths, allow one level deep for subcategories if self.config is not None: - for path in self.config: - path = os.path.realpath(os.path.expanduser(path)) - if subdirs: - contents = glob.glob("%s/*" % path) + glob.glob("%s/*/*" % path) - for c in contents: - if os.path.isdir(c) and c not in ret: - ret.append(c) - if path not in ret: - ret.append(path) + for item in self.config: + for path in glob.glob(os.path.realpath(os.path.expanduser(item))): + if subdirs: + contents = glob.glob("%s/*" % path) + glob.glob("%s/*/*" % path) + for c in contents: + if os.path.isdir(c) and c not in ret: + ret.append(c) + if path not in ret: + ret.append(path) # look for any plugins installed in the package subtree # Note package path always gets added last so that every other type of ```
This breaks configured paths that have globbing characters
Now it makes sense.. in this case it looks like it needs to happen in `_get_paths()` instead of or in addition to `all()`: ideally the globs would happen only once and remain cached while the lookup path remains unchanged, but that's a bunch more work than the original PR. Happy to abandon this for now, unless someone else is volunteering :)
I am not sure we should advice people to install this from pip.
If you use `env_fallback` then you don't require this check.
Use same `env_fallback` as `X_AUTH_TOKEN`
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
I think it's likely the proxy code won't work as I haven't been able to test it well under Meraki
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
I would do this in a more pythonic way like, `'/organizations/{0}/networks'`
This won't work if 'name' is an alias, rather than the parameter name.
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
```suggestion - name: Ensure that /exports/nas key in auto.direct map is absent ipa_automountkey: ```
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
```suggestion description: State to ensure. ```
Add another example with `ipadefaultemaildomain`
ack. merging this in since this isn't a blocker.
Ping @willthames - other than this validation fix this is good to go.
This snippet looks just like one in `role_find`. It probably deserves being moved into a reusable function.
Well, this is also very boilerplate, which you could deduplicate.
This thing is also repeated.
default is missing to allow skipping this param
Just an idea. Wouldn't you get the same result if you simply have ```suggestion port_ordered = [sorted(d.items()) for d in port[key]] ``` ? `OrderedDict(sorted(a.items())) == OrderedDict(sorted(b.items()))` should be true if and only if `sorted(a.items()) == sorted(b.items())` (for `dict`s `a` and `b`).
Ansible has allowed 160chars per line, I think it's OK to have this on single line.
So if both `portgroup_type` and `port_binding` are defined, it ignores `port_binding`? I think it should check for this and if they are not the same from the API perspective, it should fail with an error
Yeah, i understand the backward compatibility, can you add in the description of `port_binding` that it takes precedence over the deprecated `portgroup_type` value? That way people understand the precedence.
not for this PR, but we might want a 'configurable ignore facility' ala gitignore in the future
If I remember how this worked in 2.9 the 2nd tuple entry controls whether the file is excluded from the root only or throughout the collection. I would have thought we would want the latter so this should be ```suggestion b_ignore_files = frozenset([(b'*.pyc', False), (b'*.retry', False), (b'.git', False), ``` Then again looking at devel the pattern is `.git` so this does act the same as devel.
This should be `b_output_path` to indicate it is a series of bytes. Even if the caller is sending in bytes, this function should convert it to bytes just like `b_collection_path` at the beginning. That allows our `b_` naming convention to hold, making this code look incorrect (trying to join `bytes` and `str`).
Use a `main()` function for the body of the test.
(Similarly, mark any string that you are going to call decode on with as a b"string".)
Do you have any references for the inline if being discouraged? If you don't like the inline if, then I'd go with the normal if block.
`policy` should be added to `argument_spec` to be usable.
@s-hertel using client exceptions rather than botocore exceptions is nicer when they actually exist (which they do here for a kms client): ``` except connection.exceptions.NotFoundException: return None except (botocore.exceptions.ClientError, botocore.exceptions.BotoCoreError) as e: # Legitimate failure module.fail_json_aws(e, ... ```
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
use `trail['LogFileValidationEnabled'] = ct_params['EnableLogFileValidation']`
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Can you just catch `AttributeError` here instead.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Okay, if it's used by lots of modules it should go to the other PR.
I think this var needs a more specific name. Like `generic_vmw_errors`, if I understand correctly. Because now it's not clear for me what exactly you're generalizing.
You should state `Raises: TaskError` separately, because it's not a return value
It looks like you put trailing period here, while you use different style for other lines. Could you please keep consistent style? :)
I'd also explicitly state that it returns a tuple. With current wording it seems like it returns just `True` in a certain case.
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
It's important to have the same `host` kwarg value used for all calls to `display.vvv` for the same connection, whether that be the actual jail name or the iocage jail name. As written currently, the `display.vvv` call above is simply lacking the `host` kwarg. It can be added without making any changes to the message displayed.
Include a `host=kwargs[Jail.modified_jailname_key]` kwarg when calling `display.vvv`. This will maintain consistency with other calls to `display.vvv` made by the `Jail` connection plugin.
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
`self.module.warning` could be used
a generator should be used here.
`urljoin` is unused
`api_token` parameter is missing.
Yes because this module use this specific API
and 'logdna lib'
needs to be a string, "2.7" otherwise it will be used as a float and not fare well in comparissions
DO NOT AUTOINSTALL use the HAS_LOGDNA variable as a flag and return an error with the requirement when the plugin is invoked, plugins should NOT autoinstall libraries, also pip might not be installed on target systems and is also a possible error point. you can look at other lookups (like consul_kv) for how to deal with this issue
2.0 is what you want here
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
Maybe even better: ```suggestion new_item['aliases'] = sorted(new_item['aliases'] or []) ``` To convert `None` to an empty list.
```suggestion old_item['aliases'] = sorted(old_item['aliases']) ```
```suggestion zip_data = zip(sorted(new_list), sorted(old_list)) ```
Also note that simply sorting does not necessarily give the correct result for lists of dicts. So this change could actually recreate/update services where nothing changed.
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
I would remove this blank line.
Here should be two blank lines.
I would remove this blank line.
You could move this a couple lines above and remove the two in the elifs below.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
You can remove this (and the import) now that this uses AnsibleAWSModule.
Should probably check if region exists before this line.
`final_interface = dict((k,str(v)) for k,v in final_interface.iteritems())` seems to be required here since the values from new_interface may contain non-strings while the values returned by the API are always strings. With this added line, the module becomes idempotent with passive proxies.
I find a list of dict easier to handle rather than dict of dict.
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
should be superfluous unless you want to add a different command for check_mode support (since `supports_check_mode` is false)
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
Not a massive change but I'd suggest doing the split like this ```suggestion schema, tblname = self.name.split('.', 2) ```
and then remove the parts Glandos point you.
I'm totally fine with your explanation and it was just a starting point by my side. And you are right, that the usage in your module in this case is simpler, so no change needed.
You can use [`ensure_libs`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/postgres.py#L42).
A follow up PR that updates all postgres modules to use https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/postgres.py#L42 would be good. No need to block on this. Also that function should be updated to use `module.fail_json(msg=missing_required_lib("psycopg2"))`
@resmo Aren't both same ? ```py def x(): return (1, 2, 3) def y(): return 1, 2, 3 x() == y() #True
if `self.path` doesn't exist, `self.path + ".pub"` will never get removed.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
`pexpect` could be used to provide the password to the subprocess on stdin.
```suggestion result = self._run_command([self._blkid_bin, '--uuid', uuid]) ``` According to `man blkid` on my system, it is `--uuid` and not `--uid`.
```suggestion query = '%s=%s' % ('UUID', uuid) ``` Since single quotes are used everywhere else.
Probably the same with `--label` instead of `--uuid` here.
Reuse the result of [previous `get_bin_path` call](https://github.com/ansible/ansible/blob/8534178b1d28f2134da8f6b6634879157b5e34e9/lib/ansible/modules/system/filesystem.py#L397).
make this a set to be a bit more efficient. (We're only using it for containment checks.)
```suggestion - The port range for port-object. ```
Please remove this statement. Provider has been deprecated since 2.5. New modules should not have it.
```suggestion - The IP address and mask for network object-group. ```
```suggestion - The group-object for network object-group. ```
```suggestion - The description for the object-group. ```
```suggestion zip_data = zip(sorted(new_list), sorted(old_list)) ```
Also note that simply sorting does not necessarily give the correct result for lists of dicts. So this change could actually recreate/update services where nothing changed.
Maybe even better: ```suggestion new_item['aliases'] = sorted(new_item['aliases'] or []) ``` To convert `None` to an empty list.
```suggestion old_item['aliases'] = sorted(old_item['aliases']) ```
I think instead of comparing chunks like this, it might be better to sort the lists of policies first, following a heirarchy like: - SID - Effect - JSON-sort-key-dumped Action
I would insert an empty line in front of every example to separate it a bit.
Use `"""` to unify it with the other blocks above.
I would prefer explicit imports.
Format this like this: ``` remove_content = { 'operation': 'remove', 'address': [ {'deployment': deployment} ], 'json.pretty': 1 } ``` The same anywhere else where you are using ` = \`.
This is never evaluated because you are already in the branch which matches `info['status'] == 200` only.
```suggestion src: "{{ lookup('first_found', params) }}" ```
Omit these lines please.
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
```suggestion src: "{{ lookup('first_found', findme) }}" ```
```suggestion - "blkid (when I(label) or I(uuid) options are used)" ```
```suggestion - "With this option user can identify the LUKS container by UUID. ```
You can also use `I(...)` here.
Sounds fine to me. I don't think I can say shipit yet, but if this gets wrapped up in another PR the rest looks fine to me.
I don't know if I like this approach. I can't think of a time when this would ever be desired behaviour, and not a mistake - even so, I feel like we should require a force flag to remove the *only* key on a container, rendering it useless.
Missing full stop. All `descriptions:` must be full sentences. This applies to a few other `descriptions:` in these modules.
Do you support IPv6, if not then this should say IPv4 address.
First letter should be capital and the sentence should end with a period.
For consistence please ensure all `description:` lines are full sentences (capital letters + full stop at the end)
The example uses `1T`, However later on you have `module.fail_json(msg='size (Physical Capacity) should be defined in MB, GB, TB or PB units')`
Add another example with `ipadefaultemaildomain`
period at end.
Add a note that - KRA service should be enabled to use this module.
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
Add as ``` - Description of vault. ```
it can stay in this file, but i would make into a function that we can then also use in persistent, at least until we remove that. That way we avoid 'bugfixing only one path' in the future.
missed .copy() so that should not be an issue, thought you were polluting `environ` .. still i would just refactor the call to one location vs keeping dupe code around
Add to examples/ansible.cfg
Typo in the help message
Sorry, my bad. I didn't see the implementation of `_run`.
```suggestion description: Numerical ID of the group that owns the destination directory. ```
I wonder if max_attempts should depend on wait_timeout, rather than delay on wait_timeout (just thinking if wait_timeout is 30, we'd make 30 calls in 30 seconds) ``` delay = 15 max_attempts = wait_timeout // delay ```
```suggestion description: Name of the group that owns the destination directory. ```
```suggestion description: String that represents the octal permissions of the destination directory. ```
```suggestion description: Name of the user that owns the destination directory. ```
Should be 2.4 (as we don't backport new modules to older releases).
A lot of the entries here should be in the description of each relevant option. This is for a high level overview of what the module does. The `notes` entry can also be used for info about the module if it doesn't fit in a option.
This should be removed an replaced with: ```yaml default: high performance ```
Not needed. The module is new in version 2.4.
Don't add `required: false`. It is implicit.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
I blame my `black` setting.
> wirte write
I think you might want to rollback at this point.
I would not assign it w/o validation: 1) it might cause errors happening in some other place, which would be hard to spot 2) it might be a weak place, vulnerable to injection attacks (security issue)
Yes, but it is still unrelated to the env var.
This place in code **does not affect** cloning/initing, while operating on **existing repo**, which makes it pointless. Also, it would be architecturally wrong to do it from some random phase of module execution. We would still have to bypass it to clone/init anyway.
Does having a 'rename' option for state make sense? It seems like you could just check if the organization exists and if it does and rename_to is provided, then rename it. Not requesting a change, just wondering.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
Will info['body'] be json? Might be a string/HTML.
Can you test this on python3 please? I think python3 needs bytes.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Maybe even better: ```suggestion new_item['aliases'] = sorted(new_item['aliases'] or []) ``` To convert `None` to an empty list.
```suggestion old_item['aliases'] = sorted(old_item['aliases']) ```
```suggestion zip_data = zip(sorted(new_list), sorted(old_list)) ```
Also note that simply sorting does not necessarily give the correct result for lists of dicts. So this change could actually recreate/update services where nothing changed.
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
My bad. Didn't see if in later stages.
You are not executing command returned by `modify_conn_disable_ipv4` so I am sure that it has no effect.
My bad. Didn't see if in later stages.
Add an example for this in EXAMPLE section.
if not handling become methods update the class variable to indicate this
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
I'd lean towards making it an optional module arg as well. Mostly for testing purposes but also to support if the url does change users could handle it with just playbook updates instead of requiring a new module version.
```suggestion - This is a only when I(type=private). ```
operation â state
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
s/will created/will be created/
This needs to be a raw string (`r'''`) to fix the failing doc sanity check- otherwise it tries to interpret `C:\Users` as a Unicode hex literal. Ah, the joys of nesting escapes across multiple languages... :)
Would this ever return false under normal circumstances? Seems like we'd lose items if it did...
no, jimi-c has alternate solution and we'll probably go with that
which was incorrect solution as the 'non templating' of pause shows
Squashing is fine in this case, I think, if a list of lists is effectively just another way of writing a list e.g. sometimes you might want to do: ``` yum: name: "{{item}}" state: present with_items: - "{{list_of_default_rpms}}" - "{{list_of_custom_rpms}}" ``` You can use union to join the lists of course, but I'm not sure what other use case drives this test that isn't amenable to squashing
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
No longer need deepcopy
The return value is not strictly cookies. The return value is a dictionary of headers
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
Okay, so to implement the examples like this: ``` with_cyberark_password: appid: 'Application1' query: 'safe=...;' output: 'password ....' ``` We'll want to take the dict from terms instead of from kwargs. terms will hold the dict that the user passed in so you should be able to drop in replace it in your constructor like so: ```CyberarkPassword(**terms)```
and convert filename to bytes again.
if not handling become methods update the class variable to indicate this
No quotes for None, makes it unclear if it's python `None`/yaml `null` or a string.
```suggestion vmware_host_snmp: ```
```suggestion to iterate use a C(with_) directive. ```
Doesn't look like this got merged intime, so `2.8` here (and other places
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
The other option is to strip the arguments and keep it as a list
Python 2.6 needs {0}, {1} - empty brackets in various other places too.
Is there a way to format the stdout? When applying it gets hard to read: ``` "sdtout": "aws_instance.example: Creating...\n ami: \"\" => \"ami-ff4ea59d\"\n associate_public_ip_address: \"\" => \"<computed>\"\n availability_zone: \"\" => \"<computed>\"\n ebs_block_device.#: \"\" => \"<computed>\"\n ephemeral_block_device.#: \"\" => \"<computed>\"\n instance_state: \"\" => \"<computed>\"\n instance_type: \"\" => \"t2.micro\"\n ipv6_address_count: \"\" => \"<computed>\"\n ipv6_addresses.#: \"\" => \"<computed>\"\n key_name: \"\" => \"<computed>\"\n network_interface.#: \"\" => \"<computed>\"\n network_interface_id: \"\" => \"<computed>\"\n placement_group: \"\" => \"<computed>\"\n primary_network_interface_id: \"\" => \"<computed>\"\n private_dns: \"\" => \"<computed>\"\n private_ip: \"\" => \"<computed>\"\n public_dns: \"\" => \"<computed>\"\n public_ip: \"\" => \"<computed>\"\n root_block_device.#: \"\" => \"<computed>\"\n security_groups.#: \"\" => \"<computed>\"\n source_dest_check: \"\" => \"true\"\n subnet_id: \"\" => \"<computed>\"\n tenancy: \"\" => \"<computed>\"\n volume_tags.%: \"\" => \"<computed>\"\n vpc_security_group_ids.#: \"\" => \"<computed>\"\naws_instance.example: Still creating... (10s elapsed)\naws_instance.example: Still creating... (20s elapsed)\naws_instance.example: Still creating... (30s elapsed)\naws_instance.example: Creation complete after 34s (ID: i-04362e7210c113e2c)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n" ```
I find this error message very hard to understand. I don't have any experience with GitLab servers, though :) If the other gitlab_* modules have the same text, we should probably keep it here as well. Changing it could be done in another PR once this is merged.
Authentication should be handled here and not inside of the class
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion mode: '0644' ```
```suggestion - name: Change login times for user ```
```suggestion type: str choices: [ absent, present ] ```
```suggestion result = dict( ``` More in line with a lot of modules.
CI failure due to missing module metadata: ``` 2017-02-08 11:07:30 ============================================================================ 2017-02-08 11:07:30 lib/ansible/modules/cloud/misc/qemu_img.py 2017-02-08 11:07:30 ============================================================================ 2017-02-08 11:07:30 ERROR: No ANSIBLE_METADATA provided ```
This should be indented by 4 spaces as it's Python code not YAML.
I would format this like this: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.0' } ```
The syntax now is: ```yaml author: - Jeroen Hoekx (@jhoekx) - Toshaan Bharvani (@toshywoshy) ```
This is a nitpick, I'm not 100% sure if it's right, but it looks like GitLab like to go by "GitLab" and not "Gitlab"
Wrong doc string
Wouldn't this end up returning `changed=200` to callers? Usually we keep this a boolean.
This method is unused and must be removed.
check_mode is True but I don't see any check done around this. Please correct me if I am wrong here.
test of `wait` parameter could be moved inside the `wait_to_complete_state_transition` method.
You will need to include the OAUTH_TOKEN environment variable also.
In the `exit_json`, you should also return `changed` and `state`.
I see that the requirements lists python-2.6 as the minimum python version. Unfortunately, format strings in python-2.6 are more limited than in python-2.7 and later. So you need to be explicit about the position in the format args list you are looking at like this: ``` python response = rest.get('floating_ips/{0}/actions/{1}'.format(ip, action_id)) ``` There's a few other places with format strings that have to be fixed as well.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
This call is not passing `is_module`, which is required to know whether this is for a module or another plugin type.
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
This needs to pass `return_docs=True` for return docs.
This is duplicated 15 lines above that ;)
I prefer that the module would check the connection itself as well, without actually sending the message. If the API supports stub messages (or empty messages?), use that. Otherwise just test the authentication/connection some other way.
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
you should not need to checked disabled, as the plugin itself wont be called at all if true
check is redundant as you already flagged as 'required'
2.0 is what you want here
set this as the default, then you dont need to do checks yourself
Remove the quotes from around `%r` as that may cause a something like `''foo''` to appear in the output.
Please switch back to just using `%r` here instead of `'%s'` as that assists in providing more information about the original type.
Since we are updating this now, let's switch `'%s'` to `%r` for the default values.
IMO the previous block is not needed, and this error should become error 325.
But to be honest, the types should be identical, it shouldn't matter what it is.
Is the default false, if so needs adding here and in the docs
Thanks for confirming
Please add `, no_log=True`
Why are username and password define here, though should be in the docs_fragment.
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
```suggestion short_description: Manage volumes on Vexata VX100 storage arrays ```
Nice to have return values here for better UI/UX
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
```suggestion def validate_wwn(module): ```
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
Please remove this and add a note in the `description:` saying the default port will be based on the connection type, e.g. 80 or 443 for http or https respectively.
`C(api-path-CurrentConfig.json)` for formatting
this should be `backup_filename`
"Path to an ssh key used to authenticate..."
As per other PRs, you don't need to repeat the option name.
Probably more like "Whether the specified network vlan should exist or not"
@carchi8py it's declared at int below, so this should be a safe change.
`type: bool`? `default: false` (and remove the redundant default text)
You're correctly using `type='list'` in the arg_spec, so probably better if at least one example used the native YAML format and showed multiple values as list elements. The arg validator will properly handle coercion of a single value to a list (as the current examples show).
should probably specify that this is only used for deletion
I think defaulting to `false` is the safest option, and would be consistent with the purge_tags defaults in other modules.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
```suggestion module = AnsibleModule(argument_spec=argument_spec, mutually_exclusive=[['retention', 'purge_retention_policy', 'overwrite']]) ```
Not required with AnsibleAWSModule
I think we also want to require `encryption` be specified anytime `encryption_key_id` is passed. That way users won't accidentally pass the key_id and assume that it's being used when it may not be.
You should use `module.add_cleanup_file()` (somewhere above) instead of manually trying to clean up.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
`pexpect` could be used to provide the password to the subprocess on stdin.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
Ah, I think the point is that `os.remove()` raises an exception if the file isn't there, so `changed` won't be set to `True`.
`continue` isn't necessary
update_ntp_settings â update_ntp_servers (or re-change the update_ntp_servers method name)
If self.desired_state is 'present' and all the ntp servers are already present (so host_ntp_servers == []), state take the value "absent"â¦ so self.results[host.name]["current_state"] = "absent"â¦ which is not what's expected.
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
vmware_host_config_facts â vmware_host_ntp
I _think_ we're on the same page now. I initially thought about it as a simple wrapper just as `exec_command` is, but in the end it would have the same signature as `send_request`, so keeping the name would remove a lot of changes from the modules. Then again, we don't have any external consumers of the netconf plugin to my knowledge, so we're not tied to names as much as with network_cli, and renaming the function to make ithe intent clearer might be beneficial.
You shouldn't need `get_connection()` for that, you can just make a new connection to the socket_path and let the gc pick it up it at the end of the scope like `exec_command()` does... there isn't any particular reason to care about which NetconfConnection instance gets the message as far as I can tell.
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Please rename it as `get_provider_argspec()` to be in sync with other platforms
I'd move this to the `write_fstab` function so it does not need to be repeated.
You can remove the `aliases` here now.
There was multiple changes in the past but you don't make any backward compatibility fixes for that neither so I don't see a reason why to make exceptions for `type='str'` here.
This is not required as `type=str` is the default type. The same bellow.
Please could you change it to: ``` if ( fstab_file and fstab_file != '/etc/fstab' and get_platform().lower() != 'sunos'): ```
nope, looks like you missed this one.
since the plugin is called `aws_ssm`, I'd change this to `ansible_aws_ssm_retries`
All these vars should start with 'ansible_'
No need to quote the path, not using double quotes also means you don't need to double up on `\`, e.g. just do `path: C:\Windows\temp`.
Add the `r'''` to https://github.com/ansible/ansible/pull/49652/files/6dc61c94e3abd3cf74998b78f4fa08956a95c269#diff-1c417562a0944ee1362da84b93d9695dR56 to avoid it. We do this for all our module examples so we don't have to worry about escaping these values.
Not required as we can use connect_to_api method.
Not required, we already have method called `connect_to_api`. Also, I would recommend to use `from ansible.module_utils.vmware import PyVmomi` which base class for all VMware_* modules.
Remove redundant import
Add this at top after License. See example above.
I learned yesterday that nowadays we can simply do `import json` as we no longer support Python 2.4
this should use atomic_writes (but given how containers normally mount the file, it should note that for them users might need a toggle to allow 'unsafe=true'
`f` variable isn't used in this 2nd `try` block: it seems a `for` loop is missing.
Else part is not necessary since we are initialising `b_passwd` already.
I'm conflicted as to whether all of the matches style variables should also have a b_... I kinda lean towards yes. They aren't byte strings but a container of byte strings but the convention is designed to make it obvious when you're combining text and bytes. That doesn't work for matches unless you've marked that it contains byte strings.
The b_ convention was missed for line.
Great, thanks for putting this check in here.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
vms -> VMs
we want want -> we want
Please fix: '... if it doesn't exist:'
How about using `LooseVersion` from `distutils.version`? It usually handles version numbers pretty well. (Grep for `LooseVersion` in the modules directory to see plenty of examples.)
@mrdrogdrog great! Once you made the adjustments and someone else also tested it (just to be sure), I'll merge it and create a backport PR. If this gets done by the end of next week, it should make it into the 2.9.2 release.
Their are built in helpers for argspec for the this, have a look in other modules for "exclusive"
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
You can use [`env_fallback`](https://github.com/ansible/ansible/blob/8f41270a010c00d058c70bdccdc611df8b454139/lib/ansible/module_utils/basic.py#L726)
I get it now, so adding diff as part of `prepared` key results is rendering diff in a readable format in output logs. The only concern I have here is this change might break backward compatibility for playbook that depend on `diff` key
Note that this line was only added recently (https://github.com/ansible/ansible/pull/41846/files) for Ansible 1.7 development branch, i.e. it has not been added to a release. So your change should be safe.
this breaks showing diffs from loop items
This can be changed to `commit_configuration(module, check=True)`
`read_config_from_file` could return the content of the file or `None` if the file doesn't exist (instead of a tuple).
Please use add `type: bool`
Please add `type: bool`.
...The remote host **MUST** support...
I think something like `device-name` would be more descriptive.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
`type='int'` You can then remove your code to check that this is an int.
it means the same thing, it's just the flow.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
Add alias of `username` (shown in argspec).
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
I feel like this changes too much, for what could be achieved with less: ```diff diff --git a/lib/ansible/plugins/callback/json.py b/lib/ansible/plugins/callback/json.py index 3961a78aab..fd344a0cf0 100644 --- a/lib/ansible/plugins/callback/json.py +++ b/lib/ansible/plugins/callback/json.py @@ -101,14 +101,16 @@ class CallbackModule(CallbackBase): summary[h] = s custom_stats = {} + global_custom_stats = {} if self.get_option('show_custom_stats') and stats.custom: custom_stats.update(dict((self._convert_host_to_name(k), v) for k, v in stats.custom.items())) - custom_stats.pop('_run', None) + global_custom_stats.update(custom_stats.pop('_run', {})) output = { 'plays': self.results, 'stats': summary, 'custom_stats': custom_stats, + 'global_custom_stats': global_custom_stats, } self._display.display(json.dumps(output, indent=4, sort_keys=True)) ```
Is the `sorted()` actually useful here? You're adding the keys to a standard python dict, which is unsorted by nature.
This name spacing change is not backwards compatible and will cause existing uses of this plugin to fail unexpectedly. I believe a different means will be required here.
the default had to allow for '3rd party callback' subclassing and not using the new config framework
you don't need the constant, the config definition above already covers this
ok, as pointed on irc, that's verified by check, so that's ok.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Wouldn't it be better to let `openssl dhparam` write into a temp file, and on success move the temp file to the real file (with `module.atomic_move()`)? Then in case of interruptions or errors, existing destinations wouldn't be trashed (except of course if `atomic_move` itself goes terribly wrong).
We generally don't mask the usernames, just passwords.
we want want -> we want
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
```suggestion - Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance. ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
use Mapping and Sequence classes instead as you might get an AnsibleSequence or similar object that does not inherit directly from 'list`
while this might make sense for dictionaries, since shell doesn't really support them, for lists it might not as they are supported by shells
ah, its seeing it as a file name ... weird since host_list 'works' .. i should look into that
Will the azure API always return a non-zero list or could this result in an `IndexError`? (If so, please wrap in `try`/`except`)
I would really like to pull @matburt into the decision-making on this matter. It's not just the sourcing from the env var here, but also the use of the `license_type` parameter once it's received. What does this mean in practice? I think users would expect to be able to use the plugin as a part of the Ansible core CLI with any given type of target AWX or Tower instance.
If one of both is required, it is better to force this as part of the argspec.
This would turn everything into a string, not sure if that's what you want for e.g. booleans). Same for the other values that are not strings. Probably not what you want.
This is fine, but we should only update (all labels) if one changed, misses or should be added.
Unessecary blank line
I mean not to actually shrink it but doing a "no-op" but showing a warning to the user, that volumes can not be shrinked.
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
Sure, but I don't believe it ever happens (and if it does ever happen, use `.get` to return an empty list)
You haven't answered my question :). It just seems unlikely that you'd get a response object with a list of vault objects that don't happen to havethe `VaultName` key, without some other exception being thrown.
create_vault returns a dict with `location` and `ResponseMetadata`. You'll probably need to call describe_vault to return the expected parameters (and please use camel_dict_to_snake_dict, and don't forget to also call list_tags_for_vault, convert the tags using boto3_tag_list_to_ansible_dict and then add those to the results too) Edit: no need to call boto3_tag_list_to_ansible_dict as tags are actually in the right format for once. This service must be unique!
You need a paginator here still.
The description needs to have a trailing dot. (The short_description does not)
don't forget to remove if you change default
a teeny typo: ipvr_addresses -> ipv4_addresses
If parameters are not required, you do not have to add `required: false`. This is the implied value, so it is easier to see what is required if only the required parameters have this option.
Mutually exclusive with I(domain_search).
Unless it's a specific value, leave the default out and put it in the description like you have done.
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
I think we need to expand a bit on the description here. From the outset it seems like this is a dict but the examples show it is a list of dicts. Can you expand on what `linux_profile` is, whether it is a list of options or just a dict of options. The other point is that this is not `required: true` as it isn't needed when state == absent. The same applies for `agent_pool_profiles` and `service_principal`.
needs sample value
```suggestion description: Returns a dictionary for every extension OID ```
If `Migrations()` doesn't have unwanted side-effects (like changing something), you should add `if module.check_mode:` after this. You could for example do it as follows: ```.py if module.check_mode: has_migrations, skip_reason = True, None else: has_migrations, skip_reason = migrations.has_migs(module.params['local_only']) ``` Then continue as before with `if not has_migrations: ...`. (I'm assuming that `True, None` is the more common return value which is to be expected.)
Don't you need `migrations` (from three lines below) here? Otherwise you cannot use that object.
I don't know whether you changed it when you wrote this, but now it's correct ;-)
I don't think you need to return this fixed string on success. Just not returning anything should be fine.
```suggestion msg="A required Python library was not found. This module" + ``` That's more precise :) Also, you can assume that the `time` and `re` modules are installed; if not, a lot of other modules will also break and the user has a really broken Python installation, which should happen so seldomly that an extra error message for that should be unnecessary.
The `module` parameter is unused. ```suggestion def get_pid(name): ```
Use the following try/except, which is fairly standard for Ansible modules: ```python try: import psutil HAS_PSUTIL = True except ImportError: HAS_PSUTIL = False ``` This will also fix the test errors, as the existing code sets `HAS_PSUTIL` to `True` and then `False` when the import succeeds, but leaves it undefined when the import fails.
The cast to `int` shouldn't be needed, as `p.info['pid']` should already be an int. ```suggestion return [p.info['pid'] for p in psutil.process_iter(attrs=['pid', 'name']) if name == p.info['name']] ```
The `sys` import is unused. ```suggestion ```
Since the module makes no changes, it's safe to claim support for check mode: ```suggestion supports_check_mode=True, ) ```
Oh.. I missed the part about "more than two lines", so please post example output, so we could take a closer look at the issue together :)
This logic tried to enforce a minimum version requirement, which the new code does not. Since it doesn't sound like you have added compatibility with older versions (or have any reason to), why not do something like: ``` min_version = '2.4' if loose_srv_version < LooseVersion(min_version): module.fail_json(msg='MongoDB {0] found, the minimum version supported by this module is {1}'.format(srv_version, min_version)) ```
```suggestion msg = ' (Note: you must use pymongo >= {0} with MongoDB {1})'.format(loose_srv_requirement, loose_srv_version) ```
Please note that in Python we don't use brackets unless really needed.
Maybe add `default: present` here.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
host_storage.type == otypes.StorageType.FCP
Can you use here: ```python host_id = get_id_by_name(hosts_service, host_name) ``` you won't have to check if host exists and it raises the exception for you. And you are insterested in host id only anyway.
Same for VMs.
here you need just a 'steps' not whole module as well.
s/does not do anything/has no effect/
s/./ to avoid infinite hangs waiting for input./
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
oy, thanks Github
s/run the/run in the/
`changed=True` would be better.
You need to check the requirements (PyYAML and GlusterFS > 3.2) there.
`force` parameter: use boolean type
`result['changed']` must be set to `False` before the loop, then result from previous iteration must not be lost, use something like `result['changed'] |= False`
Note, it's inefficient to do this inside of the loop. Better to call get_bin_path once outside of the loop and save the path to a variable for use inside.
Long method names like this put the style checkers in a bind. Here's what I'd recommend: ``` python instance_profile_result = iam.create_instance_profile(name, path=path) \ .create_instance_profile_response.create_instance_profile_result.instance_profile ``` I hate to break on the dot but in cases like these, I think it's the best of several bad options.
@s-hertel FYI I've reworked the test suite in #62955 to make sure we test the current expected behaviour and test a few other things more thoroughly.
Only do this is module.params.get('managed_policy') is not None
Please import only what you need, rather than `*`.
I thought this initially too, looks like @sbj-ss is relying on the `if e.response['Error']['Code'] == 'NoSuchEntity'` for that use-case
Use whatever fixture names make sense. Personally I'd probably name the fixture `XenAPI` since that's the import it is replacing. Then there's no need to assign `XenAPI = fake_xenapi`. Setting `autouse=True` only loads the fixture for the test automatically. If you want access to that fixture as a local, it still needs to be a function parameter. The benefit to autouse is that it guarantees the import will be mocked, even if the test doesn't require a reference to the fixture. However, there's nothing wrong with specifying an autouse fixture as a function parameter. Doing so simply makes the auto-instantiated fixture available as a local within the test function. To guarantee correct fixture order, declare that the `fake_xenapi` fixture is used by the fixture providing `ansible.module_utils.xenserver`. Modifying `sys.modules`, or making other changes to global state, outside of a test fixture or function will apply those change to all unit tests (everything under `test/units/`) when pytest collects the tests before they are executed. Since we run unit tests with the pytest `--boxed` option, each test is run in a separate Python process after the initial collection is performed. This means that any global state changes made in-process by a test function are discarded at the end of that test function, but all changes made during collection are shared. Imports handled during collection will result in changes to `sys.modules` that will be shared across all tests. This is fine for regular imports. However, the mocked import for `XenAPI` is specific to the tests in `test/units/module_utils/xenserver/`, so it should be restricted to those tests. If another test, such as one for a xenserver module were to also mock `XenAPI` they would conflict.
You shouldn't need to assign `XenAPI = fake_xenapi`. What mocker.patch calls are you trying to make that require that? To have access to `ansible.module_utils.xenserver` in tests without importing it in each test function, you could wrap it in a fixture.
You could even rename the fixture to something other than `fake_xenapi` if desired.
This needs to be in a fixture so it doesn't affect all unit tests. To avoid the need to reference the fixture on each test you may want to use `@pytest.fixture(autouse=True)` on the fixture. Perhaps something like this: ```suggestion @pytest.fixture(autouse=True) def fake_xenapi(): xen_api = importlib.import_module('units.module_utils.xenserver.FakeXenAPI') sys.modules['XenAPI'] = xen_api return xen_api ```
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
I'll fix the "all files" bit. The old sentence had more `from`s than I thought were necessary - "from a YAML/JSON files . . from within a file or from a directory". The new sentence is cleaner. But if it's not as clear, let's find a different way to say it.
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
Ah. lambda is prettier though :). maybe we can run pep8 with ignore lambda error.
Missing `=dict` on this and the next few lines
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
Please add `mutually_exclusive = [['name', 'interface_type']]` in aggregate spec dict. This ensure the mutual exclusion is applied for each item in aggreaget list
In Python, we avoid adding unnecessary brackets.
You can just `return` without `else`.
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
You'll also note I updated the else statement to correctly reflect the vars used later. eg. cert_chain not chain.
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
most of these line continuations aren't necessary - should probably run flake8 over this.
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
(In general, I don't think modules should have such options.)
(Same for the related options.)
This should really be: ``` - Set custom DNS search domains. (Use I(dns_search) with C('') if you don't wish to set the search domain.) ```
A general remark: you should always use complete sentences. So this should end with a period.
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
Should be a parameter of the task itself and not the module
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
We don't support Server 2008 with this module so this line isn't needed.
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
```suggestion returned: success and I(ev_eligible) is C(true) and I(domain_status) is C(APPROVED), C(RE_VERIFICATION) or C(EXPIRING). ```
```suggestion sample: true ```
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
Would be better if you write it as( it will auto fail if host is not found): ```python hosts_service = connection.system_service().hosts_service() host_id = get_id_by_name(hosts_service, host) disks_service.disk_service(disk.id).refresh_lun(otypes.Host(id=host_id)) ``` Don't forget to add `from ansible.module_utils.ovirt import get_id_by_name`
I think only `self.lun` is enough here. BTY, `self.lun == 0` may fail when the `lun` is `None`.
Yes, the `lun` could be 0, but I think there is no necessary to check it here. Maybe you want to check the range of the input? `isinstance` can check if the input `lun` is a number.
Please fix the trailing space and it's ok to be merged. Thanks!
Maybe we misunderstood. We thought to_text would remove the need to import codecs and use hexlify. We now believed you meant to use to_text rather than str.encode and decode. Trying this.
Would be great to give a brief spiel about the 2, I know `windows` doesn't support explicit credentials so maybe say `password` is not required for that. I would also put this in a new list entry and start with a capital and end with a full stop.
Each option entry should be a full sentence, i.e. it starts with a capital and ends with a full stop.
Change to source and remove the alias
This supports more than just URLs, I would add more points talking about what it actually supports.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
it's not explicitly necessary but I decided to create a dictionary that I could index with a meaningful key to keep track of the commands that we are building for `http, http_port, https, https_port and sandbox` settings. This way I can just overwrite the dictionary entry as more information is discovered and then build the final list called `send_commands`.
Just for you to know, [max line length is 160](https://github.com/ansible/ansible/blob/devel/test/runner/lib/sanity/pep8.py#L59).
The `u` prefix should not be needed.
```suggestion 'Using the "list" state has been deprecated. Please use the ec2_tag_info module instead', version='2.14') ```
This should probably be in the same if statement as `if self.state == 'present'`, this way you know the disk exists and so the initial present check is not required and you never really want to run this additional operation if `state: absent`.
this still has the #73643 issue, we might want to store the 'raw' notification instead and reprocess handler matching so we always get the 'latest' version of that handler
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
@pierremahot we'll need a test for this
~~isn't this a noop?~~ ~~seems like you jsut want, `if task._parent != new_block`: and remove up to and including the `else:`~~ nvmd
We don't need tags in this function, I think.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
[`to_text`](https://github.com/ansible/ansible/blob/9c1033422b53b7308f2ec7229222c8e7740f4566/lib/ansible/module_utils/_text.py#L169) is wrapper function.
You have trailing whitespace over this line. Either remove trailing whitespaces or remove this line.
Note: I believe that both python2 and python3's json.loads() can handle resp_data as unicode strings. So you should be able to do this like this: ``` python from ansible.module_utils._text import to_text [...] resp_data = resp.read() resp_data = to_text(resp_data, errors='surrogate_or_strict') resp_json = json.loads(resp_data) ``` to_text is a nice helper because it allows much better control over tracebacks and won't touch the value if resp_data is already a text string (whereas resp_data.decode could traceback if resp_data is already a text string for some strange reason)
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
This can be converted to return True. No need of new variable retry_request
You should be able to catch `TypeError` here rather than `Exception`. Though I suppose a custom callable as a type checker could raise something other than `TypeError`.
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
lets' decide myAsg or myApplicationSecurityGroup
security group -> security groups
that should be example of module usage, not return value
should be consistent with sample name and resource_group
maybe also should be described
Now you need to update `self.public_key` another time.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
`pexpect` could be used to provide the password to the subprocess on stdin.
if `self.path` doesn't exist, `self.path + ".pub"` will never get removed.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
The goal is to keep compatibility, and default to "no" would be safe in this case, (except it make sense to change the behaviour). Could you explain why it would be good to change the default to "yes"? If yes is the default, I would suggest to make an entry in the porting guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.10.rst.
please update to "2.10"
Remove spaces at the beginning and the end of the square brackets.
Should we add here that the win_copy module is not a very efficient transfer mechanism and if possible using HTTP downloading using *win_get_url* or *win_uri* is preferred.
I see did some changes of single quotes to double quotes but you left all double quotes are the were. You should change all other cases than named above to single quotes (e.g. keys in the dict vars - `my_dict['my_key']`).
I prefer `if not module.check_mode and change_string:`.
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
Use `elif` instead of `if`.
This statement seems useless.
+1 to that I think.
vault is also used to encrypt private keys and certs, so you cannot always assume its valid yaml
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
@pierremahot we'll need a test for this
Actually, you can replace this dancing around if+for+append+extend (lines 245->250) with a simple list comprehension, which would look better readable: ```python obj['interfaces'] = [i.replace('Gi', 'GigabitEthernet') for i in interfaces] ``` It will produce the very same result.
You can completely drop this conditional, since iterating over empty iterable produces the same effect.
Please note that in Python we don't use brackets unless really needed.
This should say "- Whether the image is allowed to grow"
This should say "-Whether the image is allowed to shrink"
Probably best to use the YAML syntax for examples here. You no longer need to use `description:` and `code`. You can just add your tasks as in a normal playbook with `name:` and your module action.
It should state: ```yaml description: - If the image should be present or absent default: present ```
`notes:` is wrongly indented and looks like an option, rather than it's own list of notes. And that is why CI fails.
Rename DO to DigitalOcean to avoid acronyms
Rename DO to DigitalOcean to avoid acronyms
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
Looks like `monitoring:` has been added.
@siwyd @alikins Such timing -- I was about to submit a PR against module_utils/facts/virtual/linux.py to check {{product_name}} to detect a DO droplet when I came across this PR. $ cat /sys/devices/virtual/dmi/id/product_name Droplet
Would like confirmation the droplets are KVM guests.
it might be better to use the module method to find binaries, in case someone moves this to another path
before continuing here, check that fields is actually populated as a list, or try/except the following code
use an else here and you can have only 1 return at the end (even that is not needed)
```suggestion result['stderr'] += to_native(stderr_data) ```
```suggestion result['command'].append(to_native(command)) ```
No longer using a temporary file. This issue is resolved
If we don't go with a default regex value, this can just be `None`. ```suggestion filter_re = self._get_value_from_facts('BOOT_TIME_FILTER_REGEX', distribution, None) ```
It would be awesome if buildah supported copying from a container.
I'm not sure about these defaults - a delay of 3 and backoff of 2 for 10 tries would mean that, to fail, this retry decorator would wait for 3069 seconds (`3 + 3*2 + 3*2*2 ....`, or `sum([3 * 2**i for i in range(10)])`) or about 50 minutes. That seems like a really long time, especially since most modules make several calls. A better default might be 4 tries, for a total default wait time of 45 seconds and having a max of, say, a minute between tries. That way, if someone wanted 10 tries it would only take about 7.5 minutes to fail.
not exactly what i was asking, but good enough
This is unnecessary, by default AnsibleAWSModule automatically merges the spec you pass it with ec2_argument_spec().
This is unnecessary, AnsibleAWSModule handles it.
This whole connection block can be replaced with `conn = module.client('ssm')`
You'll need to handle pagination if there are a lot of APIs. Should probably handle rate limiting here too https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#api-throttling-rate-limiting-and-pagination
boto3_conn, ec2_argument_spec, get_aws_connection_info are not needed with AnsibleAWSModule
No need to check `region` before using `boto3_conn` - `boto3_conn` will handle a `NoRegionError` for you.
This check is no longer required with AnsibleAWSModule
You can actually skip all the expanduesr business by using `type='path'` instead, then Ansible will parse out a fully qualified path automatically.
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
Since this accepts a list of ports, change the type to `list`. This requires it to be transformed a bit, but would be a better UI. A `list` type parameter will accept a comma separated string as well as single items, which field validation will return as a string.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
`If an empty list C([]) is specified`
`If an empty list C([]) is specified`
databsae -> database
This should become: ```yaml type: bool default: 'yes' ```
Don't add `required: false`. It is implicit.
Line is too long.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
This can be as `elif`.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
This could be `elif`.
Ok, so I may have given you the wrong advice before. I was under the impression that these modules were talking to a backend, but (at least) this module seems to run on the remote target (over SSH ?). So delegate_to: localhost` will not work correctly.
If it's not required, you don't have to state `required: false` That's implicit.
Quotes are not needed here. We tend to quote in YAML only when it is necessary (for true, false, null or colon/spac sequence).
Probably worth it to use `username`, `password`, `hostname`, etc in the examples instead of `config`
As mentioned on IRC, please remove this (from here and other examples) and update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 to be `password=dict(type='str', no_log=True),`
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
and convert filename to bytes again.
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
```suggestion - The plugin returns following groups of swarm nodes: I(all) - all hosts; I(workers) - all worker nodes; ```
```suggestion I(managers) - all manager nodes; I(leader) - the swarm leader node; ```
Yes. There are usually many of them, if you don't have a one- or two-node cluster ;-)
LOL ok :D It was apparently a bit late... ;)
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
There is no need to add quotes here. Please remove them from all modules.
Use URL instead of Url. ```suggestion - The URL of the Gitlab server, with protocol (i.e. http or https). ```
This needs to be C(validate_certs) which is the standardized parameter name.
Please don't add any aliases except for backward compatibility. We don't want to offer more choice than necessary.
Quote are not required here ```suggestion default: yes ```
Same here: use `AnsibleModule.digest_from_file()`.
Instead of the checks inside of the removes and creates conditions above, conditionalize running this command on check_mode like this: ``` python startd = datetime.datetime.now() if not module.check_mode: rc, out, err = module.run_command(args, executable=executable, use_unsafe_shell=shell, encoding=None, data=stdin) elif removes or creates: rc = 0 stdout = stderr = b'Command would have run if not in check mode' else: module.exit_json(msg="skipped, running in check mode", skipped=True) ```
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
The `u` prefix should not be needed.
Why not this instead? ```suggestion if 'no such image' in ex.stderr: ``` Or use `ex.stdout` if the error is on stdout. The same applies to the other changes as well.
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
Add `cmd_verbosity` to the docstring.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
align is always lowercase.
This should be: ```python if state == 'present': ```
It's better to have a single definition of this list and use it both for parameters and here.
Some wrapper modules are very light on this, and escalate the stderr output of the command to the user. I guess it depends on the complexity of the tooling and the possible impact of incorrect input. Is there a big risk of data-loss or data-corruption, then you may want to be more safe. Also if there's a big chance that valid options change more often, you may not want to restrict your module. But this is all mostly up to the maintainer. There's also a real concern related to supporting older/newer versions of the same tool too.
If it is not required, you don't have to add `'required: False`.
```suggestion - 'If C(state) is set to C(powered-on) or C(poweredon) and virtual machine exists with powerstate other than powered on, ```
```suggestion - 'If C(state) is set to C(powered-off) or C(poweredoff) and virtual machine exists with powerstate other than powered off, ```
```suggestion - This parameter is required, if C(state) is set to C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
```suggestion - 'If C(state) is set to one of the following C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
I would keep all previous states as well in-order to maintain backward compatibility.
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
<nod> I see what you mean about checking the length for the secret leaking information about the secret that the attacker would not otherwise know. However, checking the length for the plaintext doesn't seem to suffer from that same problem. The attacker already has an idea of how long the plaintext is because the length of the ciphertext will reflect that. So checking the length of the plaintext and falling back to os.urandom() if the plaintext is too short seems like it can prevent some problems without revealing new information? (Hmm... it would reveal that the plaintext is less than a precise value whereas looking at the length of the ciphertext would be more vague.... Would that be important or not?) The attacker can learn a lot about what is in a vault file from external sources... for instance, since they're yaml files, they likely have a rough outline of: ``` --- var: value ``` an attacker might also find the precise name to use for "var" by looking at playbooks to see which variable names exist that are not defined outside of a playbook. So then the only thing about the plaintext that they'd be lacking would be the actual value....
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
is there a reason why you have a native str, I would have assumed it was a byte str beforehand for a reason. I know the tarfile is very particular about the type of string being used.
This should probably mention both slash and no-slash paths...
not for this PR, but we might want a 'configurable ignore facility' ala gitignore in the future
I'd do this unconditionally.
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
These should not be using the exception key like this. exception is only for the traceback. So this line should really look like this: ``` python import traceback from ansible.module_utils._text import to_native [...] self.module.fail_json(msg='Error getting user %s: %s' % (self.name, to_native(e)), exception=traceback.format_exc(e)) ```
Additional error information would be help for debugging.
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
see previous discussion on renaming idempotently
Use `wait`, it's standard for similar modules. Requires a configurable `wait_timeout`. I'm not sure whether it's worse to have a default `wait` with a timeout in excess of 20 minutes so that it typically succeeds, or just no wait so that people at least knowingly set a long wait time. I'd think default to waiting off, but default to 30 minutes wait_timeout if people do set `wait`
purge_tags doesn't need to remove all tags - you can use compare_aws_tags() (in module_utils/ec2) and then call untag_resource() with the list of tag_keys that are returned.
You don't need line breaks for lines less than 160 characters. Noticing a lot of these.
Most other modules default to yes so I would do the same here
I think you can just say '...input as a list of key value pairs' since these are not module options. But can tags just be a dict? You could then use ansible_dict_to_boto3_tag_list(). It feels like some functionality is being duplicated.
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
It might be also interesting to see if it would fail though.
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
Missing space between `vrf,` and `the`.
vtf has `required=True`, so they Playbook writer will always have to specify a vrf, so I'm not sure what this note means.
Not sure if this line is needed as `vrf` has `required: true`
`VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_.)`
`Range of VLANs such as C(2-10) or C(2,5,10-15), etc.`
```suggestion except (OSError, IOError): ``` Since you are not using `e`.
I don't see the point ;-)
Move import statements after Line 81 or after RETURN
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
Use to_native instead of str
should be consistent with sample name and resource_group
`cloud_environment` and `auth_source` should be derived from `AzureRMModuleBase` and not needed on the module arg spec.
`ansible_facts` are only used for specific host facts and not facts modules in general. The results should be returned under something like `azure_rm_aks` or something similar to that instead.
We may need at least the following features here: - [ ] `list_keys()`: Show the SAS policies of the Event Hub, so that we can have connection string - [ ] `list_consumer_group()` We usually add these with a flag to avoid network overhead. refer: https://github.com/ansible/ansible/blob/1dc8436ed91ef25748dd270c289c05f893cca6e3/lib/ansible/modules/cloud/azure/azure_rm_servicebus_facts.py#L55-L60
See my point in the non facts module around snake_case.
> Are you suggesting to just duplicate the code from build_summary() within each for loop? Nope. It just seems like this nested function could be a method or a standalone function. > I don't see how having the nested function within _create_role_list() makes testing harder, In order to unit test `build_summary()` you would need an instance of `RoleMixin`, then call `_create_role_list()`, and then write the test in such as way as to only run `build_summary()`. It just makes it harder to get to _just_ `build_summary()` for testing, which makes it harder to throw tons of varying inputs at `build_summary()`.
Does this need to be a nested function? The overall cyclomatic complexity of this method is 8. I bet it could be reduced by removing this nested function. It would also make this method (and the function) easier to test.
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
maybe just ```suggestion part_boundary, b"--", ```
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
It would be neat if `randomize_list` also accepted a similar `seed` arg for repeatable (pseudo-random) ordering.
Probably should also check and fail for `self._connection.transport == 'local'` - no need to go nutty trying to figure out if they're rebooting the controller via a more circuitous route, but at least cover the easy one.
You probably should just exit here with `changed=False`
having `main()` call `run_module()` feels a bit redundant, I see no reason to not put all of the main logic in `main` (and splitting actions into functions where it makes sense)
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
Since this accepts a list of ports, change the type to `list`. This requires it to be transformed a bit, but would be a better UI. A `list` type parameter will accept a comma separated string as well as single items, which field validation will return as a string.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
Same duplication of functionality as with `post_request` function.
This method definition shares most of its functionality with `get_request` method, which indicates that the common functionality (common parameters, error handling, etc.) should be extracted into private method.
It's fine if it's a placeholder for future capabilities.
Resource path should not be manipulated by hand, since we should only use paths that Redfish API returns (with one exception that has been actually removed from the latest version of the Redfish standard).
As before, this will not catch non-200 statues of response.
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
i'm not sure that makes sense, if handler was not included, it would not be available for notification already. Since it should already add the conditionals inherited (only on import or include + apply) you should not need to check any other conditions.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
Yes sorry, there is a misunderstanding; the region `choices` have to be removed (but not the `required` in my opinion). Same for the other products. Moreover, I think that we can keep the constants for region/zone (cf. my example of `module_utils/scaleway.py` above) and adopt it in the whole project.
All Scaleway products are not available in all regions/zones. I think it could be interesting to set the choices explicitly to avoid problems if we add a new region in `SCALEWAY_REGIONS` in which the `lb` product is not available. Here is a proposal inspired by [what we have implemented in the new Go SDK](https://github.com/scaleway/scaleway-sdk-go/blob/master/utils/locality.go): ```py # ansible/lib/ansible/module_utils/scaleway.py SCALEWAY_REGION_FR_PAR = "fr-par" SCALEWAY_REGION_NL_AMS = "nl-ams" SCALEWAY_ALL_REGIONS = [ SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS, ] SCALEWAY_ZONE_FR_PAR_1 = "fr-par-1" SCALEWAY_ZONE_FR_PAR_2 = "fr-par-2" SCALEWAY_ZONE_NL_AMS_1 = "nl-ams-1" SCALEWAY_ALL_ZONES = [ SCALEWAY_ZONE_FR_PAR_1, SCALEWAY_ZONE_FR_PAR_2, SCALEWAY_ZONE_NL_AMS_1, ] ``` ```py # lib/ansible/modules/cloud/scaleway/scaleway_lb_facts.py def main(): argument_spec = scaleway_argument_spec() argument_spec.update(dict( region=dict(required=True, choices=[SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS]), )) # ... ```
The module has required options, but you don't provide any in this example.
Yes because this module use this specific API
1. I am not sure why `commercial_type` is a required parameter since Scaleway API doesn't require `arch` parameter. 2. Why don't use directly `arch` module parameter instead of `commercial_type` parameter ? `arch` seems easiest to maintain (i guess a new commercial type is more likely to be added than a new arch).
Try this: ```python attrs[name] = list(map(to_bytes, value)) ```
You can add it into this PR.
The same should be applied in the [`ldap_attr`](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/net_tools/ldap/ldap_attr.py#L176) module.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
Windows 8.1 / Windows 2012 (NT 6.2), no need to set the PS version as that will inevitably confuse people on older OS' who have upgraded to PS 4 or higher.
I would have thought the only restriction would be Windows 8.1 / Windows Server 2012 (NT 6.2), it works when I try it locally. On a side note technically this should also work on Windows 8 but we don't support that OS so it should be kept at 8.1.
If it's not required, you can leave out `required: false`.
A lot of the entries here should be in the description of each relevant option. This is for a high level overview of what the module does. The `notes` entry can also be used for info about the module if it doesn't fit in a option.
Until the latter is merged I would avoid referencing it in the module docs.
`state` argument is probably missing for this module.
no worries, let's make it for 2.10, but I think that debug option would be nice ;)
it might be worth adding an option to configure debugging, unless it's explicitly needed by the module.
just an style thing, any reason for only having 3 elements per line on the list? I'm fine if you want to make it 80 line compliant but let's make it consistent for all module ;)
heh, indeed interesting, just checked it myself
lacking parameter validation, user should be notified if the minimal requirements for lookup to work are not met
Adding the exception string to the error would help the user narrow down what the issue is.
It likely makes sense to add the remaining psycopg2 parameters including host and port.
I think `if props is not None` is more conventional :smile:
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
```suggestion - Create or delete project variable. ```
Above you said "They are present before the module ran". In that case, this list should not be empty if `purge` is `true`, but contain the list of variables which were there before the module ran.
If `purge` is `true`, it will be empty according to the code you pasted below.
```suggestion - name: Delete one variable ``` For consistency (compare the other example)
Not needed. The module is new in version 2.4.
This should be removed an replaced with: ```yaml default: high performance ```
Should be 2.4 (as we don't backport new modules to older releases).
Lowercase 'yes' please :-)
Don't add `required: false`. It is implicit.
@marcin-sucharski check against current development, I've merged stringification at run_command so you might not need to do this anymore.
How about adding `to_text(value)` in next loop where we are iterating on options ? ```python for key, value in options.items(): if value is not None: if key == '802-3-ethernet.mtu' and conn_type != 'ethernet': continue cmd.extend([key, to_text(value)]) ```
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
Sure, a separate PR sounds good.
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
You're importing ClientError itself as well as botocore, but still using `except (botocore.exceptions.ClientError, ...` instead of `except (ClientError, ...`. Could remove this import. Or add , BotoCoreError to this too and save some line length in places below.
You need a paginator here still.
You should handle BotoCoreError here instead of NoCredentialsError: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws Same applies for all of the following exception handling. BotoCoreError and ClientError together should suffice.
This structure seems wrong to me. I'd rather have all the properties at the same top level. One way to do that without having to change your implementation too much would be to ``` module.exit_json(**vault, tags=self.list.tags(), changed=changed) ```
You can, just put it last. ``` (python2.7) shertel-OSX:ansible shertel$ git diff diff --git a/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py b/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py index 9eb27ef79e..2db590d6d1 100644 --- a/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py +++ b/lib/ansible/modules/cloud/amazon/aws_glacier_vault.py @@ -142,7 +142,7 @@ class GlacierVaultManager(object): vault = self.get_vault(self.name) # Vault exists, no change to do - self.module.exit_json(vault=camel_dict_to_snake_dict(vault), tags=self.list_tags(), changed=changed) + self.module.exit_json(tags=self.list_tags(), changed=changed, **camel_dict_to_snake_dict(vault)) ```
One super duper nitpick: can you swap the order on this conditional so the current/new lineup with the above? That way I think it's easier to tell this is an inversion of current/new in the previous statement.
This example isn't a valid IAM policy, because statement IDs must be unique per-policy http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Sid
Oh I see :)
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
`policy` should be added to `argument_spec` to be usable.
You don't need this conditional, since Ansible enforces that these are the only choices.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
ipt_load_stderr doesnt appear to be defined anywhere.
I'd recommend a more explicit import, ie ``` python from ansible.module_utils.basic import AnsibleModule' ``` And using regular imports for 're', 'shlex', 'os', 'json', 'tempfile'
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
```suggestion config_mapping['restart_retries'] = restart_policy_config_value.get('MaximumRetryCount') ``` and remove the line above. (Or even rename `restart_policy_config_value` to `restart_policy`.)
Please also move this into the `if` below which updates `config_mapping`.
Please remove this. It doesn't hurt to set `restart_policy` to the correct value right away.
Here you need to reuse it.
Same as above. Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
Maybe? ```suggestion self.facts[host].update(value.get('ansible_facts', {})) ```
I don't like that in this case. It's a defaultdict which means that if no facts are collected in this run at all, the host will still end up in `self.facts`. The result is that it will `POST` an empty hash to Foreman which removes all facts for that host. This version avoids that by first checking it.
Same here: move url outside of the loop: ```suggestion ```
You reassign this var on each loop iteration, please move it outside. ```suggestion ```
How about: ```suggestion from ansible.module_utils.parsing.convert_bool import boolean as to_bool try: verify = to_bool(option) except TypeError: # it wasn't a boolean value verify = option # Set to a CA bundle: finally: if verify is False: # is only set to bool if try block succeeds requests.packages.urllib3.disable_warnings() self._display.warning( u"SSL verification of %s disabled" % self.foreman_url, ) return verify ```
This will fail if `self.accounts_uri` is not initialized.
Useless loop that can be merged with the next one.
Not catching non-200 responses.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Not catching non-200 responses.
```suggestion if self.state == "present": ```
Remove parans for every if ```suggestion if find_vm_by_name(self.content, self.name, folder=folder_obj): ```
if self.state == "absent" should be explicitly checked before unregistering the VM, just to be safe.
```suggestion if not dcpath.endswith("/"): ```
```suggestion changed = False ```
No need to quote, we prefer it as a list. ```yaml author: - Daniel SÃ¡nches FÃ¡bregas (@Daniel-Sanchez-Fabregas) ```
Please remove this. If it's not required you don't need to state it, but there's also a default value, so useless :-)
Add or remove are not declarative, but imperative. So I would rather state: Specified whether the computer should be present or absent in Active Directory. Beware that the current description is talking about access rules, which is weird because we are managing computers in AD.
This should become: ```yaml type: bool default: 'yes' ```
Also, it would be better of the description is split up over multiple items. A long blob doesn't make it easier to read. Usually the first item is the "meaning", and subsequent items detail what happens in different cases, explain options, specify the format or add one or more notes.
I would remove the previous and the current line. If you write `persist_only`, you want to make sure that the variable is set in he `mysqld_auto` config. If it is not set there (but it is set in the running instance), you still want to execute the query.
For `mode == 'persist'`, you have to both check the current value *and* the value in the `mysqld_auto` config.
Why not ```suggestion if mode in ('global', 'persist'): ``` ? :)
How about moving this in the main `if:` branch above? Then there's no need to do funny tricks for `mysqlvar_val` in the `elif:` branch.
I wouldn't emit this warning. After all, the warning is just saying "the module is doing its job, nothing out of the ordinary".
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
```suggestion type: str required: True ```
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
```suggestion type: str required: True ```
```suggestion type: str required: True ```
I'll fix the "all files" bit. The old sentence had more `from`s than I thought were necessary - "from a YAML/JSON files . . from within a file or from a directory". The new sentence is cleaner. But if it's not as clear, let's find a different way to say it.
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
Missing full stop.
You can remove the `required: false` lines, it's implicit
You can removed all the `required: false` it's implicit
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
Missing full stop.
Your PR #52278 needs more `shipit` commands to be merged
```suggestion res = re.match("""GRANT (.+) ON (.+) TO (['`"]).*\\3@(['`"]).*\\4( IDENTIFIED BY PASSWORD (['`"]).+\\6)? ?(.*)""", grant[0]) ```
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
```suggestion - When the webhook does not exists in this GitLab project, it will be created. ```
```suggestion - When the webhook does exists and C(state=absent), the webhook will be deleted. ```
GitLab prefer to be called `GitLab` (with a capital `L`)
I'd reword this as `Verify SSL certificate when HTTPS is used`
This isn't valid yaml ` : `
enabled/disabled for this as we are talking about a service (email)
```suggestion - Required for C(type=DS) when C(state=present). ```
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
Please remove this property since ansible already exposes `changed` so users can see whether a resource was altered during a task.
I think a brief sentence is worthy. Nothing is worse than trying something only to figure out the target API on the server isn't compatible. We should try to remember to ask this question of all new modules and substantial changes.
You can remove `type='str'` as that's the default type.
I would rather remove this exception here and put it around the `ldap.initialize()` and `self.connection.passwd_s()` above with a more specific error message.
I think it should look like this: ``` python from ansible.module_utils._text import to_native [...] def enable_ds(module, array): """Enable Directory Service""" try: array.enable_directory_service() changed = True except Exception as e: module.fail_json(msg='Enable Directory Service failed: Check configuration: %s' % to_native(e)) module.exit_json(changed=changed) ``` One thing I'm not sure about is how we tell if array.enable_directory_service() made a change or not. Our users generally define Ansible's idempotence as: * they describe the state they want in a playbook task * the module makes the state match what is in the playbook * the module returns changed=True if something had to be changed to achieve the desired state or changed=False if the state was already as desired. This code probably does the first two but it's not doing the last one. I'm not sure how to fix it because I don't know what array.enable_directory_service() does. If it returns a specifc exception if the directory_service was already enabled, then we catch that specific exception and set changed=True for that. If it returns a status code telling whether it had to make a change or not, then we can use that to set changed. If neither of those, we would have to query the current state of the toggle first. If the toggle is already enabled, then set changed=False and call module.exit_json(). If the toggle is not yet enabled, call array.enable_directory_service(), set changed=True, and then call module.exit_json(). (Also note, these notes on changes also apply to the other verbs you have in this module: disable_ds, delete_ds, and create_ds)
I think things like this will traceback in check-mode because changed hasn't been set to a default value (Should default to True). Also, for this particular module, check_mode doesn't seem to be doing anything so you probably just want to say supports_check_mode=False when creating the AnsibleModule.
This is dangerous. Three could be several reasons why opening the container fails. These do not mean that the key does not yet exist.
There's another `try/except` missing here.
`run_luks_remove()` does raise `ValueError`.
Here's another line which can raise `ValueError` (call to `run_luks_remove()`).
You also need to store this into a variable, otherwise you can't use the resulting path.
same here, we really dont want to test the particular setting, just that both the default (dynamic template) and the nii entry are correctly parsed.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
Initialized must go first.
in all cases, I would default `group_contents.get('hosts', [])`
I've been thinking the same thing. Ideally it would be great if the validator raised exceptions, instead of passing back formatted errors, but I get the reasons why it is like it is currently.
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
May be true but this is general speaking. What behavior specific changes would you expect? Can we possibly test against those? I don't think it is meaningful to duplicate code in n modules when using OOP style.
In general argument_specs should be returned to the caller rather than subclassing AnsibleModule just to add it. AnsibleModule's behaviour could change in the future and subclassing makes it more likely that things would break than if you are simply passing an arg_spec to the module which it then uses to instantiate an AnsibleModule.
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` Here this var needs to stay as you had it originally - ansible prefers snake cased but boto typically needs camelcase. `instance_parameters` will be passed into the boto connection so needs to match what the API expects, both here and later when you access the returned parameters. https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationSubnetGroup.html#API_CreateReplicationSubnetGroup_RequestSyntax
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` and here as well
You should always have `type='str'` (or whatever type you have) in all of argument spec.
To be consistent with other modules, can you please change this to: ``` validate_certs: description: - If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. required: false default: 'yes' ``` And update code & argspec as needed
Please use: ``` type: bool default: 'no' ```
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
You can remove this line
Each example task should be a continuous block, please do not have blank lines between sections
This should be: ```python if state == 'present': ```
Should not be needed, it can only be "present" or "absent"
align is always lowercase.
If it is not required, you don't have to add `'required: False`.
It's better to have a single definition of this list and use it both for parameters and here.
Ah. lambda is prettier though :). maybe we can run pep8 with ignore lambda error.
Missing `=dict` on this and the next few lines
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
Should this handle for space within interface name? Something similar to https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/eos/eos_vrf.py#L224 to avid idempotency related issues.
Reading the code, this appears to expect a hostname and not a URI.
Inconsistent number of blank lines between blocks.
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
```suggestion description: State to ensure. ```
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
```suggestion variables = {} ```
Sure, a separate PR sounds good.
i don't think we want roles in roles
no, if the variable is set but empty, you should empty out the options
this got named use_backend
The module should not wait for `force` here. All `openssl_*` modules also don't do that, including `openssl_privatekey`.
I would simply replace this `if` block by `return False`. If the key is broken, it should simply be regenerated.
Now you need to update `self.public_key` another time.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
`pexpect` could be used to provide the password to the subprocess on stdin.
Please remove the "required: false", you only have to add `required: true` if it is required.
Please remove the "required: false", you only have to add `required: true` if it is required.
Don't quote strings when that's not necessary, and add spaces in Jinja variables for readability. ```suggestion msg: TCP port {{ item.port }} by pid {{ item.pid }} violates the whitelist ```
Add a few more examples of just listing the ports: ```suggestion when: tcp_listen_violations - name: List TCP ports debug: var: ansible_facts.tcp_listen | map(attribute='port') | sort | list - name: List UDP ports debug: var: ansible_facts.udp_listen | map(attribute='port') | sort | list - name: List all ports debug: var: (ansible_facts.tcp_listen + ansible_facts.udp_listen) | map(attribute='port') | unique | sort | list ```
```suggestion RETURN = r''' ```
```suggestion pn_admin_session_timeout: ```
```suggestion pn_admin_session_timeout: ```
```suggestion - State the action to perform. Use C(update) to modify the igmp-snooping. ```
type is missing
```suggestion - State the action to perform. Use C(update) to modify the ```
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
You can use iteritems as below ``` from ansible.module_utils.six import iteritems iteritems(parsed) ```
type='str' is a default value, not require to explicitly mention it
type='str' is a default value not required to mention in separately.
Should this handle for space within interface name? Something similar to https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/eos/eos_vrf.py#L224 to avid idempotency related issues.
```suggestion account_id=dict(type='str', fallback=(env_fallback, ['SPOTINST_ACCOUNT_ID', 'ACCOUNT']), ```
Replace line 81 to 97 - with ```yaml - name: Create an event subscription spotinst_event_subscription: account_id: token: state: present id: sis-e62dfd0f resource_id: sig-992a78db protocol: web endpoint: https://webhook.com event_type: GROUP_UPDATED event_format: { "subject" : "%s", "message" : "%s" } register: result ```
```suggestion - Type of desired protocol type: str ```
```suggestion - Parameters used for Updating or Deleting subscription. type: str ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
Please remove empty `aliases:` lines
Please remove this line
Please remove this line
Are there any disks apart from system disks? If so then this should be named `system_disk_category` and remove the aliases.
Use the following to format his as code: `C({"key":"value"})`
I'd check for `pwsh` and give a more user-friendly error message if it's not available. When I run this without `pwsh` available I get an error like: ``` ERROR: lib/ansible/modules/windows/win_ping.ps1:0:0: E321 Exception attempting to import module for argument_spec introspection, 'env: pwsh: No such file or directory ' ```
`load_fixture()` takes the module name as the first parameter now, so you can lose the `os.path.join()` above and just have `load_fixture('nxos_switchport', filename)`
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Don't assign a lambda function, use def
Set required=true in the argument_spec ```ip_address=dict(required=True)```
no, it's probably not fixable anyway
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
It might be better to use a similar regex that awx itself uses: https://github.com/ansible/awx/blob/devel/awx/main/validators.py#L51 Maybe just validate the format of the first line? ```python if re.search(r'^(?P<dashes>-{4,}) *BEGIN (?P<type>[A-Z ]+?) *(?P=dashes)', ssh_key_data): ```
I wonder if ansible itself has something for this in its `authorized_keys` module.
You're correct. I misread that this `if` statement is indented. Looks good!
Create address service object on PanOS devices This may need updating on existing modules
Capital letters & full stops please
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
`required: false` lines can be removed
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
Not needed with AnsibleAWSModule
could add HAS_BOTO3 to the imports from ansible.module_utils.ec2 instead of manually setting
Is there another option than this? If I give the parameters: ``` elb_target_group_facts: names: - validtargetgroup - notatargetgroup ``` and validtargetgroup exists and notatargetgroup doesn't, I'll get back no facts. Not sure if that's desired behavior or easily fixed if not.
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
should probably have an upper bound of < 10 just for sanity
If you're trying to make sure we don't overtax the cpu, use this: ```min(len(mtab_entries), multiprocessing.cpu_count())```
This can become a function since it no longer makes use of self.
Don't modify things inside of a function unless there's a huge performance hit. Just return the values. Also, don't pass in a meta object like mount_info... Instead be explicit that you need the mount and the device by passing just those two arguments in. Looking at this further, though, it probably makes more sense to call each of those separately as they're disjoint information and could timeout separately.
While you are here, can you please add support for - https://github.com/ansible/ansible/issues/24644 - https://github.com/ansible/ansible/issues/41494
heads up, `r` is undefined.
Also, this results in a traceback for me. I think you want to do ... ``` python if 'ipaddresses' in host and isinstance(host['ipaddresses'], list) and host['ipaddresses']: ```
Suggest changing to `if 'tags' in host:`
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
That is a limitation but there is a workaround (see #22630)
Could you please use `AnsibleAWSModule` instead? We didn't have a lot of the aws utils we do now when this was first PRd, it will save having to port it later on. https://docs.ansible.com/ansible/devel/dev_guide/platforms/aws_guidelines.html#creating-new-aws-modules
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
Missing boto3 will be automatically handled by AnsibleAWSModule, this should just be: ``` try: import botocore.exceptions except ImportError: pass ```
`aws_common_argument_spec` is currently unused, `get_aws_connection_info` and `boto3_conn` shouldn't be necessary.
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
nit-picky optimization, but if the prior step was successful then 'id' should already be in `result` Also, if the state is "absent", then you need to be sure that you don't hit this code. Either that, or it should throw an error if schema is provided and state is absent.
Try except blocks souls he as small as possible
This should be supports_check_mode=False.
Try except blocks should be as small as possible. In this case, if is only needed around the calls to modify and delete. Perhaps put the try except around the if state conditional to limit the statements that it surrounds
Not required ? Don't say so. This is implied.
This should be `type: bool` IIRC.
Not required ? Don't say so. This is implied.
If a parameter is not required, you don't have to add this. This is implied, `required:` is only needed for parameters that are required.
Do this as a list, unquoted: ```yaml author: - Richard Levenberg (@richardcs) ``` Your email can go at the top of the file for the copyright.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Parameters that are not required don't need `required: false`.
Make this a separate item in the list.
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
Note -- Looks like you have 'min' as a valid subset but in this current version of the code it's not being used to control whether this is run. Either need to make use of it or remove 'min' as an option so that it's clear that this portion of fact gathering is always run.
Better to do this transformation into a list via the setup module's argument spec rather than here.
This can be a key-value map with key as the fact name and value as the pattern to be searched for
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
I suggest to add an example of this
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
This fails when disk_size is defined as int
`if unit in disk_units:` is case sensitive already, the `unit = unit.lower()` should be done before the if statement. ```python In [24]: unit = 'Gb' â â In [25]: disk_units = dict(tb=3, gb=2, mb=1, kb=0) â â In [26]: if unit in disk_units: â ...: print 'Found' â ...: else: â ...: print 'Not Found' â ...: â Not Found ``` (done in `ipython`)
You forget to make the change.
The else: is not really necessary here since there is a return just above. But it does not change the behavior.
I would report an error here, as we did not complete the action. But this change can be delayed.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
ok, missed that!
If you are cloning from a template, there is no guest_id parameter. So we should also check the current vm's guestId setting.
this will affect it if a user is explicitly passing the default as an option (iirc we had issue, will try to find)
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
this seems like it should be shared with the main one rather than duplicated here
This is more efficient: ```suggestion key = next(iter(old[0]) ```
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This worked well in my testing. It can be made a bit more resilient in the event a package doesn't split as expected. ```suggestion raw_pkg_details = {'name', package} # or maybe # raw_pkg_details = {'name': package, 'version': '', 'release': ''} nvr = package.rsplit('-', 2) try: return { 'name': nvr[0], 'version': nvr[1], 'release': nvr[2], } except IndexError: return raw_pkg_details ```
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
trivial but you can just do: ``` python path = expanduser("~/.azure/credentials") ``` so that you only allocate a string once instead of three times. (+= creates a new string)
```suggestion verbosity = [] if display.verbosity: verbosity = ['-%s' % ('v' * display.verbosity)] ```
it can stay in this file, but i would make into a function that we can then also use in persistent, at least until we remove that. That way we avoid 'bugfixing only one path' in the future.
missed .copy() so that should not be an issue, thought you were polluting `environ` .. still i would just refactor the call to one location vs keeping dupe code around
Remove the portion that adds message as a special key. If there's modules returning message expecting it to be treated specially, change then to return msg instead
I feel like this should be moved to `else:`
default: none is also the default.
Space before ).
Shouldn't the default here be `None`? I suppose 0 can serve the same purpose since a Lambda can never be versioned at 0, but it seems odd.
I think this should allow either a list or a string (which would just coerce to a single-item list)
Same way we do for stuff like iam managed policies, accepting whatever value (no type) and if it's a list assign a list of action perms or if it's a string coerce to a single-item list.
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
Sorry, my bad. I didn't see the implementation of `_run`.
Might want to check `rc` status before return output.
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
there is no need to version params for new modules
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
```suggestion ``` I don't think you should do this, case is meaningful: ``` max@mde-oxalide % pacman -Q libreoffice-en-US libreoffice-fresh 6.1.3-1 max@mde-oxalide % pacman -Q libreoffice-en-us error: package 'libreoffice-en-us' was not found ```
```suggestion cmd = "%s --query --quiet --explicit --info" % pacman_path ```
```suggestion parts = to_native(date.strip()).split(':', 1) ```
```suggestion message_text = self.get_deprecation_message(msg, version=version, removed=removed, date=date, collection_name=collection_name, warn_change=warn_change) ```
```suggestion elif date_string.match(self.when): ```
This can be as `elif`.
You're using the result object to smuggle this around, but it should probably be an instance field instead, since we don't actually want it in the results. Probably the same for the other cases where we're using the result dict as intermediate storage- put them in fields and just construct the result object at the end before it's returned.
The condition is a bit long, I would write it this way instead: ```python if perm.principal != self.principal['domain'].upper() + '\\' + self.principal['name']: continue if perm.group != self.principal['isGroup']: continue ``` This way, you avoid an extra level of indent.
Please remove the uppwer case C. We use `vcenter_hostname`, `vcenter_username` and `vcenter_password` in the other modules.
Please use `C(present)` and `C(absent)`.
Please use `C(True)` instead of just `true`.
Could you write `Required if I(state=present)` instead.
`state` argument is probably missing for this module.
no worries, let's make it for 2.10, but I think that debug option would be nice ;)
it might be worth adding an option to configure debugging, unless it's explicitly needed by the module.
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value not specified in argspec.
The syntax for copyright line is: ```python # Copyright: (c) 2017, VEXXHOST, Inc. ``` And I'd add a blank line before.
Yes, the dev guide did something different than a major rewrite did. I'm trying to get clarification on this.
No need to quote this line. Please add spaces around `>=`
inventory plugin, not module ... also we can use 'short form' for licenses now
No need to quote this string.
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
I think we need to expand a bit on the description here. From the outset it seems like this is a dict but the examples show it is a list of dicts. Can you expand on what `linux_profile` is, whether it is a list of options or just a dict of options. The other point is that this is not `required: true` as it isn't needed when state == absent. The same applies for `agent_pool_profiles` and `service_principal`.
`self` is no need
I don't think installation should be covered by this modules, there are plenty of package management modules that are better suited for this, at worst a role that downloads and installs it
```suggestion - The friendly name of the monitor. ```
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Nowadays, we do: ```yaml type: bool default: 'no' ```
We typically do `present` and `absent` to control the state of a resource.
I think `state` is more ansibley
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
Remove as not needed (default)
Remove as not needed (default)
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
Empty proxy-init doesn't make sense and should be removed.
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
```suggestion "Error: " + to_text(err)) ```
```suggestion "Error: " + to_text(err)) ```
You don't need to branch on this, `_connect()` already does the check.
You still don't need this branch ```suggestion ```
```suggestion "Error: " + to_text(err)) ```
many modules have the default of `state=present`. consider this as a default if you feel it make sense.
since schedule_id is the unique identifier i do not use new_name, if the name does not match update it.
Although not required, we generally put `description:` first as we find it makes the source code a little more readable.
All descriptions should be full sentences, e.g start with a capital letter and end with a full stop.
non-blocker: probably some examples would be helpful
Same here. Looks like some strange linewrapping is going on.
I think changed needs to be set to True here.
This isn't used in the examples. Is it possible to do this by name instead of URL? It seems a little complex to have to provide a full URL to use non-default networks.
Since this isn't being used in any tests I was wondering if it is right that this is a str, or should it be type='float'? I wondered about this for max_utilization too.
This isn't really needed - the task should already be returning changed==[true | false], so users interested in whether the resource was altered can just check that property instead.
I think this would be 2.7.
Hmm. On second thought, I'm not even sure if ANSIBLE_METADATA is used in lookup plugins? I think that's only for modules specifically.
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
This is new lookup so no need to add `version_added`
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
`default: null/None` is the default, it can be omitted
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
No need to wrap.
what happens if it's not `> 0`? There will be a lot of `IndexError`s in the following code. We should set `launch_config = launch_configs[0]` if we know there is a result.
`dict((k, v) for k, v in launch_configs[0].items() if k not in ...)` is probably a bit more readable.
Random musing. I wonder why boto3 isn't returning CreatedTime sometimes. I made a launch configuration in us-east-1 with ami-9be6f38c. It has a creation time in the console. Hm.
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
CI failure due to invalid syntax.
```suggestion disk_result[property] = device[property] ```
One issue with this is that `win_reboot` uses this same method. So if the windows `DEFAULT_BOOT_TIME_COMMAND` results in an rc != 0, it will then try this `cat` command, which will gloriously fail. The previous conditional which runs `uptime -s` won't ever match on Windows because that string will never match the output of `(Get-WmiObject -ClassName Win32_OperatingSystem).LastBootUpTime`. This is the point where it would be helpful to have platform/dist as a class attribute, either as an additional check here, or to look up the correct boot time command based on platform/dist. I'm also open to other ideas.
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
understood, but namespacing is also a usability and convenience issue, it makes it easy for the user to define variables 'safe from conflicts'.
I think it would be more helpful to the user to show them both errors by default rather than hiding one in `-v`. Ideally we could have templating errors take precedence over loop errors and only display the templating error first, but that may not make sense in all situations. If we don't want to display both as was done originally, then I'm fine with the current use of `-v` rather than using debug since debug is information overload for users.
Yeah, I had the same problem. I tried changing the exception type raised in `templar.template()` and catching that here, but still couldn't get it quite right. Seems like putting it in `-v` is an improvement over what we have now until we can come up with something better.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
Manages bundles on Clear Linux systems
I'm not sure if we can also use the words "packages" or "updates" in their to make it a little more obvious.
This doesn't have to be quoted.
No need for the `M(..)` here as that will just generate a link to the same page.
This string doesn't have to be quoted.
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
```suggestion - The status of the secondary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - The status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - The status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - The URLs to retrieve the public I(blob), I(queue), or I(table) object from the secondary location. ```
```suggestion - The URLs to retrieve the public I(blob), I(queue), or I(table) object from the primary location. ```
Why was replace('\n', '') removed? If that was required before I don't see anything that would replace it now.
This line is incompatible with py2.6, and should either continue using printf style string formatting, or use element positions such as `{0}:{1}` instead of `{}:{}` Additionally, for proper types, please utilize `ansible.module_utils._text.to_text`.
This block is unnecessary, when using `to_text` as described above.
What is the reason of change? it would break the backwards compatibility.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
but sample is the key, it could have any value, and there I do expect such things to occur, but not on the keys themselves.
it should also check if it can write there
@webknjaz we have no gaurantees that the artifacts are being built from a git checkout.
I think this may read better: ```suggestion if missing_keys: ```
Are you only doing this to support Python 2.6? Those keys are already unique.
Need to bump this to `2.6`
not a blocker but the convention is to have `present` as default, please also consider this for your module.
Inconsistent number of blank lines between blocks.
Since ssh key management is no longer being performed within this module please remove the ssh key reference.
as `required: false` is the default, it can be left off
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
need to separate ClientError and ParamValidationError as the latter doesn't have an e.response object. Both exceptions should have `exception=traceback.format_exc()` (you'll need to `import traceback` at the top)
`required=False` is the default, and thus not required
Please import only what you need, rather than `*`.
Not strictly necessary as the default for parameter is that they're not required.
Should have been module.fail_json
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
This could move even more down. After listing apps.
AFAIK the Ansible functions should work, could you please provide a sample input value and expected output value given that input.
Maybe we misunderstood. We thought to_text would remove the need to import codecs and use hexlify. We now believed you meant to use to_text rather than str.encode and decode. Trying this.
bcoca has said he's happy with this bit
see to_text functions in ansible.module_utils._text, they are py2/3 compatible
Please fix the trailing space and it's ok to be merged. Thanks!
Anytime I reach for map or filter, I like to use a list comprehension of generator exception instead as it is faster and considered more pythonic. ``` python return [p.name for p in q] ```
Going through itertools here ends up creating both a list and a generator so it's likely slower than just returning a list. If the list is very large and your goal is to reduce memory consumption, you can use a generator expresssion instead of a list comprehension on line 322: ``` python expanded_excludes = (self._pattern_to_pkgname(self.base, p) for p in self.base.conf.exclude) ``` However, for iteration over most data, lists are faster than other iterables so it is a time-space tradeoff.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
rename variable name as it will shadow built-in 'type'.
and please add space after `)`
please use here `self.param('version')`
please use here self.param('version').get('base_template')
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Wouldn't this be handled by the branch above? ``` if hostname.count(':') > 1: ```
Situations where the v6 string in question doesn't actually specify a port, e.g., 2001:db8:0:1 See: ``` def test_parse_ip_host_and_port_v6_with_brackets ```
This can be a key-value map with key as the fact name and value as the pattern to be searched for
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Please use `module= AnsibleModule(` I guess it is a convention
As mentioned on IRC, please remove this (from here and other examples) and update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 to be `password=dict(type='str', no_log=True),`
Probably worth it to use `username`, `password`, `hostname`, etc in the examples instead of `config`
Ok, so I may have given you the wrong advice before. I was under the impression that these modules were talking to a backend, but (at least) this module seems to run on the remote target (over SSH ?). So delegate_to: localhost` will not work correctly.
At this moment, by default, the check_mode is disabled for all oneview modules directly in the [oneview.py module_utils](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L228). We do plan on supporting it, but since it would require many changes on all of the modules, that is in a "to do" list at the moment.
I *think* we want `supports_check_mode=True`
The `upper()` and `replace()` calls here seem unneeded given that the input is very strictly formatted already. But that's not a showstopper either.
space after , in replace
This looks like it is unfortunately not quite this simple. We want the following fallbacks: * If the user specifies a value explicitly in the playbook, use that * If the config file has it, then use that. * If both of those do not have a value, then use the module's defaults. This likely needs changes both here and in the mysql modules themselves. The change here will look something like this (repeat for each of the values we're setting): ``` python if cp an cp.has_section('client'): if module.params['login_host'] is None: module.params['login_host'] = cp.getint('client', 'host', fallback='localhost') [....] ``` Inside of the mysql modules we'll have to change teh module's argument_spec. For instance, mysql_db.py has this: ``` python argument_spec=dict( login_user=dict(default=None), login_password=dict(default=None, no_log=True), login_host=dict(default="localhost"), [...] ``` We would need to change it to this: ``` python argument_spec=dict( login_user=dict(default=None), login_password=dict(default=None, no_log=True), login_host=dict(default=None), [...] ```
This should be using `module.fail_json()` instead.
Change `should` to `would`.
please add ``` from __future__ import absolute_import, division, print_function __metaclass__ = type ```
I think we want to make this a one-liner now, as mentioned [here](https://github.com/ansible/community/wiki/Testing:-boilerplate,-wildcard-imports,-and-get_exception#boilerplate).
Please change this to 1.1
Please replace with the one-line license declaration.
This is the old ANSIBLE_METADATA stub. CI will fail.
No need to quote this string.
If this is set to type='int' this should avoid the later type conversion
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
hm maybe that's what I've searched for
```suggestion message_text = self.get_deprecation_message(msg, version=version, removed=removed, date=date, collection_name=collection_name, warn_change=warn_change) ```
```suggestion elif date_string.match(self.when): ```
```suggestion parts = to_native(date.strip()).split(':', 1) ```
Small fix. Else, this results in a tuple out of range error. :)
```suggestion warning_text_res = '{0} has been deprecated and will be removed in a future release of {1}'.format( ```
When changing portgroup or NSX-T portgroup to dvportgroup under this condition error occurs. The cause is that the `port` key does not exist when the portgroup or NSX-T portgroup is assigned to the vNIC. The following conditions are necessary. ```suggestion if network_object and hasattr(network_object, 'portKeys') and hasattr(nic_spec.device.backing, 'port'): ``` tested on vCenter/ESXi 6.7
The 2 `if` can be merged.
space after % operator
Can you please include `uuid` as parameter for finding VM ? you can use `find_by_vm_id` API for finding VM using uuid just like other VMware modules do.
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Missing full stop. all `description:` fields must be full sentences.
Capital letters & full stops please
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
If it's an alias (effectively an option name) then it should be written like `I(bundle)`.
Parameters that are not required, don't need a `required: False`. This is implied.
The place where the `main()` function is called explicitly does `sys.exit(main(sys.argv[:]))`. So `return 0` should really be here. (And yes, returning nothing is equivalent to `return None`, and `sys.exit(None)` is equivalent to `sys.exit(0)`, but it's still nicer to have an explicit `return 0` IMO.)
```return 0``` and ```sys.exit(main(sys.argv[:]))``` should remain. Keeping those allows the script to return a different exit code on error and isn't unusual or confusing for someone who is used to UNIX programming.
We could add it to other scripts. modules have their own exit points (fail_json and exit_json) which already call sys.exit(1) and sys.exit(0) respectively.
Note though, I wouldn't add to other scripts in this PR.... it's a separate code cleanup from the main purpose of this one (to stop rebuilding already-built docs)
Anyway, removal of `return 0` was not related to the purpose of the PR, but related to my refactoring suggestion. So it fits next to your change :)
This should not be opened with "+" (as that allows writing the file). I can't remember off the top of my head whether python2/python3 setuptools expects text strings or byte strings for longdesc. My guess is text strings. Since there isn't any non-ascii characted in README.rst I think we can ignore that for now and just use native strings but we might need to figure it out in the future.
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
there is a helper in `AnsibleModule` for mutually exclusive params: ~~~diff module = AnsibleModule( argument_spec=argument_spec, + mutually_exclusive=(('positional_args', 'named_args'),), supports_check_mode=True, ) ~~~
Would it maybe be better to only check the beginning of the query? Assume that the query is `SELECT * FROM USER_UPDATES`; in that case, because `INSERT` appears in `q.upper()` and `cursor.rowcount > 0` (assuming the table isn't empty), the module will say something was changed.
How about ```suggestion q = q.lstrip()[0:max_keyword_len].upper() ``` and removing the `.upper()` calls below? Will be more efficient :)
`current_version` could be mentioned in the error message.
Updated to use percent formatting
The `join` here seems a little unnecessary, and the performance is worse than a printf like string format or using `.format` Although it is just 1 line, and not repeated, so that's just a little bit of a nitpick.
Set required=true in the argument_spec ```ip_address=dict(required=True)```
You should use `module.get_bin_path('ssh-keygen', True)`.
`pexpect` could be used to provide the password to the subprocess on stdin.
version should be at least 4 from the point of deprecation so 2.7
we should also return if we both delegate executions and delegate_facts
this got named use_backend
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
I think it might be better to only minimally change the code by changing line [529](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/s3.py#L529) to `if '.' in bucket and not rgw and not is_fakes3(s3_url):` instead of manually fixing aws_connect_kwargs.
I don't really like manually setting aws_connect_kwargs in this function. And none of these except calling_format are ever set in main(). I don't understand why it's necessary to manually delete these.
CI failure due to PEP 8 issue: ``` 2017-02-27 20:21:42 ERROR: PEP 8: lib/ansible/modules/cloud/amazon/s3.py:807:1: W293 blank line contains whitespace (current) ``` The PEP 8 tests can be run locally with `make pep8`.
perhaps "if not region"? that keeps the standard flow from being in an "else", lets us bring the indenting back a level, etc. Otherwise this is fantastic. Thanks for pep8 and removing the stray code.
it means the same thing, it's just the flow.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please do not add `required=False`, it is implicit.
`collection_from_task, _, module_name = self._task.action.rpartition(".")` will always work regardless of whether a collection is present or not. So: `"ansible.builtins.eos_config"` returns `("ansible.builtins", ".", "eos_config")` `"eos.eos_vlans"` returns `("eos", ".", "eos_vlans")` but also `"eos_l3_interfaces"` returns `("", "", "eos_vlans")` which avoids the weirdness with `split`
We should be able to merge the two cases with something like this? ``` if collections is None and collection_from_task: collections = [collection_from_task] ``` Now `collections` is either the non-None contents of `collections`, or the task's collection, or `None` if neither exist, which means we can drop the `collections` check from the `all()`s and just use `collections` regardless
Ah, I hadn't noticed `collections` isn't added here. And yeah, we should probably be using something like `collection_list=[collection_from_task] + collections` to look up the action plugin (resolving appropriately when one or both don't exist). The two paths are just so similar to each other I'd really rather avoid keeping them separate unless there's a good reason to
Meh, what you have is fine for now- they're basically singletons already, so that constructor arg is probably superfluous, but I don't think there are any active plans to kill it... Just IIUC whatever reason it existed for in the first place doesn't exist anymore. So this looks good to merge to me.
we should also return if we both delegate executions and delegate_facts
should use `get_versioned_doclink` function as 'latest' might not apply to the 'current version'
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
Sorry, I think we had a misunderstanding when we talked earlier. I don't think we should be raising unless we add more exceptions so that we can tell why an exception occurred (right now, we'd have to catch the AnsibleError and then parse the message to tell why we failed.) raise_on_error is bad API. The API should either raise whenever there is an error or let the caller discriminate. Passing in a flag to tell the function to raise isn't meaningful. If we start raising an error, then we have to audit the code and decide what the failure case means in the present code. If the code doesn't depend on it (or works in some scenarios) then we probably have to replicate that behaviour instead of changing to always failing.
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
I think what you've got it good, thanks
This should be indented only by 2 spaces.
This should be indented only by 2 spaces.
Actually this shouldn't be indented at all. Lists can start from the same indentation as their parent. And the general rule is, don't add things that aren't needed (so don't quote strings if they're not needed, or don't indent if it's not needed).
You can drop the backticks around the `http(s)`.
You can remove the backticks when using the other decoration.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Can you just catch `AttributeError` here instead.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
Fair enough. It is not a hard requirement.
`descriptions:` should end with a full stop
From the mail I got I saw this obvious typo "receipient_id". Also now that we are at it, parameters can be indicated using C(parameter). So that line should read: ```yaml - The C(recipient_id) type must be valid for the supplied C(recipient_type). ```
missing full stop
So this class can be initialized with both format we send and format we receive? Neat! :heart: Worth mentioning in docstring IMHO.
I'm trying to think of a different class name, especially less confusable with `ManageIQAlert`. But I don't have any good suggestion. (this does fit the class naming in existing manageiq modules, matching the module name, but that's not such a good scheme IMHO, no reason to stick to it...)
as discussed previously, no such thing "alert policies". every mention of "policy/ies" should be renamed...
as someone using this module, i would be surprised if the behavior when creating a new alert profile A, a separate unrelated profile B disappeared. a different way of saying this is if the product ships with profiles X and Y, then while creating a new profile A, i shouldn't have to provide (or know about) X and Y to the ansible module call when all i want to do is create/edit/delete my own alert profile A.
If you like to replace `None` with `[]`, it sugguest to change it to `response.get('resources') or [] `. The difference is, currently with this code, `[]` will only returned if there is no `resources` key in `response`
@chouseknecht thanks a bunch, it makes sense to me. FWIW, I'm happy to help with the maintenance of the openshift client too. I'd like to help keeping the ansible module and the openshift client aligned with upstream kubernetes.
No need to use a backslash before the single quotes.
CI failure due to missing module metadata: ``` 2017-02-08 11:07:30 ============================================================================ 2017-02-08 11:07:30 lib/ansible/modules/cloud/misc/qemu_img.py 2017-02-08 11:07:30 ============================================================================ 2017-02-08 11:07:30 ERROR: No ANSIBLE_METADATA provided ```
This should be a string. ```yaml version_added: "2.3"
May want to use the configparser in 'ansible.compat.six.moves.configparser' here. Otherwise there are py2/py3 compat issues.
ansible.module_utils.ec2 sets HAS_BOTO3 to the correct value.
can delete this line
```suggestion pass # Handled by AnsibleAWSModule ```
No need for HAS_BOTO3 with AnsibleAWSModule
Can be `except ImportError:`
Also, this was added for a specific reason which made the module fail for some users, so removing it will also make the module non-functional for those users. Another reason why this is a NO-GO.
Removing a parameter that people are using will break existing playbooks that depend on it. This is a definite NO-GO.
So the default option in Ansible is named validate_certs and it defaults to 'yes'. So I would prefer we do it like this.
please add `no_log=True` to avoid leaking the password in the logs.
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
there's resource group missing in that sample
A few things when writing descriptions * Put each new sentence on a new line * When referencing another module option, enclose it in `I()` * When referencing a value for an option, enclose it in `C()` * You don't need it here but you can reference another module by enclosing it in `M()` * You don't need it here but you can add in a URL by enclosing it in `U()` So in the end this would look like ``` description: - Size in GB of the managed disk to be created. - If I(create_option) is C(copy), then the value must be greater than or equal to the source's size. ```
choices is not needed for bool type
`self` is no need
we have `self.update_tags()` method in the common module to compare the tags
```suggestion - C(name), name of app service plan. ```
Are all five parameters required for the dict to work? ```suggestion - Can be a dict containing five parameters, defined below. ```
```suggestion - C(number_of_workers), number of workers for app service plan. ```
```suggestion - Can be the resource ID of an existing app service plan. For example, ```
```suggestion - Resource id, eg. /subscriptions/<subs_id>/resourceGroups/<resource_group>/providers/Microsoft.Web/serverFarms/<plan_name>) ```
it would require to have the content into a var e.g like with the slurp module.
list_all is not really a state
Please make this oauth_token instead of api_token. This will provide some value to the end user in which type of api token and stay inline with the other modules. You will need to include the oauth_token below as an alias.
DigitalOcean no longer has the v1 api online, actually this hasn't been online in almost a year. There is no reason to reference it in the notes.
It might be helpful for new people, to show the actual variable values instead of variables. From a users perspective that has been using Ansible it's easy for us to follow but maybe not for a new user who will be reading the docs a lot.
This function is already defined.
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
You can remove this. If there isn't a specified return, None is returned.
Yes. Either to_native or to_text would be fine in this case.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
lets' decide myAsg or myApplicationSecurityGroup
security group -> security groups
should be consistent with sample name and resource_group
maybe also should be described
same here, snake case, and convert value to lowercase
Follow pattern as above. And revert to the correct spelling of `transmitted`.
Original spelling of `transmitted` was correct: ```suggestion - Threshold for defining a lossy connection by packets not transmitted due to window size. - A client connection is considered lossy when percentage of times a packet could not be transmitted due to TCP zero window is above this threshold. ```
```suggestion - Threshold for defining a lossy connection by packets that time out and get retransmitted. - A connection between client and Avi is considered lossy when more than this percentage of packets are retransmitted due to timeout. ```
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
Since the only value needed here is the password, this can be simplified: ```suggestion PASSWORDS = dict( password='test-vault-password', default='rainbows-are-pretty', ) ```
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
This would be handled by the `AnsibleAWSModule` ```python try: import botocore except ImportError: pass # handled by AnsibleAWSModule ```
```suggestion - This module creates clones for libvirt. ```
```suggestion - Create or delete project variable. ```
```suggestion 'Unable to connect to socket %s. See the socket path issue category in ' ```
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
It probably makes sense to clean-up flags before exiting this method.
It would be awesome if buildah supported copying from a container.
add CALLBACK_NEEDS_WHITELIST = True this is recent addition, it keeps plugins shipped with ansible from being executed automatically unless whitelisted through config.
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
check e.response['Error']['Code'] here too
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
If this is set to type='int' this should avoid the later type conversion
Catch botocore.exceptions.ClientError instead of Exception here too.
You are correct, I didn't look at all the code and assumed assumed there was a break on match, its last, not first, found wins ... which makes me want to rewrite this section. Not only can we have multiple package managers (add fact with list), but the traversal can be reversed + break to make it perform better. Another 'optimization' would be to create diff lists for OS families.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
we should also return if we both delegate executions and delegate_facts
Add that the user can specify the backend to use via the ```use``` parameter.
this got named use_backend
tempted to move to base class and make static
I like host_label()
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
Missing '.' at end
rename this parameter to 'boot_order' to match another PR - https://github.com/ansible/ansible/pull/40609/files#diff-edefcb875c0dd6b5deefd1c19534792dR41
There are instructions for C(sata) controller type, but controller_type says that only C(ide) is supported.
Also describe if it deletes the files or not
please add `no_log=True` to avoid leaking the password in the logs.
Please add a `version_added` to this as well.
`key: write_csv` should be `key: write_files`
`Telemetry data not capture` to `Telemetry data not captured.` as per below.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
```suggestion specify the user via UID, you must set C(ANSIBLE_REMOTE_TMP) to a path that exits ```
```suggestion - User specified via name or UID which is used to execute commands inside the container. If you ```
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Just because requests conflates validation and the source of validation truth doesn't necessarily mean we should- I've always disliked that in requests, as it prevents more granular cert validation behavior in the future (or at least makes it more complicated by requiring more config args). That's why I did the pywinrm one the way I did (left the separate arg for CA path and made validation mode a string/enum-y thing rather than boolean)
Yeah, a list is fine.
but to_boolean doesn't convert values to booleans. It's really normalize_options(). It's just that the only implemented normalization at the moment is for boolean values.
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
We use term `mapping` here.
You probably don't need `{}` fallback anymore.
Why not put the real meat directly here in main() ? I don't see a good reason to have 2 layers of abstraction (main -> setup -> setup_macpool) if it is unique to the module anyway.
``` python except KeyError as key_name: ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
Suggestion: ``The name of the node to be renamed. If I(name) already exists, no action will be performed.`
Not sure what you've done in other modules, though allowing this to take `type=list` maybe nicer
Oh, ignore this
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
You're correctly using `type='list'` in the arg_spec, so probably better if at least one example used the native YAML format and showed multiple values as list elements. The arg validator will properly handle coercion of a single value to a list (as the current examples show).
no, it's probably not fixable anyway
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
I'm not a fan of this, because credential type is not unique based on name, and because tower-cli already does a name-based lookup (again, which is wrong) of the related field in the call to the modify method. But this looks like it's mostly the same as how organization is handled, so I'm trending toward saying this is right for now.
credential is particularly problematic because it may be owned by a single user, in which case the organization will be null. This is a common case, and wouldn't be possible by assuming the organization is shared as you are doing here.
This is a pain point shared among all Tower / AWX clients, and I wouldn't say that any of them have ever gotten it right. I don't like 2 separate parameters. In my perfect world, I think it would optionally take a string or a dict (and there would be a type option to allow this), and using the dict you could specify both the project name & organization. This is unlikely to happen. The _primary_ fix you're getting in here, adding `organization` parameter to tower_inventory_source, and applying it to the inventory filter - that's really good. We need that. I would like to mostly focus from that and not worry too much about the other details which are still far from perfection.
`str` is superfluous here, it should be removed.
`a['adress']` could be used instead of `(len(a['address']) > 0)`.
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
Nowadays we list all the functionality we use from a specific library explicitly. So: ```python from ansible.module_utils.basic import AnsibleModule ```
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
```suggestion - Controls if the machine is allocated/deallocated, only useful with I(state=present). ```
```suggestion - Set to C(absent) to remove the virtual machine. ```
```suggestion the machine will be updated. - Use with I(started), I(allocated) or I(restarted) options to change the machine's power state. ```
```suggestion - Set to C(true) with I(state=present) to generalize the machine. ```
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
We generally don't mask the usernames, just passwords.
`author: Gregory Shulov (@GR360RY)"`
Do you support IPv6, if not then this should say IPv4 address.
Do you need that step? `clients = client_list` should be enough
Please put this on a single line. Lines can be 159 characters wide.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Should have a default set to `present`.
Suggest adding a combined example that also uses win_credential.
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
oy, thanks Github
```suggestion - Support for protected values requires GitLab >= 9.3. ```
```suggestion - When a value is masked, it must be in Base64 and have a length of at least 8 characters. ```
```suggestion - When you masked a value, the value must be base64 compliant and has at least a length of 8 characters. ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
It's probably better to put each requirement into its own item.
well, actually, I guess I would leave it None in the parameter list and change the setting of version which happens below to take the vault_id special case into account like this: ``` python if vault_id and vault_id != u'default': if not version: version = '1.2' else: raise AnsibleError("The vault format version must be at least 1.2 if vault_id is specified") elif not version: version = '1.1' ``` @alikins wrote the vault_id stuff, though, so he would be the one to ask if there's a reason he coded this the other way. (Note that this also appears to be a tangent to the main purpose of the PR, so perhaps it should be spearated into its own PR).
We do want to keep the CIPHER_WRITE_WHITELIST check here for sanity. It could be changed to throw an error, though, as cipher_name should be set in __init__ with your change.
We should leave the blacklists and whitelists alone for now. I don't like adding unnecessary symbols (So no blacklists, for instance). Everything should be a frozenset. Generating the whitelists from CIPHER_MAPPING.keys() does have some appeal but considering that there's currently only two ciphers, not very much compared to creating the blacklist unneccessarily. Those difficulties could all be hashed out in a different PR if we want.
~if not keeping encryption, remove the __ansible_vault key, just assign the value directly~ nmvd, misread the if to the opposite ...
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
@mattclay what do you think of this? I think it's okay but I didn't trace through and see how stdout_text and stderr_text are used later to make sure.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
This introduces a different race condition, file can now be looked at in 'intermediate' state.
the shell itself would have done it before. but might have done it slightly differently.
If you are cloning from a template, there is no guest_id parameter. So we should also check the current vm's guestId setting.
I was actually thinking of moving it closer to the AnsibleModule part, so it would fail immediately (not after 3 minutes). But that means pieces logically belonging together are torn apart.
you force the adapter creation if we don't set ip/netmask, this is wrong. In my usecase we don't use this VMWare device
```suggestion if any([i in network for i in ['ip', 'domain', 'netmask']]) ```
The 2 `if` can be merged.
Basically @gundalow's point is that you don't need to repeat the work that Ansible is already doing enforcing required parameters
But this code is never going to be hit if the argument_spec is set to required=True, unless someone set `url: ""`, but it's difficult to test for every bad input format - someone could equally pass `url: "not_a_protocol://thisisnonsense"`
Here you pass the variable `label`. You have never defined it, though (you defined `ch_label` -- maybe you meant that one?). That's the first of the sanity checks which fails. You might already get that output by running `flake8` on your module.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
Handle NoCredentialsError as well
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
facts modules can trivially support check mode (#23107)
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
IMHO this should be `apt-get/aptitude unmarkauto` instead of `apt-mark unmarkauto`
Indeed. However I can not say what exactly should be the fallback here. I didn't find a "recent" but outdated debian version not having apt-mark with manual|auto (debian7, ubuntu12.04). apt-mark probably has a fallback to apt-get itself. Works for me. Never mind.
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Here too, I believe you don't need the `cdrom_exist` variable.
I believe you should be able to replace `of (not cdrom_exist or len(cdrom_devices) == 0)...` with just `if not cdrom_device and cdrom.get('state') != 'absent'`
You can just use initialize `ide_device = None` and drop `ide_exist` variable.
`if self.params["cdrom"].get('type') not in ['none', 'client', 'iso']:`
I'm not sure you need the `ctl_exist` variable.
Wrong doc string
giving it more thought, the fix here might be to just remove the old code 9it is really not doing what it is supposed to, task_vars is not updated anymore then 'real fix' for the become issue is something like self.prompt = CLS.prompt in set_options before processing rest
This method is unused and must be removed.
we want want -> we want
Sorry about `maxsplit`, I'm mostly using Python 3 nowadays and forgot it wasn't a keyword in Python 2. Anyway, `metric.split("=", 1)` will work fine in both Python 2 and 3, so it's good!
This is a personal preference, but I'd rather not have a class name in all caps.
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
Could be shortened to `return rc == 0` if you're not doing any further processing other than returning.
`EXAMPLES = r'''`
```suggestion - If the clone should be present or started - default present. ```
Not sure this would work if flexvol_name is not specified.
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
rename is not idempotent, as discussed previously
It could be safer to add vserver to the query
oh I see, it makes sense then.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
Should also be "path"
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
Line is too long.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
Line is too long.
This line is too long. Max line length allowed in Ansible is 120 characters.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
Move it down the stack.
Same here, move it down the stack.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
Not sure if this piece is doing exactly what you expect in all cases.
Yes. We'll probably need to consider redesigning defaults separately. Out of scope now.
Yes, it will append flags with `True`, `1`, `1.0`, `y`, `n` (any string) values. And will skip `0`, `0.0`, `None`, `False`, `[]`, `{}`.
It's just a thing, which makes diffs nicer when you add/remove list items. Otherwise the other line where you put comma is always listed as changed in diff, which makes it harder to review :)
This change is causing the CI failure: > failed: [testhost] (item=python2-rpmfluff) => {"changed": false, "item": "python2-rpmfluff", "msg": "Autoremove requires dnf>=2.0.1. Current dnf version is 1.1.10"}
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Sure, but this assumes that there is nowhere else that this kind of thing comes up. I've heard of people doing their own private connection plugin that inherits from `ssh` and modifies some behaviors. With as many options that are specified by the config fragment in the `ssh` connection plugin's docs, this same situation could easily crop up.
Raise `AnsibleCallbackError`, which can be imported from `ansible.errors`.
Only one space after periods.
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
Same as for the updated, I'd rather say `has been deleted`
This one looks good but should be part of the TypeError block instead of in a finally block. The reason to me is that if the TypeError block runs successfully, then the code has successfully fallen back to code which handled the error. If the TypeError block throws its own exception (or the initial pexpect.run() failed for a different reason than TypeError) then we haven't handled the exception and the traceback could be helpful.
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
I know, was just wondering if it's intended that it works that way.
Use `msg` instead of `result` attribute ```suggestion module.exit_json(changed=True, service=remote_service.attributes, msg='Successfully deleted service %s' % service) ```
No quotes needed here;
"state" is required or you should set a default.
vmware_host_config_facts â vmware_host_ntp
`Current host '%s' can not be rebooted...`
vmware_host_config_facts â vmware_host_ntp
DO NOT AUTOINSTALL use the HAS_LOGDNA variable as a flag and return an error with the requirement when the plugin is invoked, plugins should NOT autoinstall libraries, also pip might not be installed on target systems and is also a possible error point. you can look at other lookups (like consul_kv) for how to deal with this issue
2.0 is what you want here
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
you should not need to checked disabled, as the plugin itself wont be called at all if true
check is redundant as you already flagged as 'required'
I have submitted a couple of modules with the new approach that takes care of check-mode. I am waiting to hear back from @schunduri that this approach is acceptable before continuing to enhance other modules being developed.
@jedelman8 you're right. @schunduri ^
Yes, so we plan to fix this and @jedelman8 and @jmcgill298 are involved in some new code that may help with this. However if this does not hit the tree before the freeze I will make sure this module is pulled from the tree. *It is unfortunate this PR was merged, but granted the PR should have been indicated with a WIP-tag to have prevented this.*
There is a deprecation marker, you could add here see Dag's PR
``` tenant = module.params['tenant']` ```
I don't think the logic is right here. * For failed==False, I think that the module side handles the play_context's no_log? (IIRC, we pass that into the module as _ansible_no_log?). * It feels like we should only be calling this for failed==True. failed=False should be handled entirely module-side. So I'd do the failed=True|False check in the calling code and only call this if we've failed. * The check to add invocation needs to always depend on play_context.no_log being False. If there's any case where no_log is True and we still add the invocation we'll be violating the security guarantees of no_log.
Now that the above will be changed, you can do `result["invocation"]["module_args"] = self._task.args.copy()`
we should also return if we both delegate executions and delegate_facts
this could return here? Then the next stanza doesn't need the extra indent level
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Shippable doesn't like this line for whatever reason.
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
The value should not be quoted.
Missing period at the end of the sentence.
I'm totally fine with your explanation and it was just a starting point by my side. And you are right, that the usage in your module in this case is simpler, so no change needed.
and then remove the parts Glandos point you.
A follow up PR that updates all postgres modules to use https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/postgres.py#L42 would be good. No need to block on this. Also that function should be updated to use `module.fail_json(msg=missing_required_lib("psycopg2"))`
You can use [`ensure_libs`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/postgres.py#L42).
`current_version` could be mentioned in the error message.
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
need to separate ClientError and ParamValidationError as the latter doesn't have an e.response object. Both exceptions should have `exception=traceback.format_exc()` (you'll need to `import traceback` at the top)
`required=False` is the default, and thus not required
Please import only what you need, rather than `*`.
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
This can be as `elif`.
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
CI failure due to: ``` 2017-01-31 18:50:23 ERROR: PEP 8: lib/ansible/module_utils/netapp.py:150:31: W292 no newline at end of file (current) ```
Not a must fix. We could remove 2 lines of code and logical branch for ```if not ignore_errors:``` The Core reviewers might like it more direct and declarative.
Use module.warn() instead.
This is the wrong way of doing Ansible. The user should describe the desired state, not instruct modules to perform actions. The module itself should determine what actions the specific state needs based on the current state and the desired state. That is what is needed for idempotency anyway. So rather than action=install, it should be state=present. Also, check-mode support and diff support are very important for a tool like this one IMO.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
catch all exception should be avoided
Move import statements after Line 81 or after RETURN
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
regarding backup, the way this is implemented will backup the file to the location where the module is executed. When we exeucte this as local_action or `ansible_connection=local`, it will backup the file to the control machine, however we run this module with `ansible_connection=ssh` it will be backuped to the remote machine. This is probably not what is intended. So this should be solved as "action_plugin" (identical to ios_config) which will ensure, the backup is going to the control machine.
I don't recommend going the action plugin route, just make sure description points out that backup is where module executed. backups via action plugins are a bad pattern, now that include_role exists it makes more sense to move to a role.
We tend to sort the various imports, so swap those two lines.
If there's no sample, please remove that line.
A trailing comma is preferred.
For consistency in the examples, I would do this: ```yaml - name: Gather vmware host facts vmware_host_facts: hostname: esxi_ip_or_hostname username: username password: password register: host_facts delegate_to: localhost ```
The quotes are not needed and not wanted here.
I'm not sure about these defaults - a delay of 3 and backoff of 2 for 10 tries would mean that, to fail, this retry decorator would wait for 3069 seconds (`3 + 3*2 + 3*2*2 ....`, or `sum([3 * 2**i for i in range(10)])`) or about 50 minutes. That seems like a really long time, especially since most modules make several calls. A better default might be 4 tries, for a total default wait time of 45 seconds and having a max of, say, a minute between tries. That way, if someone wanted 10 tries it would only take about 7.5 minutes to fail.
not exactly what i was asking, but good enough
This is unnecessary, by default AnsibleAWSModule automatically merges the spec you pass it with ec2_argument_spec().
This is unnecessary, AnsibleAWSModule handles it.
This whole connection block can be replaced with `conn = module.client('ssm')`
No trailing dots ! :-)
image image -> stack
Needs to include the platform. This string is used on https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html
s/2.6/2.7/ We passed the freeze date for 2.6
I would move this to the module notes.
Well you don't need the `if`, you can just run `.replace()` and it'll do the right thing regardless of whether there's a slash in the string.
Right, but `'show_vlan'.replace('2/1', '')` is still `'show_vlan'`. Unless I am missing something painfully obvious, the condition is not needed. (I will admit that I am picking nigh infinitesimal nits here... the rest of this is just fine and you could just merge it if you want)
`load_fixture()` takes the module name as the first parameter now, so you can lose the `os.path.join()` above and just have `load_fixture('nxos_switchport', filename)`
please use dict literal instead of constructor: ```python {'diff': None, 'session': 'session'} ```
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
The cgroup name must be checked.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
As we no longer care about 2.4, I think this can be cleaned
disable logging to given remote host
use sorted list. please use the sorted list in all relevant places
please give more description about the structure of the upload url: ` protocol://username[:password]@server/path `
again, please sort according to severity
use full names read-only, read-write
All occurrences of 'Gitlab' should be 'GitLab"
This isn't valid yaml ` : `
Please replace your mail with your github handle (also in cloudscale_server module)
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
Above you said "They are present before the module ran". In that case, this list should not be empty if `purge` is `true`, but contain the list of variables which were there before the module ran.
Imported but unsed
you might want to hint at which versions of requests you require, as it varies wildly across systems.
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionRqstError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.LoginError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionError' imported but unused None of those imports appear to be used.
timeout isn't defined in `argument_spec`
This argument is marked as being removed in the same version it is introduced. This makes no sense.
This function is not required as it is not doing extra arg validation. For other network platforms, this function is present due to legacy reason and will be removed in subsequent refactor.
From 2.5 onwards network platforms using persistent connection will be using cliconf and netconf plugins. To use cliconf plugin you need to add platform-specific plugin in `lib/ansible/plugins/cliconf/<platform-file>` You can refer `asa` modules as it is implemented using cliconf api's https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/asa.py https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/cliconf/asa.py
Rename this to `get_provider_argspec` to be in sync with other platforms
You don't need this function
not 2.4 compatible, checks are probably skipping everything in 'cloud' but considering the target platform, we might want to keep 2.4 compatibility in this case.
sorry, anything that smells like Sun makes me think they are still running Python2.2
Not really as there might not be any `[0]` and if there is there might not be any `uuid` in it. The right way of checking that is: ``` if len(json_output) > 0 and 'uuid' in json_out[0]: return ``` There is no need for `else:` as the default return value is `None` which is what we want if it fails.
This needs to be addressed.
The `stderr` should be used in the `exception=stderr` keyword. The same applies to all places where you use `stderr` in this module.
Rather than a try/except you could do: `old_port = self.data.get("endpoint", {}).get("port")`
This feels to me like it would be better as a function that would take a dbinstance and convert it to the facts dict, then a separate one to diff dictionaries rather than a class.
Same suggestion as above. .get() doesn't have to return a Nonetype so you can use it for "port" too.
Missing HostedZoneId here which is important if you want to set a route53 ALIAS record later
These should be using the backoff tools, since I can see folks grabbing facts on large numbers of snapshots.
Since we are now aggregating inventory info from multiple systems, the output should show which system the inventory info belongs to. Suggest changing L280 above to: ``` entries.append(({'systems_uri': systems_uri}, inventory['entries'])) ```
In case no 'entries' were added, need to avoid a KeyError. ```suggestion if 'entries' in inventory: entries.append(({'systems_uri': systems_uri}, inventory['entries'])) ```
That `get_multi_something` pattern repeats itself quite a few times in the file, which makes it a good candidate for a refactor into more general function. Something similar to this should work: def aggregate(self, func): ret = True entries = [] for systems_uri in self.systems_uris: inventory = func(systems_uri) ret = inventory.pop('ret') and ret entries.append(inventory) return dict(ret=ret, entries=entries) def get_multi_storage_controller_inventory(self): return self.aggregate(self.get_storage_controller_inventory) def get_multi_disk_inventory(self): return self.aggregate(self.get_disk_inventory) This should reduce the code duplication significantly.
Minor suggestion - I think this would be more natural than using string split(). ``` resource_uris = [self.manager_uri] ```
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
As far as other platforms modules are concerned there is a link to the platform user guide in the notes section since it supported more than one connection type, For example, refer https://docs.ansible.com/ansible/latest/modules/ios_config_module.html If it is missed for some module it is doc related bug.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
This should just be `name` since `pubnub_blocks: block=foobar` is a bit redundant.
default: none is also the default.
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
Ah, I see. Thanks for clarifying!
`author: Gregory Shulov (@GR360RY)"`
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
Should be a parameter of the task itself and not the module
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
We try not to use "_" as an identifier just in case we want to internationalize the modules someday (the convention for gettext is to mark strings using the function _(). So we don't want to inadvertantly override _ with another identifier).
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Here, you might want to return `out` if `re.findall` returns `[]`
This is never evaluated as the `state` is always set.
You should not use `stdout` and `stderror` if you use `msg`.
Please don't use `\`, there are better ways
Please don't use `\`, there are better ways Also use proper indent
Start by not using `\` and use proper indent
Please don't use `\`, there are better ways
I suggest showing two examples, one for present, one for absent
```suggestion - When I(state) is C(absent) and I(thumbprint) is not specified, the ```
If a parameter is not required, you don't need to add this. It helps readability if only required parameters have the required option.
Should be C(flatpak) not c(flatpak).
IMO it is better to move this test further up in **_flatpak_command()**. And leave the module through the final **exit_json()** just as if you would if you're not in check_mode.
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
Make this two items. We prefer the first line of the description explain what the option is for. So rather: ```yaml name: description: - The name of the flatpak repository to manage - When I(state) is set to C(present), I(name) is added as a remote for installing flatpaks. - When used with I(state=absent) the remote with that name will be removed. ``` PS There's a type in `thet`.
If a parameter is not required, you don't need to add this. It helps readability if only required parameters have the required option.
Should be C(flatpak) not c(flatpak).
IMO it is better to move this test further up in **_flatpak_command()**. And leave the module through the final **exit_json()** just as if you would if you're not in check_mode.
Not strictly necessary as the default for parameter is that they're not required.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
You could move this a couple lines above and remove the two in the elifs below.
You can remove this (and the import) now that this uses AnsibleAWSModule.
Should probably check if region exists before this line.
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
Rather than nesting this code here, I'd recommend performing the test in 'main' as a sanity test, prior to starting any of the real logic. See ecs_api_handles_launch_type for an example of how this has been handled for other boto3 requirements. (currently lines 308-313 and 373-374).
Same here - AnsibleAWSModule adds this itself.
Ping @willthames - other than this validation fix this is good to go.
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
You can add required=True here too and remove the check below.
```suggestion - The certificate in PEM format. ```
Same for other description.
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
+1 for this.
Add a sample dict returned by module.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
```suggestion - Possible values are C(INVALID), C(NEW), C(ESTABLISHED), C(RELATED), C(UNTRACKED), C(SNAT), C(DNAT). ```
Doesn't look like this got merged intime, so `2.8` here (and other places
Again, suggest rewording this as suggested for win_http_proxy.
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
You could fix #19781 real quick right here :D
All `descriptions:` should be full sentences, e.g. start with a capital letter, and end with a full stop.
`- Gather facts... `
`Allows notifications to be sent using SMS or MMS via the catapult bandwidth API.` No need to repeat the module name,
This should be quoted.
Please remove the "required: false", you only have to add `required: true` if it is required.
I would omit the 3, it seems like in the internal API you can set as many recovery actions as you want. It's just the GUI that limts to 3.
I would simplify this by saying the list order is the order of actions to take, i.e. first entry is the first action and so on.
In the code, you enforce setting all 3
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
If you enclose this in `EXAMPLES = r'''` you don't need to escape the `\`. Standard practice for all module doc blocks is to use `r''' '''`
Add alias of `username` (shown in argspec).
```suggestion - Optional private key in PEM format. ```
I would prefer explicit imports.
For an info module you will only need the name as this will be the identifier. Please remove the other options
Why are you formatting the variable? The same in many places in the code below. Is the reason that you want to have it as `string`? In that case, you can define `type='str'` in the `argument_spec` to enforce that type.
Returning only parsed data here severely limits the usefulness of this function, since any requests will be considered OK as long as the response can be parsed as JSON. This means that server returning status 404 or 403 will still be considered success, but the rest of the code has no means of checking that since status is removed from the return value of this function. It would be probably better and more consistent to return complete response here and write another wrapper function that can then check the return status, parse JSON if neeed, etc.
This method definition shares most of its functionality with `get_request` method, which indicates that the common functionality (common parameters, error handling, etc.) should be extracted into private method.
It's fine if it's a placeholder for future capabilities.
The e.message exception handling will cause an AttributeError on Python 3.
This might not work, but the __str__ return result of error might have what your looking for.
```suggestion description: library creation success and library_id ```
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion def state_update_library(self): ```
Looks to be likely boto3 1.9.45, botocore 1.12.45.
Please add in an `AWSRetry.backoff()` here in case the describe gets rate limited. Also, you may want to add a paginator in case there are lots of target groups. I've seen 100+ in accounts that use ECS heavily.
Should this be a call to a function that does handle retries (all the other API calls in this function seem to at least be capable of that)
Oh, it's supposed to be "dereg" as in "deregister"
What does this method name mean? No need to do anything, I'm just curious.
Needs a check to see if it is empty, and if so, fail the module
```suggestion [datastore_name] path/to/file.vmdk ```
Please remove the raising of an exception and properly fail the module.
I have already cleaned that up in a follow-on that I was going to submit after this..
Please remove the raising of an exception and properly fail the module.
There can't be spaces in cluster name.
Create vm pool and override the pool values.
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Types are missing above. token, msg and api are of type "str", port is of type "int". So something like: ```python token = dict(type='str', required=True) ... port = dict(type='int', default=80) ``` Please also add check-mode support. In whatever form you think is appropriate (either log messages adding check-mode run, or not sending messages but e.g. still attempt to connect).
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
Most modules using public cloud providers offer a `validate_certs`/`validate` option[1][2]. I think the same apply here. [1] https://docs.ansible.com/ansible/latest/modules/ec2_snapshot_facts_module.html#ec2-snapshot-facts-module [2] https://docs.ansible.com/ansible/latest/modules/os_volume_snapshot_module.html#os-volume-snapshot-module
nit: I would scope/namespace this to `scaleway_snapshots` to ensure it doesn't overrite another `snapshots` in `ansible_facts` scope
Other module haved aliased `oauth_token` to `api_token` since `api_token` is what's actually used in the code I think it makes sense to add the alias here.
May be the name is not correct. This won't create a server.
`START1` isn't a valid commercial type
This should have exception handling around it. Once you update to AnsibleAWSModule you can do: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to list clusters") ``` and it will use e.response and add the traceback for you.
required=False is the default, so you can omit that, same for any of the following. `name_regex=dict()`.
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
State should have the choices 'present' or 'absent' to be like other Ansible modules.
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
Might be worth validating that zones is a list rather than a single zone provided as a string.
Please also add whether filters that are listed in separate list items are an `OR` or an `AND`
The `options:` entry appears to be responsible for the `ansible-doc` failure.
You can use get_option() instead of accessing the dict directly.
```suggestion version_added: '1.9' ```
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
I believe the plan is to do a single PR to address this in all Postgres modules
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
I don't think we should be referencing a private attribute/variable here in any case. We have no guarantee that it will exist in any future release either.
Well, the reason I'm asking is that by using something which is present on only new envs you're adding an implicit dependency and we have to maintain backwards compatibility we committed to maintain.
Oh, I've got an impression that you're using pip's importables. In this case it's fine.
Cross-compability, backwards compatibility, command line compatibility, ease of discovery. * Other packaging modules support comma separated package entries. * The pip module itself supports comma separated package entries * pip supports single string entries as valid packages * comma separated list entries are the natural way to write lists on the commandline. * error messages if people were to violate these rules (for instance: ```ansible localhost -m pip -a 'names=django>=1.11.0,<1.12.0'``` wonn't point to the actual solution unless we implement this sort of detection for creating the error message... in which case we might as well do the right thing.
I usually pre-compile regexes into a global variable so that it only has to be done once. ``` _VCS_RE = re.compile(r'(svn|git|hg|bzr)\+') [...] def _is_vcs_url(name): """Test whether a name is a vcs url or not.""" return re.match(_VCS_RE, name) ```
should be 'additive' to result when other operations are also executed, unless you force to make it an exclusive argument to all others
it should update the results dictionary and not exit, since this 'looses' information of other operations that might have happened before it and prevents any actions to be made after, but gives no error on defining those actions
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Default needs adding to docs
I just realized we are missing this in all plugins (i just updated foreman #42355 ): ``` plugin: description: the name of this plugin, it should always be set to 'tower' for this plugin to recognize it as it's own. required: True choices: ['tower'] ```
How is this required if it can also be specified by the environment variable? Compare to openshift plugin via `ansible-doc -t inventory tower` ``` api_key: description: - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable. ```
i actually don't think you should force having the `tower_config_file` entry, but it could be posed as an option and default to the 'normal location'
It also might be good to compare these options to the options in https://github.com/ansible/ansible/blob/cdd21e2170b9a47d84624c8c2f792a66f2b0fe57/lib/ansible/utils/module_docs_fragments/tower.py#L23-L42
its fine to have a 'separate pre-existing file', I would just use it as a fallback if other methods are not populated and i would not create one if it were not already standard.
```suggestion - Must include VM name, appended to 'folder' as would be passed to M(vmware_guest). - Needs to include C(vm) between the Datacenter and the rest of the VM path. - Datacenter default value for ESXi server is C(ha-datacenter). - C(vm) is not visible in vSphere Web Client but necessary for VMware API to work. ```
```suggestion - Password for the user in guest operating system. ```
```suggestion - "ESXi Host Example: C(ha-datacenter/vm/testVM)." ```
```suggestion - "vCenter Example: C(Datacenter/vm/Discovered virtual machine/testVM)." ```
```suggestion - VM path absolute to the connection. ```
You can remove the `required: false` lines, it's implicit
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
Missing full stop.
You can removed all the `required: false` it's implicit
I'm not sure how old aos-pyez 0.6.0 is, though you may wish to detail that here. `- "aos-pyez >= 0.6.0"`
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
@jmighion would be great if you can update ios_config as well. Thanks!
Rather than making these globals, store them as locals and pass them into the functions, or just run `mode.get_bin_bath` within the function. Globals are not worth the future troubleshooting complexity in this case, especially since `RPM_PATH` is the only variable used in two different functions.
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
Sorry, was out all of last week. I'm looking for my reproducer right now.
I feel like 300 seconds is a long time to wait. Most droplets are created within 120 second range.
Looks like `monitoring:` has been added.
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
spec is also returned
All of these uses of `str` should be switched to `to_bytes(var, errors='surrogate_or_strict')`. `to_bytes` comes from `ansible.module_utils._text`.
Thanks for the confirmation!
You don't always have a guarantee of `other_var` being the same type. And `'some str %s'` has different types under Python 2 and Python 3. That's why it's important to explicitly use the correct literal.
Oh, and in places with variables where you concatenate that with literals, also apply this function to avoid certain edge-cases which appear sometimes when you try to merge different data types.
Yes, you can convert resulting strings. But when concatenating things it may result in unpleasant side-effects. ```python # WRONG b'some str %s' % other_var # <-- Python (esp Python 2) tries to turn `other_var` into bytes, sometimes incorrectly which may even cause exceptions in obscure cases ``` ```python # CORRECT b'some str %s' % to_bytes(other_var, errors='surrogate_or_strict') # when you convert it explicitly, it'll always succeed ``` If you don't like this `errors='surrogate_or_strict'` part, you can use curring: ```python from functools import partial ... from ansible.module_utils._text import to_bytes ... to_bytes_sos = partial(to_bytes, errors='surrogate_or_strict') # ^ # | # | # somewhere at the top of the module ... # And everywhere else in code: # | # | # v b'some str %s' % to_bytes_sos(other_var) ``` Hope this helps.
it seems this and other parameters are missing from docs
I thought we had these in a GCP docs fragment, but now I'm not able to find it.
This isn't needed, since we now only support 2.6+ anyway.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
Same here with exception handling collapse. You could use something like `type(exc).__name__` in the string if you don't want the whole stacktrace but still want to know what it was- I'm guessing that's not useful info to an end user, but might be for troubleshooting.
add CALLBACK_NEEDS_WHITELIST = True this is recent addition, it keeps plugins shipped with ansible from being executed automatically unless whitelisted through config.
this process does live for the lentgh of the play, but it is also not thread safe, we update variables that will end up being shared in the threads.
threading is pretty useless in this context, the callback gets called in it's own sub process
import errors should not be fatal, look at hipchat plugin and how it handles this, the plugin will not work but will not stop play while it issues warnings about it.
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
```suggestion - Whether an existing log group should be overwritten on create. - Mutually exclusive with I(purge_retention_policy). ```
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
You have `git>=2.19.0` in `requirements`
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
```suggestion - List of the variable names requested. type: list ```
```suggestion - name: Find several related variables that end specific way ```
```suggestion - name: Show variables with 'hosts' in their names ```
This syntax is not supported in python2.6. You will need to index your format like {0}
Much better, thanks
Maybe worth adding code to check this and call `fail_json` if it isn't allowed
You can add the following to `argument_spec` `mutually_exclusive=(['name', 'channel'],),`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
needs to be added in the purge attributes
It currently says that in 2.5, it can be the module's temp dir or a platform setting (via one of hte environment variables). But it looks like the code will only use the remote_tmp as the default with no code path that would reach the platform settings.
Something like: ``` - When run on Ansible 2.5 or greater, path defaults to ansible's remote_tmp setting - When run on Ansible prior to 2.5, it defaults to C(TMPDIR), C(TEMP) or C(TMP) env variables or a platform specific value. ```
This should be 2.10 (the version where this new option will be added).
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Don't add `required=False` because that is the default. The required parameters will stand out.
In python we tend to add a trailing comma, also for the last item in a multi-line dict or list. This is explicitly allowed by PEP8 and ensures that if any items are added, only one new line is added (and not the previous line needs a change). So it keeps the origin of lines (blame) clean. And it's also much more convenient.
I'd go for: ```python output_level=dict(type='str', default='normal', choices=['normal', 'debug']), ```
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
```suggestion module.fail_json(msg=to_native(e), errno=e[0], reason=to_native(e), **result) ```
It would be a nice idea to have return dict. not blocker though.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
I don't see the point ;-)
Can you line up `src`, `dest` and `overwrite` please.
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
Minor, please append `type: str` here as well
I believe the plan is to do a single PR to address this in all Postgres modules
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
Perhaps, `Will ensure the datacenter resource exists and its properties are compliant with HPE OneView` Or something along those lines. As it is right now I'm not sure if it is clear that this resource can actually be created if it does not exist.
As on other PR, update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 and remove `no_log: true` from examples
I'm guessing this is because the module will manage one datacenter at a time/per resource declaration, and return that datacenter's data. For getting/querying multiple datacenters, likely the DatacenterFactsModule will be required.
Can you please ensure the module works with checkmode
it doesn't really matter as modules are treated as 'independent scripts' and not meant to be shared or reused code
``` deprecated: version: 2.5 alternative: Use M(nxos_l2_interface) instead. ``` I'm working on fixing this for the existing modules
```suggestion why: Deprecated in favor of C(_info) module. ```
```suggestion why: Deprecated in favor of C(_info) module. ```
correction: It's not a byte string, it's a raw-string literal
Maybe add `default: present` here.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
I'm not certain that we want to name this *Module. Just from reading this PR it appears that it will be used more for managing keys and certs rather than managing a program (the ansible module).
Are check, dump, and generate always needed? If so, consider making this an abstractbaseclass: https://docs.python.org/2/library/abc.html
exception classes should be defined after impotrs and constants and before helper functions.
You probably should do the opposite here. Set self.changed = False on object instantiation and then set self.changed = True when a change is performed.
doc string doesn't match actual return data
Capital letters & full stops please
does not match actual return dict
`required: false` lines can be removed
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
please keep line length pep 8 compliant
This is no longer relevant.
fObj => f_obj please to respect PEP
`dcpath` probably got to the incorrect context scope
Sorry, hadn't seen this else here, and it's fine to have it like now.
```suggestion - Runs C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3. - Only works with the system Python 2 or Python 3. If you are using a Python on the remote that is not the system Python, set I(install_python_apt=false) and ensure that the Python apt library for your Python version is installed some other way. ```
This probably needs some rewording. I'm also curious as to when it was added. I'll leave this open for review from the docs team.
```suggestion - Whether to automatically try to install Python apt or not, if it is not already installed. ```
```suggestion - If python-apt Python library is not installed this module will not work. - Note that it is installed by running C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3. If you are using a Python on the remote that is not the system Python, this will not work. In that case, you should set I(install_python_apt=false) and need to ensure that the Python apt module for your Python version is installed in another way. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove `force:`
Please remove this line.
s/write target file {0}/fetch file to {0}/
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
Perfect, we should keep msg as well with message.
this could probably be simplified with using a dict of dicts: ``` power_policies = { 'high-performance': { 'key': 1, 'short_name': 'static' }, 'balanced': { 'key': 2, 'short_name': 'dynamic' }, 'low-power': { 'key': 3, 'short_name': 'low' }, 'custom': { 'key': 4, 'short_name': 'custom' } } ``` Then it is just a matter of using `power_policies[policy]['key']` and `power_policies[policy]['short_name']` Not really worth a lot of worry over, just a suggestion
I think in check mode is like dry-run without any action. so Enable hyperthreading in check mode should have current_state and desired_state as enabled.
`current_state` is state after performing vmware task and we can use that information in next ansible task in playbook. ```yaml register: hyperthreading_state delegate_to: "{{ jump_server }}" - name: Perform some task depending upon current state of hyperthreading debug: var: "I am here" when: hyperthreading_state['result']['{{ inventory_hostname }}']['current_state'] == 'enabled' ```
updatedâuptodate (or up_to_date)
you can use `state` to avoid the 'or' to the user
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
image image -> stack
Ok, so long descriptions are not a good idea. Best practice is to do: - First line is a short description of what the parameter is - Subsequent lines for additional information on behaviour, or what different possible values mean
I'd change this to keypair if it can be a name too.
stack will not be created
`then` -> `the`
Oh my bad, apologize, according the doc, it should be True by default
I don't think you need choices for bool
Also, these 2 lines can be replaced with `ec2 = module.client('ec2')` and the boto3_conn and get_aws_connection_info imports can be removed.
This should probably just be `required_if`
The rebase brought the default back. This just needs deleting, then I think we're ready.
(Similarly, mark any string that you are going to call decode on with as a b"string".)
Mark any string that you are going to call encode on as a ```u"string"```. Otherwise you can run into problems on Python2.
You're checking two separate properties here. This should be in a separate test.
It probably makes sense to test that the exception reason also matches expectations
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
Running this in check mode will always result in a change even when an update is not needed. You need to do check the existing object to see if it needs updating before you exit here.
don't put a newline right in the middle of a work, just do ``` description: - An array of 0 to 16 identities that have access to the key value. All identities in the array must use the same tenant ID as the key vault's tenant ID. ```
this line isn't needed
avoid putting quotes around values unless they are really needed
We are trying to move away from having the `state` key containing the raw Python SDK return values to just what is not known by the client. In this case I would just return the `id` of the object under the root level, e.g. ``` RETURN = ''' id: description: returned: success and keyvault exists type: str example: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX/resourceGroups/presentation_rg/providers/Microsoft.KeyVault/vaults/ozidatamanagement ''' ``` If the user wants to get more information about a resource that is what the facts module is for.
Mind putting this magic value into a constant with a descriptive name? I'd read much better if it was ```suggestion sys.exit(RC_CLI_INIT_FAILURE) ``` or something like that.
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
No, the default is None. So you can tell if the parameter was set or not.
```suggestion version_added: "2.10" ```
heal_type key is misleading. Can you change it to: `filter' (The filter can be of self-heal or rebalance)
`present` is a value of a parameter so it should be decorated like this: `C(present)`. The same for the `absent` bellow.
s/status is/facts are/ Since we are returning the facts, which also includes status.
This description seems redundant to me.
Change `should` to `would`.
I would use `module.fail_json` here to properly indicate failure.
Change `should` to `would`.
I think `gitlab` would be a better name for this variable than `git`.
A lot of this code is duplicated between this `gitlab_tag` module and the `gitlab_hook` module that you've also submitted: https://github.com/ansible/ansible/pull/19093 I think you should extract the common code into a class that goes into `ansible.module_utils`.
Please don't return different types of data from a function. It should always be consistent and discourage checking the return value. Unlike low-level C-code, Python provides you with a variety of handy ways to communicate failures to the calling code (like exceptions).
also, please use dict literal instead of constuctor (`{'key': 'val'}` instead of `dict(key='val')`)
you can probably move this statement outside of with-block
refactor: ```python additional_kwargs = ( {'showAuthenticationRestrictions': True} if authentication_restrictions_supported else {} ) result = db.command( 'rolesInfo', role, showPrivileges=True, **additional_kwargs ) ```
wrap these pieces of code into two try/except statements to be precise with what you're trapping. 1) one around with-block (with readfp call) catching `IOError` 2) the other one around creds dict constuction catching `configparser.NoOptionError`
This should be `2.9` as we don't backport features.
Exceptions shoud be handled case by case discussed in an IRC meeting. Feel free to put this on the agenda https://github.com/ansible/community/issues/474.
Lines 58-60 have inconsistent indent.
Also missing parentheses: > during vm execution (e.g. due to a vm label update),
> during vm execution (e.g. due to an update),
This seems like it should be a context manager rather than a pseudo-decorator
Solid point about the specified URI, makes sense. Thanks. ð
I'm not sure why but other parts of the code are using "my" for the variable name for a yum_base object so we should keep doing that.
If you were to do this as a decorator, you should be calling ```function``` here instead of hardcoding fetch_rpm_from_url.
I mean like: ``` python - package = fetch_rpm_from_url(spec, module) + package = function(spec, module) ``` But looking at this, I still think it should be a context manager rather than a pseudo-decorator. That would look something like this: ``` python from contextlib import contextmanager [...] @contextmanager def set_env_proxy(conf_file, installroot): old_environ = # [old values of the proxy env vars] try: my = yum_base(conf_file, installroot) # [set environment to the proxies that yum knows about] yield except: raise finally: # reset the environment to the values saved in old_environ [...] if '://' in spec: with set_env_proxy(conf_file, installroot): package = fetch_rpm_from_url(spec, module=module) [...] ```
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
I prefer this: ```python host=dict(type='str', default='api.meraki.com'), ```
So I am interested to know the difference between PUT and POST. And highlight that here.
Doesn't need to be quoted. We tend to only quote strings when it is required.
Lowercase yes :-)
It would be useful to tell the user which `key` is invalid.
As per naming convention, the name is `get_lldp_global_facts`
This condition can be removed
like diff = load_config(self._module, config_xml, [])
Please move this below the future import statement, to keep the module consistent.
@jmighion would be great if you can update ios_config as well. Thanks!
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
Those lemurs at shippable sure need to work harder! ;-)
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Is there another option than this? If I give the parameters: ``` elb_target_group_facts: names: - validtargetgroup - notatargetgroup ``` and validtargetgroup exists and notatargetgroup doesn't, I'll get back no facts. Not sure if that's desired behavior or easily fixed if not.
could add HAS_BOTO3 to the imports from ansible.module_utils.ec2 instead of manually setting
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
Period at end.
How about 'absent' as state, which make this module complete.
``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.1' } ```
First letter should be capital and the sentence should end with a period.
`short_description: Manage VLANs on VyOS devices`
I think the ` if self.param('kernel_params_persist') ` should be also here for cmdline
But it must be in this if.
and please add space after `)`
please use here `self.param('version')`
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
The value should not be quoted.
The value should be quoted.
This should be quoted but please use double quotes.
Missing period at the end of sentence.
The values in the array should not be quoted.
```suggestion - List of denied data actions. ```
This one is correct.
```suggestion - List of Role Definition permissions. ```
```suggestion - List of assignable scopes of this definition. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
If we do add something like this, three thoughts on the formatting the string: - Use clean_args since that will have had private parameters stripped out. - What's PERM? Should this be ARGS instead? - Use to_native(e) and to_native(traceback.format_exc()) instead of str(). (clean_args should be a native string so it shouldn't need to be coerced here).
Okay... We shouldn't let tests drive implementation (unless it's a case where the implementation is more modular, easier to read, or more flexible once it's adapted to the test case). let me take a look at updating the test case.
I pushed this change in my commit to the code
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
the shell itself would have done it before. but might have done it slightly differently.
Isn't it missing a whitespace ? Are you sure environ is defined here ? I don't see it. Perhaps this would work too, if you do want OVIRT_URL= to override kwargs['url']: kwargs['url'] = environ.get('OVIRT_URL', kwargs['url']) Example: $ A= python -c 'import os; print os.environ.get("A", "X")' (we get an empty string) If you do not want OVIRT_URL= to override kwargs['url'], then you can use or: kwargs['url'] = os.environ.get('OVIRT_URL') or kwargs['url'] Example: $ A= python -c 'import os; print os.environ.get("A") or "X"' X (we get the value that's at the right of or) Hope this helps
Why not leverage .setdefault here ? ``` kwargs.setdefault('url', os.environ.get('OVIRT_URL')) kwargs.setdefault('username', os.environ.get('OVIRT_USERNAME')) kwargs.setdefault('password', os.environ.get('OVIRT_PASSWORD')) ``` ï¿¼
Since this might be nested-vars, or the user may supply a relative path. To make sure you handle this var well, also use `expanduser` and `expandvars`.
instead of manually assembling all the options, use set_options/get_option and all this will be resolved 'per option' in normal precedence order
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
Doc describes `intenal`, no `state`
I think it would be better if the default region number is 0
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
You probably should just exit here with `changed=False`
This will fail if `self.accounts_uri` is not initialized.
Useless loop that can be merged with the next one.
Not catching non-200 responses.
Not catching non-200 responses.
Will fail if `self.systems_uri` is not set yet.
@mmazur, cool, do you have a pull request for devel as well? I can merge both today.
I was looking into moving `ansible.utils.vars.merge_hash()` and discovered we have `ansible.module_utils.common.dict_transformations.dict_merge()` that was added in #41471. I wonder if that function could be used in this case.
I think you're overcomplicating and obfuscating this code. If you need recursive merging, add this loop to merge_dicts() rather than creating a new, nested function with obscured variable names. Or, an even better option: talk with @sdoran and @sivel about moving ansible.utils.vars.merge_hash() somewhere in ansible.module_utils.common (perhaps ansible.module_utils.common.collections) and use that directly.
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
I think it would be better to use `MiqServer.my_server.add_settings_for_resource(â¦)` here. This will queue a settings reload for all workers running on the target server after save.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
We shouldn't be adding content-specific rules to the validation code. Why not allow any non `@` prefixed string to be used for collections instead? That will preserve the more strict check for ansible-base while allowing collection authors more flexibility.
ditto on `.` in character groups
ditto on `.` in character groups
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
this only happens if a relative path is given and it is not only in 'files' but that would be the first subdir checked.
default of none allows us to know if user set or not, unsure if it is currently needed but JIC we want to make distinction in the future.
Should we add here that the win_copy module is not a very efficient transfer mechanism and if possible using HTTP downloading using *win_get_url* or *win_uri* is preferred.
Please use add `type: bool`
Please add `type: bool`.
```suggestion - 'If C(state) is set to C(powered-on) or C(poweredon) and virtual machine exists with powerstate other than powered on, ```
```suggestion - 'If C(state) is set to C(powered-off) or C(poweredoff) and virtual machine exists with powerstate other than powered off, ```
```suggestion - This parameter is required, if C(state) is set to C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
```suggestion - 'If C(state) is set to one of the following C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
```suggestion - 'If C(state) is set to one of the following C(powered-on), C(poweredon), C(powered-off), C(poweredoff), C(present), C(restarted), C(suspended) ```
Set self.is_group by default to False
PyVmomi helper class already calls `connect_to_api`
Elaborate more on case - what happens if state is set to absent. Also, other conditions like if permission does not exists.
required=False is default so no need to add.
Add a note that principal parameter is required if group is not present and same for group parameter.
This one is correct.
```suggestion - List of Role Definition permissions. ```
```suggestion - List of denied data actions. ```
```suggestion - List of assignable scopes of this definition. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
``` python except KeyError as key_name: ```
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
Tell people where we are looking `CONFIG_FILES`
Please fix: '... if it doesn't exist:'
Fixing such stuff is in general a good idea, but it's better to do it in a PR which can be backported ;-)
That's also fine for me. Then let's hope they don't reorder them ;-)
From the code below, it looks like this doesn't do what you think it does. It creates a list of dictionaries which contain precisely one key, whose value is another dictionary whose only key is `SpreadDescriptor`.
Ah, so docker will return a list with dicts, all of them having precisely one entry. Ok, in that case, everything makes sense :)
You're right. I also checked the source at tag `2.1.0`, and it contains that parameter. I guess they did some refactoring between 2.2.x and 2.3.0 which resulted in that commit...
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
It's not a big deal either way, but since import sanity actually has to run on 2.x, it'd be *nice* if the type hint support was getting exercised there as well. Honestly I don't have strong feelings either way- I'm happy to merge as-is and we can go fix it and turn on remote-side stuff later (or not), or we can wait for Matt C to be back late next week and see what he says. There are also a couple other ways to fix this for 2.x (but a bit gnarlier at the import sites). I suspect that having the blanket ignores present for 2.x's benefit could mask potential problems or missing typeshed stuff in 3.x, so we *might* want to look at the fully-inline options if/when we light this up for 2.x.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
no need to do this check, the plugin never gets called if disabled
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
I'd move this block into it's own method since fetch_file will likely need it as well.
Used by the base class to be able to handle all ansible data https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/callback/__init__.py#L123
i recommend using the ansible json encoder as it deals with 'special' types and will avoid a lot of serialization errors you'll get with the stock json.
Or maybe ```suggestion self.default_inventory_hostname = '_'.join(( vm_model['name'], hashlib.sha1(to_bytes(vm_model['id'])).hexdigest()[0:4], )) ```
Just use ` and ...` instead of nesting. Less indentation == better readable.
Initialized must go first.
This should be on the top of the file.
we normally prefer to use the same tmp directory as the modules themselves are put into
```suggestion 'ACCEPT', '--cstate', 'NEW', ```
If it is not requires, don't add it. ```suggestion whitelist_tcp=dict(type='list', default=list()), ```
Add trailing comma for multi-line lists and dicts. ```suggestion whitelist_udp=dict(type='list', default=list()), ```
Add trailing comma for multi-line dicts. ```suggestion supports_check_mode=True, ```
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
The module does not seem to support check-mode.
We tend to only add information to the return information that is new and coming from the system. There is no added value to return the existing information back to the user, the user already knows this as it supplied this to the module himself.
Using grep/awk here is not a very good idea. Everything can be done in Python and it makes the code portable across all ZFS platforms (Linux, FreeBSD, Solaris, illumos). Please consider dropping this in favour of Python code.
```suggestion type: str choices: [ absent, present ] ```
```suggestion - The full path to a list of block devices such as hdd, nvme or nvme. ```
Missing full stop. all `description:` fields must be full sentences.
Parameters that are not required, don't need a `required: False`. This is implied.
instead of flags_on/off just flags .. a canonical list
comma-separated should not bee needed, just make flags a type=list in argspec, it will accept both actual lists and comma separated strings
Parameters that are not required, don't need a `required: False`. This is implied.
I find a list of dict easier to handle rather than dict of dict.
```suggestion serial_port_info = list() ```
I believe it should be type+device_name/service_uri/file_path.
```suggestion backing['port_index'] = port_index serial_port_info.append(backing) ```
I maybe wrong but we are getting user input for `yield_on_poll` but you are not using here.
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
It would be awesome if buildah supported copying from a container.
A message string would good to say that image is not preset or something similar.
Indentation doesn't seem quite right here.
This should use the existing `AzureRMAuth ` rather than requiring these keyvault vars only. Then auth using alternative ansible support methods works too. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/azure_rm_common.py#L971 This is how the other azure plugins work already (e.g. inventory plugin https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/inventory/azure_rm.py#L274 )
avoid putting quotes around values unless they are really needed
We are trying to move away from having the `state` key containing the raw Python SDK return values to just what is not known by the client. In this case I would just return the `id` of the object under the root level, e.g. ``` RETURN = ''' id: description: returned: success and keyvault exists type: str example: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX/resourceGroups/presentation_rg/providers/Microsoft.KeyVault/vaults/ozidatamanagement ''' ``` If the user wants to get more information about a resource that is what the facts module is for.
This shouldn't be set.
```suggestion pvdiplay_cmd_device_options = [pvdisplay_cmd, device] + pvdisplay_ops ```
```suggestion rc, pv_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pv_size"]) ```
```suggestion rc, pe_start, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pe_start"]) ```
```suggestion rc, vg_extent_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "vg_extent_size"]) ```
Line is too long.
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
Here be dragons. I don't see check-mode being tested anywhere in the module. So I expect the module to perform a reboot in check-mode. Probably not what people expect.
Why not simply do: ```python match_first = (self.params.get('name_match') == 'first') ```
The `failed=False` is assumed, so I wouldn't add it by default. The only reason when this has to be add explicitly is when you return a non-zero return code (rc-value) and don't want it to fail.
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
```suggestion - A description of the template. - Include enough detail that the user will understand what is being deployed... ```
Thanks for that clarification. Upon reviewing the code, it wasn't obvious to me that this module is actively using both connection paths (to the k8s API and also to the Upload Proxy.) I've taken your word for it and updated my related PR.
Do we still need kind? For service I think it should always be v1
you might want a `suboptions` key here, they are not implemented in config (yet) but eventually they should work the same as module suboptions.
I think we need more info here what are possible choices.
Missed one.. Should just be as below unless you want to also pass module into the function. ``` if os.path.isfile(cert_chain): cert_chain = open(cert_chain, 'r').read() ```
Could probably get rid of the surplus required=False entries I seem to have missed as well
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
It might be better to use a similar regex that awx itself uses: https://github.com/ansible/awx/blob/devel/awx/main/validators.py#L51 Maybe just validate the format of the first line? ```python if re.search(r'^(?P<dashes>-{4,}) *BEGIN (?P<type>[A-Z ]+?) *(?P=dashes)', ssh_key_data): ```
I wonder if ansible itself has something for this in its `authorized_keys` module.
Add Python3 boilerplate ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ```
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
```suggestion - Name of the domain to be managed. ```
```suggestion - The desired state of the domain. ```
Please use `to_native(e)` [1] instead of `str(e)`. [1] `from ansible.module_utils._text import to_native`
```suggestion - Desired SR-IOV state on interface. ```
```suggestion num_virt_func: ```
```suggestion - number of functions to activate on interface. ```
optional parameter, related to `C(num_virt_func)`.
I think user can specify specific host from cluster. Cluster and host both arguments should be allowed
Somehow this (+ the following line) doesn't work and prevent the module from working.I haven't digged deeper yet,
Can we remplace this line by the following three lines: ``` p = subprocess.Popen(['acme-tiny', '--account-key', self.accountkey, '--csr', self.csr_path, '--acme-dir', self.challenge_path], stdout=subprocess.PIPE) crt = p.communicate()[0] open(self.dest, 'w').write(str(crt)) ```
backupdest isn't defined anywhere
Read operation: ditto
Read operation: ditto
even better would be to show what specific operation we were attempting, but that does not seem clear w/o parsing the uri itself (for that, the caller should be processing the exception)
Same duplication of functionality as with `post_request` function.
Resource path should not be manipulated by hand, since we should only use paths that Redfish API returns (with one exception that has been actually removed from the latest version of the Redfish standard).
As before, this will not catch non-200 statues of response.
This will fail if there are no systems present (`data["Members"]` is empty list).
/me retires very old vm images We should be OK with anything added before v240 (and that is already ancient).
need to check, but I'm not sure all options are backwards compatible across most systemctl versions
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
This line is too long. Max line length allowed in Ansible is 120 characters.
This check always fails on my machine: `self.principals == None`, `principals == ['(none)']`
i would just keep a templar object and change 'get_handler_templar' to get variables and set it, avoids creating N templar objects and the 'dummy' becomes the main templar object.
This should be an error by default, created #17902 to allow this to be configurable so this change should be removed from here.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
I know, was just wondering if it's intended that it works that way.
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
`datastore.name` requires access to the datastore itself, and thus might throw a permission error. This value should be wrapped in a try/except.
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
+1 for to_text
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
These probably belong in the same section ```suggestion ```
```suggestion if not six.PY2: ```
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
Net new tests should be "pytest style tests" rather than "unittest style tests".
```suggestion """Test that a new lock can be created within a Process.""" ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
Not needed as you have `required=True`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_one_of ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
why do you need to use StopIteration etc? I think for item in response will handle the iteration including paged result.
just don't know exactly what's in the properties :-)
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
you can create entire dictionary at once
there could be a function to convert entire list, as this code is repeated below
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion cpu_facts['processor_threads_per_core'] = int(data[1]) ```
I think this should be using mock.patch? iirc, this can leave ansible.module_utils.facts.system.pkg_mgr monkeypatched to be a mock for the rest of the tests.
Need to import reduce from ansible.module_utils.six.moves.
Not sure if we need `normalize_interface` when fetching interface names from running-config.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
Please check this.
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove deprecated parameters as this is new module.
Please remove this line.
Please remove this line.
Please rewrite as ``` if __name__ == '__main__': main() ```
Please add `, no_log=True`
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
This block would be a bit more legible, if you checked use_hostnames, then assigned to a temp variable whichever label the user has requested, and then appended that. Something like (pseudopython): ``` this_host = host if not use_hostnames: this_host = ip if frontend: frontends.append(this_host) else: backends.append(this_host) ``` This is admittedly a style thing, but I think it would be more readable/shorten a few lines.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
No need to quote this value.
No need to quote.
No need to quote.
No need to quote.
The more the merrier. Take that literally, because if you have 2 maintainers adding 'shipit' to a PR, the PR is automatically merged. That means you need at least three maintainers if one of the maintainer creates a PR.
Okay, let's do this.
Now that there are two lines, "it" is a bit unclear. I'd change this to "Setting C(default) to C(yes) causes an error if the path is a file."
Just a note... We probably won't run into problems here as don't currently have symlinks with non-ascii filenames but this would be an issue if we did. I can't remember all the permutations between py2.6 and py3 but I think we'd either have to play around with the ensure_ascii and encoding arguments of json.load or do our own encoding and decoding and probably go back to f.write() and f.read() instead of using json.dump() and json.load(). I'm mentioning it since there's definitely places in the ansible code itself, where that is an issue so it's not a safe refactor in general.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
I think there might still be a concern of a race condition, between the check, and the creation. I know @abadger had some concerns as well.
Readability-wise, it'd be cleaner to put this block into a helper function that would raise a unified exception in case of any failures. Then, the calling side would just catch it and process it in one place. Decoupling the error processing into a separate if-block is prone to future refactoring attempts potentially changing the logic (b/c of human error).
I'd include a message, something like: ```python raise Exception('Missing Placebo recordings in directory: %s' % recordings_path) ```
makedirs_safe already does this, just use that function
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
Probably need to ensure this is a list or a set. ```yaml - name: flush my_handler meta: name: flush_handlers filter: my_handler ```
Squashing is fine in this case, I think, if a list of lists is effectively just another way of writing a list e.g. sometimes you might want to do: ``` yum: name: "{{item}}" state: present with_items: - "{{list_of_default_rpms}}" - "{{list_of_custom_rpms}}" ``` You can use union to join the lists of course, but I'm not sure what other use case drives this test that isn't amenable to squashing
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
Would this ever return false under normal circumstances? Seems like we'd lose items if it did...
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
So you added an extra maintainer. Very good :+1:
The more the merrier. Take that literally, because if you have 2 maintainers adding 'shipit' to a PR, the PR is automatically merged. That means you need at least three maintainers if one of the maintainer creates a PR.
The quotes here are unneeded and unwanted actually.
No need to quote strings in YAML. (unless it's yes, no or null I guess)
No need to quote this value.
This should use `ansible.utils.path.unfrackpath`.
Sorry I gave you the wrong function name (`unfrack_path`) initially.
`os.path.expanduser()` never expands tilde unless at the beginning of the string: ```python In [1]: import os.path In [2]: os.path.expanduser('~') Out[2]: '/home/wk' In [3]: os.path.expanduser('/~') Out[3]: '/~' In [4]: os.path.expanduser('http://~') Out[4]: 'http://~' ``` meaning there's no point in having this check
Also, add ```vmodl.fault.SystemError``` here,
No, I mean ``` except (vmodl.fault.SystemError, Exception) as e: ```
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
(nitpick) ```suggestion 6: 'Host public key is unknown. sshpass exits without confirming the new key.', ```
The method does nothing, should not this method be removed ? * [X] Done
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
If you use `env_fallback` then you don't require this check.
Use same `env_fallback` as `X_AUTH_TOKEN`
```suggestion possible_names.extend([context.redirect_list[-1], context.plugin_resolved_name]) ```
Are you only doing this to support Python 2.6? Those keys are already unique.
That should only be called if the plugin should in `enabled` state afterwards.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
```python for line_number, line in enumerate(lines, 1): ```
(and there's no need to have this var outside or this loop or increment it manually, then)
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
With cliconf the `get_config()` implementation and other similar api implementation is moved to platform-specific cliconf plugins [here](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/cliconf).
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
space looks unnecessary
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
This could use more explanation.
'id' is also a python built in, so it may be better to not shadow it here. In this code, it doesn't look like it would cause any problems however. But, then that would also be inconsistent with the rest of the module args and REST api names. So either way is ok with me, just pointing it out. I think if I was going to try to avoid it, I might add a dict or class that maps the local ansible module arg name to the remote rest api name, but that might be overkill, so not suggesting this as required change. But maybe something like: ``` python api_map = {'id': 'id', 'direct_access_grants_enabled': 'directAccessGrantsEnabled', # other names hre } ``` so code could do something like: ``` python if api_map['client_id'] not in updated_client: stuff() ``` Probably overkill, but also might provide some isolation against potential keycloak rest api name changes. Not worried about it now though so not a blocker for merge.
Nowadays we list all the functionality we use from a specific library explicitly. So: ```python from ansible.module_utils.basic import AnsibleModule ```
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
Should also be "path"
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
Lets see if this is better: ``` This option allows ansible to fallback to unsafe methods, when all safe methods fail```
This should be: ```yaml type: bool ```
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
This should really be a `dict` with `suboptions`.
this is too aggressive as it removes all ACLs, not just the ones we added take into account that directories can have 'default acl' to be added to all new files in a directory, this would wipe those along with the one we added to copy the file into place
Yes, please remove the return and update the caller.
Don't assign a lambda function, use def
Remove this since it doesn't do anything and `Mock` isn't defined.
This doesn't match because your test uses `http://` instead of `https://`.
So, is there a plan later to use include_private ? (as the current patch don't use it)
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
remote_src is a boolean, but you are using it as a path here, I think you have confused how this feature works elsewhere. it is just a flag indicating that project_src is on the target (True) or on the controller (False) look at copy or assemble to get this working right.
I think this formulation is a bit better. In particularly because docker might add other values for this option in the future :)
Can you update the PR accordingly? I guess we can merge it then.
```suggestion - Set the user namespace mode for the container. Currently, the only valid value is C(host). ```
The corresponding option for restart is called `force_restart`. Calling this one `force_recreate` would be much better.
Please, at most one alias, even better none. Having a long list of aliases is really bad UX IMO.
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
This `.close()` isn't needed, the context manager closes the file automatically.
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
```suggestion flag = fcntl.fcntl(fd, fcntl.F_GETFL) ```
aviod -> avoid
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
This should probably be `docker.exec_command()`
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
Please ignore, the param will be set to False when not specified
I'd rephrase: 'Obtain data of `vm_name` if specified, ...'
There are other parameter to find an existing VM using `get_vm` API such as `moid`, `uuid` and a helper parameter `use_instance_uuid`, it would be great if we can implement these parameters as well. This will make all guest module parameters equal and this module future proof.
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
IMHO there should be a possibility to use a different location for the credentials. This will be important for the integration tests and could be read from the environment variables and/or from the configuration in the playbook.
Also you'll want to use a `path` type on that parameter, so that Ansible's pre-validation on paths can be used.
`required=False` and `default=None` are defaults so you can eliminate them in every case below
Generally I'm not so happy with this long list of if statements. What I would rather have is a set of named objects (like the `eg.policy`) and a set of lists of relevant parameters (`eg_policy_params=['policy_name', 'namespace....`) and then iterate through the list to build the object from the original policy object. I think this would be easier to maintain in future.
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
Since this might be nested-vars, or the user may supply a relative path. To make sure you handle this var well, also use `expanduser` and `expandvars`.
Isn't it missing a whitespace ? Are you sure environ is defined here ? I don't see it. Perhaps this would work too, if you do want OVIRT_URL= to override kwargs['url']: kwargs['url'] = environ.get('OVIRT_URL', kwargs['url']) Example: $ A= python -c 'import os; print os.environ.get("A", "X")' (we get an empty string) If you do not want OVIRT_URL= to override kwargs['url'], then you can use or: kwargs['url'] = os.environ.get('OVIRT_URL') or kwargs['url'] Example: $ A= python -c 'import os; print os.environ.get("A") or "X"' X (we get the value that's at the right of or) Hope this helps
Why not leverage .setdefault here ? ``` kwargs.setdefault('url', os.environ.get('OVIRT_URL')) kwargs.setdefault('username', os.environ.get('OVIRT_USERNAME')) kwargs.setdefault('password', os.environ.get('OVIRT_PASSWORD')) ``` ï¿¼
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
change 'type(job).__name__.lower()' to just 'job' no need to do it generic here
you need to skip value from parent if include_tasks/include_role, but still inherit
```suggestion # just get value from attribute itself as normal ```
should be list(attr.items())[0] to work with python3 too. ``` An exception occurred during task execution. The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 310, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 280, in main attrs = EcsAttributes(module, attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 131, in __init__ self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 151, in _parse_attrs name, value = attr.items()[0] TypeError: 'dict_items' object does not support indexing fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 310, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 280, in main\n attrs = EcsAttributes(module, attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 131, in __init__\n self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 151, in _parse_attrs\n name, value = attr.items()[0]\nTypeError: 'dict_items' object does not support indexing\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ********************************************************************* localhost : ok=0 changed=0 unreachable=0 failed=1 ```
If `name` is an alias of `display_name`, and the user sets `name: xxx`, `params['display_name']` will be `'xxx'`. Ansible does that internally so no module has to do that.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
It is highly recommended to use `assert` statements in the pytest env because it integrates with its reporting better and more natively. ```suggestion assert len(ret) == 3 ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
well, maybe. I haven't checked what `.absolute()` does.
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Yes, 'msg' key and value should always present on *_exit() calls
This is a private function (starts with an underscore) so I'd hope we could move this without having to leave a stub for backwards compatibility. If you want to remove the stub in a separate commit/PR just in case, though, I can live with that.
does not resolve inheritance https://github.com/ansible/ansible/issues/25097
Upon further reflection, I think these three lines along with `check_mutually_exclusive` are erroneous for subspecs. We don't currently have a way to specify `required_if/one_of/together` or `mutually_exclusive` for subspecs, so in every case *but* the networking "aggregate" thing, this is severely broken (as you'd be making nonsensical checks in most cases)
this seems like it should be shared with the main one rather than duplicated here
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
add `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` to ensure all commands have an expected LANG
Use ```python cmd = "%s box list" % self.module.get_bin_path('vagrant', required=True) ```
Required is False by-default, so no need to describe explicitly in docs.
Line is too long.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
this is a property as well
Do we have PEP257 linter in CI? It should've failed here.
Make this a regular function
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
Yes, we will remove old style while remove it all together. Let me know if it works for you.
```suggestion elif date_string.match(self.when): ```
```suggestion @pytest.mark.parametrize( 'mocked_version', ( '', ' (devel 8a202cae3e) last updated 2021/01/11 10:24:38 (GMT +200)', ), ids=('plain', 'scm'), ) def test_ansible_version(capsys, monkeypatch, mocked_version): monkeypatch.setattr( 'ansible.cli.arguments.option_helpers._git_repo_info', lambda repo_path: mocked_version, ) ```
Also, since you mock the version, you could as well just do an equality check instead of a pattern matching
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
Instead of checking the entire version string, lets just remove the `$` from the regex.
okay, but it still find it misleading from reader's point of view. i think, it's important to make it better maintainable. P.S. I've hid concat based implementation, once noticed that it's not only about lists (which was not obvious).
Oh, and it's `KeyError` for dict.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
This is more efficient: ```suggestion key = next(iter(old[0]) ```
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Why only autoexpand and autoreplace are added as an option? I can see a value of having all or nothing and just use sets.
```suggestion - Automatically replace a bad device in pool using a spare device. ```
```suggestion - Whether to enable or disable automatic pool expansion when a larger disk replaces a smaller disk. ```
Please provide a default for autoreplace.
```suggestion - Set options for existing pools. ```
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
Another regex that can be precompiled.
`results[mount]['info']['note']`must be changed here, because `res.get()` contains no information about the timeout happened here, e.g. `'Timed out while attempting to get extra information: %s.' % (to_text(res.get()))` Also a `self.module.warn('Timed out while attempting to get extra information for mount %s: %s.' % (mount, to_text(res.get())))` should be added here, otherwise the information that a timeout happened is only in the facts note, and so mostly hidden from the user.
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I've started work here to create a separate nlb module and move common code https://github.com/wimnat/ansible/tree/feature/elb_network_lb
@wimnat Are you able to work on elb_network_lb for 2.5? If you have enough on your plate already I'll work on top of your start and open a PR.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Please add the kwarg `exception=traceback.format_exc()` to this failure.
It's worth catching BotoCoreError rather than NoCredentialsError (as that will catch ParameterValidation exceptions too).
```suggestion if not six.PY2: ```
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
```suggestion """Test that a new lock can be created within a Process.""" ```
Having such complex logic inside of tests makes them fragile. You may want to consider just using `@pytest.mark.skipif(six.PY2)`.
I don't think another var is necessary. If the first iteration to start the processes succeeds and won't interrupt the control flow, all of them will be active. ```suggestion processes = [ Process(target=_run_threads, args=(_,)) for _ in range(1, 6) ] for t in processes: t.daemon = True t.start() for t in processes: t.join() ```
Add note here saying - "'SRV' is added in version 2.7"
The impression I have gotten is that A6 records aren't used at all these days. There is also the following informational [RFC 6563: Moving A6 to Historic Status](https://tools.ietf.org/html/rfc6563) Hence I believe that listing A6 records only has the potential to cause confusion. Unless I'm wrong, and there actually are people who use A6 records today.
Same as above. ``` params.get('value') not in ['', None] ```
You could add here an example to add a record to main A record => mydomain.com
I would write it as `RECORDSET_VALUE_MAP = dict(...) if HAS_AZURE else {}`
```suggestion - Control DHCP autoconfiguration for IPv4. Disabled by default. ```
```suggestion - Control DHCP autoconfiguration for IPv4. Disabled by default. ```
Simplify that description, it is too redundant as-is.
The name of that parameter is bad, it's simply âDNS search domainsâ. Perhaps `search-domains`, or `resolvconf-domains` (but then rename `nameserver-addresses` to `resolvconf-addresses`)
Shorten to `mac` or use hyphens consistently (`mac-address`).
Most of these options are handled from the connection plugin, and are not necessary here. In particular, you should not need to define `host`, `username`, `password`, `use_ssl`, or `timeout`. and you don't appear to be using the actual plugin option framework for any of them anyway (none of them have `env`, `ini`, or `vars` keys, so they can't be set directly).
Please remove `required=False` that's the default
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
`If not specified, will fall back to the C(MCP_USER) environment variable or credentials specified in C(~/.dimensiondata).`
Please update formatting as per `mcp_user`
the community has decided that modules should be named "_facts" when providing host facts, otherwise the sufix should be _info. That is why this module should be renamed `cs_resourcelimit_info`
also replace the word "facts" with "info" in the docs
Perhaps we could add an example to show how to list zones (without filtering).
correction: It's not a byte string, it's a raw-string literal
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
You can raise from here.
not worried about the else vs indent, its more of a style issue
This was already in pre-existing code, but it doesn't seem like the 'else:' is necessary here, and the rest of the method can lose an indention level.
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
It looks like there may be an issue with the tests. I've restarted the failed test.
Yeah - I get the idea of "take a config and use it" but I think that's a touchy enough project that I'd rather have users transfer stuff either through facts or manually, since I can see a lot of weird edge cases being a problem with a "duplicate" command.
State should be required
Maybe C(.pem)? I'm not sure you need to specify that .pem is a file type since it's just the extension. @gundalow might know.
To share code between modules, please use module_utils instead of importing other modules directly.
Using AnsibleAWSModule also means you can remove importing HAS_BOTO3 and the HAS_BOTO3 check, as the module checks it.
This can be removed, just add required =True in `acs_common_argument_spec`
```suggestion type: str default: https://intersight.com/api/v1 ```
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
Please only import what you need, and not `*`
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
Missing full stop
this is a common return, please remove it.
Use `camel_dict_to_snake_dict` to return results in standard Ansible format.
this should not be happening here, play_context should have all pertinent connection info
This is actually one reason you want to use `MutableMapping` over subclassing `dict`. `.get()` does not use `.__getitem__()` in `dict`. Both methods duplicate code for performance: ```pycon >>> class VarsWithSources(dict): ... def __getitem__(self, key): ... val = super(VarsWithSources, self).__getitem__(key) ... print(('__getitem__', val)) ... return val ... >>> v = VarsWithSources() >>> v['foo'] = 'bar' >>> v['foo'] ('__getitem__', 'bar') 'bar' >>> v.get('foo') 'bar' ``` Notice that `.get()` doesn't cause the print to happen. As such, your implementation as is will only work with some accesses of keys, and not others.
Cosmetic: ```suggestion ''' Alternate constructor to instantiate class with sources ''' ``` A bit more informative about what the method is intended to be used for.
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
Do you think we should remove internal variable too. ```python host_vars = self._get_host_variables(host) if host_vars: self._remove_internal(host_vars) result.extend(self._show_vars(host_vars, depth + 1)) ```
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
Try except blocks souls he as small as possible
This should be supports_check_mode=False.
nit-picky optimization, but if the prior step was successful then 'id' should already be in `result` Also, if the state is "absent", then you need to be sure that you don't hit this code. Either that, or it should throw an error if schema is provided and state is absent.
Try except blocks should be as small as possible. In this case, if is only needed around the calls to modify and delete. Perhaps put the try except around the if state conditional to limit the statements that it surrounds
Drop the extra "Mac" here.
One last thing I thought of: it may be good to catch `AttributeError` and `ValueError` if an invalid value is passed for `namespace`. Otherwise we get a stacktrace. ```suggestion try: uuid_namespace = uuid.UUID(namespace) except (AttributeError, ValueError) as e: raise AnsibleFilterError("Invalid value '%s' for 'namespace': %s" % (to_native(namespace), to_native(e))) ```
```suggestion return to_text(uuid.uuid5(uuid_namespace, to_text(string))) ```
```suggestion uuid_namespace = namespace if not isinstance(namespace, uuid.UUID): uuid_namespace = uuid.UUID(namespace) ```
Values returned from filters should use `to_tex()` for Python 2/3 compatibility. ```suggestion return to_text(uuid.uuid5(uuid_namespace, str(string))) ```
trivial but you can just do: ``` python path = expanduser("~/.azure/credentials") ``` so that you only allocate a string once instead of three times. (+= creates a new string)
Another py3 porting note for 2.2 and beyond: if you don't need to use `.iteritems()` (because the number of entries would be small) just use `.items()`. If you do need to use iteritems because the items take up a lot of memory, in 2.2 we'll be adding ansible.module_utils.six which has an iteritems function to replace the dict method.
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
It's almost always better to do this instead: ``` python except Exception as exc: self.log(str(exc)) raise ``` By using raise all by itself in the exception handler, the exaclt exception you caught will be continued up the stack. raising the exception again like this: ``` raise exc ``` Will change the stack trace and doing it as you have it here will additionally change the exception type (which can be good in some circumstances but probably isn't what you want here since you'd just be changing it to the Exception base class.)
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
Or did you mean ```suggestion raise exc from None ```
I'm fine with the change in message, just noting that this test needs to be fixed up to check the new assertion https://github.com/ansible/ansible/blob/cf39d9de258cb9c47de9043e1a85e327e177dba7/test/integration/targets/ansible-galaxy-collection/tasks/install.yml#L43.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
Is this even needed, we will be dropping py2 and `to_text` does not call `__unicode__`. You may as well just put this in `__str__`.
How about: ```suggestion if not os.path.exists(file_path): continue ```
right now, this would need to be version_added: '2.6'
typo: thier -> 'their'
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
the brackets in the URL itself cause issues when rendering this, just remove the `(v=vs.110)` and it will still work
I'm curious as to whether this needs to be in upper case or if it works in lower case as well.
When changes need to be made to docs that are in need of reformatting and/or cleanup, I've found it very helpful to perform all the cleanup first. You can then open a PR for the cleanup and base your second PR on the first (if not waiting for the first to be merged). Alternatively, if using a single PR, at least make the docs cleanup in a separate commit. Doing either of those greatly simplifies the review process.
just import `AnsibleModule` here
You should try to follow pep8. Therefore, the spacing here isn't required. Also, applies to the rest of the dict
remove these if not required
This is unnecessary, by default AnsibleAWSModule automatically merges the spec you pass it with ec2_argument_spec().
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Oh, I see it's addressed now.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Why add another level of nesting with a list? Just have a dict comprehension.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
I don't see these files
```suggestion version_added: '2.8' ```
Ansible 2.8 isn't supporting Python < 2.6 anymore, so this line is no longer needed.
This needs to be C(validate_certs) which is the standardized parameter name.
`Name of the cluster from which all child datastores need to be managed` I find this a bit weird, btw... clusters do not really have datastores directly as children, only datacenters have datastores directly: You can not create a datastore specific to a cluster, you create datastores on the datacenter, and connect hosts to them. I assume the `cluster.datastores` just lists all datastores that are connected to hosts in that cluster. Personally, it would make more sense to use datacenter as a grouping parameter instead of cluster (but that might also be a bit excessive, as that would put all datastores in maintenance mode in a DC, basically preventing any VM to run at all...)
Do we want errors with this? ```suggestion compiled = compile(parsed_tree, to_native(expr, errors='surrogate_or_strict'), 'eval') ```
Ok, that makes sense. Thanks for the great explanation.
Got it. But this is very confusing error message. anyways, not a blocker as such.
Can we add a `key` name as well ? It is very confusing message if we have multiple warnings like this - ``` [WARNING]: The value 600 (type int) in a string field was converted to u'600' (type string). If this does not look like what you expect, quote the entire value to ensure it does not change. [WARNING]: The value {'Name': 'aws-blorp_rhel7'} (type dict) in a string field was converted to u"{'Name': 'aws-blorp_rhel8'}" (type string). If this does not look like what you expect, quote the entire value to ensure it does not change. [WARNING]: The value 300 (type int) in a string field was converted to u'300' (type string). If this does not look like what you expect, quote the entire value to ensure it does not change. ``` Maybe something like - ```suggestion msg = ('The value {0!r} (type {0.__class__.__name__}) in a string field of argument {1} was converted to {2!r} (type string). ' ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
```suggestion default: no ```
```suggestion - Whether to remove or define a device including child devices. ```
```suggestion default: no ```
```suggestion required: true type: str ```
```suggestion - Use C(all) to rescan all C(present) devices (AIX cfgmgr command). ```
would you mind minimalizing the example for state=absent to the things required: ~~~yaml - name: Remove a vpc offering local_action: module: cs_vpc_offering name: my_vpc_offering state: absent ~~~
would you mind change this to the following? ~~~ 'roleid': 'role_id', ~~~
shouldn't this be like the following? ~~~python if rule == _rule['rule'] or rule == _rule['id']: ~~~
there is a helper function `has_changed()` for that, which also handles --diff https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/cloudstack.py#L149
This and the following update should only be executed if there is a change.
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
Should be a parameter of the task itself and not the module
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
```suggestion - List of supported values maintained at U(https://docs.microsoft.com/en-us/rest/api/appservice/webapps/createorupdate#scmtype). ```
```suggestion - Name of container, for example C(imagename:tag). ```
```suggestion - Sample values for C(Tomcat), C(8.0), C(8.5), C(9.0). For C(Jetty,), C(9.1), C(9.3). ```
```suggestion - Supported only when I(frameworks=java). ```
```suggestion - Supported only when I(frameworks=java). Sample values C(Tomcat), C(Jetty). ```
but this all in a try/except/pass to avoid leaving other temp dirs if one fails all way through
ignore if it is missing, warn if we fail to remove
I'm not sure we want to traceback on a failure to remove the tmpdir. We should probably wrap this in a try/except, and either explicitly ignore the exception, or warn.
probably want a to_text and u prefix.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
This `else` branch is unecessary cruft, remove it.
It's unclear from the name what this is (or even that it's supposed to be a URL). Please rename.
`deepcopy` is unused
`exec_command` is unused
this can be initialized to `result = {'changed': False}`
Missing `self.uuid_type = self.params['uuid_type']` in `__init__`
Remove trailing space here.
```suggestion - Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance. ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
@webknjaz I don't believe anyone has said it's dangerous. It's discouraged.... the Python idiom is "consenting adults" meaning, use the single underscore convention to tell people not to use something rather than trying to outright stop them. The double underscore isn't really an attempt for private methods and variables (the automatic rename is just another convention to be followed if you really need access, for instance), it's meant to prevent conflicts between methods in things like helper methods for mixin classes (ie: you have a mixin that's generic and could be used with other classes that you don't control. Using double underscore there makes it so the other class doesn't accidentally overwrite the mixin's private methods.) I would say that our style probably should be to use single underscores to denote private methods and attributes but I would not go so far as to say that double leading underscores are "dangerous".
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
```python for line_number, line in enumerate(lines, 1): ```
Handle NoCredentialsError as well
Should probably use a [paginator](http://boto3.readthedocs.io/en/latest/reference/services/route53.html#paginators) here to support large accounts.
facts modules can trivially support check mode (#23107)
botocore.exceptions.PartialCredentialsError can also occur on connection creation.
boto3_conn now copes with RegionNotFound errors for you
```python cmd += ''.join(' "%s"' % d for d in distributions) ```
I believe @abadger meant this place. So you basically want to use `to_native()` instead.
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
I'd prefer ```python # a generator expression: cmd.extend(str(p) for p in packages) # or: cmd.extend(map(str, packages)) ```
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
Why is support for `-` being removed? Doing so doesn't seem to be required to implement support for symbolic links.
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
and convert filename to bytes again.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
this should be a common function in basic.py (i think there is this one or the reverse there already)
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
I am not clear as to why `before` `hostname` and `vmnic` are required, whatever the input parameters can be obtained from `module.params`
SR-IOV can be enabled only if `C(num_virt_func) > 0.`
optional parameter, related to `C(num_virt_func)`.
If we are creating a new module then why to add old parameters which we don't want in first place.
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
You should always have `type='str'` (or whatever type you have) in all of argument spec.
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
I think it's not good style to use `global`.
`changed = True` should also happen in this branch.
You should handle check mode here!
No longer needed
Once you replace the connection block below with module.client('ec2') you don't need these 3 imports...
While I think this is correct I'm not sure if it uses no proxy or the default proxy configured in the IE settings. I don't have easy access to an environment with a proxy configured so I can't test this assumption.
```suggestion - There is a small delay (typically about 5 seconds, but can be as long as 60 seconds) before obtaining the random values when requesting a validation ```
```suggestion - There is a small delay (typically about 5 seconds, but can be as long as 30 seconds) before obtaining the random values when requesting a validation. ```
Period at end.
Period at end.
`A list of virtual machine names starting with the given regex`
A sample of output would be helpful.
Can be removed, indeed, check other newer modules :)
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
You should use `module.get_bin_path('ssh-keygen', True)`.
When this message is printed, it will contain a newline followed by a lot of spaces. You should compose it as follows: ``` .py module.fail_json(msg=('For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. ' 'Attempting to use bit lengths under 1024 will cause the module to fail.')) ```
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
Yes, good catch. We can delete one of the two functions, they are now identical.
Remove this line.
```suggestion if not datacenter: ```
if self.state == "absent" should be explicitly checked before unregistering the VM, just to be safe.
```suggestion if not dcpath.endswith("/"): ```
```suggestion if self.state == "present": ```
Ok, I am confused, about it being a 3rd level dict (and why that even matters) and it being complicated (why ?). Even if it is under hardware it could be a separate spec, I don't see why that would matter. To me putting everything as a top-level parameter is problematic, that's why we introduced the hardware parameter in the first place. The problem here is that if people add it the way they prefer, things will become very inconsistent (and I guess this is why we are having that discussion now, again).
You are right, it's not consistent as-is. @Akasurde What is the direction we are taking this ? Also, we should also define a sub-spec for the hardware-parameter at some point.
Add a note that while cloning from template, editing floppy setting is not allowed.
The message is a bit confusing, Could you just write something like "Only C(ide) controller are supported for CD-ROM".
This is malformed compared to other entries.
host and verify_ssl are common settings in module auth, see other cloud/api modules for same. we normally have auth at module level and optionally at config file/env as options.
if requied is true, default does not make sense
> set the default to be True (that way user have to force into an insecure setup, that's how other modules work) By default tower-cli will assume True by the same reasoning. The net effect after making that change should be the same.
i would consider moving this to a module_utils/tower as I expect other modules will need to use the same auth
this is a bad pattern for a module, change to detect dict or string (assume path)
I'd use `elif` here.
This is wrong, already explained.
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
This won't work if 'name' is an alias, rather than the parameter name.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
changed is displayed as False by default so you don't even need to specify it at all. Can delete this line.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
Formatting nitpick. You can add this to the line above.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
I've tried your branch on my local grafana with the `json.loads` fix. If I import an existing dashboard (previously in general folder) it will be moved to the specified folder. but the module is not idempotent anymore. If I re-run the playbook the task will return a `changed` status even if the dashboard json file has no changes.
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Uses of `{}` should be updated with positions as this will be incompatible with python 2.6. This applies through the code base. e.g. `'{0}'.format('foo')`
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
Make that `elif:`
We should plan a cleanup of the module signature and start using sub options, that way, something like this can be captured early
Also, if the disk already exist, 'autoselect_datastore' shouldn't modify the disk.
`if expect_disk_spec.get('autoselect_datastore', False):`
add ``` datastore = None ```
That should already be the case except where 'python stringification' takes place, ... which affects fields like Default but not most others. Removing the python stringification would make it match.
I'd like to not pull SEQUENCETYPE into this file but this one is a little tricky. A Mapping is an iterable and we have a separate conditional block to work with those. If we just check for collections.abc.Sequence then we wouldn't catch things like sets and keyview.... I think what we can do is put the Mapping conditional before this one and then change this one to ```if is_iterable(obj)```.
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
~if not keeping encryption, remove the __ansible_vault key, just assign the value directly~ nmvd, misread the if to the opposite ...
It seems like no_log and deprecation are separate things and should be handled in separate functions.
add ``` version_added: 2.8 ```
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
from 4.4 there is `cluster_default` maybe remove the default option and keep it None
same here (remove the `is True`)
also, merge the two level of `if`. ``` if self.params.get('secure_boot_enabled') and self.params.get('boot_firmware') is None and self.vm.config.firmware == 'bios': â¦ ```
I don't see why `chmod` should be necessary considering `module.set_fs_attributes_if_different` is used.
You're not setting the owner of the file until the end of this module (through `module.set_fs_attributes_if_different()`). I'd rather only change the mode to `self.mode` after writing the sensitive data, so that any early abort without cleanup will result in a key only being readable by the user `root` (and not any groups, for example).
This line should still be there (though probably one line down), while...
I wouldn't consider it the most elegant code, but it at least has no chance of exposing the private key with a wrong mode. I am not really concerned about in essence creating an empty file first. Performance wise, yes it'll be slower but I bet that the by far limiting factor of this module (next to network latency) is the private key generation, not a few filesystem calls. If this is actually of concern, the `_symbolic_mode_to_octal` function is something that might need a further look to work without a lstat call. For now I'd prefer @abadger's solution in combination with a default `0o600` mode - maaaaaybe even setting the initial mode already in `privatekey_file = os.open(self.path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)` hardcoded to `0o600`.
`0o600` is more readable than `384`.
Putting this under a conditional makes it undefined under the opposite condition.
The phrase "unless within a playbook adjacent collections directory" is a mouthful. It's also not immediately apparent what that means unless the reader is well versed in Ansible jargon. > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection may not be picked up in an Ansible run. If there is a strong desire to mention adjacency (I know this was explicitly requested in the related issue, but I don't think it's the clearest phrasing), then something like this is probably best: > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection will not be picked up in an Ansible run unless adjacent to a playbook.
If an unknown keyword is specified, `kdata` has not yet been assigned at this point.
to_text and prefix the string with u.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
Empty proxy-init doesn't make sense and should be removed.
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
the default had to allow for '3rd party callback' subclassing and not using the new config framework
you don't need the constant, the config definition above already covers this
I feel like this changes too much, for what could be achieved with less: ```diff diff --git a/lib/ansible/plugins/callback/json.py b/lib/ansible/plugins/callback/json.py index 3961a78aab..fd344a0cf0 100644 --- a/lib/ansible/plugins/callback/json.py +++ b/lib/ansible/plugins/callback/json.py @@ -101,14 +101,16 @@ class CallbackModule(CallbackBase): summary[h] = s custom_stats = {} + global_custom_stats = {} if self.get_option('show_custom_stats') and stats.custom: custom_stats.update(dict((self._convert_host_to_name(k), v) for k, v in stats.custom.items())) - custom_stats.pop('_run', None) + global_custom_stats.update(custom_stats.pop('_run', {})) output = { 'plays': self.results, 'stats': summary, 'custom_stats': custom_stats, + 'global_custom_stats': global_custom_stats, } self._display.display(json.dumps(output, indent=4, sort_keys=True)) ```
Is the `sorted()` actually useful here? You're adding the keys to a standard python dict, which is unsorted by nature.
Since we're making msg unicode above we need to do the same here: ``` python msg += u"\n{0:-<79}".format('{0} '.format(result['path'])) ```
there is a missing condition for check mode
there is a missing condition for check mode
OK, not a blocker anyway.
there is a missing condition for check mode
Can you please include `uuid` as parameter for finding VM ? you can use `find_by_vm_id` API for finding VM using uuid just like other VMware modules do.
```suggestion - The plugin also sets standard host variable I(ansible_ssh_common_args) to C(-o StrictHostKeyChecking=no). ``` C(...) is also commonly used for general "code"/"teletype" markings
```suggestion - The plugin also sets standard host variable ansible_ssh_common_args to '-o StrictHostKeyChecking=no'. ``` Same in the line below.
First, use `yes`/`no` or `true`/`false` for booleans in YAML, not `True`/`False` or other of the myriad allowed forms. Second, don't add `required: false`; only specify `required` if it is `yes`/`true`.
You should add something on how the labels look and into what they are converted. That makes it easier for people to understand how this feature works.
```suggestion description: when true, include all available nodes metadata (e.g. Image, Region, Size) as a JSON object named C(docker_machine_node_attributes). ```
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
```suggestion ``` I don't think you should do this, case is meaningful: ``` max@mde-oxalide % pacman -Q libreoffice-en-US libreoffice-fresh 6.1.3-1 max@mde-oxalide % pacman -Q libreoffice-en-us error: package 'libreoffice-en-us' was not found ```
```suggestion cmd = "%s --query --quiet --explicit --info" % pacman_path ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
use a list type .. since that is what you want
I would really like to pull @matburt into the decision-making on this matter. It's not just the sourcing from the env var here, but also the use of the `license_type` parameter once it's received. What does this mean in practice? I think users would expect to be able to use the plugin as a part of the Ansible core CLI with any given type of target AWX or Tower instance.
```suggestion for key, value in self.parameters.plugin_options.items(): ```
set type to 'path'
You should set the default value for this like ``` create_mode: description: - ... choices: - ... - ... default: default ```
s/createMode/I(create_mode)/ When referencing other options, enclose it in `I()` and the docs will do the formatting for you.
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
This really needs to be split up instead of just one long paragraph that seems copied from the Azure Docs. Set each options under the options key and Create a new description category for each option. ``` create_mode: description: - Specifies the mode of data creation. - When C(default) means a regular database creation. - When C(copy) will create a database as a copy of an existing data. I(source_database_id) must be specified. - When C()..... default: default options: - default - copy - non_readable_secondary - online_secondary - point_in_time_restore - recovery - restore - restore_long_term_retention_backup ``` I would also convert the options to use snake_cake and not CamelCase as that is what Ansible usually does.
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
Typically speaking, using `lower_case_with_underscores` is preferrable to `headlessCamelCase`. This applies throughout the code base
Make this error more specific to cyberark. A lookup is often used in conjunction with other modules and features, this sounds too generic.
It may be beneficial to clarify that this is cyberark vault, to avoid confusion where someone may think the error is in reference to ansible vault.
This string concatenation is confusing. It should be on a single line, and preferably be updated to look like: ``` 'AppDescs.AppID=%s' % self.appid, ``` There are other instances of this across codebase.
Maybe think about doing: ``` '-o', 'self.output', '-d', 'self.delimiter', ] ``` instead, this is a very long list, and making these changes is likely to make it more readable.
since checksum seems designed to allow for diff hashing algorithms, should this not be configurable depending on which one is used and not just always sha256
This is just an internal implementation and doesn't need to be configurable. It is generating a unique hash of the line and using that as the key rather than using the hash itself as the key. The example from the bug report had a file that used the same hash for different files, which resulted in it reporting it could not find the hash. ``` 80fcaa0ead2d75283613b9d9d8a02f0df76b7cd018153c2454069cb30ebc0fdb rhcos-aws.x86_64.vmdk.gz 80fcaa0ead2d75283613b9d9d8a02f0df76b7cd018153c2454069cb30ebc0fdb rhcos-4.5.6-x86_64-aws.x86_64.vmdk.gz ```
```suggestion # checksum filename ```
Please note that in Python we don't use brackets unless really needed.
I liked generator approach more: it's more readable in terms of separating a distinct logical step from a higher-level flow.
Instead of `str`, we need to allow for unicode: ``` from ansible.module_utils.six import string_types if isinstance(x, string_types): ``` From the `CODING_GUIDELINES.md` doc
If this is a `str` and is cast to `list()` you get: ``` >>> list('foobar') ['f', 'o', 'o', 'b', 'a', 'r'] ``` Needs to be `[statement['Principal']['AWS']]`
I'd rather get rid of the `filter` and `lambda` entirely: ``` valid_entries = [item for item in statement['Principal']['AWS'] if not item.startswith('arn:aws:iam::')] ```
You don't need this conditional, since Ansible enforces that these are the only choices.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
```suggestion short_description: Gather information about Zabbix user ```
```suggestion module: zabbix_user_info ```
pyvmomi only support 2.7+, so you can safely bump to Python version to 2.7
```suggestion version_added: "2.10" ``` The current devel version is 2.10, so I think `version_added` is `2.10`. https://github.com/ansible/ansible/blob/devel/lib/ansible/release.py
Thanks for the quick fix :)
If found this part weird with using `self` for temporary variables
not a blocker, but I don't think this is required, it is a default group, instead I would suggest to add a group `self.inventory.add_group('gitlab_runners')` and in the host loop, put them into this group `self.inventory.add_host(host=self.host, group='gitlab_runners')`
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
Yeah, he also said to use `loads`, not `load`. I remember debugging its internals and it was processing the stream in chunks internally and turned some of them into unicode while keeping the others in bytes and then crashed trying to combine those...
Interesting, I've tested this with BytesIO and it works...
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Yeah, I'd drop the try: except altogether.
I think we should just raise. setup.py is for installing the software. That comes with different assumptions about what you'd want to see than for running the software.
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
For `mode == 'persist'`, you have to both check the current value *and* the value in the `mysqld_auto` config.
I would remove the previous and the current line. If you write `persist_only`, you want to make sure that the variable is set in he `mysqld_auto` config. If it is not set there (but it is set in the running instance), you still want to execute the query.
Why not ```suggestion if mode in ('global', 'persist'): ``` ? :)
How about moving this in the main `if:` branch above? Then there's no need to do funny tricks for `mysqlvar_val` in the `elif:` branch.
Indentation level of `return` statement need to be increased.
*Right now.* But that isn't something that should be depended upon in general and especially if you are creating a subclass of a builtin type. I did recall the non-hacky way to fix this, though. Change the constructor to be dict-compatible and then create an alternate constructor using classmethod to do what you want. Then use the classmethod in your code. Looks like this: ``` python class VarsWithSources(MutableMapping): def __init__(self, data): self.sources = "<Source unset>" super(self, VarsWithSources).__init__(data) @classmethod def new_vars_with_source(cls, data, sources): new_vars_with_source = cls(data) new_vars_with_source.sources = sources return new_vars_with_source ```
And then where you call it you do: ```python VarsWithSources.new_vars_with_source(all_vars, _vars_sources) ```
This is actually one reason you want to use `MutableMapping` over subclassing `dict`. `.get()` does not use `.__getitem__()` in `dict`. Both methods duplicate code for performance: ```pycon >>> class VarsWithSources(dict): ... def __getitem__(self, key): ... val = super(VarsWithSources, self).__getitem__(key) ... print(('__getitem__', val)) ... return val ... >>> v = VarsWithSources() >>> v['foo'] = 'bar' >>> v['foo'] ('__getitem__', 'bar') 'bar' >>> v.get('foo') 'bar' ``` Notice that `.get()` doesn't cause the print to happen. As such, your implementation as is will only work with some accesses of keys, and not others.
Cosmetic: ```suggestion ''' Alternate constructor to instantiate class with sources ''' ``` A bit more informative about what the method is intended to be used for.
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
Please use add `type: bool`
Please add `type: bool`.
Please remove this + from docs. No point releasing something that we will deprecate soon.
Please remove this line.
Please remove this line.
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
All the boto3 client methods in this module should handle BotoCoreError. There are a number of places that need this added.
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
Not required with AnsibleAWSModule
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
Spurious `else:` Breaking the tests.
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
please use explicit import statements
If state: absent and the ip is not there, this raises botocore exception `InvalidAddress.NotFound`.
no need. dependency check done by AnsibleAWSModule
It may not be forward compatible then, but it seems unlikely AWS would change it unless they introduced something new.
```suggestion msg = "Couldn't associate Elastic IP address with instance '{0}'".format(device_id) ```
Ah, it's nice that the syntax checker caught this bug. This should be `network_interface['tags'] = boto3_tag_list_to_ansible_dict(tag_set_copy)`
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
This applies to the other functions where a list is the default value as well.
Can we have a list of packages which can be locked/unlocked? just like yum module does.
use this instead ``` module.get_bin_path('yum', required=True) ```
Please add an example below that shows you how get the newer NuGet provider version.
How about 'absent' as state, which make this module complete.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
`return not owner or owner == publication_info['owner']` could be used.
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
```suggestion sample: false ```
This expression do look a bit suspcious, can you explain a bit more what you try to achieve ? (cause that's if "A and B or A and B" and I am a bit unsure on the order to which I need to evaluate things)
`current_version` could be mentioned in the error message.
host, username, password, timeout and vdom is already in fortios.py in module_utils
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
```python # warn when failing to skip due to lack of support for skipping only some versions display.warning('Including test "%s" which was marked to skip for --windows %s but not %s.' % (target, ', '.join(skip_valid), ', '.join(skip_missing))) ```
Use a separate skip and prune list, as is done in other sanity tests: https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L7-L14 Then check each separately: https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L38-L42
Leftover reference to `vcenter`.
You should be able to use `self.vmware_test_platform` here.
For consistency path pruning should be done the same as in the boilerplate test: https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L13-L14 https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L41-L42
Why don't we return the return_code back to the user ? I think we should also return the command output back to the user, especially if the command failed.
IMO it is better to move this test further up in **_flatpak_command()**. And leave the module through the final **exit_json()** just as if you would if you're not in check_mode.
Should have been module.fail_json
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
Move it down the stack.
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
If the result was a 4xx or 5xx then I think this fails.
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I'd also include a check for server errors (500)
This limits you to 1000 hosts where previously it iterated all the pages.
This needs to go outside of CM. If `ipsubnet` will raise exception it will interrupt code block within `with`.
Please keep your code style consistent: first you assign vars for some time, then you pass lots of function args directly. There's a better way.
fixture with load_json
You could `mock.patch` it to do so :)
my personal preference here is to dump all of these 2.7 specific modules into a Test class that has a pytest decorator of @pytest.skipif(sys.version_info <(2,7)) or whatever the syntax is. By collecting the version specific tests in their own classes, you can avoid this conditional logic in the test itself
As far as I understand functionality of the API, when you sent: ``` PUT /api/clusters/123 <cluster id='123'> <external_network_providers/> </cluster> ``` You will detach the external network providers from the cluster, even if you didn't intent to. I think `_get_external_network_providers_entity` method should return None, in case `self.param('external_network_providers')` is None.
Also it complains about indent here.
Can you please rather add as first line of this method: ```python if self.param('external_network_providers') is None: return True ``` This way we just don't touch anything if user will not pass external providers parameter.
`network = on_service.networks_service().network_service(search_entity().id)`
For add and update as well: ```python self.changed = True if not self._module.check_mode: auth_keys_service.add(auth_key) ```
This is still outstanding
you can just `module.exit_json(changed=changed, parameter_groups=response)`
This method can be simplified to: ``` return [{"ParameterName": str(k), "ParameterValue": str(v)} for (k,v) in params.items] ```
we should be using boto3_conn for all connections. For example, security_token is missing here. boto3_conn avoids you having to worry about that.
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
You could remove this check since `for o in open_ports` should work as well.
Should inst ever be None without being in the process of being created at this point? Wouldn't it be worth waiting for that too? If so you could remove the call to _find_instance_info(client, instance_name) just above and change this conditional.
It looks like if it isn't a permission error or request expired the exceptions are ignored. It would probably be better just to retry on a specific exception or two and otherwise call fail_json than mask undisclosed exceptions.
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
`wait_for=dict(type='list'),` (remove waitfor)
check_mode is True but I don't see any check done around this. Please correct me if I am wrong here.
IMHO this will always return changed as False. `Changed` should be change according to action module performs.
That may have to be `*string_types` and `list(string_types)`. Maybe create `string_types_list = list(string_types)` so you avoid recasting to a list multiple times.
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
plugins should not error on import, capture the fact that it is missing the library and exit on 'parse' also see ` from ansible.basic import missing_required_lib` which gives users specific information.
```suggestion elif date_string.match(self.when): ```
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
Shouldn't have `required: true` for things that have a default.
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
Please do this for all parameters. ```suggestion - The iptables chain in which to insert the direct_rule, used with the C(direct_rule) option. type: str ```
Must be in Sentence case, and IP needs bee upper case. Also it should mention that the default is to be both ipv4 and ipv6.
Is this required anymore now that it is removed from the module.
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
You can delete this line.
instead of changing the example, i would add an additional one, both ways are valid and there are reasons to use a var instead of putting the list directly. Also 'a list' is used on purpose to make clear the 'type' of the option is `list`
We should use bytes with file paths since the text type will vary between Python 2 (`unicode`) and Python 3 (`str`). We also prefix byte strings with `b_` as a convention. ```suggestion self.cron_file = cron_file self.b_cron_file = to_bytes(cron_file, errors='surrogate_or_strict') ``` This likely means there are other places that should use the bytes version of the path that need to be updated.
Mode getstr also returns `contents` in addition to msg.
Same here. ```suggestion self.cron_file = os.path.join('/etc/cron.d', cron_file) self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict')) ```
I don't see the point here, both errors are identical, so why do this ? If it fails you wouldn't even know which one actually failed.
This is wrong. Now if you don't supply login credentials at all, it will error out. So goodbye localhost exception to create the first user. The "elif" branch must not be deleted.
This clause is exactly the same as in the first branch. This branch will never get executed.
You shouldn't use `is`. Just `not mongo_configuration_credentials`.
This snippet looks just like one in `role_find`. It probably deserves being moved into a reusable function.
Please don't return different types of data from a function. It should always be consistent and discourage checking the return value. Unlike low-level C-code, Python provides you with a variety of handy ways to communicate failures to the calling code (like exceptions).
just a minor typo and nothing important, multiple occurrences of 'compaire'
Add "- Works only with >= Zabbix 3.4" same probably goes for other arguments related to `acknowledge_*`
Add "- Works only with >= Zabbix 3.2" same probably goes for other arguments related to `recovery_*`
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Drop the extra "Mac" here.
One last thing I thought of: it may be good to catch `AttributeError` and `ValueError` if an invalid value is passed for `namespace`. Otherwise we get a stacktrace. ```suggestion try: uuid_namespace = uuid.UUID(namespace) except (AttributeError, ValueError) as e: raise AnsibleFilterError("Invalid value '%s' for 'namespace': %s" % (to_native(namespace), to_native(e))) ```
Values returned from filters should use `to_tex()` for Python 2/3 compatibility. ```suggestion return to_text(uuid.uuid5(uuid_namespace, str(string))) ```
```suggestion return to_text(uuid.uuid5(uuid_namespace, to_text(string))) ```
Making this change here doesn't work because we aren't guaranteed to have passlib installed. The crypt.crypt() method will require that we have a salt set. You could move salt generation into the conditional for ```not HAS_PASSLIB```.
This will fail if ```updated_list``` has items which are not present in ```original_list```. You probably want something like this instead: ``` python merged_items[item_key] = items_map.get(item_key, {}) merged_items[item_key].update(item) ```
There's a lot of copying going on here as well. Both on this line and on line 456. Copying is slow so you want to eliminate any that aren't needed.
In python, this is probably better represented as a global dictionary in a separate module (as outlined above). Something like file serviceprovider.py: SPKEYS = { 'ID': 'id', 'NAME': 'name', [..] } ```
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
name of the `route`, not virtual network
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
Probably best to add an entry saying the location is derived from `C(resource_group)` if not specified
`required: false` is the default value, we can omit it here
We should probably also include a sample and/or doc note that shows that the route table is associated via `azure_rm_subnet` - was definitely the simpler choice to implement that way, but we need to tell people where that happens.
This is a personal preference, but I'd rather not have a class name in all caps.
Could be shortened to `return rc == 0` if you're not doing any further processing other than returning.
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
missing `if not self.module.check_mode`
missing `if not self.module.check_mode`
Also, it seems that you don't strip spaces, so if there will be leading spaces it would not match, for example.
This is tricky. It should probably return false because there's no way of knowing whether it's the same version, so we'll need to invoke pip to reinstall it as it does when you run it manually
Why don't you do this right in the `return` line? If you think it's going to be too long, be aware that you can break the line by wrapping it with braces: ```python def _is_valid_distribution_name(name): return ( not name. lstrip(). startswith(('>=', '<=', '!=', '==', '>', '<')) ) ``` (you can put `not` outside of brackets if you like it more this way)
use list literal
I'd probably add `distribution_parts = []` after yield inside of `if` block and then you'd only need `distribution_parts.append(name)` outside of if-block without a need to have diverse code or `else`-block.
no need for is_x, online: yes|no is already clear
we have existing byte/bit functions in module_utils
All descriptions should be full sentences, e.g start with a capital letter and end with a full stop.
new_X is a bad pattern, if you have a unique identifier a comparison of account_id supplied vs existing should determine if this changes or not
CI failure due to: ``` 2017-02-10 20:57:26 ERROR: PEP 8: lib/ansible/modules/storage/netapp/na_cdot_user.py:59:161: E501 line too long (173 > 160 characters) (current) ```
Should not be quoted. It might confuse people to think this is needed. It is not.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
Some stuff complains if the .py file is missing the final LF- can't remember if we hit that anymore or not, but not a bad idea to add it just in case.
+1 to `psexec_command` just for clarity...
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
It would be nice to somehow clarify it's a deep merge. It's not obvious "Any not given will be left at current value" extends down, one could read this as you may omit 2nd level keys but have to provide whole subtrees from 3rd level and below.
This should be configurable in the module arguments.
If we do go with this approach, I feel like `VMDB_PATH` should be user-configurable
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
You probably should just exit here with `changed=False`
Thanks, if you push those changes I can re-review
Doesn't seem to have been done
FYI, all these RETURN items will end up as rows in a table and will not be grouped by default, hardware, etc. I can't think of a better way of doing this, no action, just so you are aware.
This applies to a few places.
Refer https://github.com/ansible/ansible/pull/59914#discussion_r313247935 Same doc guideline is followed for other modules.
The method does nothing, should not this method be removed ? * [X] Done
You might want to move that in `module_utils` because all lxca modules will reuse it (Then `HAS_PYLXCA` could be moved too).
since `has_pylxca` method is used, `HAS_PYLXCA` doesn't need to be defined here. * [X] Done
Isn't `ImportError` sufficient ? ```suggestion except ImportError: ``` * [X] Done
In order to simplify the code, `main` could call `execute_module` directly (and then `run_tasks` method should be removed), apart from that module behavior seems fine.
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
```suggestion self.container = PodmanContainer(self.module, self.name) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
No need for params: * they are accessible via module * they aren't used here at all ```suggestion def __init__(self, module, name): ```
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
See my point in the non facts module around snake_case.
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
Incorrect description; "If remote gateways can be used on this virtual network."
The quotes here are unneeded and unwanted actually.
The more the merrier. Take that literally, because if you have 2 maintainers adding 'shipit' to a PR, the PR is automatically merged. That means you need at least three maintainers if one of the maintainer creates a PR.
So you added an extra maintainer. Very good :+1:
No trailing dot in short_description. Keep the index clean and tidy ;-)
No need to quote strings in YAML. (unless it's yes, no or null I guess)
this should be in the run method, otherwise ansible itself will fail to run
we should capture possible import exception and explain that this lookup requires the credstash python library when it fails
It likely makes sense to add the remaining psycopg2 parameters including host and port.
It may be beneficial to clarify that this is cyberark vault, to avoid confusion where someone may think the error is in reference to ansible vault.
Make this error more specific to cyberark. A lookup is often used in conjunction with other modules and features, this sounds too generic.
```suggestion elif date_string.match(self.when): ```
I'd keep the original style here: ```suggestion version_schema = { Required('removed_in'): deprecation_versions(), } ```
+1 to these variables, makes it a lot easier to read, thanks.
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
I'm not sure what the point is to assigning a class with only static methods to an instance variable. (For that matter, it is not clear to me why this is a class at all, but that seems less confusing)
Most of these options are handled from the connection plugin, and are not necessary here. In particular, you should not need to define `host`, `username`, `password`, `use_ssl`, or `timeout`. and you don't appear to be using the actual plugin option framework for any of them anyway (none of them have `env`, `ini`, or `vars` keys, so they can't be set directly).
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
if required is true , default value can be removed.
A minor typo in `address`.
`if network['type'] != 'static' and ( 'ip' in network or 'netmask' in network):`
Yes, 'msg' key and value should always present on *_exit() calls
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
do you know if the name are case sensitive? AFAIK their are not, so we could change it in a way, any thoughts? ~~~python if nsp_name.lower() in ['virtualrouter', 'vpcvirtualrouter']: ~~~
Okay, I see. (should not look at code before the first coffee)
You can remove this import.
You can remove all of these imports except ec2_argument_spec.
You don't really need a class for this.
If cluster_id is None this will fail. Alternative, if cluster_id should be optional: use list_clusters and use each cluster id in the response to call describe_cluster.
Since you're using AnsibleAWSModule, you don't need to call get_aws_connection_info or boto3_conn. You can do `connection = module.client('emr')` (no exception handling needed around that either). You can pass connection and module to get_emr_cluster in addition to cluster_id.
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
Why is support for `-` being removed? Doing so doesn't seem to be required to implement support for symbolic links.
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
and convert filename to bytes again.
Remove default from `description:`
The doesn't appear to match the code ``` + mutually_exclusive=[['source', 'image']], + required_one_of=[['image', 'image_family']], + supports_check_mode=True ``` Please also use `I(...)` for option names
Please add docs on what this module returns.
Same here, seems a ValueError would be cleaner.
Please remove empty `aliases:` lines
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
This syntax is not supported in python2.6. You will need to index your format like {0}
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
Suggestion: Create, update and __delete__ cloud subnetworks on the Hetzner Cloud.
This information is redundant, I would remove it
It's unclear from the name what this is (or even that it's supposed to be a URL). Please rename.
```suggestion - This module creates clones for libvirt. ```
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
Please remove this + from docs. No point releasing something that we will deprecate soon.
```suggestion replace: ```
```suggestion result = dict( ``` More in line with a lot of modules.
```suggestion - name: Change login times for user ```
```suggestion mode: '0644' ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
Missing closing `)`
Please remove `no_log=False` as it's the default
Please add `, choices=['present', 'absent']`
Please remove `no_log=False` as it's the default
Please remove `no_log=False` as it's the default
I think it might be good to have a `purge_roles` option to be able to only enable role_to_remove if desired. I think it's a little confusing that both state: absent and state: present can be used to remove roles. I like the logic in this section (particularly if there was a purge_roles option that works like purge_tags does for other AWS Ansible modules) better than for state absent.
I think it might be safer if roles had to explicitly be an empty list to remove all of them. ``` - name: remove all IAM roles from a redshift cluster redshift_iam_roles: cluster: "staging" state: absent roles: [] ```
When I was reading the docs I entirely misunderstood that this would happen, thinking state=absent would use the `roles` option as well. `roles` is also a required=True option.
This should be except (BotoCoreError, ClientError) as e:
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
no need to specify required=False or type=str as these are defaults
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
`required: false` lines can be removed
Capital letters & full stops please
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
This will fix the CI issue
My concern about this really needing to be two modules, one for settings_facts and one for settings, has not been addressed.
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
*be a string
@jainnikhil30 and I took a look at the tower_cli code which is backing this tonight and decided that tower_cli is trying to coerce the types from a schema that it retrieves from the tower server. So it looks like the module code does not have to worry about this conversion.
While we're at it: please add a trailing comma, that makes it easier to add another option (if we ever need to) :)
I think this description is off :)
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
```suggestion if self.client.module.params['disk_usage']: ```
```suggestion elif docker_object == 'networks': ```
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
Empty proxy-init doesn't make sense and should be removed.
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
That's also fine for me. Then let's hope they don't reorder them ;-)
Fixing such stuff is in general a good idea, but it's better to do it in a PR which can be backported ;-)
From the code below, it looks like this doesn't do what you think it does. It creates a list of dictionaries which contain precisely one key, whose value is another dictionary whose only key is `SpreadDescriptor`.
Ah, so docker will return a list with dicts, all of them having precisely one entry. Ok, in that case, everything makes sense :)
You're right. I also checked the source at tag `2.1.0`, and it contains that parameter. I guess they did some refactoring between 2.2.x and 2.3.0 which resulted in that commit...
`Ansible uses the boto configuration file (typically C(~/.boto) or C(~/.aws)) if no`
I had a PR for the same - #32020. I will go ahead and close it. :)
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
This looks for tags with the `Name` key set to `dev` - maybe a better example would be: ``` # all instances with their `Environment` tag set to `dev` tag:Environment: dev # all dev and QA hosts tag:Environment: - dev - qa ``` Since `tag:Name` could be confused for "tags with the name dev" as in `dev : true` or something
Changed to `final_snapshot_id`
Instead of enforcing in code, you can use "required_if" on the argspec to enforce this.
Oops, missed something. I think this should still return the describe_db_clusters call so changed is accurately reflected by whether or not the cluster exists. No changes are being made by that call so it's fine and you're checking for module.check_mode in delete_cluster().
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
Only those two lines are required, and it works for me with it
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
normally they don't need it as they got added at same time as the plugin did, but newer options require it.
fyi, make it a string "2.7" otherwise it becomes a float and .. version comparison can break
Turns out it was in commit d5f20e6b2163b7bc74f5855f1da58cabd30edcbd that DISPLAY_SKIPPED_HOSTS was added. At that time, it was the only env var in lib/ansible/constants.py to NOT start with `ANSIBLE_`
opened an issue for it: https://github.com/ansible/ansible/issues/52967
This is probably also broken for the same reason as the one above.
This should be using `module.fail_json()` instead.
This is no longer needed. Ansible adds traceback information automagically. ```suggestion ```
Please don't return different types of data from a function. It should always be consistent and discourage checking the return value. Unlike low-level C-code, Python provides you with a variety of handy ways to communicate failures to the calling code (like exceptions).
refactor: ```python additional_kwargs = ( {'showAuthenticationRestrictions': True} if authentication_restrictions_supported else {} ) result = db.command( 'rolesInfo', role, showPrivileges=True, **additional_kwargs ) ```
also, please use dict literal instead of constuctor (`{'key': 'val'}` instead of `dict(key='val')`)
Please add `note: Version 4.4.3 or high required.`
`Manage Cisco NSO configuration and service synchronization`
Fixed in https://github.com/ansible/ansible/pull/34186
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
Fair enough. It is not a hard requirement.
Looks like a split line.
This line seems to have been split into two.
Typo in `aggressive`
Typo in `aggressive`
`across` has broken into two separate lines.
we should search both
because the version i tested with initially had the message in stdout
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
does this make sense with a stop? in most cases 'reload' is just sending a signal to the daemon ... not sure it applies to that action either.
I would imagine the same issue is possible for other states also, i would solve this in a generic way instead of only for one of them.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
and convert filename to bytes again.
if not handling become methods update the class variable to indicate this
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
And as gundalow said on irc, explain a bit more the difference with recipient
I know you aren't fond of the current name, but for clarity I'd consider referring to the ConfigureRemotingForAnsible.ps1 name here
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
this can be initialized to `result = {'changed': False}`
Examples should be in multi-line with `key: value`
Please use verbs in method names. Like ```suggestion def _perform_action(self, action): ```
That `__metaclass__ = type` line in the top of this module turns all classes into new-style automagically. So you don't need to inherit from `object` explicitly anymore. ```suggestion class PodmanManager: ```
I recommend you reversing this into a "guard expression" style: ```suggestion if rc == 0: return json.loads(out)[0] ``` And then you can reduce the nesting of the whole block of code which improves readability.
Maybe ```suggestion return bool(self.info) ```
Please don't use inconsistent return values throughout the function. Currently, you use `NoneType` and `bool`. Use just one type. This is unnecessary. ```suggestion ```
Why change the requirement? Also, you should add an explanation in the description that this was changed for version 2.3 and that in previous versions it was not requried.
why lowercase "The" and remove 2nd the? original needed correction but it should look like this: ```The source region that the AMI (image) should be copied from.```
`required: false` already denotes `optional`, but I'm not against this update
The original phrasing is more complete
No need to re-add these docs, as the default for any non-specified param is `null`
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
When failing, please include the traceback with the `exception` keyword arg to fail_json. `exception=traceback.format_exc()` so people know where the failure came from.
Add `exception=traceback.format_exc()` here as well please.
the cache will be by 'plugin/source' initially it will be globally enabled, but i hope to implement per plugin and even per source settings
```suggestion version_added: '2.10' ```
```suggestion Ansible 2.14 ```
```suggestion - Remove tags not listed in I(tags) when tags is specified. ```
Should also extend ec2
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think this would be more elegant with `any()` semantics + as efficient because of generator: ```python if not any((s in return_tuple[1]) for s in NOT_SSH_ERRORS): raise AnsibleConnectionFailure("Failed to connect to the host via ssh: %s" % to_native(return_tuple[2])) ```
or ```python if all((s not in return_tuple[1]) for s in NOT_SSH_ERRORS): raise AnsibleConnectionFailure("Failed to connect to the host via ssh: %s" % to_native(return_tuple[2])) ```
Instead of doing a conversion here, just modify the NOT_SSH_ERRORS structure to contain byte strings instead: ``` NOT_SSH_ERRORS = (b'Traceback (most recent call last):', # Python-2.6 when there's an exception # while invoking a script via -m b'PHP Parse error:', # Php always returns error 255 ) ```
If you drop negation, it will be possible to drop `else` part: ```python if return_tuple[0] == 255 and all((s not in return_tuple[1]) for s in NOT_SSH_ERRORS): raise AnsibleConnectionFailure("Failed to connect to the host via ssh: %s" % to_native(return_tuple[2])) ```
Honestly I was about to suggest using for-else and then I looked closer :)
I don't think we need a default for this since I can't image it being generally applicable.
this should look like this instead: ``` result = super(ActionModule, self).run(tmp, task_vars) if result.get('skipped', False) or result.get('failed', False): return result ```
`int()`? Guessing bad copy/paste and no testing- this results in `ValueError: invalid literal for int() with base 10: 'hey d00d gonna reboot'`
Both `reboot_timeout_sec` and `connect_timeout_sec` are valid for `win_reboot`. Since `win_reboot` is using this method, these options need to stay.
`delay_min_macos = delay_min | 1`
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Could this block (520-528) be a method on the AggregateStats class? something like AggregateStats.aggregate_custom_stats(data=result_item['ansible_stats'], host_list=host_list)
I meant `IndexError` not `ValueError`, but it don't really matter. What I meant is, that isn't it better to have this safe contruct there: ```python try: main() except Exception as e: module.fail_json(msg=str(e), exception=traceback.format_exc()) ``` It's then better to debug issues.
http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#new-module-development There is written: ``` # during the execution of the module, if there is an exception or a # conditional state that effectively causes a failure, run # AnsibleModule.fail_json() to pass in the message and the result if module.params['name'] == 'fail me': module.fail_json(msg='You requested this to fail', **result) ``` AFAIK module should return with `module.exit_json` or `module.fail_json`, not `raise ValueError` for example.
this is never invoked as the v2_ method that would forward to this in the callbackbase is overridden below
```suggestion description: library creation success and library_id ```
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion def state_update_library(self): ```
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
we should also return if we both delegate executions and delegate_facts
this got named use_backend
redis is good example, https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/lookup/redis.py in any case it is ts simple: ``` ini: - section: consule_kv_lookup key: validate_certs ```
env var or ini entry, just like you do for host
forgot that part, still it seems that rest of options can be set in other ways also, why force user to always set in kwargs
TBH I prefer `cert_validation` as it uses namespace prefixes (and related options sort together). Maybe we ought to fix the **httpapi** connection plugin instead ? ;-)
For the **httpapi** plugin the parameter is `validate_certs` and config item `ansible_httpapi_validate_certs`.
Fix spelling of `duplicate`.
Please use more descriptive variable names for at least `_h` and `_k`, and probably `k` and `v` also. I think it's fine to use some single letter variables in list/dict comprehensions or simple loops, but once there is some additional logic I think readability is improved by using longer names. Also, it should be fine to reassign the lowercase version of `k` (or whatever it ends up being) to itself since the original value isn't used anywhere else and the type hasn't changed.
`auth_realm` should also be added to `fetch_url`.
I still do not believe this should be here. This class should not have any knowledge of modules. I realize the alternative is insanely more complex, but that doesn't mean that this is the right choice due to ease.
This should probably be ``` python if cookies is None: ``` If cookies was neither None nor a cookiejar.CookieJar, a TypeError or similar should be raised (although the idiom in python is not to check for that). The present code could mask coding errors (Say I pass in a list of cookies instead of a cookie jar.... I might think the code will do the right thing because I don't get an error but in reality, this code will silently discard my list of cookies and use a new, empty cookiejar instead. This is not a blocker for merging the backport but it should be changed in devel and perhaps backported as well..
Neither of those are special characters in python so they don't have to be escaped for python strings. Inside of a character class regex characters like ```.``` don't have to be escaped because they don't have special meaning there. ```-``` doesn't have to be escaped in a character class as long as it is the first character in the character class.
`six.raise_from(ValueError("Can not parse package name '%s', error: '%s'" % (name_string, to_native(e))), e)`
`list`s have `.append()` method. You probably don't want to re-allocate a new instance on each iteration of the loop.
Lists also have .extend() which might be what you need here
I liked generator approach more: it's more readable in terms of separating a distinct logical step from a higher-level flow.
These lines should also be removed
No need to re-add these docs, as the default for any non-specified param is `null`
Why change the requirement? Also, you should add an explanation in the description that this was changed for version 2.3 and that in previous versions it was not requried.
`required: false` already denotes `optional`, but I'm not against this update
The original phrasing is more complete
we could U() the link
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
We should probably also include a sample and/or doc note that shows that the route table is associated via `azure_rm_subnet` - was definitely the simpler choice to implement that way, but we need to tell people where that happens.
Probably best to add an entry saying the location is derived from `C(resource_group)` if not specified
name of the `route`, not virtual network
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
`cloud_environment` and `auth_source` should be derived from `AzureRMModuleBase` and not needed on the module arg spec.
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
Add that the user can specify the backend to use via the ```use``` parameter.
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
It would be easier if RPM and DEB were to give the same structured reply, or having an agnostic module would not be very useful (in cases like "if upstream version is greater than x.y"). Comparing versions is a complex operation and there is no filter around `dpkg --compare-versions`. Also having the full version (epoch+upstream+release, following the standard distro notation) along with the upstream version would be useful I think.
just call scaleway.ini we are in ansible conflict should not occur
Be more specific in this message about what was happening when the exception happened, and remember to include the `exception=traceback.format_exc()` argument to fail_json to include the stacktrace.
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
For this case, the user may just want the parameter group to exist, but not care about what the params are set to (if they have some other tool to set them, for example) so instead of failing, this case should just exit as a success with the current values of the group (since you already got the info above).
```suggestion - false, Run Puppet agent with C(--no-noop) switch set. ```
```suggestion - true, Run Puppet agent with C(--noop) switch set. ```
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This is unnecessary, by default AnsibleAWSModule automatically merges the spec you pass it with ec2_argument_spec().
`type: complex` Have a look at other modules with the above line for how to format this
```suggestion </html> ```
```suggestion Hello world. ```
```suggestion <body> ```
```suggestion <html> ```
```suggestion returned: When return_content is TRUE. ```
`tag` is not required so check for `None`
For things with this many arguments, I'd really like to see keywords used to avoid any order mixups in the future.
I think `gitlab` would be a better name for this variable than `git`.
Change `should` to `would`.
I would use `module.fail_json` here to properly indicate failure.
Nevermind me, I follow. Your control flow is better :+1:
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
Add that the user can specify the backend to use via the ```use``` parameter.
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
You should really have at least one example with `state=absent`.
You probably should add yourself to the authors list as well.
I would name the method `passwd_check`.
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
I would name the method `passwd_set`.
Indentation doesn't look right here.
indentation doesn't look right here
urllib, traceback, sys dont seem to be used.
A couple of things, we try to avoid 'catchalls' as they don't give good error messages. We try to capture the errors after a specific action "friendly' part that suggests what was being attempted and possibly what user can do to change error to success. Also, the 'exception' field is badly named for python, it is mostly for tracebacks and we normally append the exception string to the msg field after the 'friendly msg'
having such a large try/except can lead to troubleshooting problems for the end user. Please break it up into smaller blocks.
This should be regular text. ```suggestion - Creates or destroys a data migration services subnet group. ```
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` and here as well
```suggestion SubnetIds=module.params.get('subnet_ids'), ``` Here this var needs to stay as you had it originally - ansible prefers snake cased but boto typically needs camelcase. `instance_parameters` will be passed into the boto connection so needs to match what the API expects, both here and later when you access the returned parameters. https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationSubnetGroup.html#API_CreateReplicationSubnetGroup_RequestSyntax
```suggestion for modulesubnet in modparams['SubnetIds']: ```
This one still needs to be swapped.
Always use raises with `match=` or you'll catch false positives. Especially because almost any exception is a subclass of `Exception`. ```suggestion with pytest.raises(Exception, match='Error'): ```
It'd be interesting to see a test case for something inheriting a `BaseException` too.
Another (and possibly cleaner) way to do this is to use `pytest-mock`: ```python class SpiedOnTarget: @staticmethod def do_a_thing(): return None def test_empty_retry_iterator(mocker): decorate_with_no_retries = retry_with_delays_and_condition(backoff_iterator=[]) spyable = mocker.spy(SpiedOnTarget, do_a_thing) invoke_retriable = decorate_with_no_retries(SpiedOnTarget.do_a_thing) invoke_retriable() assert spyable.call_count == 0 ```
use `type='int'` here and you won't have to do manual conversion or checking manually
This should be using `module.fail_json()` instead.
Should be specific about what's being forced in the arg name, something like: `force_removal_with_mapped_luns`. These tend to grow over time, and generic names like `force` are problematic for someone just reading the playbook to know what it does without consulting the docs.
use `choices`, ditch inline "possible values" text
Yes, you can- so long as a default is not specified, an unset value will still be `None`
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
It looks like there may be an issue with the tests. I've restarted the failed test.
Why a 1 second sleep here, I had this removed in my testing and was fine without it. 1 second is a long time for each command, especially since tasks can execute more than 1.
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
With the removal of `$?` this shouldn't be needed.
Use `to_text(line)` instead.
Yes because this module use this specific API
Yes sorry, there is a misunderstanding; the region `choices` have to be removed (but not the `required` in my opinion). Same for the other products. Moreover, I think that we can keep the constants for region/zone (cf. my example of `module_utils/scaleway.py` above) and adopt it in the whole project.
All Scaleway products are not available in all regions/zones. I think it could be interesting to set the choices explicitly to avoid problems if we add a new region in `SCALEWAY_REGIONS` in which the `lb` product is not available. Here is a proposal inspired by [what we have implemented in the new Go SDK](https://github.com/scaleway/scaleway-sdk-go/blob/master/utils/locality.go): ```py # ansible/lib/ansible/module_utils/scaleway.py SCALEWAY_REGION_FR_PAR = "fr-par" SCALEWAY_REGION_NL_AMS = "nl-ams" SCALEWAY_ALL_REGIONS = [ SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS, ] SCALEWAY_ZONE_FR_PAR_1 = "fr-par-1" SCALEWAY_ZONE_FR_PAR_2 = "fr-par-2" SCALEWAY_ZONE_NL_AMS_1 = "nl-ams-1" SCALEWAY_ALL_ZONES = [ SCALEWAY_ZONE_FR_PAR_1, SCALEWAY_ZONE_FR_PAR_2, SCALEWAY_ZONE_NL_AMS_1, ] ``` ```py # lib/ansible/modules/cloud/scaleway/scaleway_lb_facts.py def main(): argument_spec = scaleway_argument_spec() argument_spec.update(dict( region=dict(required=True, choices=[SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS]), )) # ... ```
The module has required options, but you don't provide any in this example.
remove `convert_to='int'`as it does not look like it can be converted.
Keep a blank line between examples for readability.
boto3 import failure is handled by AnsibleAWSModule. ``` try: from botocore.exceptions import BotoCoreError, ClientError except ImportError: pass # Handled by AnsibleAWSModule ```
Should catch `BotoCoreError` and `ClientError` here, and use `module.fail_json_aws()`.
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
These should be in ansible standard form (use boto3_tag_list_to_ansible_dict)
If you turn this into ```suggestion if not os.path.exists(collection_output): _build_collection_tar( collection_path, collection_output, collection_manifest, file_manifest, ) return ``` you could reduce some nesting which improves readability.
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
But since Python 2 doesn't support the `default` keyword argument, here's a cross-compatible shim for you: ```suggestion try: return max(v for v in self.versions if v != '*', key=LooseVersion) except ValueError: # ValueError: max() arg is an empty sequence return '*' ```
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
@AlanCoding since most of those deal with 'after' and this is meant to deal with 'before' the signature is not expected to be consistent.
Any logic for handling `changed` should be in `_finish_task` instead of here.
nvmd, had not looked at the called method which already handles skipped coloring
Sounds good! The newest version looks good to me. And it also still works (just re-verified) ;)
Why not keep `C.DISPLAY_SKIPPED_HOSTS`? This breaks backwards compatibility, I think, because now the behavior of callback plugins derived from `default.py` can no longer be changed with the same env variables as the behavior of the default plugin itself.
These are both defined as lists, so I assume people may want to manage those as a list? In that case we ought to have **mso_schema_site_vrf_region** and **mso_schema_site_vrf_region_cidr** modules. Unless we expect that the complete definition always replaces what already existed. In that case the user should be able to add a list of lists.
Why `dict(required=True)` is added here? It is already part of the spec.
yes, this was 'old' way when they were not real imports, now they can be moved to top of file and used like normal python imports.
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
s/user/caller/ (although user creation really is the only safe method if the file is in a world-writable directory).
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
```suggestion ansible_vmware_validate_certs: False # default is True ```
Nothing specific, wanted to match other module style.
It is available in PR. Added on https://github.com/ansible/ansible/pull/55059/files#diff-2c15779308a54e8ac33b5eba806f6e5bR84
Since this is a fact module, I think it can be said that it supports check_mode as it won't change anything but just retrieve informations.
nit: I would scope/namespace this to `scaleway_snapshots` to ensure it doesn't overrite another `snapshots` in `ansible_facts` scope
Most modules using public cloud providers offer a `validate_certs`/`validate` option[1][2]. I think the same apply here. [1] https://docs.ansible.com/ansible/latest/modules/ec2_snapshot_facts_module.html#ec2-snapshot-facts-module [2] https://docs.ansible.com/ansible/latest/modules/os_volume_snapshot_module.html#os-volume-snapshot-module
If a new commercial type is added, Ansible users won't be able to use it, they will need to wait for an update of the code. If this addition occurs during code freeze or n-1/n-2 versions is used, this update will never happen. Commercial type value should not be checked before calling the API. When the API returns an error, known commercial types might be displayed. `ec2_instance` module doesn't check commercial type (neither does `rax` module): https://github.com/ansible/ansible/blob/84bedcbd82a1e1cafd758eb20f18bc2542bfc106/lib/ansible/modules/cloud/amazon/ec2_instance.py#L1432
1. I am not sure why `commercial_type` is a required parameter since Scaleway API doesn't require `arch` parameter. 2. Why don't use directly `arch` module parameter instead of `commercial_type` parameter ? `arch` seems easiest to maintain (i guess a new commercial type is more likely to be added than a new arch).
I'd also default to True for validate_certs as that is a safer default.
Doesn't really matter since you're not likely to instantiate more than one PasswordManagerPro object in this short script but these should be instance variables, not class attributes. Move setting of default values into the ```__init__```
This is just style but we try to follow standard python naming conventions. So function and method names should be underscore separated like this: ```get_resources```.
It's safer to quote unvalidated strings with, e.g., [`urllib.quote`](https://docs.python.org/2.7/library/urllib.html?#urllib.quote) before concatenating them into a URL.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
Ah never mind, I forgot that the `if response` handles when the recursive URL lookup might have ended.
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_PROFILE') ```
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_API_VERSION') ``` Will not work for azure-mgmt-resource before 1.3.0 if you want multi-api support there as well.
ContainerInstance doesn't support profile, it's why it doesn't have a `models` method
You will need to include the OAUTH_TOKEN environment variable also.
Not needed as you have `required=True`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
I'm not familiar with CE, though is this correct? ``` if mode == "mode-l3": ... mode = "mode-l2" cfg_xml = CE_NC_MERGE_NVE_MODE % (nve_name, mode) ... self.updates_cmd.append("undo mode l3") ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_if ```
This needs to be rewritten to support Python 2.6.
This could be written without the explicit list. Passing the expression directly to `dict` should suffice.
```suggestion assert expected == "exception" ```
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
```suggestion assert expected == "exception" ```
I would just make this a plain function that calls fetch_url and then lowercases the keys instead of making it a decorator. I'm a little hesitant about overriding the name (I'd use a different name than fetch_url) but I can see you do that so you don't have to change the name everywhere. Since I'm not the module author, I won't block it over that but I think it's better style to use a new name.
Don't assign a lambda function, use def
Yes, please remove the return and update the caller.
Don't assign a lambda function, use def
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
```suggestion if cert_valid_from <= self.convertToDatetime(module, self.valid_at) <= cert_valid_to: ```
`state=absent` requires a *lot* of additional arguments which are not needed: `{"changed": false, "msg": "missing required arguments: type, signing_key, public_key, valid_from, valid_to"}` These arguments should only be required when `state` is `'present'`. Look at the `required_if` parameter of `AnsibleModule()`.
This check always fails on my machine: `self.principals == None`, `principals == ['(none)']`
I created a PR for `openssh_keypair` in #50106.
```suggestion base_dir = os.path.dirname(path) or '.' ``` Otherwise, `path == 'file'` (i.e. file in current directory) will result in `fatal: [localhost]: FAILED! => {"changed": false, "msg": "The directory does not exist or the file is not a directory", "name": ""}` The same thing goes wrong in `openssh_keypair`, BTW.
```suggestion msg='vRouter with interface %s does not exist' % ip ```
```suggestion cli += ' vrouter-show name %s format name no-show-headers' % name ```
This can be simplified as ```python VROUTER_EXISTS = '' if out else None ```
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion if VROUTER_EXISTS is None: module.fail_json(msg='Vrouter does not exist', failed=True) ```
Now you need to update `self.public_key` another time.
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
This is not concurrency safe.
Something like this instead: ``` python def _get_vm_prop(vm, attributes): result = vm for attribute in attributes: try: result = getattr(result, attribute) except AttributeError: return None return result _get_vm_props(vm, ('guest', 'toolsRunningStatus')) ```
I think, using `pass` instead of returning `None` in AttributeError as `return None` fails to retrieve snapshots. Snapshot data works perfect with `pass`.
Why do we need to force to change powerstate? Seems over protective.
The expected_state variable only strips the underscore (_) character from the state variable, but the providable power states for vmware_guest_powerstate use hyphens (-), so the expected state will never match the current_state or any of the other conditionals. Using underscores for the state names (ex. powered_off) strikes me as being more consistent with the existing conventions than adding hyphens.
Could try ``` python def _get_vm_prop(vm, *attributes): result = vm for attribute in attributes: < etc > ``` That version is a tiny bit magic, but it would allow: ``` python _get_vm_prop(vm, 'some_attr') # as well as _get_vm_prop(vm, 'some_attr', 'another_attr', 'etc_attr') ```
Thanks for confirming
Is the default false, if so needs adding here and in the docs
Please add `, no_log=True`
Why are username and password define here, though should be in the docs_fragment.
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
<nod> I've gone back and forth with people. Since dynamic inventory runs out of process, some people don't want to have to depend on six. I've been merging either way.
I'd probably recommend using six, instead of a try/except dance. ansible ships with six in `ansible.module_utils.six` that can be used here.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
Please remove whitespaces around the braces.
This `.close()` isn't needed, the context manager closes the file automatically.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
I think this message should just be `botocore and boto3 are required for this module`.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
Minor UI thing, but might be nice if "default", "maximized" and "minimized" were accepted instead of the numeric enum values. Should probably also have "choices" defined (and -ValidateSet up above).
Some stuff complains if the .py file is missing the final LF- can't remember if we hit that anymore or not, but not a bad idea to add it just in case.
This needs to be a raw string (`r'''`) to fix the failing doc sanity check- otherwise it tries to interpret `C:\Users` as a Unicode hex literal. Ah, the joys of nesting escapes across multiple languages... :)
I would simply call this `icon:` There is no other specific icon property for shortcuts.
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
default is not the correct place for this as other custom callbacks can ignore it then. items should be scrubbed before they even get to callbacks, or if not possible, _get_censored_item should be called automatically from the base class (which still leaves v1 callbacks able to ignore it).
this breaks showing diffs from loop items
`read_config_from_file` could return the content of the file or `None` if the file doesn't exist (instead of a tuple).
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
`'get'` is in base_rpc already? ```suggestion ```
Let's remove the `if` and set default `None`.
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Any way to block/poll for completion on this? Otherwise this is a built-in race condition for anyone that wants to do anything with a renamed infinite volume from Ansible...
docs should probably specify that deleting an infinite volume is not synchronous
Never raise an exception, fail the module instead
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
As per naming convention, the name is `get_lldp_global_facts`
Name as per convention can be `lag_itnerfaces_facts`
The name as per conventions can be `existing_lag_interfaces_facts` and `get_lag_interfaces_facts`
Same as above and applicable at other places as well
like diff = load_config(self._module, config_xml, [])
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
You may want to specify 'type: str/list/bool/dict' for some of these.
```suggestion - The URLs to retrieve the public I(blob), I(queue), or I(table) object from the primary location. ```
```suggestion - The status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - The status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - The status of the secondary location of the storage account; either C(available) or C(unavailable). ```
Can remove this one. If there is a credentials issue it should happen when the connection is created, I think.
This line doesn't need to be in the try/except.
botocore.exceptions.ProfileNotFound may also be raised
These tests are made redundant by mutually_exclusive, required_one_of and required_together below.
Can get rid of required=False.
This one *might* not be redundant, if it's possible to make changes that will cause the CDN endpoint hostname to change...
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
`Only application to an endpoint of I(type) C(nested_endpoints).
Maybe should be AzureRMCdnEndpointFacts, but that's minor
Are there plans on adding more objects that can manage the disks? if it is only a VM then it may be better to have this be `vm_name` but happy to be convinced otherwise.
`required: false` is the default value and is best omitted
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
I think you need `to_native` here.
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
How about: ```suggestion if not os.path.exists(file_path): continue ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I'd do ```suggestion if not ignore_errors: raise ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
No quotes for None, makes it unclear if it's python `None`/yaml `null` or a string.
```suggestion vmware_host_snmp: ```
```suggestion to iterate use a C(with_) directive. ```
Doesn't look like this got merged intime, so `2.8` here (and other places
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Just noticed you're rewriting security_groups that has been set on line 248. This eliminates the ability to specify a mix of security group ids and security group names. You can delete this line.
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
No need to wrap.
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
Easier to read if written like this: ``` python VALID_ARGS = tuple(frozenset(BASE + FROM_ARGS + OTHER_ARGS)) ```
This should also accept the deprecated args.
And the same here
not for this PR, but we might want a 'configurable ignore facility' ala gitignore in the future
That's a really interesting piece of information I did not know.
I have added similar note in porting guide for `vmware_local_role_facts` here = https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.8.rst#id12
No longer needed
Once you replace the connection block below with module.client('ec2') you don't need these 3 imports...
It may not be forward compatible then, but it seems unlikely AWS would change it unless they introduced something new.
Should be listed in `requirements:`
Am not talking about `check_mode`, but about `change=True` / `changed=False`.
It's nicer and less error prone to send a list to module.run_command than a string.
http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#new-module-development There is written: ``` # during the execution of the module, if there is an exception or a # conditional state that effectively causes a failure, run # AnsibleModule.fail_json() to pass in the message and the result if module.params['name'] == 'fail me': module.fail_json(msg='You requested this to fail', **result) ``` AFAIK module should return with `module.exit_json` or `module.fail_json`, not `raise ValueError` for example.
Will this parsing also work when gluster isn't installed at all? In that case any meaningfull message would be nice.
I meant `IndexError` not `ValueError`, but it don't really matter. What I meant is, that isn't it better to have this safe contruct there: ```python try: main() except Exception as e: module.fail_json(msg=str(e), exception=traceback.format_exc()) ``` It's then better to debug issues.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same as for the updated, I'd rather say `has been deleted`
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use 'msg' for returned messages, this is a standardized return value.
Additional error information would be help for debugging.
This is known limitation with `no_log`, it won't affect the module functionality. It will just obfuscate password like words in log output.
add `no_log=True` as this is password for something, which you might want to hide in logs and console logs.
Add period at end in each description.
It doesn't really support `check_mode` since when check mode is enabled `changed` is always `False`.
```suggestion result = dict( ``` More in line with a lot of modules.
```suggestion - name: Change login times for user ```
```suggestion mode: '0644' ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
The same like above.
This should also start on the line above if the other is moved.
This is implicit for parameters. Unless it is required, you don't have to add anything.
Why would you default to an empty string here ? Is an empty string actually useful ? The default is None, which is a good default so you know it was set or not. Simply remove this for the "default" default.
Remove this. But do add: ```yaml choices: [ absent, present ] ```
This will not render correctly. If you use multiple dashes for the same sentence, they will end up being different paragraphs in the description. You don't need those subsequent dashes.
Makes this `Whether compatibility checks should be ignored.`
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
1) you don't need another nested `sample` key as it's not what you return 2) please just use YAML for the structure description, it's a superset of JSON: ```suggestion InstanceID: JID_XXXXXXXXXXXX JobState: Completed Message: Job completed successfully. MessageId: REDXXX Name: Repository Update JobStartTime: NA Status: Success ```
You should probably put this check into a separate function and run it before `with` block https://github.com/ansible/ansible/pull/46675/files#diff-62a00abb6ff3cd2c35f54b8b82436130R205 so that it'll halt execution even before trying to construct that connection object.
The official name is "Docker SDK for Python" ([docs](https://docker-py.readthedocs.io/en/stable/)).
You might also want to say which versions you support.
```suggestion type: str required: true ```
```suggestion type: str required: true ```
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
and maybe a blurb indicating that error comes from withing the debug action itself, 'While "debug" task was trying to display the value of "%s" the result of templating was expected to be text type, but instead was a "%s" type.' % (type(results), self._task.args['var'],)
Since we can now display the exception message, this AnsibleUndefinedVariable would be better with an explanation message. something like: ``` python raise AnsibleUndefinedVariable('The result of templating was expected to be text type, but instead was a "%s" type. The template input: %s" % (self._task.args['var'], type(results))) ```
Grammar-wise, might as well remove the excalamation point here. All caps is already shouting and "DEFINED!: error" is improper punctuation.
This won't work as the os.path.abspath() is executed on the current machine. Needs to execute on the remote machine instead.
can be removed, the call to 'supper' below already takes care of this
```suggestion groupby = {k: self.to_safe(to_text(v)) for k, v in params.items()} ```
I find the inconsistent capitalization very confusing. There's `Name` and `Facts` but also `all_parameters`. Here we have `environment` but also `Location` and `Organization`. Ideally the original API response would be normalized.
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
Suggest changing to `if 'tags' in host:`
same here for arg bools vs strings- this needn't exist
@carchi8py : enable/disable UDP protocol It would be nice to have a default of 'enabled'
Yes, but we can address this in another release.
definitely seems like there should be an else with an error here...
All of them should be is None IMHO.
My concern about this really needing to be two modules, one for settings_facts and one for settings, has not been addressed.
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
*be a string
@jainnikhil30 and I took a look at the tower_cli code which is backing this tonight and decided that tower_cli is trying to coerce the types from a schema that it retrieves from the tower server. So it looks like the module code does not have to worry about this conversion.
supports_check_mode still needs to be toggled to False
```suggestion pass # Handled by AnsibleAWSModule ```
I prefer a second (and perhaps even third) `from ansible.module_utils.ec2 import` line to a line continuation (brackets also work, but are subjectively less elegant). Not a blocker though
self.ec2 still needs to be defined here. Also, AnsibleAWSModule lets you do `self.ecs = module.client('ecs')` and `self.ec2 = module.client('ec2')`, so you could remove the imports get_aws_connection_info and boto3_conn.
SubnetIds expects a list `[result['subnets'][0]]`
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
This is correct.
```suggestion description: The Organizational Unit details. ```
I'm not a big fan of this self recursion. We're a bit limited since boto doesn't give any way to get the entire tree, but it would be nice if this could be broken out differently.
```suggestion parent_ous = paginator.paginate(ParentId=parent_id).build_full_result().get('OrganizationalUnits', []) for child_ou in parent_ous: ``` You could remove the outer loop here by using the paginator's `.build_full_result()` method and retrieving the OrganizationalUnits from it.
```suggestion - State of the organizational unit. ```
`, no_log=True` here please
Each example task should be a continuous block, please do not have blank lines between sections
Sound, sound sensible
`IP` `Netscaler` - Applies to a number of places `Nitro` - Applies to a number of places
`Ansible control node` (Capital and remove double space)
Use a `seealso:` sections for external information.
Please don't start every description with "This is", simply state what it is used for. ```suggestion - The ID of sheet to append columns to. ```
The module can be used for more than archiving (which is just a use-case). So I would make this more generic.
Make this two items in your description. ```suggestion - The value should end with C(.apps.googleusercontent.com). ```
If it is not required, don't add it.
I am not clear as to why `before` `hostname` and `vmnic` are required, whatever the input parameters can be obtained from `module.params`
SR-IOV can be enabled only if `C(num_virt_func) > 0.`
optional parameter, related to `C(num_virt_func)`.
```suggestion - number of functions to activate on interface. ```
```suggestion - Desired SR-IOV state on interface. ```
```suggestion description: If multicast is enabled. ```
```suggestion description: If promiscuous mode is enabled. ```
```suggestion description: Administrative state of the interface (C(up) or C(down)). ```
```suggestion description: L2 address (may be C(None), if the interface does not have one). ```
```suggestion description: L2 Broadcast address (may be C(None) if the interface does not have one). ```
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Message cleanup needed. Notice `installed installed`.
this should be a common function in basic.py (i think there is this one or the reverse there already)
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
@bcoca noted the use of state=info in today's meeting... I think a year ago, or so, we discussed using a separate module named with an _info suffix (like sophos_utm_info.py) for things that are just for gathering info about something which doesn't relate to the host it is run on. (You also thought you might turn that portion into a lookup plugin. That would also be fine. The difference is just that a lookup can only be run o nthe controller whereas a module can be used on either the controller or a remote host).
Same change needs to be made to many other uses of filter.
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
I don't think you need the `list` here - `for` can iterate over a `set`
this doesn't work as `ParamValidationError` doesn't have a `response` attribute - you need to have separate handlers for both exception types.
Only do this is module.params.get('managed_policy') is not None
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
Ping @willthames - other than this validation fix this is good to go.
While I think this is correct I'm not sure if it uses no proxy or the default proxy configured in the IE settings. I don't have easy access to an environment with a proxy configured so I can't test this assumption.
Can you change the examples to use YAML rather than `k=v` shorthand? ```yaml - debug: var: lookup('cpm_status', 'temperature', validate_certs=true, use_https=true, cpm_url='rest.wti.com', cpm_username='rest', cpm_password='restfulpassword') ```
```suggestion - Enable or disable promiscuous mode for interface. ```
```suggestion - Enable or disable the MULTICAST flag on a device. ```
Just noting that this RETURN is incomplete
Also, why do you compute `data.split(delimiter)` again instead of using `data_arr`? ```suggestion metric.split("=", maxsplit=1) for metric in data_arr) ```
This will fail if `len(data) == 1`, which you explicitly allow above.
This would also match version 10.x. Also, `4.[0-2]` will also match `421` (an unescaped dot matches anything). You probably want: ```suggestion if re.search('^([0-3]\\.|4\\.[0-2])', min(self._build_list)): ``` Or (using raw strings, to avoid double escaping): ```suggestion if re.search(R'^([0-3]\.|4\.[0-2])', min(self._build_list)): ```
Sorry about `maxsplit`, I'm mostly using Python 3 nowadays and forgot it wasn't a keyword in Python 2. Anyway, `metric.split("=", 1)` will work fine in both Python 2 and 3, so it's good!
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
Ah, right, hadn't realised that. I'm not sure any modules using AnsibleAWSModule would have got as far as module.fail_json_aws if HAS_BOTO3 is not True though. Worth checking just in case I suppose!
you could line that up with msg
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
```suggestion - Do NOT add a colon (:) to your custom entries. Ansible adds a colon at the end of each prompt;```
```suggestion if you add another one in your string, your prompt will fail with a "Timeout" error. ```
I'd put this line under the current line 95, in the description of the `deb` parameter.
```suggestion to iterate use a C(with_) directive. ```
Please remove this line
CI failure due to: ``` 2017-01-31 18:50:23 ERROR: PEP 8: lib/ansible/module_utils/netapp.py:150:31: W292 no newline at end of file (current) ```
Not a must fix. We could remove 2 lines of code and logical branch for ```if not ignore_errors:``` The Core reviewers might like it more direct and declarative.
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
As before, this will not catch non-200 statues of response.
remove this line as it is not needed
the changed = True from 410 should be moved below this
Since we have used `EDITOR` historically, we should not change the default and need to start with `EDITOR` as the default. This precedence may not make sense, though, and we may need to add a config option to control this. ```suggestion env_editor = os.environ.get('EDITOR', os.environ.get('VISUAL', 'vi')) ```
I think it's best to always provide **template_destpath**, and if it wasn't defined return `jinja.StrictUndefined` or possible `None`.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
I wonder if the output can be simplified to avoid repeating `unset` and `export`.
this is checking the directory on the controller, not on the remote
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
I would split these ('install' and 'install --offline -p -r etc') into two separate tests so any failures are more specific and granular.
I think this may read better: ```suggestion if missing_keys: ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
Are you only doing this to support Python 2.6? Those keys are already unique.
I'd do ```suggestion if not ignore_errors: raise ```
Grammar-wise, might as well remove the excalamation point here. All caps is already shouting and "DEFINED!: error" is improper punctuation.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
I wouldn't call `module.params` as `packages` since it will hold also other parameters, not only the packages
You can remove the brackets here.
The `type` value should be quoted: ```python force=dict(type="bool", default=False) ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
We support python-2.6 and python2.7 (and python3.5 and above) in controller code (which this is). For modules we support python-2.4 and above unless there's a dependency that requires a newer version of python.
IIRC should be just `raise` to re-raise the existing error
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
You're using the result object to smuggle this around, but it should probably be an instance field instead, since we don't actually want it in the results. Probably the same for the other cases where we're using the result dict as intermediate storage- put them in fields and just construct the result object at the end before it's returned.
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
```suggestion default: no ```
```suggestion - Whether to remove or define a device including child devices. ```
```suggestion default: no ```
```suggestion required: true type: str ```
```suggestion - Use C(all) to rescan all C(present) devices (AIX cfgmgr command). ```
This should probably guarded with `if __name__ == '__main__':`
Initialized must go first.
Just use ` and ...` instead of nesting. Less indentation == better readable.
Add this snippet at the top of the module: ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ``` Then, you won't have to inherit from `object`.
just call scaleway.ini we are in ansible conflict should not occur
Hmm, you may be right, but I would be adding it to result, rather than the msg-string.
I don't see the point here, both errors are identical, so why do this ? If it fails you wouldn't even know which one actually failed.
It might also be useful to print login response code to supplement earlier login method debug. white testing this patch I felt login did not go through
Please use 'msg' for returned messages, this is a standardized return value.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
This is 1:1 the same code as in https://github.com/ansible/ansible/blob/8a671f54ddc5ec114ef807dc71f49d61261d2107/lib/ansible/module_utils/crypto.py#L150-L160
Ah, I think the point is that `os.remove()` raises an exception if the file isn't there, so `changed` won't be set to `True`.
In case the file doesn't exist, `keypair.check(module)` returns `False`, whence `changed` is set to `True`. I don't think that's correct.
You should use `module.get_bin_path('ssh-keygen', True)`.
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
Remove the `try` block, it is unused.
This statement seems useless.
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
I believe the plan is to do a single PR to address this in all Postgres modules
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
On CentOS, `/etc/sysconf/selinux` is a symlink to `/etc/selinux/config`: ``` [root@lab-centos7 ~]# ll /etc/sysconfig/selinux lrwxrwxrwx. 1 root root 17 Aug 29 06:21 /etc/sysconfig/selinux -> ../selinux/config ``` > On centos there is no such thing as `/etc/selinux/%s/policy`. This is the path where the policy files for the selected policy, as configured by `SELINUXTYPE` in `/etc/selinux/config`: ``` [root@lab-centos7 ~]# ll /etc/selinux/targeted/ total 16 drwx------. 3 root root 263 Aug 29 06:30 active -rw-r--r--. 1 root root 2623 Aug 16 17:40 booleans.subs_dist drwxr-xr-x. 4 root root 4096 Aug 29 06:28 contexts drwxr-xr-x. 2 root root 6 Aug 16 17:40 logins drwxr-xr-x. 3 root root 20 Aug 29 06:21 modules drwxr-xr-x. 2 root root 23 Aug 29 06:30 policy -rw-------. 1 root root 0 Aug 16 17:10 semanage.read.LOCK -rw-------. 1 root root 0 Aug 16 17:10 semanage.trans.LOCK -rw-r--r--. 1 root root 607 Aug 16 17:40 setrans.conf -rw-r--r--. 1 root root 106 Aug 29 06:30 seusers ``` What the existing code is doing is preventing you from setting a policy in `/etc/selinux/config` that does not have a corresponding set of policy files, which would be an invalid configuration. If we change that behavior to just checking for the existence of the config file, it would allow someone to configure a policy that does not exist. I don't think that is a good idea.
Could we verify that the file /etc/selinux/%s/policy exist ? While the goal is to prevent errors, someone could use another name (config, final, tmp) that would bypass this check. Not a big deal, but I like to be precise.
Please put all imports together at the top, and include only the stuff you are using, i.e. ```python from ansible.module_utils.basic import AnsibleModule ```
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
suggest to call this `state` and make set the `default=present`
is there a convention for this? I'm wondering if this could be more than binary (present / absent / disabled)
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
missing from docs fragment
instead of manually assembling all the options, use set_options/get_option and all this will be resolved 'per option' in normal precedence order
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
How about: ```suggestion from ansible.module_utils.parsing.convert_bool import boolean as to_bool try: verify = to_bool(option) except TypeError: # it wasn't a boolean value verify = option # Set to a CA bundle: finally: if verify is False: # is only set to bool if try block succeeds requests.packages.urllib3.disable_warnings() self._display.warning( u"SSL verification of %s disabled" % self.foreman_url, ) return verify ```
You reassign this var on each loop iteration, please move it outside. ```suggestion ```
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
```suggestion version_added: '2.8' ```
And you don't have to quote it.
The author string should be formated like `<name> (@<githubhandle>)`
This should be quoted.
Period at end.
This example is supposed to show the difference in single vs double quoting requirements in YAML, but it's incorrect. This like should be singel quoted but the `regexp` should be double quoted.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
Default needs adding to docs
according code, it is not required.
according code, there is no default, so can be left off.
might as well get rid of any `required: false` and `default: null`s
`default: null/None` is the default, it can be omitted
`required: false` is the default, can be omitted
@kaneda-fr its a direct network. is there anything in particular you'd like me to pull for you in the config. i will warn you, i'm very new to VCD and pyvcloud so this is me trying to get to where i'm not just using the gui all the time. I did not set this up, it was already configured. are you in the irc channel? if so i am xaeth
So we figured it out. As long as we setup the vapp template to have no network configured in it then it works :)
For this module there are 3 network types supported: * static * pool * dhcp Looking at the pyvcloud.vapp library it appears that the supported modes are: * pool * dhcp * manual * none I tested changing from static (which is what matches the UI) to pool, and it appears to have worked. This block doesn't do anything if network_mode is set to static, which is why mine was failing i think. You may have already covered this in your upcoming patch but i figured it would be good to point it out.
move this line 1028
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
It would be awesome if buildah supported copying from a container.
This should probably be `docker.exec_command()`
No longer using a temporary file. This issue is resolved
This should be a string: ```yaml version_added: '2.4' ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
This needs to be the **repo** parameter, with possibly **name** as alias.
Nowadays we do: ```yaml type: bool default: 'yes' ```
Please check if this is still valid for `icx` parameter since current release is 2.9
Please check this.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
```suggestion - The port range for port-object. ```
```suggestion - The IP address and mask for network object-group. ```
```suggestion - The group-object for network object-group. ```
Please remove this statement. Provider has been deprecated since 2.5. New modules should not have it.
```suggestion - The description for the object-group. ```
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Again, path concatenation is bad. And in this case it is not needed at all, since we have a path stored in `device["@odata.id"]`.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
`Name` field does not need to be unique (and on the Lenovo recording I have all the disk firmwares have the same name "Disk firmware"), so this has the potential to overwrite data from previous iterations, returning only the last non-unique entry.
How about: ```suggestion - The cipher to encrypt the private key. (Valid values can be found by running `openssl list -cipher-algorithms` or `openssl list-cipher-algorithms`, depending on your OpenSSL version.) ```
OSX Mojave's openssl (which is LibreSSL 2.6.5) also doesn't like the new syntax.
That's very interesting. @Akasurde which version of OpenSSL do you have? I've tested it both with 1.1.0j and 1.1.1b; for both only `openssl list -cipher-algorithms` works.
The CI run fails because this line is now too long. How about splitting it up like this: ```suggestion - The cipher to encrypt the private key. (Valid values can be found by running `openssl list -cipher-algorithms` or `openssl list-cipher-algorithms`, depending on your OpenSSL version.) ```
I think it would be nice to have a idea of the potential value and format, and the default value.
i would have single 'msg' and then a 'type' option, this follows the pattern of other modules.
add 'python library' , then the 'pip install' becomes redundant, some people cannot use pip to install libraries
Parameters that are not required don't need `required: false`.
Make this a separate item in the list.
Make this a separate item in the list.
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
`msg="'%s' device group not found in Panorama. Is the name correct?" % devicegroup)`
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
`policy` should be added to `argument_spec` to be usable.
This would be clearer as: ``` elif len(connection) == 1: return {'connection': connection[0]} return {'connection': {}} ``` because all the cases in this if/elif/else are returns.
Instead of recording `changed`, you can `return (current_bandwidth != bandwidth or current_location != location)` since that conditional is what's really deciding whether to change the resource or not.
Since this is length 1 always, you can use `connection.extend(response['connections'])` for the same result.
Don't need these parens.
`latest_state` is never used. Instead of keeping `changed` as a var, you can `return True, connection_id` from here and from line 255, then `return False, connection_id` from line 257.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a function.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
Typo in `command`.
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Yeah, that's from 2013. Nowadays it probably matters less. If only we had less weird things in setup.py, we could just migrate to setup.cfg mostly...
That is true but also the target file only contains ASCII so this will not fail as long as we don't "add emojis" there at which point it'll fail in the CI. So there's a really low risk of shipping broken dists...
<nod> okay,. Since we control the release.py file, we probably shouldn't add this particular encoding code, then. It overcomplicates things and confused people who don't have encoding experience won't understand why latin1 is used here and will assume the file actually contains characters encoded in Latin 1). I suggest either ignoring the encoding question if we are going to say the release.py file is ascii-only or reading as bytes and then decoding from utf8 if we want to future proof it against things like a non-ascii code name. (Importing and using codecs is another thing that will be nonobvious to people who are unfamiliar with encoding issues)
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
Remove the two extra double-quotes here.
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
```python if state == 'present': if not volume: create_volume(module, array) elif volume: update_volume(module, array, volume) elif state == 'absent' and volume: delete_volume(module, array, volume) else: module.exit_json(changed=False) ```
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
Now that there are two lines, "it" is a bit unclear. I'd change this to "Setting C(default) to C(yes) causes an error if the path is a file."
Since we have a line for `version_added`, I'd remove the "(added in Ansible 2.0)".
I would have preferred a more explicit removal of `name=(default)` for the removal of the default key. This is to me more confusing (because whether it is set to `yes` or `no` it will delete a key. So I would get rid of this option altogether.
Yes, so what I am saying is to keep it simple, and if no name was provided (with `state=absent`), delete the path. If a `(default)` name was provided, remove that key (as in unsetting it, just as the registry editor is not showing an unset `(default)' key). So you don't need the additional `delete_key` parameter, and it's actually as one would expect it to work. The `name` parameter was optional.
`RETURN` block missing
note: the 'startswith' _ is still needed for deprecations (but that is handled elsewhere), so we only skipped when it was a symlink (rename deprecating old name, not module itself) so this should 'work'tm as it is now
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
This needs to pass `return_docs=True` for return docs.
For some reason this causes ``` {aliases: [attr]} {choices: [all, 'no', none, safe, urllib2, 'yes']} {default: [200]} ``` while non-sequence values for `default` yield ``` default: 30 ``` without the `{...}`.
```suggestion module.exit_json(changed=True,**camel_dict_to_snake_dict(res))) ```
Why have both `schema` and `newschema`? I would assume that if I specify another value for `schema`, that the schema will be changed.
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
This can all be replaced by `module.client('iam')` or `module.resource('iam')`, but module.resource doesn't support the aws_retry feature.
excellent handling of congestion control
May be true but this is general speaking. What behavior specific changes would you expect? Can we possibly test against those? I don't think it is meaningful to duplicate code in n modules when using OOP style.
I really don't want to be calling the API this often. Can we make this 6 by default (as that's what it was before the change)
@chouseknecht makes sense. Also, as a first iteration, this is already good so I wouldn't stress it to find a better abstraction at this stage. I think once this module matures, we can start thinking about splitting some of this logic.
I think it's fine to keep this here for now but, I wonder if this check (and similar checks in the future) should go into the `OpenShift` client as they are specific to `OpenShift` and not `Kubernetes`.
Yeah, but does this code works well, when updating some attribute via that? As far as I read it correctly it doesn't.
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
Just making a note that we should probably restrict this to the exceptions that will likely occur and call fail_json instead of raising an Exception again.
Debugging, I assume, but should be limited before merging.
Looks like this is used now, yay :-)
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
This is now auto-handled by AnsibleAWSModule
You can just use initialize `ide_device = None` and drop `ide_exist` variable.
Here too, I believe you don't need the `cdrom_exist` variable.
I believe you should be able to replace `of (not cdrom_exist or len(cdrom_devices) == 0)...` with just `if not cdrom_device and cdrom.get('state') != 'absent'`
`if self.params["cdrom"].get('type') not in ['none', 'client', 'iso']:`
I'm not sure you need the `ctl_exist` variable.
our mistake :-) it's verfy_ssl: true ... because we have 'ssl-with-validation-custom-ca' in the next line ... I asked @ilackarms to fix this in his playbook too ...
don't need hosts: and tasks: in EXAMPLES, see #29054
Awesome, all looks great now, but I think there should be a way to omit role here. I think if you give Director `ssh_keypair_role="ssh_keypair"` in `supported_providers()`, you will be able to omit it, via this logic: https://github.com/snecklifter/ansible/blob/2fb8d3b7e139/lib/ansible/modules/remote_management/manageiq/manageiq_provider.py#L637
shipit This is great, can improve in followup PR if we find how.
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
We'll also want an `exclude_package_data` entry to exclude all of `test/lib/ansible_test/tests/`.
Files without extensions need to be included as well. For example, all the files in this directory: https://github.com/ansible/ansible/tree/devel/test/lib/ansible_test/_data/sanity/pylint/config
I think you probably want a function which does this rather than trying to hardcode wildcarded strings in here.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Please also use proper doc formatting like: "C(template) and C(storage_domain) parameters are provided"
Please add ` version_added: "2.4"`
But won't be moved if the storage domain is changed, no? The note should be added only if the parameter is NOT idempotent. The default is meant to be idempotent.
```suggestion - Only used for images that contain the Windows Server operating system. ```
If module-level version_added is 2.5 this can be deleted
That is a great reason :) Keep up the great work with BAS!
this only happens if a relative path is given and it is not only in 'files' but that would be the first subdir checked.
default of none allows us to know if user set or not, unsure if it is currently needed but JIC we want to make distinction in the future.
Example fields doesn't match the real fields name (server,user, pass)
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
```suggestion username: '{{ vcenter_username }}' ```
```suggestion password: '{{ vcenter_password }}' ```
I learned yesterday that nowadays we can simply do `import json` as we no longer support Python 2.4
Could you please move these function to vmware module utils so that other modules can also use them ? - find_resource_pool_by_name - find_network_by_name - wait_for_vm_ip
```suggestion class VMwareExportVmOvf(PyVmomi): ```
You could just do this as: ``` python values = [search_response] ```
This is wrong. Do it like this: ``` python raise AnsibleError('Kind %s requires a namespace.' ' None provided' % kind) ```
Since this is setting data, you also want to use an error handler like this: ``` python from ansible.module_utils._text import to_text [...] for resource in json.loads(to_text(response.read(), errors='surrogate_or_strict'))['resources']: ``` The default error handler is replace which is good for things displayed to the user but not good for preserving data.
Probably need to use to_native() (from ansible.modoule_utils._text) to make sure that body is a native string type on both python2 and python3.
required is by-default false so no need to add it for every instance.
Simplier: ```python password.os.path.exists = lambda x: x == to_bytes('/path/to/somewhere') ```
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
Check for the exception in the test body instead of using a decorator. Also, since you're testing for an exception, you only need to define the input and not compare against expected: ```suggestion with pytest.raises(TypeError): ansible_json_encoder.default(test_input) ```
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
How about splitting up the PR into multiple ones? At least one for the cases where semantics have to change (probably best one PR per module, because it will need discussion for every one of them, and having one module per PR increases the chance that some of them will be merged, even if some others are not or take forever), and one for the "obvious" changes.
You are changing semantics here. Originally, errors while opening the file were ignored, the function simply returned. Errors while reading the file's content were escalated, and errors while closing the file were handled (by failing the module). Now, you're handling **all** errors by failing the module. You should definitely **not** handle file not found errors this way! (No idea about other errors while opening the file.)
Same here. Don't do that!
This is changing semantics!
As we no longer care about 2.4, I think this can be cleaned
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
Should be a parameter of the task itself and not the module
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
I'd do: ```python from functools import partial ... def is_satisfied_by(current_version, constraint_predicate): op, ver = constraint_predicate return op_dict[op](current_version, LooseVersion(ver)) satisfies_target_version = partial(is_satisfied_by, current_version=LooseVersion(version_to_test)) return all( satisfies_target_version(spec) for spec in self._requirement.specs ) # or return all(map(satisfies_target_version, self._requirement.specs)) ```
`'>=', '<=', '!=', '==', '>', '<'` is duplicated with that operator map. you could do global map and use `that_map.keys()`
As far as I understand this is only necessary to support stuff like `djang>1.11.0,<1.12.0,bottle>0.10,<0.20,!=0.11`. Why should we support this? Using a list is to me the obviously better API and support this structure adds a lot of (to me unnecessary) complexity.
Cross-compability, backwards compatibility, command line compatibility, ease of discovery. * Other packaging modules support comma separated package entries. * The pip module itself supports comma separated package entries * pip supports single string entries as valid packages * comma separated list entries are the natural way to write lists on the commandline. * error messages if people were to violate these rules (for instance: ```ansible localhost -m pip -a 'names=django>=1.11.0,<1.12.0'``` wonn't point to the actual solution unless we implement this sort of detection for creating the error message... in which case we might as well do the right thing.
Can you give an example for the error message coming from this? As stated above I would rather remove support for construtcs, which can raise exceptions here.
Preserve the original behavior for the default port. Add `self.port = None` under the `elif self.provider == 'vmware':` conditional in `__init__` above to provide the correct default. ```suggestion port=int(con.get('port', self.port)), ```
This will fail if `len(data) == 1`, which you explicitly allow above.
Also, why do you compute `data.split(delimiter)` again instead of using `data_arr`? ```suggestion metric.split("=", maxsplit=1) for metric in data_arr) ```
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
This would also match version 10.x. Also, `4.[0-2]` will also match `421` (an unescaped dot matches anything). You probably want: ```suggestion if re.search('^([0-3]\\.|4\\.[0-2])', min(self._build_list)): ``` Or (using raw strings, to avoid double escaping): ```suggestion if re.search(R'^([0-3]\.|4\.[0-2])', min(self._build_list)): ```
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
```suggestion - Management groups connected to the workspace. ```
And this one: ```suggestion - Usage metrics for the workspace. ```
```suggestion - Usage metrics for the workspace. ```
You can remove this line if there are no notes.
Your full name should be used.
create/remove are not really states, use 'present' and 'absent'
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
set type to 'path'
use a list type .. since that is what you want
Since attr_field is a list, attr_fields would be a better name (and for the 'field' list above as well)
Code looks good to me but wouldn't mind seeing some unit tests. a little refactoring may make it easier to test, something like: ``` python def _parse_lsdev(self, out_lsdev): devices = [] for line in out_lsdev.splitlines(): field = line.split() device_name = field[0] device_state = field[1] device_type = field[2:] devices.append({'name': device_name, 'state': device_state, 'type': device_type}) return devices def _parse_lsattr(self, out_lsattr): device_attrs = {} for attr in out_lsattr.splitlines(): attr_fields = attr.split() attr_name = attr_fields[0] attr_parameter = attr_fields[1] # attrs.append({'name': attr_name, # 'parameter': attr_parameter}) device_attrs[attr_name] = attr_parameter return device_attrs def _get_device_attrs(self, lsattr_cmd, device_name): lsattr_cmd_args = [lsattr_cmd, '-E', '-l', device_name] rc, out_lsattr, err = self.module.run_command(lsattr_cmd_args) device_attrs = self._parse_lsattr(out_lsattr) return device_attrs def _get_devices(self, lsdev_cmd): rc, out_lsdev, err = self.module.run_command(lsdev_cmd) devices = self._parse_lsdev(out_lsdev) return devices def get_device_facts(self): device_facts = {} device_facts['devices'] = {} lsdev_cmd = self.module.get_bin_path('lsdev', True) lsattr_cmd = self.module.get_bin_path('lsattr', True) rc, out_lsdev, err = self.module.run_command(lsdev_cmd) devices = self._get_devices(lsdev_cmd, out_lsdev) for device in devices: device_attrs = self._get_device_attrs(lsattr_cmd, device['name']) device_facts['devices'][device['name']] = { 'state': device['state'], 'type': ' '.join(device['type']), 'attributes': device_attrs } return device_facts ``` The _parse_lsattr and _parse_lsdev could be unit tests with sample output from the commands
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Need to `return bind_mounts` here
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
pep8 will probably complain about missing a space before the ```in```.
Since we aren't sending the errormsg to an exception, we want to use to_unicode rather than to_bytes. to_bytes won't cause any problems with the code here in python2 but it will fail in python3 (because the string literals will be of the text type and so it won't match with errormsg as bytes then.)
task_uuid seems unused
It would be awesome if buildah supported copying from a container.
pyyhon2 -> python2
its fine to have a 'separate pre-existing file', I would just use it as a fallback if other methods are not populated and i would not create one if it were not already standard.
It also might be good to compare these options to the options in https://github.com/ansible/ansible/blob/cdd21e2170b9a47d84624c8c2f792a66f2b0fe57/lib/ansible/utils/module_docs_fragments/tower.py#L23-L42
i actually don't think you should force having the `tower_config_file` entry, but it could be posed as an option and default to the 'normal location'
you are missing 'requirements' section, requests lib is not part of stdlib in python
How is this required if it can also be specified by the environment variable? Compare to openshift plugin via `ansible-doc -t inventory tower` ``` api_key: description: - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable. ```
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
Probably need a third clause on this for `aws_security_token`- IIRC that can be specified alone.
Is this call redundant? The manager already calls this earlier, so seems like it shouldn't need to happen again (plus we're ignoring its result).
the cache will be by 'plugin/source' initially it will be globally enabled, but i hope to implement per plugin and even per source settings
This is probably more a bigger-picture usability thing with inventory plugins, but it seems like making the plugin do this validation is error-prone, and potentially opens the door to malicious or poorly-written plugins to consume stuff they shouldn't. A realistic setup might have multiple cloud inventory plugins enabled (eg, I'd argue that all the ones we ship in the box should be enabled), which means there's a lot of refusal going on. Regardless, it seems like for config-based plugins like this, that this should be handled by the engine, not the plugin itself. Topic for broader discussion, I'm sure.
https://github.com/ansible/ansible/blob/cd988f645aaf774c55a98a90e3ef42cc5b1a1563/lib/ansible/module_utils/urls.py#L1147 gives all options.
+1 for this.
Add a sample dict returned by module.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
I've started work here to create a separate nlb module and move common code https://github.com/wimnat/ansible/tree/feature/elb_network_lb
@wimnat Are you able to work on elb_network_lb for 2.5? If you have enough on your plate already I'll work on top of your start and open a PR.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Please add the kwarg `exception=traceback.format_exc()` to this failure.
It's worth catching BotoCoreError rather than NoCredentialsError (as that will catch ParameterValidation exceptions too).
`class_name_to_type()` has fallthrough return None if it doesn't find (unless I'm reading it wrong)
Awesome Thanks! ð
shouldn't be required, irrelevant for Amazon providers
`{}` is not compatible across python versions that support format, use `{0}` or `%` instead
this is not good way to set 'changed', if user does not exist you are erroring out instead of returning 'ok' and `changed=False`
here you need just a 'steps' not whole module as well.
also please rename entity_id to job_id, no need to have it too generic here
change 'type(job).__name__.lower()' to just 'job' no need to do it generic here
I would add here fetch_nested=True, because we always want to return steps.
I would write: C(started) is alias for C(present). C(finished) is alias for C(absent). Same in the steps.
Same as above: ```suggestion if params['direction'] not in ['in', 'out']: ```
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
A message string would good to say that image is not preset or something similar.
Here, you might want to return `out` if `re.findall` returns `[]`
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
Yeah, a list is fine.
s/write target file {0}/fetch file to {0}/
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Both `required: true` and `default: null` are not needed anymore. You can leave them if you like, but I thought I'd mention it.
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
`return not owner or owner == publication_info['owner']` could be used.
Lists also have .extend() which might be what you need here
`list`s have `.append()` method. You probably don't want to re-allocate a new instance on each iteration of the loop.
I liked generator approach more: it's more readable in terms of separating a distinct logical step from a higher-level flow.
Let native speakers correct me if I'm wrong, but I think `a` article should be moved to before `package` and before `version`.
Functions which are side effect free and don't deal with external information like this one are excellent choices to unittest. You can give the function a wide range of potential inputs and check that they match up with the expected outputs far cheaper than you can with intergration tests.
No need if there isn't a default variable
Description should be a sentence and include a full stop at the end
Please do it like this: ```yaml author: - Ripon Banik (@riponbanik) ```
The example does not conform to other modules, but also is not in line with this module's parameters.
Please use YAML syntax.
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
unused import ```suggestion ```
```suggestion zabbix_user_info: ```
```suggestion import atexit import traceback ``` Please import `atexit` module
```suggestion tuple: First element is True if valuemap exists and False otherwise. ```
Personally I prefer `is_ansible` or `is_ansible_install` as it makes it more obvious the `is_install` is referring to Ansible's install location and not the collection path. I'm not married to it but I definitely had to look at the code to make sure that is correct.
Typo in the help message
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
Please fix: '... if it doesn't exist:'
Delete this line, this import is also not used.
Delete this line, it's not used either.
Delete this line, it's not used either
This is not used and shouldn't be imported
AnsibleFailJson is not used and shouldn't be imported
please use here self.param('version').get('base_template')
and please add space after `)`
please use here `self.param('version')`
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
Can you please create method `__get_cluster()` and add there the logic on line 1307 - 1310
With this we can't customize from scratch vm. I think we only need: if len(self.params['customization']) > 0:
```suggestion if any([i in network for i in ['ip', 'domain', 'netmask']]) ```
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
Ok we can use sysprep with from scratch VM. But if we run customization in all cases why this condition ? I think it should be : if we set customizations params : if len(self.params['customize']) > 0:
in fact, you are wrong @aperigault because if you add that you will break the guest_map customizations which are handled in customize_vm and doesn't require customize variable namespace
this is an unsafe way to write the file, other processes might get incorrect/incomplete data and if it fails it leaves a corrupt file. write to a temp file and use `atomic_move` instead
This is no longer relevant.
Sorry, hadn't seen this else here, and it's fine to have it like now.
`dcpath` probably got to the incorrect context scope
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
```suggestion re.compile(br"% Prefix length must be less than"), ``` We can almost certainly get away with being slightly less precise with this error.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
ditto on `.` in character groups
ditto on `.` in character groups
It'd be probably better readable with ```suggestion cmd.extend(('-c', communities_tempfile.name)) ``` instead
```suggestion - The public key. ```
```suggestion - The repository name. ```
```suggestion - The public key. ```
```suggestion - The repository owner. ```
The reason I brought it up: https://github.com/ansible/ansible/issues/51757 Though in this case it may not be a connection variable.
not sure if its just me but i still find it confusing, wouldn't it be cleaner as?: ```python flag_val = p[flag] if flag_val: args.extend((arg, to_native(flag_val))) elif flag_val is not None: args.append(arg) ```
At the point it is 'clear' i'm fine with either way, i am not going to force a style unless the code need de-obfuscation.
use to_native (module_utils._text) instead of str, it deals with py2/py3 compatiblity
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
I'm not really a fan of this approach, and generally speaking, we have tried to stay away from it. I am more in favor of just doing: ``` try: sock = socket.create_connection(address) except AttributeError: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect(address) ```
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Types are missing above. token, msg and api are of type "str", port is of type "int". So something like: ```python token = dict(type='str', required=True) ... port = dict(type='int', default=80) ``` Please also add check-mode support. In whatever form you think is appropriate (either log messages adding check-mode run, or not sending messages but e.g. still attempt to connect).
check is redundant as you already flagged as 'required'
set this as the default, then you dont need to do checks yourself
I wonder if we should put each `_evaluate_*_when_result` call into separate `try..except` block for the (I guess rare) case when both `changed_when` and `failed_when` fail. Then we could include the failure reasons for both in the task result at once.
This is probably just me but I had a hard time parsing that. I would change `notify_scope != 'per_loop_item'` into `notify_scope == 'task'` and put it all on the one or two lines maybe. Not a blocker, of course.
This doesn't account for invalid values. I'm wondering if this would be better as a boolean value rather than a string field. Something like `notify_per_item` with a default of `False`. Are there other values for this option that would make it better suited to a string than a boolean? If we do keep it as a string value, maybe the options could be `task, item` or `task, per_item`. Just throwing out ideas.
Nice. So I'd go with `_validate_$whatever_name_we_bikeshed` method to check for invalid values. Unless we decide to use a boolean.
The way we have done this before is via something like `_validate_debugger`. That method effectively does this, but for `debugger`
If the last argument takes precedence then that's even more of a reason to not explicitly support this. On failures the module will try and read the log and return that for debugging purposes but if the file doesn't exist we could be coming across other issues.
This should get imported from ansible.module_utils.six
Please update to be ``` validate_certs: description: - If C(no), SSL certificates will not be validated. - This should only set to C(no) used on personally controlled sites using self-signed certificates. type: bool default: 'yes' ``` and update the module spec
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
You can delete this note and instead use `required: true` under `rpc:`
vtf has `required=True`, so they Playbook writer will always have to specify a vrf, so I'm not sure what this note means.
Not sure if this line is needed as `vrf` has `required: true`
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
Mutually exclusive with I(domain_search).
```suggestion - When you masked a value, the value must be base64 compliant and has at least a length of 8 characters. ```
```suggestion - When a value is masked, it must be in Base64 and have a length of at least 8 characters. ```
You could simply only pass variables that are `True`, then you're on the safe side :) I.e. something like ```.py params = {"key": key, "value": value} if masked: params["masked"] = True if protected: params["protected"] = True return self.project.variables.create(params) ```
```suggestion - Support for protected values requires GitLab >= 9.3. ```
```suggestion self._module.fail_json(msg="value must be of type string or dict") ```
rename to `cluster`
rename to `zone`
call this just pod, identical to the param we pass. Fixes inconsistency with other modules.
call this just cluster, identical to the param we pass. Fixes inconsistency with other modules.
yes, None values are excluded by the lib cs underneath
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
just call scaleway.ini we are in ansible conflict should not occur
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
You should probably note that these patterns are expected to be regex (vs. globs). The examples show this, but it doesn't hurt to be explicit. It also wouldn't hurt to mention that the patterns are not implicitly anchored.
```suggestion - name: Show variables with 'hosts' in their names ```
```suggestion - name: Find several related variables that end specific way ```
```suggestion - List of the variable names requested. type: list ```
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
Hmm. The problem with this is that it isn't possible to turn off log file validation, making this fail the idempotency test (you can't assert that log file validation is disabled). I'm not sure if the 'bool' param allows for the param to be [omitted](http://docs.ansible.com/ansible/latest/playbooks_filters.html#omitting-parameters) or if it defaults to false; if you can't test that, I'll try to get to it in the next few days/weeks.
I just tested this and can confirm that once you enable log file validation you can't set it back to False due to the conditional on 488. `AnsibleModule` by default sets parameters to None if they are not specified and do not have a Default set, regardless of their type. So in the current code I think the above behavior can be avoided by changing line 488 to: ```python if module.params['enable_log_file_validation'] is not None: ct_params['EnableLogFileValidation'] = module.params['enable_log_file_validation'] ```
No worries. Thanks for your patience.
If this is set to type='int' this should avoid the later type conversion
You might need to use a paginator here if there might ever be more than 50 results
This API does not look good to me, it's unpythonic. Using return values to indicate errors is used in some ancient and low-level languages like C or Go which don't have nice built-in mechanisms for communicating errors to the caller. In Python we raise exceptions for that and try/except at proper locations up the call stack.
This is a bad API: initializer should return a ready-to-use connection object rather than some half-baked thing somebody should not forget to poke afterwards. Please connect right in initializer. Also, Python has a context manager protocol especially useful for working with external resources (files, DBs, services on the network. If any exception happens before "manual" disconnect it won't get called and the connection may stay unclosed for a while on the low-level. You should use a context manager openning the connection in initializer and/or on enter and closing it on exit. Besides, API like this looks just beautiful: ```python with iDRACConnection(module) as idrac: msg = update_firmware_from_netshare(idrac, module) ```
I just want to emphasize that assigning different types of data to the same variable is usually error-prone and should be avoided.
Please use PEP257 style guide for good docstrings. The title should be a sentence with a period in the end and it should go one line above with one empty line separator from the long description.
Python is a language with encourages clear and human-readable communication. While keeping things short we don't sacrifice keystrokes. fw and nw are misleading for the reader (especially where this thing is called). firewall? northwest? ```suggestion def update_firmware_from_netshare(idrac, module): ```
You should probably use `transform_commands` from `ansible.module_utils.network.common.utils` instead.
`wait_for=dict(type='list'),` (remove waitfor)
resue the function here https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L73 to avoid code duplication
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
Please remove `force:`
Please remove `module.fail_json` and use `ModuleFailException`.
You have some syntax errors in this `if` statement.
You can simplify this line and the next ones as follows: ```suggestion if (300 <= info['status'] < 400 and not allow_redirect) or \ ``` In Python (as opposed to C/C++), this yields the correct behavior.
You are not returning `state` in any of the `exit_json`. You should drop the `status` as that can be determined from the `state` and the `changed` values.
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
```suggestion try: ```
Why the loop here? `if match` should be sufficient
This break will be unnecessary if the loop gets dropped
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Help text needed now that this is not an internal implementation detail: ```suggestion help='base branch used for change detection') ```
Personally I prefer `is_ansible` or `is_ansible_install` as it makes it more obvious the `is_install` is referring to Ansible's install location and not the collection path. I'm not married to it but I definitely had to look at the code to make sure that is correct.
Tell people where we are looking `CONFIG_FILES`
Please fix: '... if it doesn't exist:'
'exists' -> 'exist'
No need for this to be a private method. rename to get_inventory().
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
This should be a @staticmethod and self removed.
Make this a regular function
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Yes. Either to_native or to_text would be fine in this case.
You can remove this. If there isn't a specified return, None is returned.
Can you just catch `AttributeError` here instead.
Another general exception handling that can be removed.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
IMHO this is not python 2.6 compatible (https://docs.python.org/2/library/string.html#format-string-syntax). I usually avoid format at all and use the % syntax.
`creation_response.body` is empty I propose to use: ``` "%s: '%s' (%s)" % (creation_response.info['msg'], creation_response.json['message'], creation_response.json) ```
I see that the requirements lists python-2.6 as the minimum python version. Unfortunately, format strings in python-2.6 are more limited than in python-2.7 and later. So you need to be explicit about the position in the format args list you are looking at like this: ``` python response = rest.get('floating_ips/{0}/actions/{1}'.format(ip, action_id)) ``` There's a few other places with format strings that have to be fixed as well.
``` if module.params["state"] == absent: absent_strategy(pi=api, wished_ip=wished_ip) else: present_strategy(pi=api, wished_ip=wished_ip) ``` could be more readable.
examples. - Remove space before full stop
Mutually exclusive with I(domain_search).
a teeny typo: ipvr_addresses -> ipv4_addresses
Let's see if anyone else complains about that when reviewing ;)
I know, but I had the impression that there was a tendency to switch from `true`/`false` to `yes`/`no`. But maybe I'm also mistaken.
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line.
```suggestion - This parameter is required, if C(state) is set to C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
```suggestion - 'If C(state) is set to C(powered-on) or C(poweredon) and virtual machine exists with powerstate other than powered on, ```
```suggestion - 'If C(state) is set to C(powered-off) or C(poweredoff) and virtual machine exists with powerstate other than powered off, ```
I would keep all previous states as well in-order to maintain backward compatibility.
```suggestion - 'If C(state) is set to one of the following C(powered-on), C(poweredon), C(powered-off), C(poweredoff), C(present), C(restarted), C(suspended) ```
This should be 2.4 now
Same here, no quotes needed for a multiline string.
Not sure if it's the good way to do this. I think you better put common code (like authentication) in some module_utils file and use it in modules. Look at cloudstak modules and module_utils files.
No quotes needed for present or absent, so: ```yaml choices: [ absent, present ] ```
Choose between camel case (here for userName) and delimiter-separated words (in validate_certs) Most of ansible is based on delimiter-separated words.
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
you use get_bin_path above, i would reuse it for all lsattr calls (and do same for the other utilities below)
It looks to me like you're assuming that the commen this always there (is it like that? I don't know) and has no spaces in it.
In case the file doesn't exist, `keypair.check(module)` returns `False`, whence `changed` is set to `True`. I don't think that's correct.
This is 1:1 the same code as in https://github.com/ansible/ansible/blob/8a671f54ddc5ec114ef807dc71f49d61261d2107/lib/ansible/module_utils/crypto.py#L150-L160
Ah, I think the point is that `os.remove()` raises an exception if the file isn't there, so `changed` won't be set to `True`.
- You are producing a hex-encoded digest, decoding it back into binary, then encoding it as hex again. - `encode('hex')` (or rather the `hex` codec) is pretty nasty to use, as codecs as supposed to work with Unicode strings. (I suspect that's why you end up doing the encode/decode/encode dance) What about this: fingerprint[algo] = ':'.join(pubkey_digest[i:i+2] for i in range(0, len(pubkey_digest), 2))
Here and below: ~~private key~~ --> key pair
`pipes.quote` is deprecated in Python 2.7 already. You should import `shlex.quote` if available. try: from shlex import quote except ImportError: from pipes import quote
When this message is printed, it will contain a newline followed by a lot of spaces. You should compose it as follows: ``` .py module.fail_json(msg=('For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. ' 'Attempting to use bit lengths under 1024 will cause the module to fail.')) ```
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
I think it would be fine to specify that group_id can just be used with absent. The ability to change security group attributes with the ID could be another feature request/pr. If you're itching to implement that have at it, but do whatever makes sense to you.
So I'd change this description here to required when I(state=present) or something.
I wonder if you should create an alias: descrption So that existing playbooks are not broken. And maybe it would fix the validation error.
No need to add quotes around this line.
please add a note that this feature is available since ansible 2.6
@abadger I checked the source of that `warning()` function and it seems like it concatenates input with native strings which concerns me.
```suggestion json=facts, ```
This is probably the only line which should be wrapped with try/except.
no prints, no str , use display and to_text
Same here: move url outside of the loop: ```suggestion ```
The results of vmdk_disk_path_split are not used anywhere here (they are used inside find_vmdk, but it calls the routine directly.
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
You forget to make the change.
Ah, right, got it :+1:
I don't understand why we would `return False` here. This function is about giving back an instance based on the public IP address or failing gracefully with an error message for the user. If this `return False` is happening, we need to write code to handle that in all places it is called within the module. This can lead to extra `if/else` which we should avoid for maintainability purposes.
I think we should guard against an `IndexError`. Even if Linode guarantee us some value, given programming error and such, I'd like to guarantee users of this module error messages that lead them in the right direction.
no need. dependency check done by AnsibleAWSModule
If state: absent and the ip is not there, this raises botocore exception `InvalidAddress.NotFound`.
It is valid for a ComputerSystem to have a `Storage` resource or a `SimpleStorage` resource or both. And each of these can describe Drives in the system. So we should keep the original `SimpleStorage` logic along with your newly added `Storage` logic. If there are both `SimpleStorage` and `Stroage` resoures present, the returned `result` should include the drive info from both. Something like this: ``` if 'SimpleStorage' not in data and 'Storage' not in data: return {'ret': False, 'msg': "SimpleStorage or Storage resource not found"} if 'SimpleStorage' in data: # do the original SimpleStorage logic if 'Storage' in data: # do the new Storage logic ```
```suggestion disk_result[property] = device[property] ```
Not all chassis will have a `Power` property. Should check for `if 'Power' in data:` before proceeding with this line.
Will fail if `self.manager_uri` is not set yet.
This will fail if `self.accounts_uri` is not initialized.
```suggestion rc, vg_extent_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "vg_extent_size"]) ```
```suggestion rc, pe_start, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pe_start"]) ```
```suggestion rc, pv_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pv_size"]) ```
```suggestion pvdiplay_cmd_device_options = [pvdisplay_cmd, device] + pvdisplay_ops ```
Line is too long.
Not required, we already have method called `connect_to_api`. Also, I would recommend to use `from ansible.module_utils.vmware import PyVmomi` which base class for all VMware_* modules.
Not required as we can use connect_to_api method.
Remove redundant import
Add this at top after License. See example above.
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
Don't add this, if the parameter is not required.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Right but this seems arbitrary, cut off at 40 characters ? For readability I think it's better to not split lines if it is not required. But you are right, it's not mandatory. So you can ignore this :-)
Please put this on a single line. Lines can be 159 characters wide.
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
finding it when not using pipeline is normally `dirname(__file__)` as module itself is located there.. but as discussed, need to create generic and then revisit modules doing this
we normally prefer to use the same tmp directory as the modules themselves are put into
not a requirement, but would be nice to validate all IDs before returning an error (in case more than one is wrong)
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
If you're trying to make sure we don't overtax the cpu, use this: ```min(len(mtab_entries), multiprocessing.cpu_count())```
Another regex that can be precompiled.
Right -- it shouldn't be needed because splitlines() will remove all "\n".
Can you please add a check if db exists before taking backup ? I see there is a method called `db_exists` which can reused here.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
nit: I think this should be wrapped. 121 line length is longer than it should be. While Ansible has a lot of code which doesn't adhere to pep8 we should strive to be better, so lets try and keep the line length to 80 or 120.
nit: I think this should be wrapped. 121 line length is longer than it should be. While Ansible has a lot of code which doesn't adhere to pep8 we should strive to be better, so lets try and keep the line length to 80 or 120.
Use iface['subnet'] in the fail_json().
It might also be no IGWs found here.
So why are you setting `ip_configuration` with `ip_configurations`, if there is only 1 IP configuration then shouldn't the Azure SDK be able to handle that within the `ip_configurations` field making this a moot parameter.
I would change "updated" to "present". Some other network modules. e.g. ios_config, have an boolean option backup (e.g. backup: true) to make a backup before copied locally before changing.
regarding backup, the way this is implemented will backup the file to the location where the module is executed. When we exeucte this as local_action or `ansible_connection=local`, it will backup the file to the control machine, however we run this module with `ansible_connection=ssh` it will be backuped to the remote machine. This is probably not what is intended. So this should be solved as "action_plugin" (identical to ios_config) which will ensure, the backup is going to the control machine.
I don't recommend going the action plugin route, just make sure description points out that backup is where module executed. backups via action plugins are a bad pattern, now that include_role exists it makes more sense to move to a role.
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
catch all exception should be avoided
My bad. Didn't see if in later stages.
You are not executing command returned by `modify_conn_disable_ipv4` so I am sure that it has no effect.
My bad. Didn't see if in later stages.
Add an example for this in EXAMPLE section.
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Only those two lines are required, and it works for me with it
I've tried your branch on my local grafana with the `json.loads` fix. If I import an existing dashboard (previously in general folder) it will be moved to the specified folder. but the module is not idempotent anymore. If I re-run the playbook the task will return a `changed` status even if the dashboard json file has no changes.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
This logic tried to enforce a minimum version requirement, which the new code does not. Since it doesn't sound like you have added compatibility with older versions (or have any reason to), why not do something like: ``` min_version = '2.4' if loose_srv_version < LooseVersion(min_version): module.fail_json(msg='MongoDB {0] found, the minimum version supported by this module is {1}'.format(srv_version, min_version)) ```
```suggestion msg = ' (Note: you must use pymongo >= {0} with MongoDB {1})'.format(loose_srv_requirement, loose_srv_version) ```
`loose_driver_version = LooseVersion(PyMongoVersion)` <-- it's already calculated above. I think this case could go to the dict above if done carefully. This could be some hack like `{'-inf': '2.5'}`. But, looking at the error message, I'd say it'd be just `{'2.4': '2.5'}` and the error message would be normilized as well then.
It's different because the join and split actually do something and have a clear reason for being included. It also correctly handles versions like 3.4.1, which chopping off the end of the string doesn't. ``` >>> srv_version = '3.4.16' >>> srv_version[:-3] '3.4' >>> srv_version = '3.4.1' >>> srv_version[:-3] '3.' ```
I'm not sure what the purpose of the split and join currently are. Shouldn't this be splitting and joining on `.`? ```suggestion loose_srv_version = LooseVersion('.'.join(srv_version.split('.')[:2])) ```
not needed when `required=True` is specified
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
not needed when `required=True` is specified
having `main()` call `run_module()` feels a bit redundant, I see no reason to not put all of the main logic in `main` (and splitting actions into functions where it makes sense)
Wondering what the advantage is to do it this way, or just have: ```python if ...: return True return False ```
This will concatenate all chunks into a single-line string. Try multiline: ```suggestion self.module.fail_json(msg=textwrap.dedent(""" Failed to add vSwitch '%s', this can be due to either of following: 1. vSwitch Name exceeds the maximum allowed length, 2. Number of ports specified falls out of valid range, 3. Network policy is invalid, 4. Beacon configuration is invalid : %s """) % (self.switch, to_native(invalid_argument.msg))) ```
Yeah, smth like that. Input args might also be useful there. Basically any details you're able to retrieve is good :)
Sorry, I cannot point to one. It's just an idea though, not a strict rule or requirement.
@ckotte you're right about wholesale exceptions in general. However, there's one case when it's okay: on the top level layer of the app (in this case the module). The thing is that if the process will just crash it won't return a failed json struct to the Ansible controller, which won't be able to handle this better then. So I'd put such handler around (some part of?) main func.
Oops, the following sentence is now redundant and can be removed: > A previous version may be specified C(name-0.9) to downgrade a package.
Can we have a list of packages which can be locked/unlocked? just like yum module does.
use this instead ``` module.get_bin_path('yum', required=True) ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
Should have a default set to `present`.
I don't think the `or []` is needed here. If there are no server groups defined, the API already returns an empty list.
The API currently allows multiple groups with the same name. Do we need some logic similar to the logic in `cloudscale_server` to detect this? Otherwise this could lead to surprising results... And tests for this case would be nice too.
I would probably make this a module level constant like `ALLOWED_STATES`. I also noticed that you don't transform the output for the diff. I don't think it matters much but for consistency this should ideally also be transformed. Maybe the best way to handle this would be to transform the values already in `def _get_server_info`. This way the module internal name would always be "state" and there would be no confusion between "state" and "status". That's also how this was handled before your change.
As you already have the same 'or' clause in `_init_server_container` you can just rely on `self._info.get('uuid')` here.
call this just pod, identical to the param we pass. Fixes inconsistency with other modules.
No need to set this, or check it.
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
change this to return `customer_gateways`
not needed with AnsibleAWSModule
e is added to the exception in fail_json_aws so doing it again here will result in a redundant error message. Same for the other exception handling. You could use `.format(module.params['domain'])` instead to let the user know which domain failed.
You could just import `defaultdict` from collections
You don't need to import everything from ec2. Looks like you're using: ec2_argument_spec, HAS_BOTO3, get_aws_connection_info, boto3_conn
You can change this to `from botocore.exceptions import BotoCoreError, ClientError` since those are the two that need handling.
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
the key is now `id` ~~~ "id": "5abf426403479", ~~~
docs, hint, hint. ~~~diff - "SSHKEYID": "5abf426403479", ~~~
remove `convert_to='int'`as it does not look like it can be converted.
I don't believe we should be hard coding permissions here. We should use the system default value from `/etc/login.defs` or add this as a module parameter the defaults to the system value.
`f` variable isn't used in this 2nd `try` block: it seems a `for` loop is missing.
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
I think you need `to_native` here.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This should be 2.4 now
Same here, no quotes needed for a multiline string.
Not sure if it's the good way to do this. I think you better put common code (like authentication) in some module_utils file and use it in modules. Look at cloudstak modules and module_utils files.
No quotes needed for present or absent, so: ```yaml choices: [ absent, present ] ```
Choose between camel case (here for userName) and delimiter-separated words (in validate_certs) Most of ansible is based on delimiter-separated words.
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
What if the rest service_principal missing client/secret field
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
I think this logic should be handled by service instead of ansible client side
`self` is no need
This was kept here for backward compatbility - https://github.com/ansible/ansible/pull/59974/files#r313368633
Looking through the code more carefully, I think this change is correct. We should only being using `hostnamectl` where we pass it flags to return _only_ the hostname. That is currently the `SystemdStrategy` class. Otherwise the value returned from `self.hostname_cmd` would be not at all what we expect. I don't think having this conditional buys us anything, nor does it help with backward compatibility.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
no need for the () after if
excellent handling of congestion control
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
I learned recently that you can use actual separate literals to improve readability: ```suggestion @pytest.mark.parametrize(['url', 'expected'], [ ```
I'd do ```suggestion if not ignore_errors: raise ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Lines [434,441] are just plain wrong, since Redfish standard mandates that new user (or any other resource) is created by POSTing payload to the proper collection's path (`ManagerAccountCollection` in this case specifically). The returned response body and `Location` header will contain OData id of the user that is automatically generated (reference: http://redfish.dmtf.org/schemas/DSP0266_1.5.0.html#create-post-a-id-create-post-a-).
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Note: It's preferable to use Mapping rather than dict. That way a Mapping object that does not inherit from dict would be recognized.
IMO the previous block is not needed, and this error should become error 325.
That list should be shared with the Schema tests :)
But to be honest, the types should be identical, it shouldn't matter what it is.
Same as in the doc
why force either/or? you should be able to read some things from the config file, others from env vars, user might not wan't all eggs in one basket
you can also just have a config file with `plugin: tower` as it's only entry
my other issue is if user has an actual 'tower_inventory' file in cwd ... i would use something more like `@tower_inventory` or some other symbol to disambiguate from 'actual file'
Are other plugins supporting any kind of file-less use? It seems like that's more of where this was trying to go.
I wouldn't dive into that just yet. That would be very hard to do elegantly. I'm not even sure if it really philosophically makes sense.
```suggestion description: - A seed to initialize the random number generator. - Identical seeds will yield identical passwords. - Use this parameter for random but idempotent password generation. ```
```suggestion - Use this for random-but-consistent password generation. ```
I'm not a fan of the "I" word because it's quite jargon-y. But I'll yield to consistency for the time being.
Since you're updating the docs, can you update the Examples to use multi-line YAML? ```yaml - debug: var: mypassword vars: mypassword: "{{ lookup('passwordstore', 'example/test create=true')}}" ```
If it is not requires, don't add it. ```suggestion whitelist_tcp=dict(type='list', default=list()), ```
Maybe change the name from dsc to. Something else, it seems a bit out of place here
Would it be better to change the logic here to be: ```python query = "CREATE EXTENSION \"%s\"" % ext if cascade: query += " CASCADE" ```
Typo: exists -> exist (should be singular). I'm not really sure this is an improvement as you lose the explanation of what 'args' can be used for.
```suggestion {% if no_proxy | regex_search('\/') and ```
Targeting 2.7.10. Updated to reflect that.
The sample should likely be an actual hash output (i.e. with the right format/size)
Same here: use `AnsibleModule.digest_from_file()`.
Or maybe ```suggestion self.default_inventory_hostname = '_'.join(( vm_model['name'], hashlib.sha1(to_bytes(vm_model['id'])).hexdigest()[0:4], )) ```
Needs to be `changeset_name = stack_params['ChangeSetName']` to match PEP8 style of whitespace around operators.
Use `to_native` for wrapping error message.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
I think it's nicer to have trailing commas: ```suggestion ], indirect=['mapping'], ```
This assertion doesn't make sense: you're testing whether your fixture returns a Mapping instance which it always does. ```suggestion ```
```suggestion assert ansible_json_encoder.default(m) == expected ```
Could you please keep the same string quoting style across the module? ```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('UTC')), '2019-06-15T14:45:00+00:00'), ```
```suggestion vault_data(), ```
That's an ugly one. Interesting that no-one ever complained about it...
> I feel like a [WARNING] should pop up when you do that When specify a hash string that matches more than one image? We should `fail` immediately, this is users' fault.
`docker_py` use `id[:10]` as `short_id`, but `docker images` shows a 12-char version. I think there's no "standard" short version of `image[Id]`. "Registry returned more than one result for sha256:8fc" should be good enough. Users know what they're doing.
What happens if it is missing? Will the module still work? (Right now, it never checks this variable again.)
i would mention this plugin is Windows specific
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
no need to specify required=False or type=str as these are defaults
`changed` doesn't need to be an attribute.
this is not good way to set 'changed', if user does not exist you are erroring out instead of returning 'ok' and `changed=False`
i would still not make this an option, but try to capture the copystat error on hp/ux and issue the warning as we do for enosys case
Note that fail/exit_json should be handling bytes or text; making them the proper string type for that python version before passing them in to the stdlib's json.dumps().
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
This should be `b_output_path` to indicate it is a series of bytes. Even if the caller is sending in bytes, this function should convert it to bytes just like `b_collection_path` at the beginning. That allows our `b_` naming convention to hold, making this code look incorrect (trying to join `bytes` and `str`).
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
This is new lookup so no need to add `version_added`
Might want to check `rc` status before return output.
Sorry, my bad. I didn't see the implementation of `_run`.
```suggestion version_added: "2.8" ```
```suggestion msg = "Couldn't associate Elastic IP address with instance '{0}'".format(device_id) ```
It may not be forward compatible then, but it seems unlikely AWS would change it unless they introduced something new.
no need. dependency check done by AnsibleAWSModule
If state: absent and the ip is not there, this raises botocore exception `InvalidAddress.NotFound`.
Ah, it's nice that the syntax checker caught this bug. This should be `network_interface['tags'] = boto3_tag_list_to_ansible_dict(tag_set_copy)`
This API does not look good to me, it's unpythonic. Using return values to indicate errors is used in some ancient and low-level languages like C or Go which don't have nice built-in mechanisms for communicating errors to the caller. In Python we raise exceptions for that and try/except at proper locations up the call stack.
This is a bad API: initializer should return a ready-to-use connection object rather than some half-baked thing somebody should not forget to poke afterwards. Please connect right in initializer. Also, Python has a context manager protocol especially useful for working with external resources (files, DBs, services on the network. If any exception happens before "manual" disconnect it won't get called and the connection may stay unclosed for a while on the low-level. You should use a context manager openning the connection in initializer and/or on enter and closing it on exit. Besides, API like this looks just beautiful: ```python with iDRACConnection(module) as idrac: msg = update_firmware_from_netshare(idrac, module) ```
I just want to emphasize that assigning different types of data to the same variable is usually error-prone and should be avoided.
Please use PEP257 style guide for good docstrings. The title should be a sentence with a period in the end and it should go one line above with one empty line separator from the long description.
Python is a language with encourages clear and human-readable communication. While keeping things short we don't sacrifice keystrokes. fw and nw are misleading for the reader (especially where this thing is called). firewall? northwest? ```suggestion def update_firmware_from_netshare(idrac, module): ```
Same as above: unnecessary fixture test.
```suggestion assert ansible_json_encoder.default(test_input) == expected ```
```suggestion assert ansible_json_encoder.default(m) == expected ```
This assertion doesn't make sense: you're testing whether your fixture returns a Mapping instance which it always does. ```suggestion ```
If you expect this invocation to emit an exception, `assert`ion doesn't make sense here: ```suggestion ansible_json_encoder.default(test_input) ```
not just tags, i would make this a generic function for templatable and appendable FieldAttirbutes (tags, environment, module_defaults and conditionals)
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
```suggestion # just get value from attribute itself as normal ```
What does this method name mean? No need to do anything, I'm just curious.
Oh, it's supposed to be "dereg" as in "deregister"
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
makedirs_safe already does this, just use that function
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
Is there a case to be made for `task_definition` being optional, and if not present, returning task definitions for all tasks. Furthermore, I think I'd consider extending this module to become ecs_task_facts, and return the task data along with the task definition and then describing one or more tasks as options.
This class isn't really providing any value. Usual practice is to create the client in main and then call a describe_task_definitions method.
Thanks for the contribution! Since new AWS modules are required to just use boto3, you can remove this. Your exception handling can also be updated to be for boto3. Each boto3 call should be in a try/except. There's some helpful info here: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
Need to use new-style Python 2 classes, as this Py3 class declaration won't behave right in Python 2 environments. Change to `class EcsAttributes(object):`
This place in code **does not affect** cloning/initing, while operating on **existing repo**, which makes it pointless. Also, it would be architecturally wrong to do it from some random phase of module execution. We would still have to bypass it to clone/init anyway.
Yes, but it is still unrelated to the env var.
should the line start with `gitdir` or should it be in the end of line with smth prefixed? you might want to prefix the regex with `^`. On the other hand, taking into account that regexps are expensive, you could just use str.split or partition with bits of validation on top, like: ```python try: ref_prefix, separate_git_dir = data.split('gitdir: ', 1) if ref_prefix: raise ValueError('.git file has invalid git dir reference format') if not os.path.isdir(separate_git_dir): raise TypeError('%s is not a directory' % separate_git_dir) os.environ['GIT_DIR'] = separate_git_dir except (TypeError, ValueError) as err: """``.git`` file does not have a valid format for detached Git dir.""" module.fail_json( msg='Current repo does not have a valid reference to a ' 'separate Git dir or it refers to the invalid path', details=str(err), ) ```
Please dedent all the following code, so that it would be outside of `with`-block.
Also, in case of not match `gitconfig` would have `None` value, which would've broken this module in some place being executed later.
Nowadays, we import BUFSIZE from ansible.plugins.connection.
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
```suggestion - Name of the domain to be managed. ```
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
well, maybe. I haven't checked what `.absolute()` does.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
probably want a to_text and u prefix.
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
Just to be sure add a `if not host_data: ...`
I would default vars to `{}`
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
```suggestion groupby = {k: self.to_safe(to_text(v)) for k, v in params.items()} ```
I find the inconsistent capitalization very confusing. There's `Name` and `Facts` but also `all_parameters`. Here we have `environment` but also `Location` and `Organization`. Ideally the original API response would be normalized.
That `__metaclass__ = type` line in the top of this module turns all classes into new-style automagically. So you don't need to inherit from `object` explicitly anymore. ```suggestion class PodmanManager: ```
Please use verbs in method names. Like ```suggestion def _perform_action(self, action): ```
I recommend you reversing this into a "guard expression" style: ```suggestion if rc == 0: return json.loads(out)[0] ``` And then you can reduce the nesting of the whole block of code which improves readability.
Maybe ```suggestion return bool(self.info) ```
Please don't use inconsistent return values throughout the function. Currently, you use `NoneType` and `bool`. Use just one type. This is unnecessary. ```suggestion ```
Use 2019 instead and use the latest license template https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/cli/cli_config.py#L1-L5
Copyright should be updated (that's a detail)
Typo here, should be L2 interfaces
Replace vyos with junos
Please use updated boilerplate. [Reference](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/iosxr/iosxr_banner.py)
this is error-prone as it will cause exception if someone decides to have duplicate keys there. better way is to do like this: ```python kwargs = dict(...) # leave it as is if any(spec in kwargs for spec in extra_specs): # do input validation raise ValueError('Duplicate key in extra_specs') kwargs = dict(kwargs, **extra_specs) # actually upgrade it ```
Technically this will never be `None` because of the defaults.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Note that str() can fail if the object's __str__ method returns non-ascii characters. You probably control the objects being used here so you know whether that's the case or not. I usually use ```to_native(self.change_relelvant_keys, nonstring='simplerepr')``` in similar situations so I don't have to worry about it.
@bcoca noted the use of state=info in today's meeting... I think a year ago, or so, we discussed using a separate module named with an _info suffix (like sophos_utm_info.py) for things that are just for gathering info about something which doesn't relate to the host it is run on. (You also thought you might turn that portion into a lookup plugin. That would also be fine. The difference is just that a lookup can only be run o nthe controller whereas a module can be used on either the controller or a remote host).
should be consistent with sample name and resource_group
that should be example of module usage, not return value
we should be using boto3_conn for all connections. For example, security_token is missing here. boto3_conn avoids you having to worry about that.
`Current host '%s' can not be %s...`
you can create entire dictionary at once
Please order the parameters alphabetically.
This should be `fail_json()`.
This should be `fail_json()`.
please use explicit imports
please wrap in `if` block
This will fix the CI issue
My concern about this really needing to be two modules, one for settings_facts and one for settings, has not been addressed.
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
*be a string
@jainnikhil30 and I took a look at the tower_cli code which is backing this tonight and decided that tower_cli is trying to coerce the types from a schema that it retrieves from the tower server. So it looks like the module code does not have to worry about this conversion.
doesnt --> does not
Probably more like "Whether the specified network vlan should exist or not"
Yes, you can- so long as a default is not specified, an unset value will still be `None`
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
Not having any default would cause failures for folks who have been relying on default=instance with state=present, we'd need a deprecation cycle to do this. Logically I think we only need a default if state=present though, so we could put this in the if block at ln843.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
host_storage.type == otypes.StorageType.FCP
If this is set to type='int' this should avoid the later type conversion
I would let the `scaleway_compute` handles IP assignation to server.
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
Do note that this only looks at the primary credential cache. This means that if you use a collection credential cache such as DIR, KEYRING or KCM (default in most distributions these days), you might not see a ticket that exists in a non-primary credential cache. Maybe consider using `klist -A`, or try a `kswitch -p <principal>`? The latter is easier to parse, but might break stuff if people are still using the old krb5 APIs (rather than GSSAPI) and were using the primary credential that you just made secondary.
s/run the/run in the/
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
s/does not do anything/has no effect/
You can do that as part of the param_spec like this: ```python module = AnsibleModule( argument_spec = dict( dest = dict(type='str', required=True), options = dict(type='str', default='preallocation=metadata'), format = dict(type='str', default='qcow2'), size = dict(type='str'), grow= dict(type="bool", default=True), shrink = dict(type="bool", default=False), state = dict(type='str', choices=['absent', 'present'], default='present'), ), supports_check_mode = True, required_if=[ ( "state", "present", [ "size" ] ), ], ) ```
I don't think this is working correctly, did you test it for all possible inputs ? - First of all the size_unit is only correct if it is a known unit. - And if that's not true, and it's not a digit, you have to escalate. - If it is a digit, you likely won't have a unit and then you could assume bytes.
The mixup to me is that people using incorrect units will silently be using bytes, whereas it should report this as an error.
This means that if you'd be using 16m, it will be 16 bytes too. You will have to do a lot more to avoid mixups here.
There is a much easier way to do this, by using the index in the list. Something like: ```python unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
```suggestion def fetch_chart_info(command, chart_ref): ```
Yes, but this module doesn't run on machines where ansible is installed...
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
Maybe use ```suggestion type: path ``` instead? Then Ansible will replace things like `~` IIRC.
```suggestion - Required when I(release_state) is set to C(present) ``` Use `I(...)` for option names, `C(...)` for option values.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
please add the httplib in requirements
Is it worthwhile taking a copy of the text utils we already have in Ansible. They have a `nonstring` option to define things like what to do when a None object is being encoded.
the error should go to stderr, since sys.exit does this by default (and still returns rc=1) just use that.
Now you need to update `self.public_key` another time.
I think an internal map with the file_type to 'stat operation' matching would be a cleaner way to implement this and then have: ```statop = getattr(stat, FILE_MAP[params['file_type']]``` to find the function for comparison
I think `if props is not None` is more conventional :smile:
The default here is to use 'yes'. That's how all modules work, by default they take the system configuration.
Doesn't need to be quoted. We tend to only quote strings when it is required.
Lowercase yes :-)
The `version` return value could be valuable for users that need to support more than one DNA-Center which may return different results.
Ok, so I see 2 values being returned, `response` and `version`. I would merged the result dictionary and add both. ```python result.update(json.loads(resp.read())) ``` In this case you don't have to create the `message` entry in **result**.
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Only those two lines are required, and it works for me with it
I've tried your branch on my local grafana with the `json.loads` fix. If I import an existing dashboard (previously in general folder) it will be moved to the specified folder. but the module is not idempotent anymore. If I re-run the playbook the task will return a `changed` status even if the dashboard json file has no changes.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling here too.
No need for quotes here.
Could you please correct docstring? There is no boolean value in return value.
Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
For options, use C(absent) instead of I(absent)
use `from ansible.module_utils.six import iteritems`
Please add spaces around the equal sign.
Please add spaces around the equal sign.
I used to do a lot of Perl before as well. You can take that as a good opportunity to get into the Python programming. I think it would be worth using the Python module instead of calling the shell command.
Please add spaces around the equal sign.
Please add spaces around the equal sign.
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
<nod> I see what you mean about checking the length for the secret leaking information about the secret that the attacker would not otherwise know. However, checking the length for the plaintext doesn't seem to suffer from that same problem. The attacker already has an idea of how long the plaintext is because the length of the ciphertext will reflect that. So checking the length of the plaintext and falling back to os.urandom() if the plaintext is too short seems like it can prevent some problems without revealing new information? (Hmm... it would reveal that the plaintext is less than a precise value whereas looking at the length of the ciphertext would be more vague.... Would that be important or not?) The attacker can learn a lot about what is in a vault file from external sources... for instance, since they're yaml files, they likely have a rough outline of: ``` --- var: value ``` an attacker might also find the precise name to use for "var" by looking at playbooks to see which variable names exist that are not defined outside of a playbook. So then the only thing about the plaintext that they'd be lacking would be the actual value....
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
I'd rephrase: 'Obtain data of `vm_name` if specified, ...'
s/will created/will be created/
Please fix: '... if it doesn't exist:'
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
You can delete this line.
Please update formatting as per `mcp_user`
`If not specified, will fall back to the C(MCP_USER) environment variable or credentials specified in C(~/.dimensiondata).`
+1 to adding that note :)
Please only import what you need, rather than `*`.
Use ```python cmd = "%s box list" % self.module.get_bin_path('vagrant', required=True) ```
Required is False by-default, so no need to describe explicitly in docs.
add `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` to ensure all commands have an expected LANG
`default: None` is the default, can be left off
This line can be removed
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
I think it's not good style to use `global`.
You should always have `type='str'` (or whatever type you have) in all of argument spec.
```suggestion # require that the final recorded stack state was DELETE_COMPLETE ```
This is now auto-handled by AnsibleAWSModule
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
This could be optimized to state the used domain_type.
could be just `if module.params['dns_domain'] is not None:`
`if self.params["cdrom"].get('type') not in ['none', 'client', 'iso']:`
You can just use initialize `ide_device = None` and drop `ide_exist` variable.
It would be nice to return the object you created too: `res['provider'] = self._get_saml_provider(self._get_provider_arn(name))`
We don't need it. It could be simplified using: ```python keys = out.splitlines()[0].lower().split() ```
Isn't duplicate this loop in here? I also think we could simplify it here starting after the first line ```python for line in out.splitlines()[1:] ```
keys in lowercase
It's probably better to loop over the items and check the value before changing, so you can report back if there was a change or not.
This condition can be removed
You're correct. I misread that this `if` statement is indented. Looks good!
I would also add the deprecation warning here in addition to the failure.
no, it's probably not fixable anyway
It might be better to use a similar regex that awx itself uses: https://github.com/ansible/awx/blob/devel/awx/main/validators.py#L51 Maybe just validate the format of the first line? ```python if re.search(r'^(?P<dashes>-{4,}) *BEGIN (?P<type>[A-Z ]+?) *(?P=dashes)', ssh_key_data): ```
I wonder if ansible itself has something for this in its `authorized_keys` module.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
Running this in check mode will always result in a change even when an update is not needed. You need to do check the existing object to see if it needs updating before you exit here.
Can any of these values actually be changed on an existing database? It seems like they can only be set on creation time and you would need to delete the recreate the database, similar to what you did on the other database modules.
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
TODO add Exception handling for login error
- name: "Create an IP Pool with one subnet"
You can delete this line.
A little more detail here would be good.
Name of the IP Pool to manage. Only one of I(name), I(id) or I(src) can be set. This apply to a few option descriptions.
It's not safe to modify sys.path outside of unit test functions, as these changes will affect other unrelated tests.
You may be able to modify sys.path, perform an import, and then restore sys.path. That will probably prevent it from causing issues for other unit tests, but I haven't verified that.
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
This should be a @staticmethod and self removed.
@abadger I checked the source of that `warning()` function and it seems like it concatenates input with native strings which concerns me.
```suggestion json=facts, ```
This is probably the only line which should be wrapped with try/except.
no prints, no str , use display and to_text
Same here: move url outside of the loop: ```suggestion ```
Typo: exists -> exist (should be singular). I'm not really sure this is an improvement as you lose the explanation of what 'args' can be used for.
Targeting 2.7.10. Updated to reflect that.
The double backslashes are not needed here. They are actually unwanted.
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
Now you have to change it to 2.8.
(Same for the related options.)
I would remove this `device` here, and similar the option name in the examples for `device_read_bps`, `device_read_iops` etc.
A general remark: you should always use complete sentences. So this should end with a period.
Please use formatting like `C(<device-on-host>[:<device-on-container>][:<permissions>])`, and `(e.g. device C(/dev/sdc:/dev/xvdc:rwm))` in the line below.
Better to call it path.
You should really have at least one example with `state=absent`.
To me it seems more logical if the format is not a list, but a dictionary. ```yaml options: SYSTEM: LDAP registry: LDAP logintimes: :0800-1700 ``` The only reasons for using a list here, would be to ensure a specific order for processing, or to ensure that a specific key can be duplicate (so provided keys are not unique). But I don't think these are no applicable here.
It's probably better to loop over the items and check the value before changing, so you can report back if there was a change or not.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
```suggestion self.container = PodmanContainer(self.module, self.name) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
No need for params: * they are accessible via module * they aren't used here at all ```suggestion def __init__(self, module, name): ```
Yep... Reading the Unsafe code, AnsibleUnsafeText and AnsibleUnsafeBytes are just light wrappers around the equivalent python types. Since the equivalent python types are fragile when mixing types, this is fragile as well. I think we need to consider it invalid to pass Text type to AnsibleUnsafeBytes and invalid to pass Bytes type to AnsibleUnsafeText. By extension, it's also invalid to pass Native strings to either AnsibleUnsafeText or AnsibleUnsafeBytes because that will be wrong on one of python2 or python3.
I'm not sure this should work (that may be a "this shouldn't work in the future even if it works now") I think AnsibleUnsafeText should convert any string it's given into a text string, ie: unicode type on python2 and str type on python3. This may be the case now but the self.assertEqual is just not picking it up. For each of your three test cases, try putting non-ascii characters into them. (Note that the bytes one will needs a special incantation so it works on python3: ``` python b_text = u'some byte string cafÃ©'.encode('utf-8') ```
py3.x-only code; can safely ditch the args to `super()`
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
This line can also raise a `ValueError`.
Here's still another one.
Here's another line which can raise `ValueError` (call to `run_luks_remove()`).
`run_luks_remove()` does raise `ValueError`.
There's another `try/except` missing here.
Nevermind, carry on :-)
I don't think this needs to be converted into a string. ```suggestion rc, ps_output, stderr = module.run_command([ps_cmd, '-o', 'lstart', '-p', pid]) ```
Ok, I see. What we tend to do is pass the module to the function instead. But honestly, don't bother.
Not a requirement, just to understand. Why define this as part of the main function and not make this just a global function ? I think it helps with readability.
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
`default=False` (same for others)
Please add `monitoring` and pass this argument to the request.
urllib, traceback, sys dont seem to be used.
Please use: ``` type: bool default: 'no' ```
Please use: ``` type: bool default: 'no' ```
Confusing string concatenation. Look into `printf`-like string formatting or `.format()` I see other places where this should be changed.
A couple of things, we try to avoid 'catchalls' as they don't give good error messages. We try to capture the errors after a specific action "friendly' part that suggests what was being attempted and possibly what user can do to change error to success. Also, the 'exception' field is badly named for python, it is mostly for tracebacks and we normally append the exception string to the msg field after the 'friendly msg'
You can remove the `required: false` lines, it's implicit
Missing full stop.
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
You can removed all the `required: false` it's implicit
I'm not sure how old aos-pyez 0.6.0 is, though you may wish to detail that here. `- "aos-pyez >= 0.6.0"`
Create a ticket for console for a running VM:
Add new line here.
```suggestion - Period for refresh pool and gslb DNS job. ```
```suggestion - This setting enables the controller leader to shard API requests to the followers (if any). ```
Add a `required_one_of` for name/uuid (the mutually exclusive is good, but this adds in module robustness as well)
change to data
I'm just trying to think of a simple use case for these facts.
We should no longer need this token validation if PR #36352 is merged before.
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
Remove this because is already inside DO utils
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
We generally don't mask the usernames, just passwords.
`author: Gregory Shulov (@GR360RY)"`
Do you support IPv6, if not then this should say IPv4 address.
Do you need that step? `clients = client_list` should be enough
Please put this on a single line. Lines can be 159 characters wide.
Ack. Looks like a good change.
I mean, you could do an `or` but that might break pep8 on line length, I dont care either way, the major thing for me was just being defensive about index 0 potentially being a `None` value AND not the _only_ index.
Yeah that's probably more defensive given `UserError`, it _could_ be possible, though probably not that likely that there would be some array `[None,'foo', 'bar']`
Yes, and that would narrow it down to one `if`statement.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
This is a bit of a bad way of checking wether it is IPv6 or IPv4: `::` only occurs if one of the hexadectets is `0000`. You can easily end up with `2001:db8:1:2:3:4:5:6`, which does not contain `::`. quick fix: check for `:` in `ipaddress`. Clean fix: use the `ipaddress` python module (python 3.3+ native https://docs.python.org/3/library/ipaddress.html; or https://pypi.org/project/ipaddress/ for 2.6, 2.7 and 3.2, which is a backport (so same functionality). This is the interesting part: > ipaddress.ip_address(address) > Return an IPv4Address or IPv6Address object depending on the IP address passed as argument. Either IPv4 or IPv6 addresses may be supplied; integers less than 2**32 will be considered to be IPv4 by default. A **ValueError** is raised if address does not represent a valid IPv4 or IPv6 address. ```python >>>ipaddress.ip_address('192.168.0.1') IPv4Address('192.168.0.1') >>> ipaddress.ip_address('2001:db8::') IPv6Address('2001:db8::') ```
The 2 `if` can be merged.
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
Please do it like this: ```yaml author: - Ripon Banik (@riponbanik) ```
The example does not conform to other modules, but also is not in line with this module's parameters.
Please use YAML syntax.
Description should be a sentence and include a full stop at the end
No need if there isn't a default variable
s/user/caller/ (although user creation really is the only safe method if the file is in a world-writable directory).
This isn't true anymore.
Just a suggestion. We can rely on the GuestID here to set the default value: If the GuestId starts with "win" -> PowerShell, otherwise, /bin/sh.
missing ini/env var entries (to use global default)
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
No need to quote.
No need to quote this string.
No need to quote.
I'd prefer having the type specified for all parameters, like this: ```python argument_spec = openstack_full_argument_spec( service=dict(type='str', required=True), interface=dict(type='str', required=True, choices=['admin', 'internal', 'public']), url=dict(type='str', required=True), region=dict(type='str'), enabled=dict(type='bool', default=True), state=dict(type='str', default='present', choices=['absent', 'present']), ) ```
No need to quote this line. Please add spaces around `>=`
Feels a little long, maybe something like ```suggestion short_description: Retrieves CyberArk vaulted credential using PAS Web Services SDK through the Central Credential Provider ``` or ```suggestion short_description: Retrieves CyberArk vaulted credential using PAS Web Services SDK ```
The default should either be one of the choices or None if this is a tristate (ie: not being explicitly set by the user has a special meaning).
yeah, M(cyberark_authentication) is how to link to another module.
Indentation doesn't look right here.
indentation doesn't look right here
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Azure Container Service(ACS)
The term is "Azure Container Service", "instance" is not in the term, no need to capitalize it
no Instance refer: https://docs.microsoft.com/en-us/azure/container-service/
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
These asserts may be optimized out, so you shouldn't be using assertions in code that needs to run in prod. Instead, this has to stay as the if statements we had.
Still don't see these changes as outweighing the loss of authorship/blame.
It might also be no IGWs found here.
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
This `.close()` isn't needed, the context manager closes the file automatically.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
`'get'` is in base_rpc already? ```suggestion ```
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
`wait_for=dict(type='list'),` (remove waitfor)
This can be a key-value map with key as the fact name and value as the pattern to be searched for
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
Why have 2 parameters to set the name or ID, surely we would just want to set the name and not worry about the ID. Is there a benefit to using the ID over the name, if not then this should just be removed.
You still have SDK speak in here like `serviceLevelObject`
s/elasticPoolName/I(elastic_pool_name. Also change the word updated to set.
I think I'd handle purge_listeners at the consumer end of this method. Just seems easier than passing it in and handling it here. But not a blocker
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
use ```from ansible.module_utils.vmware import find_obj```
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
@jmighion would be great if you can update ios_config as well. Thanks!
it should be `minor_vers = int(version[1])`
Note that `LooseVersion` could be used there: ``` from distutils.version import LooseVersion [...] return LooseVersion(version) < LooseVersion('3.2') ```
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Mark any string that you are going to call encode on as a ```u"string"```. Otherwise you can run into problems on Python2.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
and convert filename to bytes again.
It would be awesome if buildah supported copying from a container.
s/write target file {0}/fetch file to {0}/
nothing should use config_data, its only meant for 'extras not covered by get_option', but that is a preexisting problem here
also not needed, add `type: list` to configuration definition, nothing should be added back to config_data
You can use get_option() instead of accessing the dict directly.
Might be worth validating that zones is a list rather than a single zone provided as a string.
The inventory still needs to be populated with the results from the cache. The cache plugins themselves get/set data, but do not use it.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
You can remove this check for region as it is now handled in boto3_conn.
I'd define the (common) `vars:` just once and list the different examples one after each other within the same `tasks:` section.
Use the following to format his as code: `C({"key":"value"})`
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
``` distributions.extend(self.list_streaming_distributions(False))``` ```+=``` may be fast , `extend` bring clarity.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Please put these back.
Most other modules default to yes so I would do the same here
I think you can just say '...input as a list of key value pairs' since these are not module options. But can tags just be a dict? You could then use ansible_dict_to_boto3_tag_list(). It feels like some functionality is being duplicated.
```suggestion if not six.PY2: ```
```suggestion """Test that a new lock can be created within a Process.""" ```
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
Having such complex logic inside of tests makes them fragile. You may want to consider just using `@pytest.mark.skipif(six.PY2)`.
I don't think another var is necessary. If the first iteration to start the processes succeeds and won't interrupt the control flow, all of them will be active. ```suggestion processes = [ Process(target=_run_threads, args=(_,)) for _ in range(1, 6) ] for t in processes: t.daemon = True t.start() for t in processes: t.join() ```
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
py3.x-only code; can safely ditch the args to `super()`
```suggestion b_colldirs = list_collection_dirs(coll_filter=coll_filter) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
```python def toml_dumps(data): return toml.dumps(convert_yaml_objects_to_native(data)) ```
Ditto about the deprecation notice
Ditto about the deprecation notice
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
`required: false` is not needed.
Ditto about the deprecation notice
The `RepoIDs` is not the module option and therefore it should not be decorated in `C()`.
This is indented only by one character. Please indent it by two chars like elsewhere.
The list of option could be ordered alphabetically.
Please add dot at the end.
Please change the indentation to 2 characters to have the same formatting like above.
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
No need for the 'else' here either. The 'if' is the exit statement.
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_PASSWORD']), ```
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_USER']), ```
Not required, we already have method called `connect_to_api`. Also, I would recommend to use `from ansible.module_utils.vmware import PyVmomi` which base class for all VMware_* modules.
Not required as we can use connect_to_api method.
Remove redundant import
Add this at top after License. See example above.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
there could be a function to convert entire list, as this code is repeated below
Shouldn't these be `not_actions` ? ... and the tests should probably include some of these to catch the fact that they're not working... ;)
`not_data_actions` + tests (same as above)
just don't know exactly what's in the properties :-)
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
Fails because self_host is not defined for accelerate transport.
I would probably go for "Exit" here, but that's more cosmetic than functional.
Again self_host is not defined for winrm.
instead of 'starting connection' here we might want to 'reserve socket path', to create it if it doesn't exist and to 'touch it' if it does (making a-connection timeout reset so we avoid a race condition)
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Here only detect adding change
Maybe: `"CHANGED: subnet {0} route_table to {1}".format(self.name, route_table['name'])` (or similar) is less ambiguous
ditto multiple ip configurations
also default false is not needed
If for some reason you want to be able to enable without installing, you could add a flag which for `enable`/`disable` fails instead of installing (if the plugin doesn't exist). But the default behavior should be "install if not there, then make sure you have the correct state".
I'm not really familiar with swarm, but should this also be changed? ```suggestion - "Service memory limit in format C(<number>[<unit>]). Number is a positive integer. ```
`<number>[<unit>]` should be formatted with `C(...)` as well (everywhere). Currently, backticks are only used for `shm_size` (which should be converted to `C(...)` too).
Please use `C(...)` instead of backticks.
The message is a bit confusing, Could you just write something like "Only C(ide) controller are supported for CD-ROM".
```suggestion match your environment." ```
Use `errors='replace'` so that we don't traceback in case of invalid utf-8. Since this is a logging function, it's okay to display a mangled string.
- I wonder if we need to also catch things that are not text (for instance a number)? - The previous code handled that further down with a format string. We also wouldn't want to throw a traceback here on non-utf8 bytes. Since this is logging we probably want to use errors='replace' to deal with that. - I took a look at systemd.journal on fedora21. (Note: these behaviours are unaffected by client locale settings. Don't know if the systemd daemon has a settable locale setting). - in python2 it will take either bytes or unicode string. If the string is not utf-8, systemd.journal registers it as a binary blob. - On python3 this must be a unicode string. - Also took a look at syslog on fedora 21(these are unaffected by the client locale setting) - In python2 it must be a byte string. A non-utf-8 string becomes the replacement character - In python3 this must be a text str type. So this whole method needs to be reworked for python3 compatibility.
Yeah, sounds like a plan for now. If we can, it's better to fix it correctly than to do something incorrect and forget that it's still a problem. If we get to the place where it's the only failing test left we can revisit whether a stopgap is appropriate so that other pieces of code don't regress.
It seems like no_log and deprecation are separate things and should be handled in separate functions.
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
I would think what useful information you could possibly return to the user to work with from the registered variable.
Too long line.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
This line is too long. Max line length allowed in Ansible is 120 characters.
Line is too long.
you force the adapter creation if we don't set ip/netmask, this is wrong. In my usecase we don't use this VMWare device
I was actually thinking of moving it closer to the AnsibleModule part, so it would fail immediately (not after 3 minutes). But that means pieces logically belonging together are torn apart.
If you are cloning from a template, there is no guest_id parameter. So we should also check the current vm's guestId setting.
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
No quotes needed here;
description missing. Add a note saying that - vnc_ip is required only when state is set to present and will be ignored if state is absent.
Do not use default value for folder. This has caused lot of troubles in the past. It will be easy to fail rather than assuming something about user environment.
Why not simply do: ```python match_first = (self.params.get('name_match') == 'first') ```
The `failed=False` is assumed, so I wouldn't add it by default. The only reason when this has to be add explicitly is when you return a non-zero return code (rc-value) and don't want it to fail.
This will drop most ClientErrors on the floor and block the retries It would be better to use the helper from ansible.module_utils.aws.core ``` except is_boto3_error_code('LoadBalancerNotFound'): return [] ```
It would make much more sense to pass load_balancer_names to this call rather than handle paging (we expect to find zero or one load balancers with the given name) http://boto.cloudhackers.com/en/latest/ref/elb.html#boto.ec2.elb.ELBConnection.get_all_load_balancers
Wouldn't it be better to use the `load_balancer_names` argument with `get_all_load_balancers` - as long as `self.names` defaults to `None`, this should work: ``` all.elbs = self.connection.get_all_load_balancers(marker=token, load_balancer_names=self.names) ``` http://boto.cloudhackers.com/en/latest/ref/elb.html#boto.ec2.elb.ELBConnection.get_all_load_balancers
As long as `self.names` defaults to `None` AND all names passed in `self.names` exist in the AWS account. We could optimistically try with `self.names` and if that has an exception fall back to getting all of them. I don't know if the extra conditionals are worth it for that though.
look in module_utils, there are generic funcions/decorators, no need to reinvent
This method can be simplified to: ``` return [{"ParameterName": str(k), "ParameterValue": str(v)} for (k,v) in params.items] ```
This is still outstanding
should be HAS_BOTO3
we should be using boto3_conn for all connections. For example, security_token is missing here. boto3_conn avoids you having to worry about that.
you can just `module.exit_json(changed=changed, parameter_groups=response)`
Yup, please split this into docs fragment
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
No need for quotes here.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
You could just return this dict, same below.
This call needs exception handling.
Same order, type first.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
Nowadays, we do: ```yaml type: bool default: 'no' ```
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
Doesn't look like this got merged intime, so `2.8` here (and other places
s/like C(mail)/(e.g., C(mail))./
s/will be used/will be used by default if not otherwise specified/ - or could be handled like `scope` (no default, must be specified on new group)
That would ignore the explicit wish of the user to have serial number `0`.
Yeah, if I create an ssh-cert with number 123 manually and then execute this module without setting a serial number, I'd expect that it wouldn't care about the number - not start complaining that the number isn't 0.
So let's do ```.py if self.serial_number is None: return ``` instead :)
`pexpect` could be used to provide the password to the subprocess on stdin.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
Make pep8 happy ```suggestion priv, append_privs, module) ```
```suggestion changed, msg = user_mod(cursor, user, host, host_all, None, encrypted, plugin, plugin_hash_string, plugin_auth_string, ```
just return pm.encrypt(password, user) != current_role_attrs['rolpassword']:
Looks like we got an extra 3 backticks :( ```suggestion cursor.execute("SELECT plugin, authentication_string FROM mysql.user WHERE user = %s AND host = %s", (user, host)) ```
Does the order matter? If yes, it's probably better to use ```suggestion return '/'.join(sorted(priv_list)) ```
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
I think it makes sense - the user is responsible for making sure the library is available for specified Python interpreter. Similar to how user is required to install necessary prerequisites for modules, for example.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
...The remote host **MUST** support...
Please remove this line.
This could be done in the logging Formatter (and/or a logging.Filter). And then the modules could just pass objects to self.debug_logger.debug(), and the handler/formatter decides how to pretty print.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
assumes cert_path is always set, should be: `if cert_path and cert_path == self._env_args.cert_path:` same for cacert_path and key_path
cacertpath should be cacert_path
`default=True` (as it's a bool, not a string)
`default=True` (as it's a bool, not a string)
In addition to the error message from boto, can you include a nice message like "ClientError while listing SSH public keys" for users? Also, please catch a generic exception and fail with the traceback, like `module.fail_json(msg="Could not list SSH public keys", exception=traceback.format_exc())`
`pipes.quote` is deprecated in Python 2.7 already. You should import `shlex.quote` if available. try: from shlex import quote except ImportError: from pipes import quote
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
Nowadays we do: ```yaml type: bool default: 'yes' ```
Wouldn't the choice be [ 'yes', 'no' ] as you'd expect from a boolean ? As per previous remark, this would become: ```yaml type: bool ```
CI failure due to missing newline at end of file: ``` 2017-02-02 22:37:29 ERROR: PEP 8: lib/ansible/modules/windows/win_git.py:72:2: W292 no newline at end of file (current) ```
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
`Name of the cluster from which all child datastores need to be managed` I find this a bit weird, btw... clusters do not really have datastores directly as children, only datacenters have datastores directly: You can not create a datastore specific to a cluster, you create datastores on the datacenter, and connect hosts to them. I assume the `cluster.datastores` just lists all datastores that are connected to hosts in that cluster. Personally, it would make more sense to use datacenter as a grouping parameter instead of cluster (but that might also be a bit excessive, as that would put all datastores in maintenance mode in a DC, basically preventing any VM to run at all...)
`Name of the datastore cluster from which all child datastores need to be managed`
`This module can be used to manage maintenance mode of a datastore` (small change: remove 'for', add 'a')
I assume `If the datastore cluster should be present or absent`
"state" is required or you should set a default.
Have you checked whether any of the value options where you removed the change overrides something defined in the image? If that's the case, this can't be a Bugfix PR (similar to changing the default of `user`).
Not passing arguments to docker which don't affect the resulting service is no problem. It's only a problem (and shouldn't be backported) if it affects the visible behavior as seen from a user (like it updates a service which hasn't been updated with the old version).
The rebase brought the default back. This just needs deleting, then I think we're ready.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
```suggestion - Enable or disable promiscuous mode for interface. ```
```suggestion - This is the L3 MTU (limit on size of IP packets). ```
```suggestion - Enable or disable the MULTICAST flag on a device. ```
```suggestion - Enable or disable ARP on an interface. ```
```suggestion - The broadcast (L2) address for the interface. ```
no, it's probably not fixable anyway
If the source is not provided, there is an endpoint that lets you update all inventory sources for an inventory (future enhancement, I would not suggest doing that here, just pointing it out)
nit-picky optimization, but if the prior step was successful then 'id' should already be in `result` Also, if the state is "absent", then you need to be sure that you don't hit this code. Either that, or it should throw an error if schema is provided and state is absent.
Could you update this to pull in: https://github.com/ansible/awx/commit/34e2d9b47ccc923623627e1d8cfafdb25afb70e4#diff-08d6dd3b52bc7b9781186afe8c1e29ea This adds the response data in cases where it's available. Without that, the root cause is not exposed in some circumstances.
wrap exceptions in `to_native` when stringifying them
Yeah, it's only AWS-specific because we only use it in AWS. I'm not sure what to name the new file it would be moved to (`dict_transformations.py`?) but moving it out then re-exposing in the AWS utils for backwards compatibility seems like a good idea.
You don't need to be an AWS module to use the ec2 module utils. Just do the following ``` from ansible.module_utils.ec2 import camel_dict_to_snake_dict camel_dict_to_snake_dict(vm_info) ```
That's fair enough, the code should be split out into a generic function so it can be used by other modules. There is nothing AWS specific about the camel_dict_to_snake_dict and the reverse function, it was only used there because on AWS had a need for it.
@gustavomcarmo please check my pr #39722 , i have 2 options now, raw and curated
Let's just standardize on `resource_group` and `name` for these (feel free to leave `server_name` as an alias though); the resource type should already be clear from the module name in a playbook context
I'm a little iffy about the ungrouped or all group here. I would skip ungrouped.
I wouldn't dive into that just yet. That would be very hard to do elegantly. I'm not even sure if it really philosophically makes sense.
Are other plugins supporting any kind of file-less use? It seems like that's more of where this was trying to go.
you can also just have a config file with `plugin: tower` as it's only entry
my other issue is if user has an actual 'tower_inventory' file in cwd ... i would use something more like `@tower_inventory` or some other symbol to disambiguate from 'actual file'
I think most if not all of this can be removed and replaced with argspec code https://github.com/gundalow/ansible/blob/docs-argspec/docs/docsite/rst/dev_guide/developing_modules_general.rst#main-and-ansiblemodule-argument-spec
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
duh :-) Something like ``dict with `msg` and `changed`.`` would be more informative
Can you test this on python3 please? I think python3 needs bytes.
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
That's quite a strange (and un-pythonic) way to indicate failure. But if the library does that, there's not much you can do :)
Use [missing_required_lib](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L562) to generate the message.
```suggestion password=dict(type='str', required=True, no_log=True), ```
Seems to be unreachable code to me.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
SubnetIds expects a list `[result['subnets'][0]]`
Good point :)
This should be enforced by the argument_spec, not sure how this would happen.
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
Looking at the boto3 docs, it looks like cluster ID is required for the describe_cluster call you are making. list_clusters would be a call you could use if no cluster_id is provided. required: false is also the default, so if this remains to be true you can remove this line.
State should have the choices 'present' or 'absent' to be like other Ansible modules.
This should have exception handling around it. Once you update to AnsibleAWSModule you can do: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to list clusters") ``` and it will use e.response and add the traceback for you.
required=False is the default, so you can omit that, same for any of the following. `name_regex=dict()`.
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
```suggestion - When you masked a value, the value must be base64 compliant and has at least a length of 8 characters. ```
```suggestion - When a value is masked, it must be in Base64 and have a length of at least 8 characters. ```
```suggestion - Support for protected values requires GitLab >= 9.3. ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
```suggestion description: A list of variables whose values were changed. ```
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
It's safer to quote unvalidated strings with, e.g., [`urllib.quote`](https://docs.python.org/2.7/library/urllib.html?#urllib.quote) before concatenating them into a URL.
I'd also default to True for validate_certs as that is a safer default.
Doesn't really matter since you're not likely to instantiate more than one PasswordManagerPro object in this short script but these should be instance variables, not class attributes. Move setting of default values into the ```__init__```
This is just style but we try to follow standard python naming conventions. So function and method names should be underscore separated like this: ```get_resources```.
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
Remove the two extra double-quotes here.
`delete` and `create` are not valid states
Not required with AnsibleAWSModule
please add the `version_added: '2.10'` here as well
call this just pod, identical to the param we pass. Fixes inconsistency with other modules.
can be simplified to ~~~ cluster = self.get_cluster(key='id') ~~~ and following lines can be removed ~~~ if cluster: args['clusterid'] = self.get_cluster(key='id') ~~~
yes, None values are excluded by the lib cs underneath
identical here for pod,
This method is unused and must be removed.
test of `wait` parameter could be moved inside the `wait_to_complete_state_transition` method.
Not sure if `module.debug` should be used instead.
methods `start_server`/`stop_server`/`restart_server` are almost the same and could be factorized.
`START1` isn't a valid commercial type
I don't think I'd say this, it's more like a really smart patch that can automatically compute deletions. It's still going to be sending a PATCH and not a PUT so I'd just worry someone gets the wrong idea.
This is unreachable code, as module.fail_json will be exit point the module.
Do we still need kind? For service I think it should always be v1
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
task_uuid seems unused
`'get'` is in base_rpc already? ```suggestion ```
`wait_for=dict(type='list'),` (remove waitfor)
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
SHould inherit from object because of python2
No, it doesn't become the default until Python3.0
I would recommend updating to inherit from object. Just because others did it or are doing it, doesn't necessarily make it a thing we wish to have. We are trying to improve and standardize on implementations, and the preference here is that we standardize on inheriting from object. A future task can be to improve modules where this was not followed.
Parentheses around `e.message` are useless.
No need for a class.
This function must be a fixture. You invoke it multiple times in tests which causes rereading the same file. Which in turn slows down tests execution. ```suggestion @pytest.fixture def vault_data(): ```
Return ```suggestion return [ (data_0, expected_0), (data_1, expected_1), ] ``` And then have just one invocation.
Also, in Python, you have to specify a list of base classes when declaring a new one or omit the braces completely. ```suggestion class TestAnsibleJSONEncoder: ```
That's not true. This class is used only to namespace things. Not for testing. Also, [stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0). It's not worth it, not in this case.
required=False is default so no need to add.
Set self.is_group by default to False
PyVmomi helper class already calls `connect_to_api`
Elaborate more on case - what happens if state is set to absent. Also, other conditions like if permission does not exists.
The condition is a bit long, I would write it this way instead: ```python if perm.principal != self.principal['domain'].upper() + '\\' + self.principal['name']: continue if perm.group != self.principal['isGroup']: continue ``` This way, you avoid an extra level of indent.
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
if you are using loader, just use `get_file_contents`
No need for this to be a private method. rename to get_inventory().
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
CI failure due to PEP 8 issue: ``` 2017-01-31 22:24:00 ERROR: PEP 8: test/units/template/test_templar.py:447:161: E501 line too long (172 > 160 characters) (current) ```
In python, this is probably better represented as a global dictionary in a separate module (as outlined above). Something like file serviceprovider.py: SPKEYS = { 'ID': 'id', 'NAME': 'name', [..] } ```
This will fail if ```updated_list``` has items which are not present in ```original_list```. You probably want something like this instead: ``` python merged_items[item_key] = items_map.get(item_key, {}) merged_items[item_key].update(item) ```
There's a lot of copying going on here as well. Both on this line and on line 456. Copying is slow so you want to eliminate any that aren't needed.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
No need to wrap.
The CamelCase exception .response attribute is particular to boto3's ClientError. IOError doesn't have .response so you can remove the `**camel_dict_to_snake_dict(e.response)` bit of this.
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
I think defaulting to `false` is the safest option, and would be consistent with the purge_tags defaults in other modules.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
```suggestion module = AnsibleModule(argument_spec=argument_spec, mutually_exclusive=[['retention', 'purge_retention_policy', 'overwrite']]) ```
Not required with AnsibleAWSModule
I think we also want to require `encryption` be specified anytime `encryption_key_id` is passed. That way users won't accidentally pass the key_id and assume that it's being used when it may not be.
I thought we decided on titlecase, no? ```suggestion t = cls._RST_NOTE.sub(r"Note:", t) # .. note:: to note: ```
I wonder if it'd be hard to title-case the matched admonition. They are case insensitive. One can do any of ```rst .. Note:: .. notE:: .. NOTE:: .. NOTe:: ```
And with `\1` you preserve what's matched but I'd argue it should always be normalized to `Note:`.
I'd go for underlining.
Looking at how this is handled, I wonder if this could be turned into a sequence of transformations. ```python _RST_TRANSFORMATIONS = ( (re.compile(r".. seealso::"), "See website for:"), # seealso directive (re.compile(r".. note::"), "Note:"), # note admonition (re.compile(r":\w+?:`"), "website for `"), # any role (re.compile(r".. \w+?::"), ""), # any directive ) ``` And then just ```python for regex, replacement in cls._RST_TRANSFORMATIONS: t = regex.sub(replacement, t) ``` (below)
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
not needed when `required=True` is specified
not needed when `required=True` is specified
does not match actual return dict
use `required_one_of` kwarg when creating AnsibleModule instead
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
Please use `- name: ` with examples
You have `git>=2.19.0` in `requirements`
Please remove this line. As this is a new module the top-level version_added is the only one needed.
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
This is handled by `argument_spec`
If you provide non-existing DVSwitch then `self.dvs` will be `None` and module will fail with error saying ``` "'NoneType' object has no attribute 'EnableNetworkResourceManagement'" ```
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This is not required if using `super`
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
```suggestion required: true type: str ```
I think you should either use `pid` or `PID` everywhere. Whether you prefer `PID` or `pid` is something you have to decide :)
This debug needs to be updated for a few things: 1. Use full YAML syntax, not `key=value` 1. `.pid` should be `.pids` 1. Instead of `','.join` please use the `|join` jinja filter.
add sample of pids like ```yaml sample: [ 10101, 12011 ] ```
You could drop "It return", i.e. change the description to "Process IDs of the given process"
Removing the to_safe parameter here will affect the output whether or not the route53_hostnames option is enabled, breaking any playbook that uses the existing hostnames. I understand that route53 names can't be filtered through to_safe since it strips DNS-valid characters, so if you add a conditional then this would be ok.
This conditional needs to only cover hostnames that actually match the route53 name. If I have some instances with example.com suffixes, and some without, then those other hostnames won't be passed through to_safe. So this check also needs something like `and hostname.endswith(self.route53_hostnames)` to only operate on hostnames that actually match DNS.
Would be nice to warn the user their configuration is being ignored because the specified value wasn't recognized.
Should probably use a [paginator](http://boto3.readthedocs.io/en/latest/reference/services/route53.html#paginators) here to support large accounts.
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
Please add dot at the end.
These two empty lines should be just one.
Missing space in front of `1`. I strongly recommend to use `flake8` tool on your code before you submit it. It significantly improve the code formatting which has direct influence on the readability of the code.
AnsibleModule already has a `.debug ` property which can be enabled via configuration on the controller
I would remove the debugging from the module as user cannot enable it anyway.
You could remove this check since `for o in open_ports` should work as well.
It looks like if it isn't a permission error or request expired the exceptions are ignored. It would probably be better just to retry on a specific exception or two and otherwise call fail_json than mask undisclosed exceptions.
Should inst ever be None without being in the process of being created at this point? Wouldn't it be worth waiting for that too? If so you could remove the call to _find_instance_info(client, instance_name) just above and change this conditional.
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
Well this would be for 2.4 so maybe that is the better path
it absolutely is but "New in version 2.3." so I didn't make use of it yet.
local_action has same issue as it is an alias to `delegate_to: localhost`
this is actually incorrect, ansibile_ssh_host will reflect 'localhost' not the var associated with 'inventory_hostname' .. which is why this should use `connection: local`
You could fix #19781 real quick right here :D
I guess forcing the user to be more explicit should be OK, too. Defaults can always be problematic, remember the default user `root` ;-)
No, we don't, we only have copies of the publish lists. The elements of these lists say the same (though they appear in different order in the lists).
I spent more time than I care to admit to understand what was going on here... What would you think of removing the keys from the newly created dictionaries instead of creating new ones? ```suggestion for key in ignored_keys: old_publish_item.pop(key, None) publish_item.pop(key, None) return publish_items != old_publish_items ```
Note, usually, one should check whether something is an instance of an abstractbaseclass instead of dict, list, or other builtin types. For instance: ``` python from ansible.module_utils.common._collections_compat import Mapping [...] if not isinstance(publish_def, Mapping): ```
Do a pull request.
Read operation: ditto
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
`then` -> `the`
```suggestion - The name of content library to manage. ```
`Name of the datastore cluster from which all child datastores need to be managed`
```suggestion - content library id for which details needs to be fetched. ```
```suggestion - The content library description. ```
We should probably rename this. Revisiting this code... this is a pretty special-case function as well. I wonder if it should be a private function inside of parameters.py (basic.py can make it public as part of its API but the idea would be that we don't expect any new code to use it.)
I'd like to not pull SEQUENCETYPE into this file but this one is a little tricky. A Mapping is an iterable and we have a separate conditional block to work with those. If we just check for collections.abc.Sequence then we wouldn't catch things like sets and keyview.... I think what we can do is put the Mapping conditional before this one and then change this one to ```if is_iterable(obj)```.
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
It seems like no_log and deprecation are separate things and should be handled in separate functions.
It looks like you will need to sort the legal inputs before comparing. Something like: ``` diff --git a/test/units/module_utils/common/parameters/test_handle_aliases.py b/test/units/module_utils/common/parameters/test_handle_aliases.py index 0db4c2ee7a..2b1e13cd95 100644 --- a/test/units/module_utils/common/parameters/test_handle_aliases.py +++ b/test/units/module_utils/common/parameters/test_handle_aliases.py @@ -59,12 +59,15 @@ def test_handle_aliases_basic(): 'nick': 'foo', } - result = ( + expected = ( {'surname': 'name', 'nick': 'name'}, DEFAULT_LEGAL_INPUTS + ['name', 'surname', 'nick'], ) - assert result == handle_aliases(argument_spec, params) + expected[1].sort() + result = handle_aliases(argument_spec, params) + result[1].sort() + assert expected == result def test_handle_aliases_value_error(): ``` That diff is for the next testa actually.
Same question about returning module_path here.
```suggestion 'community.crypto': 'acme', ``` With this, my tests actually work :)
var name bikeshed: ```suggestion group_collection_map = { ```
Is it even possible for this not to be a list? The original code didn't have this check.
This check (and _is_binary) seem like they belong in executor/module_common.py. Make modify_module responsible for detecting that this is a binary module and returning it unchanged. We might need to create a new module type so that the rest of the code in action/__init__.py knows it's dealing with a binary module but that shouldn't be a problem. We already have "old" and "non_native_want_json" which do nearly the same things.
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion - Whether to power on the VM after cloning. ```
add CALLBACK_NEEDS_WHITELIST = True this is recent addition, it keeps plugins shipped with ansible from being executed automatically unless whitelisted through config.
this process does live for the lentgh of the play, but it is also not thread safe, we update variables that will end up being shared in the threads.
threading is pretty useless in this context, the callback gets called in it's own sub process
import errors should not be fatal, look at hipchat plugin and how it handles this, the plugin will not work but will not stop play while it issues warnings about it.
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
We use term `mapping` here.
You probably don't need `{}` fallback anymore.
I'd move this into check
but to_boolean doesn't convert values to booleans. It's really normalize_options(). It's just that the only implemented normalization at the moment is for boolean values.
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
Please remove `module.fail_json` and use `ModuleFailException`.
You have some syntax errors in this `if` statement.
You will need to include the OAUTH_TOKEN environment variable also.
I see that the requirements lists python-2.6 as the minimum python version. Unfortunately, format strings in python-2.6 are more limited than in python-2.7 and later. So you need to be explicit about the position in the format args list you are looking at like this: ``` python response = rest.get('floating_ips/{0}/actions/{1}'.format(ip, action_id)) ``` There's a few other places with format strings that have to be fixed as well.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
the mutually exclusive group should already do this
no need to do this here, we already take care of it below, just update 'docs' variable and 353/635 will display
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
I feel like this should be moved to `else:`
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
So we will remove it, and add it back? Okay :)
I think we should keep this for user, mainly in this early stage.
Well, I think MAX_SUPPORTED_API_VERSION should be overriden by this parameter
@chouseknecht makes sense. Also, as a first iteration, this is already good so I wouldn't stress it to find a better abstraction at this stage. I think once this module matures, we can start thinking about splitting some of this logic.
I think it's fine to keep this here for now but, I wonder if this check (and similar checks in the future) should go into the `OpenShift` client as they are specific to `OpenShift` and not `Kubernetes`.
use the `missing_required_lib` function from `ansible.module_utils.basic`
use `missing_required_lib` from `ansible.module_utils.basic`
Authentication should be handled here and not inside of the class
I find this error message very hard to understand. I don't have any experience with GitLab servers, though :) If the other gitlab_* modules have the same text, we should probably keep it here as well. Changing it could be done in another PR once this is merged.
Use `missing_required_lib` from `ansible.module_utils.basic`
The `upper()` and `replace()` calls here seem unneeded given that the input is very strictly formatted already. But that's not a showstopper either.
space after , in replace
This looks like it is unfortunately not quite this simple. We want the following fallbacks: * If the user specifies a value explicitly in the playbook, use that * If the config file has it, then use that. * If both of those do not have a value, then use the module's defaults. This likely needs changes both here and in the mysql modules themselves. The change here will look something like this (repeat for each of the values we're setting): ``` python if cp an cp.has_section('client'): if module.params['login_host'] is None: module.params['login_host'] = cp.getint('client', 'host', fallback='localhost') [....] ``` Inside of the mysql modules we'll have to change teh module's argument_spec. For instance, mysql_db.py has this: ``` python argument_spec=dict( login_user=dict(default=None), login_password=dict(default=None, no_log=True), login_host=dict(default="localhost"), [...] ``` We would need to change it to this: ``` python argument_spec=dict( login_user=dict(default=None), login_password=dict(default=None, no_log=True), login_host=dict(default=None), [...] ```
This should be using `module.fail_json()` instead.
Change `should` to `would`.
there's away to have this checked in the declaration of the module: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/nuage/nuage_vspk.py#L1019-L1020 (same for esxi_hostnames)
As I understand it, this module isn't about gathering facts.
`vmware_host_config_facts` â `vmware_host_config_manager`.
"state" is required or you should set a default.
`vmware_host_config_facts` â `vmware_host_config_manager`
This should be removed an replaced with: ```yaml default: high performance ```
Not needed. The module is new in version 2.4.
Should be 2.4 (as we don't backport new modules to older releases).
Make this two entries in your description. Especially because the first entry is the description of the option, the next entries are specifications or additional notes.
Don't add `required: false`. It is implicit.
also you might want to make this into an option, see ssh connection plugin's `reconnection_retries`
This is an unrelated change but I think this line should be ```suggestion module.fail_json(msg=missing_required_lib('ipaddress'), exception=IPADDRESS_IMP_ERR) ```
This was kept here for backward compatbility - https://github.com/ansible/ansible/pull/59974/files#r313368633
Looking through the code more carefully, I think this change is correct. We should only being using `hostnamectl` where we pass it flags to return _only_ the hostname. That is currently the `SystemdStrategy` class. Otherwise the value returned from `self.hostname_cmd` would be not at all what we expect. I don't think having this conditional buys us anything, nor does it help with backward compatibility.
```suggestion pass # Handled by AnsibleAWSModule ```
Maybe add a doc string as well. ```suggestion def recursive_diff(dict1, dict2): """Recursively diff two dictionaries Raises ``TypeError`` for incorrect argument type. :arg dict1: Dictionary to compare against. :arg dict2: Dictionary to compare with ``dict1``. :return: Tuple of dictionaries of differences or ``None`` if there are no differences. """ ```
Rather than silently returning `None` when incorrect argument types are used, explicitly raise a `TypeError` to communicate the problem to the caller. ```suggestion raise TypeError(f"Unable to diff 'dict1' {type(dict1)} and 'dict2' {type(dict2)}. Both must be a dictionary.") ```
```suggestion assert wrap_var(dict(foo=None))['foo'] is None ```
```suggestion assert isinstance(wrap_var(set(['foo'])), set) ```
```suggestion assert isinstance(wrap_var(('foo',)), tuple) ```
Again, use C(balanced) and C(high performance) here.
Make this `This module wil...`
This should be removed an replaced with: ```yaml default: high performance ```
Not needed. The module is new in version 2.4.
The more I think about this the more I think this should be a list type where you can specify some the options `success` and `failure`. You can use a combination of both (`success and failure`) or just an empty list (`none`) for the other options. We should also decide on a default, potentially `none` is the default if it isn't set.
```suggestion The C(address_list) is a comma-separated list of one or more address/netmask pairs in CIDR format." ```
@thomwiggers you also seem to like the "suggested change" feature :D
This will probably not be formatted as you intend it. How about: ``` - "Specify a certificate options when signing a key. The option that are valid for user certificates are:" - "C(clear): Clear all enabled permissions. This is useful for clearing the default set of permissions so permissions may be added individually." - "C(force-command=command): Forces the execution of command instead of any shell or command specified by the user when the certificate is used for authentication." - "C(no-agent-forwarding): Disable ssh-agent forwarding (permitted by default)." ... ```
```suggestion - "Specify certificate options when signing a key. The options that are valid for user certificates are: ```
`type: list` is missing.
We tend to have full descriptions, so that the meaning is more clear to the end-user. The first line is a description of the parameter. Subsequent lines clarify the value, its use or dependencies. All descriptions (except the short_description) should have a trailing dot, so please add those everywhere. ```suggestion - The ID of the Hetzner server to manage. ```
```suggestion - Only required if no server I(id) is given or a server does not exists. ```
I would not add this alias. We tend to use aliases for backward compatibility or to add consistency between modules. But there's no value in adding this alias here. Rather stick to one parameter name.
All our parameters that accept lists, accept single items too. But we never offer both the plural and singular version for parameter name. A one-item list, is still a list :-) So I wouldn't bother. IMO offering both is more confusing as people may assume that: ```yaml ssh_key: my-ssh-key ``` means there is only one SSH key to add. That is why I would only have the plural form and no aliases. It will end up to be more consistent between users/playbooks and it's clear the parameter accepts more than one value.
to show datacenter is anoter param use I(datacenter)
This could use more explanation.
``` - dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in KeyCloak REST API. ``` Example of mentioning the upstream api camel case name.
This argument falls under the same guideline requirements as explained for `protocol_mappers`, this needs to be a more explicit argument, and not an arbitrary field.
This shouldn't be `required: True` since realm may be provided instead.
'id' is also a python built in, so it may be better to not shadow it here. In this code, it doesn't look like it would cause any problems however. But, then that would also be inconsistent with the rest of the module args and REST api names. So either way is ok with me, just pointing it out. I think if I was going to try to avoid it, I might add a dict or class that maps the local ansible module arg name to the remote rest api name, but that might be overkill, so not suggesting this as required change. But maybe something like: ``` python api_map = {'id': 'id', 'direct_access_grants_enabled': 'directAccessGrantsEnabled', # other names hre } ``` so code could do something like: ``` python if api_map['client_id'] not in updated_client: stuff() ``` Probably overkill, but also might provide some isolation against potential keycloak rest api name changes. Not worried about it now though so not a blocker for merge.
not exactly what i was asking, but good enough
I'm not sure about these defaults - a delay of 3 and backoff of 2 for 10 tries would mean that, to fail, this retry decorator would wait for 3069 seconds (`3 + 3*2 + 3*2*2 ....`, or `sum([3 * 2**i for i in range(10)])`) or about 50 minutes. That seems like a really long time, especially since most modules make several calls. A better default might be 4 tries, for a total default wait time of 45 seconds and having a max of, say, a minute between tries. That way, if someone wanted 10 tries it would only take about 7.5 minutes to fail.
Remove this since it doesn't do anything and `Mock` isn't defined.
This doesn't match because your test uses `http://` instead of `https://`.
Oh, and `args[0]` is the module, so you want to look at `args[1]` for the url.
Maybe use ```suggestion type: path ``` instead? Then Ansible will replace things like `~` IIRC.
```suggestion - Required when I(release_state) is set to C(present) ``` Use `I(...)` for option names, `C(...)` for option values.
Afaik the `version_added` line is not necessary for new modules
Maybe add a link to PyPi or something, one of these is a Python library and the other one an external binary.
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
```suggestion - Either I(template_link) or I(template) is required if I(state=present). ```
s/will created/will be created/
avoid putting quotes around values unless they are really needed
this line isn't needed
AnsibleModule already has a `.debug ` property which can be enabled via configuration on the controller
I would remove the debugging from the module as user cannot enable it anyway.
ansiblemodule already has a .log method, this is redundant.
Please change the indentation to 2 characters to have the same formatting like above.
Should the `continue` be here? The following 3 lines will never get evaluated.
I wouldn't dive into that just yet. That would be very hard to do elegantly. I'm not even sure if it really philosophically makes sense.
my other issue is if user has an actual 'tower_inventory' file in cwd ... i would use something more like `@tower_inventory` or some other symbol to disambiguate from 'actual file'
Are other plugins supporting any kind of file-less use? It seems like that's more of where this was trying to go.
you can also just have a config file with `plugin: tower` as it's only entry
why force either/or? you should be able to read some things from the config file, others from env vars, user might not wan't all eggs in one basket
@ckotte you're right about wholesale exceptions in general. However, there's one case when it's okay: on the top level layer of the app (in this case the module). The thing is that if the process will just crash it won't return a failed json struct to the Ansible controller, which won't be able to handle this better then. So I'd put such handler around (some part of?) main func.
Yeah, smth like that. Input args might also be useful there. Basically any details you're able to retrieve is good :)
Sorry, I cannot point to one. It's just an idea though, not a strict rule or requirement.
This will concatenate all chunks into a single-line string. Try multiline: ```suggestion self.module.fail_json(msg=textwrap.dedent(""" Failed to add vSwitch '%s', this can be due to either of following: 1. vSwitch Name exceeds the maximum allowed length, 2. Number of ports specified falls out of valid range, 3. Network policy is invalid, 4. Beacon configuration is invalid : %s """) % (self.switch, to_native(invalid_argument.msg))) ```
please use dict literal ```suggestion vswitch_offload = {} ```
Each entry for a description must be a sentence so should start with a capital letter.
@xiaozhu36 you should update this version number from 2.7 to 2.8. We have already released 2.7, so this module will be added as of version 2.8.
`Manage Cisco NSO configuration and service synchronization`
This should be quoted.
Period at end.
this will repro the "what if one of the collections is missing?" case ```suggestion 'testgroup': ['testns.testcoll', 'testns.othercoll', 'testns.boguscoll'] ```
Module arg building doesn't take place here. This file packages up a module. It doesn't handle construction of module parameters at all. Action plugins sit in between module arg construction and here.
This does not belong in here. Since you took it out of a function in task_executor, it might belong in there.
Doing this inline is OK for beta- it makes the feature function, but it's a performance problem. Post-beta, we'll want to move most of this to an intermediate lazy indexing process during playbook parsing when a module_defaults clause references a group, where we'd build that global "sieve" I was talking about for O:1 lookup. At that point, we can probably get rid of the transformation in the collection metadata canonicalization phase entirely and just store it plain.
personal preference, but since we only want to do the work once based on the result of a looped query, I usually write those things as an explicit query predicate, eg: ``` if any(name for name in redirected_names if name in action_group): tmp_args.update(...) ``` this form also stops the iteration once we know there's work to be done. You could accomplish the same in the existing form by adding a `break` after the update, but IMO the existing form is less clear that you're not really looping over the side effect.
```suggestion - Threshold for defining a lossy connection by packets that time out and get retransmitted. - A connection between client and Avi is considered lossy when more than this percentage of packets are retransmitted due to timeout. ```
Original spelling of `transmitted` was correct: ```suggestion - Threshold for defining a lossy connection by packets not transmitted due to window size. - A client connection is considered lossy when percentage of times a packet could not be transmitted due to TCP zero window is above this threshold. ```
Follow pattern as above. And revert to the correct spelling of `transmitted`.
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
i cannot imagine people look at deprecated files first for examples ...., but they do see changes to them and then try to use those to justify subsequent changes.
You want to swap these conditionals, so that check mode can actually report anything. `load_config()` should be the only thing gated by `if not module.check_mode`, that way the result is correct
nxapi will fail here when given a CustomNetworkConfig directly. In order to avoid this, call `.items_text()` before `load_config()` like so: ``` candidate = candidate.items_text() load_config(module, candidate) result['changed'] = True result['commands'] = candidate ```
Please remove `force:`
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
would you mind change this to the following? ~~~ 'roleid': 'role_id', ~~~
shouldn't this be like the following? ~~~python if rule == _rule['rule'] or rule == _rule['id']: ~~~
not a blocker but `required: false` is the default, can be omitted in the docs (was needed in the past)
PyVmomi helper class already calls `connect_to_api`
Set self.is_group by default to False
identical here for pod,
can be simplified to ~~~ cluster = self.get_cluster(key='id') ~~~ and following lines can be removed ~~~ if cluster: args['clusterid'] = self.get_cluster(key='id') ~~~
yes, None values are excluded by the lib cs underneath
alright. let's keep it as is.
call this just cluster, identical to the param we pass. Fixes inconsistency with other modules.
Well, then they will never really know and think they always have to quote. I don't think it's better to teach them to always quote, and certainly not using double quotes. Besides, you're not being consistent, you're not quoting the task name value and delegate_to.
The short_description never has a trailing dot. Help keep the index clean !
This should get imported from ansible.module_utils.six
Add double quotes to Author name.
Double quote around Author name.
```suggestion specify the user via UID, you must set C(ANSIBLE_REMOTE_TMP) to a path that exits ```
```suggestion - User specified via name or UID which is used to execute commands inside the container. If you ```
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
Just because requests conflates validation and the source of validation truth doesn't necessarily mean we should- I've always disliked that in requests, as it prevents more granular cert validation behavior in the future (or at least makes it more complicated by requiring more config args). That's why I did the pywinrm one the way I did (left the separate arg for CA path and made validation mode a string/enum-y thing rather than boolean)
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Remove this line
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line.
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
this func takes and returns single dict, not array of dicts.
"the relevant" not clear enough IMHO. something like "the type of the resource to which the profile should be [un]assigned" ? same for `resource_name` below.
now in utils, can drop from here.
If you like to replace `None` with `[]`, it sugguest to change it to `response.get('resources') or [] `. The difference is, currently with this code, `[]` will only returned if there is no `resources` key in `response`
Actually, on the whole, this belongs in netcommon, so now it will be: https://github.com/ansible-collections/ansible.netcommon/pull/308/files#diff-e84f32f4c9057b4900c0593346d486cf66db31cb92dcf9016d75d0bba03ce88d
Having had some time to reflect on it, this should probably stay here and get updated while `module_utils/connection.py` and friends are in core. We want to maintain the ability to make persistent connections that don't depend on `ansible.netcommon`. `httpapi` for example could theoretically live somewhere else and not have much issue. A complete version of this doc_fragment has been merged to netcommon, but that really is only because this is pretty useful but we would not be able to use it for a long time if it were just in core. Basically, my opinion is that while it remains possible to make a standalone persistent connection without any collections, (which is pretty much just needs `ansible-connection` & `connection.py`), then this doc_fragment should probably live here, too.
```suggestion options: persistent_connect_timeout: type: int description: - Configures, in seconds, the amount of time to wait when trying to initially establish a persistent connection. If this value expires before the connection to the remote device is completed, the connection will fail. default: 30 ini: - section: persistent_connection key: connect_timeout env: - name: ANSIBLE_PERSISTENT_CONNECT_TIMEOUT vars: - name: ansible_connect_timeout ```
Could you add a fullstop at the end of this (and other)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
the community has decided that modules should be named "_facts" when providing host facts, otherwise the sufix should be _info. That is why this module should be renamed `cs_resourcelimit_info`
also replace the word "facts" with "info" in the docs
```suggestion short_description: Create, update and delete VMware content library ```
Should note about `is_dir` and `is_link` here.
```suggestion - Module to manage VMware content Library ```
Hello and thank you for your PR! Sorry for the lag time on this but this would need to be updated to `2.6` if you can get it done today, otherwise it will be `2.7` because today is dev freeze for `2.6`.
Update this to `2.8` because we're not in the 2.8 dev cycle, but other than that this looks good. Thanks!
Would be a nice to have if the plugin allowed an `ini` file configuration instead of only env vars.
Use `self.get_option` instead of `os.getenv` directly.
Consider `open_url` from `ansible.module_utils.urls` as an option to remove the dependency on `requests`.
It would be nice if you could add PEP257 compliant docstrings to public interfaces (classes, functions, methods, module)
All of these strings should also likely be prefixed with `b` as in `b'start'` to avoid confusion. Since later we need these to be bytes, we should start that way, so that it isn't confusing.
Oh, in this case yes. Let's do bytes everywhere.
yes, basically, apply to_bytes() to all parts of cmd (change that last one in the return statement as well)
this also deserves more spacing ```suggestion if action == 'stop': ```
Parameters that are not required don't need `required: false`.
If there's no default, `None' is implicit. (It means parameter undefined) So this is not needed.
Parameters that are not required don't need `required: false`.
Make this a separate item in the list.
Make this a separate item in the list.
I think this behavior should be shown in the examples since it is tricky to explain.
This would be handled by the `AnsibleAWSModule` ```python try: import botocore except ImportError: pass # handled by AnsibleAWSModule ```
You can remove these imports except ec2_argument_spec
snake_dict_to_camel_dict can be removed.
This will be handled by the `AnsiblleAWSModule`
```suggestion - A description of the template. - Include enough detail that the user will understand what is being deployed... ```
Thanks for that clarification. Upon reviewing the code, it wasn't obvious to me that this module is actively using both connection paths (to the k8s API and also to the Upload Proxy.) I've taken your word for it and updated my related PR.
Really like this raw access to the kubernetes yaml, personal preference I don't want a layer of declarative config on top of a layer of declarative config so it's great to see this available.
missing 'type: list'
you might want a `suboptions` key here, they are not implemented in config (yet) but eventually they should work the same as module suboptions.
I would do: ```python # Ensure we have a starting slash and no trailing slash self.params['folder'] = os.path.join('/', self.params['folder']).rstrip('/') ```
This is no longer relevant.
fObj => f_obj please to respect PEP
`dcpath` probably got to the incorrect context scope
Sorry, hadn't seen this else here, and it's fine to have it like now.
The description should be a full sentence. So this probably ought to read: > The alias for the current object. This relates to the `nameAlias` field in ACI.
s/if it specified/if specified/
Indentation here doesn't look right
Fair enough. It is not a hard requirement.
Do not change jinja variables to arbitrary values.
After thinking about this more, it's probably more reliable and easier to maintain if we just default to always using our version of `ismount()` rather that trying to evaluate the Python version. Ideally we could probe somehow and fallback to this version rather than doing a version comparison, but it's really hard to probe for a bugfix. ```suggestion ```
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
No need to parametrize with just one case.
Better to name this after what it is used for. BUFSIZE is used in other connection plugins.
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
You could replace this entire block with: ``` from distutils.version import StrictVersion return StrictVersion(host_version) >= StrictVersion('.'.join(map(str,version))) ```
One more question on this: The checks are to see if the current VM group name _equals_ the new VM group name? (same for hosts), shouldn't that be if they differ? It would make the code: ``` if ((existing_rule['rule_vm_group_name'] != self.vm_group_name) or (existing_rule['rule_anti_affine_host_group_name'] != self.host_group_name and not self.affinity_rule) or (existing_rule['rule_affine_host_group_name'] != self.host_group_name and self.affinity_rule) or (existing_rule['rule_enabled'] != self.enabled) or (existing_rule['rule_mandatory'] != self.mandatory)) ``` (added check to only check for the right host group name depending on type of rule)
idem, but I would have write: ``` rule_obj = self.get_rule_key_by_name(rule_name=self.rule_name) if rule_obj is not None: # Rule already exists, remove and create again # Cluster does not allow editing existing rule existing_rule = self.normalize_rule_spec(rule_obj=rule_obj) if ((existing_rule['rule_vm_group_name'] == self.vm_group_name) or (existing_rule['rule_anti_affine_host_group_name'] == self.host_group_name) or (existing_rule['rule_affine_host_group_name'] == self.host_group_name) or (existing_rule['rule_enabled'] == self.enabled) or (existing_rule['rule_mandatory'] == self.mandatory)): # Rule is same as existing rule, evacuate self.module.exit_json(changed=False, result=existing_rule) # Delete existing rule as we cannot edit it changed, result = self.delete(rule_name=self.rule_name) if not changed: self.module.fail_json(msg="Failed to delete while updating rule %s due to %s" % (self.rule_name, result)) changed, result = self.create_rule_spec() return changed, result ```
`Host group` (copy/paste, i guess)
Can be covered in the `AnsibleModule` instantiation by using `required_if`
A lot of the entries here should be in the description of each relevant option. This is for a high level overview of what the module does. The `notes` entry can also be used for info about the module if it doesn't fit in a option.
Please change this to 2.5
All `description:` (apart from `short_description:`) must be full sentences, ie start with a capital letter and end with a full stop.
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
This should be quoted.
```suggestion self.container = PodmanContainer(self.module, self.name) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
No need for params: * they are accessible via module * they aren't used here at all ```suggestion def __init__(self, module, name): ```
If source is None, the conditional `not source` will be true. So I don't think the second part of this conditional will ever hit.
i would execute AFTER getting module's shebang so you can find the 'right interpreter' also check that ansible_x_interpreter does not exist already
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
Not required after above `load_provider()` change
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
```suggestion for key, value in client.module.params.items(): ```
It's probably not a good long-term solution, but currently it's fine, especially because docker-py's `DockerClient` at the moment simply creates `self.api = APIClient(...)` and does nothing else. Once this PR is merged, we can improve this behavior in a bugfix PR (which can also be merged after next Thursday).
While working on #53906, I explored the docker client creation process a bit more in detail. You can use `self.dclient = DockerClient(**self.client._connect_params)` to initialize the client with the same arguments as `self.client` is initialized. Relying on a Ansible docker internal API should be safer than relying on docker-py internal API.
`self.client` is already derived from `DockerClient` (and ready to use), there's no need for `self.dclient`.
I would return an explicit boolean flag which informs whether the plugin is activated or not (for `state != 'absent'`).
since checksum seems designed to allow for diff hashing algorithms, should this not be configurable depending on which one is used and not just always sha256
This is just an internal implementation and doesn't need to be configurable. It is generating a unique hash of the line and using that as the key rather than using the hash itself as the key. The example from the bug report had a file that used the same hash for different files, which resulted in it reporting it could not find the hash. ``` 80fcaa0ead2d75283613b9d9d8a02f0df76b7cd018153c2454069cb30ebc0fdb rhcos-aws.x86_64.vmdk.gz 80fcaa0ead2d75283613b9d9d8a02f0df76b7cd018153c2454069cb30ebc0fdb rhcos-4.5.6-x86_64-aws.x86_64.vmdk.gz ```
```suggestion # checksum filename ```
Please note that in Python we don't use brackets unless really needed.
I liked generator approach more: it's more readable in terms of separating a distinct logical step from a higher-level flow.
```suggestion required: true type: str ```
This debug needs to be updated for a few things: 1. Use full YAML syntax, not `key=value` 1. `.pid` should be `.pids` 1. Instead of `','.join` please use the `|join` jinja filter.
add sample of pids like ```yaml sample: [ 10101, 12011 ] ```
You could drop "It return", i.e. change the description to "Process IDs of the given process"
sys is unused import
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
There's a lot of copying going on here as well. Both on this line and on line 456. Copying is slow so you want to eliminate any that aren't needed.
no, if the variable is set but empty, you should empty out the options
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
Please use `- name: ` with examples
s/will created/will be created/
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
Not catching non-200 responses.
Not catching non-200 responses.
Not catching non-200 responses.
Useless loop, since it can be merged with the next one.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
This is handled by the Azure module utils so isn't needed in the module arg spec
ah, ok... yes, i think when original azure_rm_virtualmachine was done, as_dict() was not available yet. that's why there's serialize_vm function in there. I will actually try to check how it differs from raw REST API response....
i meant that maybe you don't need serialize_vm function at all, you could just use as_dict() which is available from vm object
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
minor, convention is to use `yes` or `no`, and not `True` or `False`, for values in case type: bool
to show datacenter is anoter param use I(datacenter)
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
All our parameters that accept lists, accept single items too. But we never offer both the plural and singular version for parameter name. A one-item list, is still a list :-) So I wouldn't bother. IMO offering both is more confusing as people may assume that: ```yaml ssh_key: my-ssh-key ``` means there is only one SSH key to add. That is why I would only have the plural form and no aliases. It will end up to be more consistent between users/playbooks and it's clear the parameter accepts more than one value.
Is this (and `providers:` below) part of `property_attributes:`? Dedent if you want them to be example of top-level `providers` and `services` args.
may be nice to support description in addition to name.
Perhaps `required_if` can help.
no, this refers to the standard `changed=True` / `changed=False` and `msg="..."` results returned by ansible modules.
I think this is a typo - `changed` should be `changes`
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
This check shouldn't be required if `self.tags` defaults to the empty dict - the else clause would be taken care of in the same way using compare_aws_tags.
Fails since message contains An error occurred (InvalidParameterValue) when calling the ModifyCacheSubnetGroup operation: No modifications were requested.\n instead have if 'No modifications were requested' in str(e):
This method can be simplified to: ``` return [{"ParameterName": str(k), "ParameterValue": str(v)} for (k,v) in params.items] ```
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
Please keep your code style consistent: first you assign vars for some time, then you pass lots of function args directly. There's a better way.
This needs to go outside of CM. If `ipsubnet` will raise exception it will interrupt code block within `with`.
``` self.assertRaises(ValueError, get_ip_version, '192.168.0.1') ``` should work with python 2.6 but you can't check the error message.
For the cases where I've wanted to use a nose test generator, I've ended up just making the test class inherit from object. You lose the TestCase methods (various self.assert*) but usually test generators methods have pretty simple assertions so not too much of a issue. To me it is simpler than injecting the support into a TestCase subclass. (an example is https://github.com/alikins/ansible/blob/6e8a3d0c25fdeaa349351c6636b062376c30b0a6/test/units/plugins/lookup/test_ini.py)
You could `mock.patch` it to do so :)
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
host, username, password, timeout and vdom is already in fortios.py in module_utils
s/write target file {0}/fetch file to {0}/
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
IMHO `ansible.module_utils.six` should be used: `from ansible.module_utils.six import with_metaclass`
`in()` looks like a function call, extra list creation not needed (generator expression should be fine) and it's better readable when multiline: ```suggestion return dict( (obj.__name__.lower(), obj) for obj in get_all_subclasses(PkgMgr) if obj not in (CLIMgr, LibMgr) ) ```
how about ```suggestion installed_packages = defaultdict(list) ```
Use a more clear name to better reflect what the function is actually doing. It doesn't just check availability but also mutates state. ```suggestion def try_import(self): ```
Using this directly is discouraged: https://docs.python.org/3/library/importlib.html#importlib.__import__ > Note Programmatic importing of modules should use import_module() instead of this function.
@gundalow I'm not sure what that does - I updated it (from 2.6) as part of the 2.7 release, thinking perhaps the `VERSION` setting in the Sphinx config should match the `latest` setting on the docsite. We could experiment . . .
Thanks for running the experiment, @aknrdureegaesr. I'll open a separate PR to update the version to 2.8 on `devel`.
Any reason not to use a CM? ```suggestion with codecs.open(os.path.join(*file_paths), 'r', 'latin1') as f: info_file = f.read() ```
Maybe add "ansible versions below 2.10" or something so it's clear this is a one-time problem, not that they can never upgrade `ansible` again...
Don't assign a lambda function, use def
Could be shortened to `return rc == 0` if you're not doing any further processing other than returning.
This is a personal preference, but I'd rather not have a class name in all caps.
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
You can remove all of these imports except ec2_argument_spec.
If cluster_id is None this will fail. Alternative, if cluster_id should be optional: use list_clusters and use each cluster id in the response to call describe_cluster.
heh, indeed interesting, just checked it myself
just an style thing, any reason for only having 3 elements per line on the list? I'm fine if you want to make it 80 line compliant but let's make it consistent for all module ;)
I like the code organization here ð , but it is a little different than most modules. Some folks may prefer the deeply nested args style. I don't think you should change it, just a heads up that it might be a little unusual to some folks.
redundant code to line 291
Split GitLab authentification en project gathering. Add a custom check on `git.projects.get(project)` with a custom message
An example of removing role would be nice.
You miss description parameter of the role.
It's not dicitinonary. It's list of permit names.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
Can you use here: ```python host_id = get_id_by_name(hosts_service, host_name) ``` you won't have to check if host exists and it raises the exception for you. And you are insterested in host id only anyway.
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
Again nitpicker - sentence sounds a bit weird. Maybe something as follows would be better? ``` Nested keys must be quoted when specified in abbreviated form (e.g. C("DesktopViewSettings:IconViewSettings:arrangeBy")), since colons are treated as part of YAML syntax itself. ```
I think it makes sense - the user is responsible for making sure the library is available for specified Python interpreter. Similar to how user is required to install necessary prerequisites for modules, for example.
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
New modules shouldn't have aliases, plus the alias seems to be wrong as this is the name of the storage account instance.
default: null doesn't need to be set and can be omitted
One thing we are trying to do with the Azure facts modules is to return both a curated and raw/api structure as specified by a `format` option. We want to favour the `curated` values and set that as the default output which means they need to be in place before we merge the module. The curated option is designed to flatten and make the return values from Azure a lot easier to view and access in Ansible.
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
You should fail here with `self.fail`. Currently you'll have `account_keys` as undefined if this exception is thrown.
This needs to pass `return_docs=True` for return docs.
I think this will fail on py3, as `encoded` will be a list of bytes. ``` TypeError: sequence item 0: expected str instance, bytes found ``` Might make `b''.join` and then use `to_native(data, errors='surrogate_or_strict')`
if you are using loader, just use `get_file_contents`
Also, add ```vmodl.fault.SystemError``` here,
No, I mean ``` except (vmodl.fault.SystemError, Exception) as e: ```
I think it's better to set them to null if they always existed before - unknown key would behave differently than a key that exists but is set to a null value and we don't want to break things for people if possible. Thanks very much for diving in to this.
AnsibleAWSModule automatically adds ec2_argument_spec() so you can simplify 213 through 219 ``` argument_spec = dict( route_table_ids=dict(default=[], type='list'), filters=dict(default={}, type='dict') )
Actually caught by AnsibleAWSModule
```suggestion description: The ID of a NAT instance owner in your VPC. returned: when NAT instance owner is available ```
This `.close()` isn't needed, the context manager closes the file automatically.
Create address service object on PanOS devices This may need updating on existing modules
Capital letters & full stops please
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
`required: false` lines can be removed
I get that long format task ARNS might be a prerequisite for tags but might be better say e.g. > "Cannot set task tags: long format task arns are required to set tags"
There is a 'createdAt' as a key in service as well.
Same here - AnsibleAWSModule adds this itself.
Like many other statements in the examples.
No need to use quotes. We tend to not quote when it's not needed, as this helps people understand the YAML rules better.
I think it'd be better readable if you do `C(valid_from)` and `C(valid_to)`
```suggestion Time will always be interpreted as UTC. Mainly to be used with relative timespec for C(valid_from) and / or C(valid_to). ```
I think `C()` should help with formatting and readability ```suggestion Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY:MM:DD | YYYY:MM:DD:HH:MM:SS | YYYY:MM:DD HH:MM:SS | forever) ```
`type: list` is missing.
```suggestion - "Specify certificate options when signing a key. The options that are valid for user certificates are: ```
I think we need to emit a deprecation warning so that it'd be discoverable by users and also the module docstring should be the first AST node in the module: ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ import warnings # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text warnings.warn( 'Importing to_bytes, to_native, to_text from _text ' 'has been deprecated. Please import them from ' 'ansible.module_utils.common.text.converters instead.', DeprecationWarning, stacklevel=2, ) ```
Alright, after seeing the messages on slack I think that adding warnings can wait but still the docstring must be relocated because it was a module docstring originally and we should keep it on the top of the module. ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text ```
We already have a warnings mechanism in `module_utils.common.warnings` that is consumed on the module side, but we need to implement consuming of these warnings controller side. As such, it's not a completed feature yet.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Odd -- on python3, to_str should just be an alias for to_unicode so there shouldn't be any difference. On python2, they'd be different but it should work because of automatic coercion of byte strings to unicode strings in python2.
I understand, theses are really nice functions you got there, thanks a heap for your reply !
to_str will work here but probably for cleanness sake, want to use to_unicode here, like this: ``` python err = to_unicode(err) if u'Bad configuration option' in err or u'Usage:' in err: ```
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
Yeah, a list is fine.
Add traceback here as well (for line numbers).
Add `exception=traceback.format_exc()` here as well please.
Can `state` default to `present`? I usually expect this, I'm not sure if the flaw is with me or not :)
Could add the expected keys to the error since CamelCase may be unexpected.
Please add the kwarg `exception=traceback.format_exc()` to this failure.
The alternative would be to always report `changed=False` in check mode, but that could result in an unexpected change during normal execution when you were expecting no change. I would rather Ansible report a change in check mode, but do nothing in normal mode to be on the safe side.
s/does not do anything/has no effect/
s/./ to avoid infinite hangs waiting for input./
Please remove this line.
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
But won't be moved if the storage domain is changed, no? The note should be added only if the parameter is NOT idempotent. The default is meant to be idempotent.
Please add ` version_added: "2.4"`
Please also use proper doc formatting like: "C(template) and C(storage_domain) parameters are provided"
```suggestion - Only used for images that contain the Windows Server operating system. ```
```suggestion - To remove only resources that were automatically created while provisioning the VM being removed, set to C(all_autocreated). ```
s/Disk quota ID/Virtual Machine quota ID
Please add a note that it's supported since oVirt 4.1.
```suggestion choices: ['present', 'absent'] type: str ```
Include type for other parameters as well.
```suggestion - "Required when state is present." type: str ```
Better to use ```get_id_by_name``` it get proper error message if storage is not found
Can we somehow implement behavior of specify storage_domain for all disks? If I understand the code correctly, it not currently.
I think it's `disk.disk.id`
Can you move this logic to `__get_storage_domain_and_all_template_disks` and just call: ``` return otypes.Vm( ... disk_attachments=self.__get_storage_domain_and_all_template_disks() ... ) ```
I think it's not worth to create the temp var here, maybe just pass the `self._connection.follow_link(template.disk_attachments)` directly in `for`, also it's not strict to use 80 chars/line and I think here the newline makes it less readable, so if you want to use temp var then I think it would be more readeble, to not use new line, but up to you.
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
You can replace line 1284-1293 by: ```python vms_service = self._connection.system_service().vms_service() vm_id = get_id_by_name(vms_service, self.param('srcvm')) vm_service = vms_service.vm_service(vm_id) ```
Can you please create method `__get_cluster()` and add there the logic on line 1307 - 1310
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
Ansible has allowed 160chars per line, I think it's OK to have this on single line.
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
This check can be also moved to `module_utils`.
`delete_volume` does not require size. This check will force user to specify size even if he/she is deleting the volume. I feel this is not intuitive UI/UX.
```python if state == 'present': if not volume: create_volume(module, array) elif volume: update_volume(module, array, volume) elif state == 'absent' and volume: delete_volume(module, array, volume) else: module.exit_json(changed=False) ```
Is anything `required_together`, if not please remove this line
str? ```suggestion size=dict(type='str') ```
It might be also interesting to see if it would fail though.
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
Read operation: ditto
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
Yes, the revisions you'v emade to this look good to me.
I see you fixed this one. :+1:
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
Use connect_to_api from vmware.py
Check if self.dc_obj is not None. We have seen "AttributeError" failures in past related to this.
Could you please correct docstring? There is no boolean value in return value.
Doesn't seem to have been done
Thanks, if you push those changes I can re-review
FYI, all these RETURN items will end up as rows in a table and will not be grouped by default, hardware, etc. I can't think of a better way of doing this, no action, just so you are aware.
This applies to a few places.
Refer https://github.com/ansible/ansible/pull/59914#discussion_r313247935 Same doc guideline is followed for other modules.
This should get imported from ansible.module_utils.six
Double quote around Author name.
Well, then they will never really know and think they always have to quote. I don't think it's better to teach them to always quote, and certainly not using double quotes. Besides, you're not being consistent, you're not quoting the task name value and delegate_to.
Add double quotes to Author name.
IMHO this will always return changed as False. `Changed` should be change according to action module performs.
```suggestion - Size of the domain. ```
```suggestion - The desired state of the domain. ```
```suggestion - Name of the domain to be managed. ```
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
Add github handle here. ```suggestion - Tzur Eliyahu (@tzurE) ```
Use `to_native` for wrapping error message.
This is dangerous. Three could be several reasons why opening the container fails. These do not mean that the key does not yet exist.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
the error should go to stderr, since sys.exit does this by default (and still returns rc=1) just use that.
I think `if props is not None` is more conventional :smile:
check_mode is True but I don't see any check done around this. Please correct me if I am wrong here.
Please remove deprecated parameters as this is new module.
```suggestion if self.client.module.params['disk_usage']: ```
Default needs adding to docs
Probably we need something similar for all the `module.run_command()` stuff. As I don't know if they fail gracefully by themselves. Easy to test though.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Technically this will never be `None` because of the defaults.
It might also be no IGWs found here.
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
it doesn't really matter as modules are treated as 'independent scripts' and not meant to be shared or reused code
Can you please ensure the module works with checkmode
swap out required for `default` and make it default to `present`
As on other PR, update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 and remove `no_log: true` from examples
I'm guessing this is because the module will manage one datacenter at a time/per resource declaration, and return that datacenter's data. For getting/querying multiple datacenters, likely the DatacenterFactsModule will be required.
Might be worth updating https://github.com/ansible/ansible/blob/devel/CHANGELOG.md in this PR as well to made that clear
Remove this line
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove this line.
Please remove this line.
again, this is not required, since the key IS REQUIRED you never get to this point
set this as the default, then you dont need to do checks yourself
check is redundant as you already flagged as 'required'
i recommend using the ansible json encoder as it deals with 'special' types and will avoid a lot of serialization errors you'll get with the stock json.
Used by the base class to be able to handle all ansible data https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/callback/__init__.py#L123
naming this as `connect_ssh_port` will imply use of ssh port on the server.
`A regular expression or pattern`
```suggestion - Requires C(net_name) or C(net_id) to be specified. ```
`version_added` should be 2.7 for now
This isn't strictly required. ```suggestion ```
Since all of these appear to be constants, it seems to me that making them tuples instead of lists would be good to avoid accidentally modifying them.
For these to be a tuple you need a trailing comma, like `opsworks_fields = ('layer_id',)` for all single-item tuples.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
Generally I'm not so happy with this long list of if statements. What I would rather have is a set of named objects (like the `eg.policy`) and a set of lists of relevant parameters (`eg_policy_params=['policy_name', 'namespace....`) and then iterate through the list to build the object from the original policy object. I think this would be easier to maintain in future.
`required=False` and `default=None` are defaults so you can eliminate them in every case below
env var or ini entry, just like you do for host
forgot that part, still it seems that rest of options can be set in other ways also, why force user to always set in kwargs
missing version_added for the ini entry
redis is good example, https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/lookup/redis.py in any case it is ts simple: ``` ini: - section: consule_kv_lookup key: validate_certs ```
This should be a more comprehensive example, I don't follow what the intent here is. I have an assumption that you're connecting to a ssh daemon that's running in the context of a chroot located at `/mnt` on the `server01` system but it should be more explicitly stated in an attempt to remove the ambiguity.
`short_description: Manage VLANs on VyOS devices`
Missing `=dict` on this and the next few lines
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
VERSION_ADDED should be "2.3"
As `state` value is fetched at L112, this is not required.
avoid making double "get"
do not call "get" twice
```yaml type: bool ```
state: type: str choices: ['present', 'absent']
use full names read-only, read-write
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
```suggestion - Set to C(true) with I(state=present) to generalize the machine. ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
```suggestion - Controls if the machine is allocated/deallocated, only useful with I(state=present). ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
I fixed them in https://github.com/ansible/ansible/pull/22415 which I can fix up once this is merged in.
Just put this on one line (or two if needed for line lengths) ``` from a.b.c import x, y, z from a.b.c import u, v, w ```
Since we are going to import this back into basic.py, it probably shouldn't be "private"
AnsibleFailJson is not used and shouldn't be imported
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
type='str' is the default so I think you can remove those.
@abadger I wasn't aware. I wonder why some of the modules with no type seem to work as if they have type='raw', and fix those. Sorry for the noise, case closed. PS Still I prefer to have the type written out for every argiment. It is the only option for arguments I think should be explicitly mentioned always.
Mea culpa. I told them to take the defaults out for brevity. I'll keep your preference in mind in the future.
I prefer explicit types for all the parameters (unless they are multi-type parameters)
@dagwieers @s-hertel The default **is** str. It changed (from what is now type=raw) a while ago, maybe 2.0 or 2.1. One of the major drivers for the change was that while yaml has types, k=v parsing does not. things like ports and timeouts were then getting to the modules as ints if they were specificed via yaml or strings if they were specified via k=v parsing. There are a few parameters in a few modules (for instance, the infamous file mode parameter) which use type=raw so that the module can accept different types of values for the parameter. We try not to use that in modules if we can get away with it but there are a few places where it's needed.
`rsa1` is indeed the old, deprecated (but still supported on some platforms...) format for RSA keys.
Use `C(ssh-keygen)`, and also `... generate C(rsa), R(dsa), R(rsa1), C(ed25519), or C(ecdsa) private keys.` to improve formatting.
And out of curiosity: what is `rsa1`? The ssh-keygen on my machine does not know about it (`unknown key type rsa1`); I've got OpenSSH_7.8p1 installed. From searching the internet, it looks like `rsa1` is a SSHv1 RSA key (and thus deprecated, as the whole SSHv1 protocol). If that's correct, you might want to mention that, and that not all implementations support it.
`PyOpenSSL>= 0.15` seems only required for `SelfSignedCertificate`, with other providers older PyOpenSSL versions should work fine: this information could be added here.
as `required: false` is the default, it can be left off
Please put all imports together at the top, and include only the stuff you are using, i.e. ```python from ansible.module_utils.basic import AnsibleModule ```
Too long line.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
Please use `module= AnsibleModule(` I guess it is a convention
```suggestion # type: (str, bytes, Optional[str], bool, GalaxyToken, int) -> bytes ``` This fix was already applied in devel: https://github.com/ansible/ansible/pull/77147
This should probably mention both slash and no-slash paths...
to_text and prefix the string with u.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
probably want a to_text and u prefix.
If VMM domain, add support for "vmmDomainProperties": { "microSegVlan": { "vlanType": {}, "vlan": 0 }, "portEncapVlan": { "vlanType": {}, "vlan": 0 }, "vlanEncapMode": {}, "allowMicroSegmentation": 0, "switchType": {}, "switchingMode": {}, "epgLagPol": { "enhancedLagPol": { "name": "string", "dn": "string" } }
There could be a check in here to prevent both label and label_id from being specified if state is absent.
update the author
nit-picky optimization, but if the prior step was successful then 'id' should already be in `result` Also, if the state is "absent", then you need to be sure that you don't hit this code. Either that, or it should throw an error if schema is provided and state is absent.
I would probably do something like this, to make sure the choices always match what you can accept. ```suggestion vm_provider=dict(type='str', choices=VM_PROVIDER_MAPPING.keys()) ```
```suggestion - name: show configuration information ```
You could fix #19781 real quick right here :D
This should get imported from ansible.module_utils.six
local_action has same issue as it is an alias to `delegate_to: localhost`
Well this would be for 2.4 so maybe that is the better path
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
Absolute paths still can contain `..` in the middle of the path and that would be processed when accessing paths.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I'd do ```suggestion if not ignore_errors: raise ```
Casting to list isn't needed here ```suggestion elif any(fnmatch.fnmatch(item, pattern) for pattern in ignore_files): ```
Please don't use lists for tracking differences, but `DifferenceTracker`. That produces a much better output.
```suggestion for key, value in self.parameters.plugin_options.items(): ```
You should check if the options actually changed before reconfiguring the plugin. It only makes sense to reconfigure if this actually changes something.
That should only be called if the plugin should in `enabled` state afterwards.
```suggestion for key, value in client.module.params.items(): ```
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
this got named use_backend
we should also return if we both delegate executions and delegate_facts
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
Add that the user can specify the backend to use via the ```use``` parameter.
Nit: `(object)` is unnecessary
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
It looks to me like these URLs are better suited for a `seealso` section.
```suggestion version_added: "2.8" ```
`rsa1` is indeed the old, deprecated (but still supported on some platforms...) format for RSA keys.
Sorry, I think we had a misunderstanding when we talked earlier. I don't think we should be raising unless we add more exceptions so that we can tell why an exception occurred (right now, we'd have to catch the AnsibleError and then parse the message to tell why we failed.) raise_on_error is bad API. The API should either raise whenever there is an error or let the caller discriminate. Passing in a flag to tell the function to raise isn't meaningful. If we start raising an error, then we have to audit the code and decide what the failure case means in the present code. If the code doesn't depend on it (or works in some scenarios) then we probably have to replicate that behaviour instead of changing to always failing.
Nit: It would make this test a lot more readable if the `lambda` was just a function. ```python def fake_remote_chmod(x, y): if y == '+a': raiseExc(AnsibleAuthenticationFailure()) return {'rc': 0, 'stdout': '', 'stderr': ''} action_base._remote_chmod.side_effect = fake_remote_chmod ```
```suggestion # This function ensures that only the macOS case (+a) throws this. ```
```suggestion # Based on our function above, it should be successful. ```
we want want -> we want
You should probably put this check into a separate function and run it before `with` block https://github.com/ansible/ansible/pull/46675/files#diff-62a00abb6ff3cd2c35f54b8b82436130R205 so that it'll halt execution even before trying to construct that connection object.
Python is a language with encourages clear and human-readable communication. While keeping things short we don't sacrifice keystrokes. fw and nw are misleading for the reader (especially where this thing is called). firewall? northwest? ```suggestion def update_firmware_from_netshare(idrac, module): ```
So let's just raise an appropriate exception...
I just want to emphasize that assigning different types of data to the same variable is usually error-prone and should be avoided.
Please use PEP257 style guide for good docstrings. The title should be a sentence with a period in the end and it should go one line above with one empty line separator from the long description.
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
In the "Generate privatekey6 - standard - with non-ASCII passphrase" test, this fails with `'ascii' codec can't decode byte 0xc3 in position 16: ordinal not in range(128)`. Stacktrace: ``` File "/tmp/ansible_openssh_keypair_payload_kCnMbD/__main__.py", line 193, in generate tf.write("#!/bin/sh\necho %s" % quote(self.passphrase)) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 706, in write return self.writer.write(data) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 369, in write data, consumed = self.encode(object, self.errors) ``` It seems to fail in all Python 2 tests; in Python 3 it seems to work.
You should use `module.add_cleanup_file()` (somewhere above) instead of manually trying to clean up.
```suggestion - Windows containers must use I(network_mode=default), which will utilize docker NAT networking. - Setting I(network_mode=default) for a Linux container will use bridge mode. ```
```suggestion - Windows containers must use I(network_mode=default), which will utilize docker NAT networking. ``` Using I(...) adds some extra highlighting that says "Option network_mode set to value 'default'"
This needs to be a string: `"2.3"`
```suggestion - List of IP addresses. ```
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
@beudbeud I think Felix was asking if this was correct: `As of Ansible 2.8, if you use KV v2 now you get only the last secret from a path.`
this should be moved into the run method, as we only want this to error on running, not on loading, which will always happen if this is included in ansible. or in the hasivault class init, which gets called from run.
Since we have a line for `version_added`, I'd remove the "(added in Ansible 2.0)".
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
Don't add this, if the parameter is not required.
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
Looks like this is used now, yay :-)
Debugging, I assume, but should be limited before merging.
py3.x-only code; can safely ditch the args to `super()`
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
link used to be different, not sure when it got made the same
I think an internal map with the file_type to 'stat operation' matching would be a cleaner way to implement this and then have: ```statop = getattr(stat, FILE_MAP[params['file_type']]``` to find the function for comparison
I think `if props is not None` is more conventional :smile:
I think it's best to always provide **template_destpath**, and if it wasn't defined return `jinja.StrictUndefined` or possible `None`.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
I had a PR for the same - #32020. I will go ahead and close it. :)
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
This looks for tags with the `Name` key set to `dev` - maybe a better example would be: ``` # all instances with their `Environment` tag set to `dev` tag:Environment: dev # all dev and QA hosts tag:Environment: - dev - qa ``` Since `tag:Name` could be confused for "tags with the name dev" as in `dev : true` or something
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
Yep, that's how ec2.py works by default if you include tags, so I'd assume *someone* will want that behavior in the new script.
SyntaxError ``` lib/ansible/vars/__init__.py:41: in <module> from ansible.template import Templar E File "/home/adrian/src/ansible/lib/ansible/template/__init__.py", line 517 E for k in data.: E ^ E SyntaxError: invalid syntax ```
We can remove import of `text_type` as well.
For the record, as mentioned in the triage, we want to run `safe_eval` in specific cases (dict, list, bool), so this check needs to stay.
I believe you need to wrap the exception types in parentheses
As a note, I just remembered that we had to preserve `NativeJinjaText` somewhere else too for the same reason. Trying to `join` a result from a lookup in https://github.com/ansible/ansible/blob/bf7d4ce260dc4ffc6074b2a392b9ff4d3794308b/lib/ansible/template/__init__.py#L1057 led to losing the type so we had to explicitly convert the result of `join` to `NativeJinjaText` (and further make it unsafe to `NativeJinjaUnsafeText`).
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
I'm working on a PR to update CI for these tests right now. :)
BotoCoreError does not have a .response attribute so this may throw an AttributeError.
No need to import HAS_BOTO3 now.
sample should just be the content of `gateway_id`, not the whole dict.
Seems this is only returned when state=present.
Doesn't look this this is needed anymore, quick check shows that it was only used in `dict_merge`
New unit tests should be pytest style (stand-alone functions) instead of classes.
I think you have to do the same for ldap_attr. Anyway, with the commit you added ldap_entry no longer crashes for me (my playbooks no longer use ldap_attr, I vendored the 2.10 ldap_attrs a longer time ago).
The code from here until line 224 needs to be indented by one level. Otherwise the module will crash if `params` is not used.
Name as per convention can be `lag_itnerfaces_facts`
ansible.module_utils.ec2 sets HAS_BOTO3 to the correct value.
can delete this line
Now that we're making this a module_util, this should no longer be considered a hack.
Since we are already using `six`, we should use `six.moves` here instead. ``` from six.moves.urllib.parse import urlencode ```
I don't believe this should have changed. The module was available in 2.3
Will fail if `self.systems_uri` is not set yet.
Not catching non-200 responses.
Will fail if `self.manager_uri` is not set yet.
Not catching non-200 responses.
This will fail if `self.accounts_uri` is not initialized.
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
I'm going to add a commit to do `if os.path.exists(module.params.get('cert')):` instead of try/except.
This module doesn't support check mode. I'm not sure if this is the best method to do this either though.
I don't know the `purestorage.FlashArray` API behind the `array` type, but was curious if there a potential error condition or unhandled exception that could occur here in the event the attempt to `set_hgroup` fails? (same question for various `set_hgroup`, `connect_hgroup`, and `set_hgroup` calls in this patch).
This check can be also moved to `module_utils`.
str? ```suggestion size=dict(type='str') ```
Is anything `required_together`, if not please remove this line
`delete_volume` does not require size. This check will force user to specify size even if he/she is deleting the volume. I feel this is not intuitive UI/UX.
Right, in this case the connection vars are actually `client_id` and `client_secret`, for those we picked standard names, like in `typetalk` or `azure` modules. Using those connection variables, you can modify repositories belonging to any `username` you have access to, be it a team or a user.
The reason I brought it up: https://github.com/ansible/ansible/issues/51757 Though in this case it may not be a connection variable.
```suggestion - The repository owner. ```
```suggestion - The repository name. ```
```suggestion - The public key. ```
What's the plan for this, since it's connection local only
Would it be possible to go into some detail, rather than just repeating the configuration options
since xml list is returned this can be modified to `sample: ['xml 1', 'xml 2', 'xml 3']`
`read-onYly` should probably be `read-only`
Did you try using `jxmlease` for dict to xml conversion? As it is already used in other modules it makes sense to reuse it. ``` from jxmlease.dictnode import XMLDictNode XMLDictNode({'unlock': {'target': {'candidate': None}}}).emit_xml() ```
Should probably check if region exists before this line.
You could move this a couple lines above and remove the two in the elifs below.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
You can remove this (and the import) now that this uses AnsibleAWSModule.
This wasn't aligned correctly before but we may as well fix it up now we're changing it.
Windows 8.1 / Windows 2012 (NT 6.2), no need to set the PS version as that will inevitably confuse people on older OS' who have upgraded to PS 4 or higher.
2012 comes with Powershell 3 which seems to work fine with the code so far so the restriction isn't there. I can't test with storage spaces but that should not be a reason why we would restrict the version.
I would have thought the only restriction would be Windows 8.1 / Windows Server 2012 (NT 6.2), it works when I try it locally. On a side note technically this should also work on Windows 8 but we don't support that OS so it should be kept at 8.1.
If it's not required, you can leave out `required: false`.
Until the latter is merged I would avoid referencing it in the module docs.
```suggestion - List of specific nat gateway IDs to get details for. ```
Modify this one as well? `if not delta.get('peer-link') and existing.get('peer-link'):`
Please modify this to `elif delta.get('peer-link') and not existing.get('peer-link'):`
```suggestion version_added: "2.10" ```
`my_vrf -> obvious_vrf`
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
I usually feel that something of this level of granularity is overly subdividing the code but this is setup.py, so I'm not as worried about it here as in the main code.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
```suggestion return False, 'Command "%s" found no files in archive. Empty archive files are not supported.' % self.cmd_path ```
This isn't showing changed=True for me when is succeeds. In fact, I don't know if it will ever complete without changing something, since right now we're failing if the git archive command isn't successful and if the directory creation isn't successful. Maybe a nice addition would be to compare the checksums of the contents of the archive destination to see if they are different than initially so changed could be False. But that would entail putting adding the zipfile to the directory, since I think we wouldn't want to rewrite the possibly existing file. Not sure what the best course of action is here. But exit with changed=True here, for now at least.
The remove is in the wrong place and tempdir is not removed. Better: ``` tempdir = tempfile.mkdtemp() new_archive = os.path.join(tempdir, 'archive.' + archive_fmt) git_archive(git_path, module, dest, new_archive, archive_fmt, version) archive_unchanged = filecmp.cmp(new_archive, archive) shutil.rmtree(tempdir) if archive_unchanged: result.update(changed=False) else: ... ```
This will fail if the destination exists. Is that the desired behavior? Since it is making a directory, maybe it should check if the directory already exists and if not create it? If it does exist, maybe we should be able to continue onto the archiving step. In addition, here's a hypothetical scenario: if this archiving fails the first time because the user uses an invalid URL to archive this part of the operation will succeed and the directory will be created. When the URL is fixed and this operation will run a second time it will fail here and not be readily apparent why. I think importing traceback and then failing with `module.fail_json(msg="Failed to clone source", exception=traceback.format_exc())` would be really helpful here for future debugging.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
Their are built in helpers for argspec for the this, have a look in other modules for "exclusive"
How about using `LooseVersion` from `distutils.version`? It usually handles version numbers pretty well. (Grep for `LooseVersion` in the modules directory to see plenty of examples.)
@mrdrogdrog great! Once you made the adjustments and someone else also tested it (just to be sure), I'll merge it and create a backport PR. If this gets done by the end of next week, it should make it into the 2.9.2 release.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
[textwrap.dedent](https://docs.python.org/2.7/library/textwrap.html?#textwrap.dedent) could be used here.
This "multi" method isn't needed in this PR since this is for a "set" method called from redfish_command.
I'd also explicitly state that it returns a tuple. With current wording it seems like it returns just `True` in a certain case.
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
We use `pytest` to run tests and the helpers from `unittest.TestCase` should be avoided (ideally, `unittest.TestCase` should never be used because it limits the compatibility with `pytest`). Instead, use `pytest.raises()`: ```suggestion expected_error_msg = ( r'^The --prompt option is not supported if ' r'also reading input from stdin$' ) with pytest.raises(errors.AnsibleOptionsError, match=expected_error_msg): cli.parse() ```
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
I'm not sure how old aos-pyez 0.6.0 is, though you may wish to detail that here. `- "aos-pyez >= 0.6.0"`
You can removed all the `required: false` it's implicit
Missing full stop.
support -> supports
Since we have used `EDITOR` historically, we should not change the default and need to start with `EDITOR` as the default. This precedence may not make sense, though, and we may need to add a config option to control this. ```suggestion env_editor = os.environ.get('EDITOR', os.environ.get('VISUAL', 'vi')) ```
move this to under the If
the changed = True from 410 should be moved below this
i need to think about the if in 411, it does not look right to me ... but there are many complex combinations here
remove this line as it is not needed
```suggestion import traceback ```
```suggestion if not HAS_OVH: self.fail_json(msg=missing_required_lib('python-ovh'), exception=OVH_IMPORT_ERROR) ```
```suggestion - ovh_monthly_billing: project_id: 0c727a20aa144485b70c44dee9123b46 instance_id: 8fa89ad2-8f08-4220-9fa4-9695ea23e948 ```
```suggestion - ID of the instance, get it with U(https://api.ovh.com/console/#/cloud/project/%7BserviceName%7D/instance#GET) ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Here is my reproducer, consistently fails: ``` --- - hosts: localhost connection: local vars: elb_app_lb_name: "{{ elb_app_lb_name }}" tg_name: "{{ tg_name }}" tasks: - name: create an application lb elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 listeners: - Protocol: HTTP Port: 80 DefaultActions: - 'Type': 'forward' 'TargetGroupName': '{{ tg_name }}' - name: update subnets elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-cbdf56ae - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 ``` Traceback: ``` TASK [update subnets] ************************************************************************************************** task path: /Users/shertel/Workspace/ansible/my_playbooks/elb_application_lb/iterate_over_NoneType.yml:22 Using module file /Users/shertel/Workspace/ansible/lib/ansible/modules/cloud/amazon/elb_application_lb.py <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: shertel <127.0.0.1> EXEC /bin/sh -c 'echo ~ && sleep 0' <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" && echo ansible-tmp-1499709521.38-260285283136193="` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" ) && sleep 0' <127.0.0.1> PUT /var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/tmpiiu8JI TO /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/ /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py && sleep 0' <127.0.0.1> EXEC /bin/sh -c '/Users/shertel/Workspace/ansible/venv/python2.7/bin/python /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py; rm -rf "/Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/" > /dev/null 2>&1 && sleep 0' The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1005, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1000, in main create_or_update_elb(connection, connection_ec2, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 895, in create_or_update_elb listener_changed = create_or_update_elb_listeners(connection, module, elb) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 704, in create_or_update_elb_listeners listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 487, in ensure_listeners_default_action_has_arn for listener in listeners: TypeError: 'NoneType' object is not iterable fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1005, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1000, in main\n create_or_update_elb(connection, connection_ec2, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 895, in create_or_update_elb\n listener_changed = create_or_update_elb_listeners(connection, module, elb)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 704, in create_or_update_elb_listeners\n listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get(\"listeners\"))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 487, in ensure_listeners_default_action_has_arn\n for listener in listeners:\nTypeError: 'NoneType' object is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ************************************************************************************************************* localhost : ok=1 changed=1 unreachable=0 failed=1 ```
Sorry, was out all of last week. I'm looking for my reproducer right now.
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
The reason is we don't really want to specifically call out relative paths as what they are relative to is determined by the setup of the remote system rather than anything under ansible's control.
Sorry, a few more minor clarifications after I read the related issue in detail. ```suggestion is equivalent to C(git clone [repo_url] [directory]). The repository named in C(repo) is not appended to this path and the destination directory must be empty. This ```
```suggestion is similar to C(git clone repo_url target_name). The repository ```
If we ever start generating the docs from docstrings, this will be problematic â RST uses double backticks for inline code, unlike Markdown.
You have `git>=2.19.0` in `requirements`
Use `missing_required_lib` from `ansible.module_utils.basic`
use `missing_required_lib` from `ansible.module_utils.basic`
use the `missing_required_lib` function from `ansible.module_utils.basic`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
@mmazur I think that Ondra's suggestion is correct. We need to be consistent how we present vm state to the user. At some point users will be confused if they not understand ephemeral vs stateful vm. For ephemeral vms stopping means delete and it is fine.
I think it make sense to support running state for ephmeral VM, as well as stopped and absent. which would be same. The code will be more straighforward then without not needed ifs
Do we still need kind? For service I think it should always be v1
Also we should still call this in case of check mode, and say whether it will be changed
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
again, please sort according to severity
disable logging to given remote host
please give more description about the structure of the upload url: ` protocol://username[:password]@server/path `
use sorted list. please use the sorted list in all relevant places
```python if size_pct is not None ```
To be consistent with other modules, can you please change this to: ``` validate_certs: description: - If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. required: false default: 'yes' ``` And update code & argspec as needed
```suggestion version_added: "2.8" ```
Each example task should be a continuous block, please do not have blank lines between sections
Sound, sound sensible
`, no_log=True` here please
Why not use deprecated_aliases, ```suggestion notification_message=dict(required=False, default=None, deprecated_aliases=[dict(name='message', version='2.14')]) ```
I think defaulting to `false` is the safest option, and would be consistent with the purge_tags defaults in other modules.
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
`timeout` and `username` aren't the same thing.
Use `elif` instead of `if`.
Change description to match `enable` and `disable` dvSwitch.
period at the end of statement.
We are not dealing with Standard switch, right ? Also, we are not creating or removing switch.
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
This is not required if using `super`
if required is true , default value can be removed.
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
A minor typo in `address`.
I know, but I had the impression that there was a tendency to switch from `true`/`false` to `yes`/`no`. But maybe I'm also mistaken.
Let's see if anyone else complains about that when reviewing ;)
This is correct.
I'm not a big fan of this self recursion. We're a bit limited since boto doesn't give any way to get the entire tree, but it would be nice if this could be broken out differently.
```suggestion description: The Organizational Unit details. ```
```suggestion parent_ous = paginator.paginate(ParentId=parent_id).build_full_result().get('OrganizationalUnits', []) for child_ou in parent_ous: ``` You could remove the outer loop here by using the paginator's `.build_full_result()` method and retrieving the OrganizationalUnits from it.
```suggestion aws_organization_units: ```
Write a method to generate final diff so it can be used anywhere in the code when required.
`commands` should always be a list.
This should be handled in the method where commands are being generated.
This isn't necessary as facts will always be empty if running-config has no lldp config.
No need to set `have`, `want` explicitly as it is always be empty dict if not resource is given/present.
This seems to be a leftover, there is no state "updated" anywhere else in the code.
When required is false, it can be left out (since it is the default).
This shouldn't be `required: True` since realm may be provided instead.
Required: false is implicit and not required
space looks unnecessary
Lines 58-60 have inconsistent indent.
Also missing parentheses: > during vm execution (e.g. due to a vm label update),
This should be `2.9` as we don't backport features.
Exceptions shoud be handled case by case discussed in an IRC meeting. Feel free to put this on the agenda https://github.com/ansible/community/issues/474.
> during vm execution (e.g. due to an update),
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
replace this with `return`, the actual `exit_json` call happens later and there is some ssh_wrapper code in the main routine that should run. Where do you remove tempdir/new_archive? Maybe that code got lost in one of the last refactorings. Remove the temp part should also happen before the `exit`.
I think you need `to_native` here.
The remove is in the wrong place and tempdir is not removed. Better: ``` tempdir = tempfile.mkdtemp() new_archive = os.path.join(tempdir, 'archive.' + archive_fmt) git_archive(git_path, module, dest, new_archive, archive_fmt, version) archive_unchanged = filecmp.cmp(new_archive, archive) shutil.rmtree(tempdir) if archive_unchanged: result.update(changed=False) else: ... ```
`str` isn't needed here.
we cannot set remote_addr w/o post_validating first
instead of 'starting connection' here we might want to 'reserve socket path', to create it if it doesn't exist and to 'touch it' if it does (making a-connection timeout reset so we avoid a race condition)
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
I'm not sure it really matters, but I'd put `self.ALLOW_BASE_THROTTLING` first.
use `task_keys['password']` instead to keep correct precedence
one more question, this would also be "true" for enlargement of the disk, would this work as expected? if yes, `allow_root_disk_shrink` would be a misleading name because it would not only resize to smaller, but also resize to bigger volume --> `allow_root_disk_resize`
No, you can resize the volume up or down, ***but*** if you want to resize it down you must specify the flag `shrink` to ensure you know what you are doing since it requires some preparation of the volume.
ok, got it! :+1:
Shall we catch a *just in case* missing volume in the response to be cleaner?: ``` volume = res.get('volume') if volume: .... ```
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
if you change `check_trunk_vlan_config` to return in the same order as the others, the variables here need to be reversed (and any `result[1]` in the code, needs to change to `result[0]`)
`""Delete a DVS Portgroup""`
Shouldn't this be in the reverse order, so it is in line with the other check methods? (consistency in code is good). That way you always use `result[0]` (will need to update that at other spots as well)
This should really be `switch=dict(type='str', required=True, aliases=['switch_name']),`, so that is in line with the doc. Otherwise switch it in the doc... (but as you changed the `portgroup_name` to `portgroup` here, it needs to be consistent)
Suggest to add the alias for `load_balancing_policy` for backward compatibility, including in doc
Change this parameter for a more explicite one : `project` This one should handle project `path` or `id`
Your module is named `gitlab_project_variable` don't use plural in your example
Since each of your attributes have only one attributes, what's the point of making a list ? Usage of a simple dictionary should be more easier to understand. ```yaml vars: ACCESS_KEY_ID: abc123 SECRET_ACCESS_KEY: 321cba ```
Use best practice to handler this error : ```python GITLAB_IMP_ERR = None try: import gitlab HAS_GITLAB_PACKAGE = True except Exception: GITLAB_IMP_ERR = traceback.format_exc() HAS_GITLAB_PACKAGE = False ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
vms -> VMs
vm -> VM
please use C() around possible values of the state
I would write: C(started) is alias for C(present). C(finished) is alias for C(absent). Same in the steps.
also please rename entity_id to job_id, no need to have it too generic here
We can remove import of `text_type` as well.
For the record, as mentioned in the triage, we want to run `safe_eval` in specific cases (dict, list, bool), so this check needs to stay.
SyntaxError ``` lib/ansible/vars/__init__.py:41: in <module> from ansible.template import Templar E File "/home/adrian/src/ansible/lib/ansible/template/__init__.py", line 517 E for k in data.: E ^ E SyntaxError: invalid syntax ```
As a note, I just remembered that we had to preserve `NativeJinjaText` somewhere else too for the same reason. Trying to `join` a result from a lookup in https://github.com/ansible/ansible/blob/bf7d4ce260dc4ffc6074b2a392b9ff4d3794308b/lib/ansible/template/__init__.py#L1057 led to losing the type so we had to explicitly convert the result of `join` to `NativeJinjaText` (and further make it unsafe to `NativeJinjaUnsafeText`).
no, jimi-c has alternate solution and we'll probably go with that
```suggestion feed_ca_cert=dict(aliases=['importer_ssl_ca_cert','ca_cert']), ```
This is not a good idea, since `ca_cert` is already a module option. (Due to `url_argument_spec()` above.) Either do ```suggestion feed_ca_cert=dict(aliases=['importer_ssl_ca_cert'']), ``` and make sure that `feed_ca_cert` is set to `ca_cert`'s value if not set, or name the option `ca_cert` and add `feed_ca_cert` and `importer_ssl_ca_cert` as aliases. (Then there's no way to separate these options.)
Hmm, I was pretty sure it was in there. Apparently, I'm wrong. Sorry!
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
No, the previous formatting was much better here for this block, much more readable.
example should be removed.
```suggestion - List of user aliases to add in the group ```
```suggestion import atexit import traceback ``` Please import `atexit` module
@rubentsirunyan thanks a lot for taking a look at this! :)
Ok, my bad. Thanks for clarification! :)
It's a minor issue. Wonder if it can go in the docs fragment
FYI you can replace this with `type: bool`
Double quote around Author name.
remove `default: None` as default is set to None by-default.
Required is default to false, so this line is not required.
Wait, never mind. I think vpc ID is required for VGW's.
It would be good to have some tests for check mode too.
For things with this many arguments, I'd really like to see keywords used to avoid any order mixups in the future.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
Just say `boto3` here, since botocore is a transitive dependency of boto3.
```suggestion import requests try: # requests is required for exception handling of the ConnectionError import requests HAS_REQUESTS = True except ImportError: REQUESTS_IMP_ERR = traceback.format_exc() HAS_REQUESTS = False ... if not HAS_REQUESTS: module.fail_json(msg=missing_required_lib('requests'), exception=REQUESTS_IMP_ERR) ```
```suggestion short_description: Execute tasks inside a VM via VMware Tools ```
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion - pyvmomi (Python library) ```
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
```suggestion choices: [ full list, top sites ] ```
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
This is wrong, already explained.
Keep a blank line between examples for readability.
```suggestion - "With this option user can identify the LUKS container by UUID. ```
```suggestion label on later usages." - "Will only be used on container creation, or when I(device) is not specified." ```
```suggestion - "blkid (when I(label) or I(uuid) options are used)" ```
```suggestion with label support, respectively to identify the container by ```
```suggestion - "This option allow the user to create a LUKS2 format container with ```
not worried about the else vs indent, its more of a style issue
This was already in pre-existing code, but it doesn't seem like the 'else:' is necessary here, and the rest of the method can lose an indention level.
also worthy noting, -G won't show actual ssh options used, just those configured
With the removal of `$?` this shouldn't be needed.
It looks like there may be an issue with the tests. I've restarted the failed test.
@aioue Thanks for the patch for this. What do you think about doing away with the valid tags check altogether? Some other opinions on this would probably be good too. I haven't noticed this attempted verification in other modules and I'm not sure what purpose it has. Tags should be able to be integers as well.
I think this should be: ``` python values = map(lambda x: x.strip(), tags['Value'].split(',')) ``` Basically the same as it was before this change but with `tags['Value']` instead.
If you are removing the last user, users_to_add == ['None'], which is truthy so it fails on line 280. Same problem with remove the group "all".
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
botocore.exceptions.ProfileNotFound may also be raised
Missing full stop.
You can removed all the `required: false` it's implicit
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
You can remove the `required: false` lines, it's implicit
I'm not sure how old aos-pyez 0.6.0 is, though you may wish to detail that here. `- "aos-pyez >= 0.6.0"`
You can make the list a frozenset at the toplevel of the file to speed this up slightly..
move this into main so you only need to define on load instead on every call
~should this be `if not`?~ nvmd, avoiding keywords
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
This is handled by `argument_spec`
If you provide non-existing DVSwitch then `self.dvs` will be `None` and module will fail with error saying ``` "'NoneType' object has no attribute 'EnableNetworkResourceManagement'" ```
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This is not required if using `super`
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
It looks like this is just a serial upload, how is this faster than the current S3 module? I definitely see the benefit of the glob & sync strategies, but it seems like this would be just as fast.
You don't need this conditional, since Ansible enforces that these are the only choices.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
Add `exception=traceback.format_exc()` here as well please.
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
we should also return if we both delegate executions and delegate_facts
Feel free to ignore me here but `get_*_coverage_files()` is common between python and powershell, you could just have the 1 function and have ``` def _get_coverage_files(language): coverage_dir = ResultType.COVERAGE.path coverage_files = [os.path.join(coverage_dir, f) for f in os.listdir(coverage_dir) if '=coverage.' in f and ('=%s' % language) in f] return coverage_files def get_python_coverage_files(): return _get_coverage_files('python') def get_powershell_coverage_files(): return _get_coverage_files('powershell') ```
I think, guard-expression style would fit better here: ```python if not import_name in module_utils: display.warning('%s:%d Invalid module_utils import: %s' % (path, line_number, import_name)) continue imports.add(import_name) ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
```python for line_number, line in enumerate(lines, 1): ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
```suggestion - name: Install python package using a proxy # Pip doesn't use the standard environment variables, please use the CAPITALIZED ones below ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Please don't use `\`, there are better ways
Start by not using `\` and use proper indent
Please don't use `\`, there are better ways Also use proper indent
Please don't use `\`, there are better ways
I don't see any check_mode related code.
`if key is not None and hash_host:` could be used too (because `hast_host` could be one of `None`, `True`, `False`)
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
In case the file doesn't exist, `keypair.check(module)` returns `False`, whence `changed` is set to `True`. I don't think that's correct.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
This is 1:1 the same code as in https://github.com/ansible/ansible/blob/8a671f54ddc5ec114ef807dc71f49d61261d2107/lib/ansible/module_utils/crypto.py#L150-L160
should be 'additive' to result when other operations are also executed, unless you force to make it an exclusive argument to all others
it should update the results dictionary and not exit, since this 'looses' information of other operations that might have happened before it and prevents any actions to be made after, but gives no error on defining those actions
"manual" is a recent occurrence, for older versions it was 'unmarkauto' iirc
IMHO this should be `apt-get/aptitude unmarkauto` instead of `apt-mark unmarkauto`
Indeed. However I can not say what exactly should be the fallback here. I didn't find a "recent" but outdated debian version not having apt-mark with manual|auto (debian7, ubuntu12.04). apt-mark probably has a fallback to apt-get itself. Works for me. Never mind.
I'm curious as to whether this needs to be in upper case or if it works in lower case as well.
Change to source and remove the alias
This supports more than just URLs, I would add more points talking about what it actually supports.
Please add an example below that shows you how get the newer NuGet provider version.
This is still something we shouldn't really want to explicitly support.
That's not what the code says (where default is `zip`)
Can you please rewrite the examples with a `name:` and multi line statements using `key: value` We are in the process of standardising all the modules to use that format.
You probably want this here: ```yaml type: bool default: 'no' ```
I would separate individual examples by an empty line.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
this might not be py2/py3 compatible, we might want to force bytes
One issue with this is that `win_reboot` uses this same method. So if the windows `DEFAULT_BOOT_TIME_COMMAND` results in an rc != 0, it will then try this `cat` command, which will gloriously fail. The previous conditional which runs `uptime -s` won't ever match on Windows because that string will never match the output of `(Get-WmiObject -ClassName Win32_OperatingSystem).LastBootUpTime`. This is the point where it would be helpful to have platform/dist as a class attribute, either as an additional check here, or to look up the correct boot time command based on platform/dist. I'm also open to other ideas.
Platform is also not present in Python 3.8 i think
I wonder if, rather than messing with regexp and all the complexity that brings with it, could we just get the last line of stdout? All of the boot time commands we expect to be a single line of output. Just getting the last line might avoid a lot of complexity and solve the problem.
last line wont work, but you can at least rely on the output of the command sending it's own line break
I'm not sure the `if seconds` makes sense here since we'll never get to this point if `seconds` is defined.
use `get_exception()` instead
If that's too much of a headache, even just removing the accidental line would be good.
You inadvertently added a third blank line. Probably worth running flake8 and removing what issues you can
just don't know exactly what's in the properties :-)
`join` takes one argument, so pass a tuple: ```suggestion failure_response['failures'].append(" ".join((module, to_native(e)))) ``` Same below.
Due to this, at the moment I am denying acceptance of this PR. I'll ask to get additional feedback from some other core developers, but we have explicitly denied modules that attempted to address arbitrary API functionality like this in the past. The recommended way would be to write individual modules for individual parts of functionality.
And just to clarify - currently the argument spec per API endpoint is being cached locally. So if API changes, the file has to be deleted and then it can be recreated again. Here's an example of this file after running a few playbooks: https://pastebin.com/CcPuMQCu
We have historically not allowed generic API modules. We generally require a module to be a specific set of features that perform an action. This would be in opposition to that stand point.
That is correct, argument spec is dynamic. If it is not dynamic, then any change to the API would render this module useless. Also, it would require me to write modules for every single API endpoint. There are some specific modules - https://github.com/willwagner602/ansible/tree/will-devel/lib/ansible/modules/network/fortios but there are a lot more of endpoints. So it made sense to let this core module build dynamic argument spec based on the data received from the API.
We should only be catching boto exceptions, not *every* exception here, since there may be issues we aren't able to handle here.
We can't leave this 100% unbounded, in general a higher timeout (10 minutes should be sufficient for most every stack changesets) is fine, and avoids us accidentally creating an infinite loop.
Needs to be `changeset_name = stack_params['ChangeSetName']` to match PEP8 style of whitespace around operators.
Prefer `del` over `pop` when not using the return value.
Wouldn't this create a conflict if someone ran this task twice with the same params, thus resulting in the same name (and a conflict)? Generating the name this way seems good, but can you add a check to make sure there isn't a changeset with that name already? If there is one, then you could return unchanged because the changeset already exists so this task's work is already done.
real sample value
The docs say this should be `servers`, I'm ok with either but it should be consistent.
Let's just standardize on `resource_group` and `name` for these (feel free to leave `server_name` as an alias though); the resource type should already be clear from the module name in a playbook context
lets' decide myAsg or myApplicationSecurityGroup
should be consistent with sample name and resource_group
```suggestion - content library id for which details needs to be fetched. ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
You said line 91 & 92 that only reducing the disk size is not allowed. Maybe you should remove line 70.
operation â state
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
All client calls should have exception handling. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
This approach adds a lot of complexity, since we're jumping into every place a write happens and adding a conditional. I'd prefer an approach that split out the "checking for differences" work from the "actually writing changes" work. That way, we'd have fewer new conditionals to manage.
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
`delete` and `create` are not valid states
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
What's the difference between Seeing state `present` and state `update` looks a little strange here. ```yaml - name: Change role type for existing user purefa_user: name: ansible role: storage_admin state: present # <---- fb_url: 10.10.10.2 api_token: e31060a7-21fc-e277-6240-25983c6c4592 ``` ```yaml - name: Change role type for existing user purefa_user: name: ansible role: storage_admin state: update # <---- fb_url: 10.10.10.2 api_token: e31060a7-21fc-e277-6240-25983c6c4592 ```
Maybe add `register: result` to one of the examples and then a `debug` task to view the result (or parts of it). That makes it easier for not so experienced people to use the module.
```suggestion - name: show configuration information ```
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Same typo as above
Oh! That's actually quite scary. Could people unexpectedly clobber their own variables through ansible_facts? I'm actually much more worried about ansible_facts than I was before - I really don't think it's clear that if you use a module, variables will be set whether you like it or not. I prefer explicit use of `register`.
It'd be better here to catch boto exceptions & other exceptions separately, since generic exceptions (like IOError if the network fails, for example) don't have status codes and other boto-isms.
```suggestion # require that the final recorded stack state was DELETE_COMPLETE ```
```suggestion # require that the final recorded stack state was ROLLBACK_COMPLETE ```
Ooh, this is a nasty bug - if this wasn't in this PR,I wouldn't have spotted this. If this code happens elsewhere, it'll break when 2.4 goes out (because a now valid key is overwritten by the content of a now missing key)
With cliconf the `get_config()` implementation and other similar api implementation is moved to platform-specific cliconf plugins [here](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/cliconf).
Rename this to `get_provider_argspec` to be in sync with other platforms
This extra check is not required after above provider spec changes
Please rename it as `get_provider_argspec()` to be in sync with other platforms
This check is not required after above `provider` spec change as `no_log=True` in auth_pass and passwords sub-options will take care to mask password.
Use `==` to compare booleans. The `is` test should *only* be used when you really want to compare identities of objects! Finally, there's no need to compare a boolean to `True` or `False` explicitly; simply write `elif self._has_migs(local):`.
`return migs != 0` is equivalent ot lines 380 to 382.
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
This would also match version 10.x. Also, `4.[0-2]` will also match `421` (an unescaped dot matches anything). You probably want: ```suggestion if re.search('^([0-3]\\.|4\\.[0-2])', min(self._build_list)): ``` Or (using raw strings, to avoid double escaping): ```suggestion if re.search(R'^([0-3]\.|4\.[0-2])', min(self._build_list)): ```
https://stackoverflow.com/a/2239753 ```suggestion if consecutive_good == self.module.params[ ```
It looks like scaleway modules allow a series of fallback environment variables as well as a module option. If you wanted to do the same thing for this plugin you could do ``` options: ... oauth_token: env: # in order of precedence - name: SCW_TOKEN - name: SCW_API_KEY - name: SCW_OAUTH_TOKEN ``` Then you can use self.get_option('oauth_token').
Same as earlier, I would check that `if mandatory_tags and not set(mandatory_tags).issubset(set(server_tags))`.
As exclude_tags could be an empty set, I would directly check `if exclude_tags and set(server_tags).intersection(exclude_tags)`. This way, it should also work when exclude_tags and server_tags are empty.
there could be a function to convert entire list, as this code is repeated below
`cloud_environment` and `auth_source` should be derived from `AzureRMModuleBase` and not needed on the module arg spec.
```suggestion - true, Run Puppet agent with C(--noop) switch set. ```
```suggestion - false, Run Puppet agent with C(--no-noop) switch set. ```
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
Please use `- name: ` with examples
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Also describe if it deletes the files or not
Why are all of these `@property`s? They don't return anything, so I don't see what the use of that is.
I don't think there's any reason to keep this path, ComplexDict needs a module parameter
Why the ConnectionError exception is returned as a normal response here. In case of an error, this might not be right.
It is not recommended to log commands executed on the remote device due to security reasons.
The error message can be "timeout value %s seconds reached while trying to send command %s"
host, username, password, timeout and vdom is already in fortios.py in module_utils
Remove the `try` block, it is unused.
I would change "updated" to "present". Some other network modules. e.g. ios_config, have an boolean option backup (e.g. backup: true) to make a backup before copied locally before changing.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
Just to clarify, a manual test is all we are looking for.
Yes. If you use language: no, Ansible transforms it to false, and the module fails, saying that false is not a recognized language. If you use language: "no", everything works.
Please test the code to ensure that `no` isn't treated as false
s/./ to avoid infinite hangs waiting for input./
This should really be a `dict` with `suboptions`.
Suggestion: ``The name of the node to be renamed. If I(name) already exists, no action will be performed.`
Oh, ignore this
Not sure what you've done in other modules, though allowing this to take `type=list` maybe nicer
I would prefer to say name. But Iâm ok if you want to stick with this here. Or maybe client_config_name.
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
Don't quote strings when that's not necessary, and add spaces in Jinja variables for readability. ```suggestion msg: TCP port {{ item.port }} by pid {{ item.pid }} violates the whitelist ```
```suggestion RETURN = r''' ```
Add a few more examples of just listing the ports: ```suggestion when: tcp_listen_violations - name: List TCP ports debug: var: ansible_facts.tcp_listen | map(attribute='port') | sort | list - name: List UDP ports debug: var: ansible_facts.udp_listen | map(attribute='port') | sort | list - name: List all ports debug: var: (ansible_facts.tcp_listen + ansible_facts.udp_listen) | map(attribute='port') | unique | sort | list ```
Please remove the "required: false", you only have to add `required: true` if it is required.
Please remove the "required: false", you only have to add `required: true` if it is required.
`check_rc` is false by default, no need to pass.
Please replace with `type: false`
`required: false` is default so you can remove this.
This could be `elif`.
This could be `elif`.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
I wouldn't exactly call a dictionary `list`.
Too long line.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
If this needs to be done in two months we may want to keep this emitting a warnings until then, so that the bugfix versions of Ansible would warn users at least for some time...
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Can you test this on python3 please? I think python3 needs bytes.
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
Someone could have a proxy in front, and if it intercepted a non-200 status code could replace the body with HTML or otherwise.
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
`delete` and `create` are not valid states
Making `name` optional is probably a good idea.
Would it be possible to have this field accept a dict instead of `k=v` string? ```yaml - os_server_metadata: server: vm1 state: absent meta: hostname: '' group: '' ```
be careful with defaults, if this is not "specified" by the user it would get updated to False if it was True before. If we keep this "None" it would be like "keep it as it was before".
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
You should not use `curl` as the alias for `Invoke-WebRequest`. Use the full cmdlet name to avoid confusing people whether it's actually using curl or a PowerShell cmdlet.
Use `to_text(line)` instead.
With the removal of `$?` this shouldn't be needed.
Why a 1 second sleep here, I had this removed in my testing and was fine without it. 1 second is a long time for each command, especially since tasks can execute more than 1.
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
`final_interface = dict((k,str(v)) for k,v in final_interface.iteritems())` seems to be required here since the values from new_interface may contain non-strings while the values returned by the API are always strings. With this added line, the module becomes idempotent with passive proxies.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
I completely missed that, apologies
Am I correct that we've still got no tie-in with the advanced 3-way merge logic currently baked into the kubectl/oc client binaries? That functionality seems so important for Ansible, and rumored to head for the API server soon but still may be a few releases out.
Do we still need kind? For service I think it should always be v1
Ah yes sorry, ~~prefix~~ suffix
I think we need more info here what are possible choices.
Should match the variable registered in the preceding task. ```suggestion spot_price: "{{ spot_prices.ec2_spot_pricing_history.0.spot_price }}" ```
Wrong module name. ```suggestion - ec2_spot_pricing_history_info: ```
spec is also returned
This needs exception handling.
Since all of these appear to be constants, it seems to me that making them tuples instead of lists would be good to avoid accidentally modifying them.
This one *might* not be redundant, if it's possible to make changes that will cause the CDN endpoint hostname to change...
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
`Only application to an endpoint of I(type) C(nested_endpoints).
Also import to_bytes (So we can use it below)
We should disable pylint's check for this one line rather than doing this. doing this defeats part of the purpose of having a compatibility library.
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
Please ensure all the descriptions are full sentences (capital letters & full stops)
`This module can be used to manage object permissions on the given host.`
I think I'd handle purge_listeners at the consumer end of this method. Just seems easier than passing it in and handling it here. But not a blocker
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
`ip_range=dict(default='0.0.0.0/0', type=lambda x: to_text(ip_network(to_text(x)))),` could be used in `argument_spec` instead of this method: * inner `to_text` required because `ip_network` requires unicode in input * outer `to_text` required because `module_utils` [doesn't handle parameter which aren't basic type](https://github.com/ansible/ansible/blob/83ec4184701f77d4de68d0c52946fd80a13fbe0a/lib/ansible/module_utils/basic.py#L504) (except `datetime`) (`to_text` comes from `from ansible.module_utils._text import to_text`)
Most modules using public cloud providers offer a `validate_certs`/`validate` option[1][2]. I think the same apply here. [1] https://docs.ansible.com/ansible/latest/modules/ec2_snapshot_facts_module.html#ec2-snapshot-facts-module [2] https://docs.ansible.com/ansible/latest/modules/os_volume_snapshot_module.html#os-volume-snapshot-module
It doesn't make sense to use `id` parameter with `state=present`. Currently when `state=present` is used and `id` is specified, a new IP with another `id` is created.
May be the name is not correct. This won't create a server.
`organization` parameter is required
Use literals rather than constructors: ```suggestion argument_spec={ 'executable': {'type': 'str', 'default': 'podman'}, 'name': {'type': 'list', 'elements': 'str'}, }, ```
@felixfontein > elements can be used for every type: 'list' parameter. I didn't know that. I've only ever seen this used for suboptions. I didn't know we handled it anywhere else. Now I know. ð
That used to be the case, but it changed somewhen this year (IIRC). I searched a bit, here's the PR which implemented validation: #50335
> What's the point of `'elements': 'str'` in this parameter? This is only used for sub options. This appears to be regular list parameter. `elements` can be used for every `type: 'list'` parameter. In this case, Ansible will make sure that the list contains strings (and not booleans, numbers, lists, dictionaries, ...).
What's the point of `'elements': 'str'` in this parameter? This is only used for sub options. This appears to be regular list parameter.
Make pep8 happy ```suggestion priv, append_privs, module) ```
```suggestion changed, msg = user_mod(cursor, user, host, host_all, None, encrypted, plugin, plugin_hash_string, plugin_auth_string, ```
Looks like we got an extra 3 backticks :( ```suggestion cursor.execute("SELECT plugin, authentication_string FROM mysql.user WHERE user = %s AND host = %s", (user, host)) ```
just return pm.encrypt(password, user) != current_role_attrs['rolpassword']:
just return password != current_role_attrs['rolpassword']
we want want -> we want
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
I completely missed that, apologies
Am I correct that we've still got no tie-in with the advanced 3-way merge logic currently baked into the kubectl/oc client binaries? That functionality seems so important for Ansible, and rumored to head for the API server soon but still may be a few releases out.
Do we still need kind? For service I think it should always be v1
Just noting that this RETURN is incomplete
This line of code is not required, you can modify your condition @ line 293 as "prior_event.get('reason') == reason"
Sorry, I think we had a misunderstanding when we talked earlier. I don't think we should be raising unless we add more exceptions so that we can tell why an exception occurred (right now, we'd have to catch the AnsibleError and then parse the message to tell why we failed.) raise_on_error is bad API. The API should either raise whenever there is an error or let the caller discriminate. Passing in a flag to tell the function to raise isn't meaningful. If we start raising an error, then we have to audit the code and decide what the failure case means in the present code. If the code doesn't depend on it (or works in some scenarios) then we probably have to replicate that behaviour instead of changing to always failing.
The thing is that you are removing an existing feature, not simplifying anything, nothing FORCES modules to use this, many don't, that is why we ALSO supply remote_tmp (though that value is not always usable depending on become and other circumstances). Many modules don't use either value and opt to handle it completely on their own. But those that do use it, rely on this behaviour and making this change won't 'break' things in a way that alerts anyone, it will start leaving dangling temp files or attempt to create them in an unexpected directory. Which IMHO is worse, since it is a 'silent break'.
that still happens no matter what info you pass to the module ... unsure how removing this info for the module to CHOOSE to share the dir is a simplification. Speaking of the end user, we CAN show them the tempdir being used since that info is available on the controller, but not when the module itself generates it (and many do).
I don't see how this is a simplification, we just give modules the information about the dir the controller would have used, but it doesn't force the module to do anything. While this change will alter the behaviour of existing modules that rely on it.
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
If we do go with this approach, I feel like `VMDB_PATH` should be user-configurable
You probably should just exit here with `changed=False`
This should be configurable in the module arguments.
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
For the new added facts, we suggests no `raw`
instead of example now we need proper description of returned values, please check facts modules like azure_rm_webapp_facts or azure_rm_containerregistry_facts as a reference
remove the register line, kind of confused
here we can just use "image" instead of GalleryImage
Please remove your confidential information in PR
All `description` should be full sentences, capital letters & full stops.
I think `required: true` is missing from `neighbors`
Yup, add that in the `description`.
Yup, add that in the `description`.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
```suggestion required: true type: str ```
I think you should either use `pid` or `PID` everywhere. Whether you prefer `PID` or `pid` is something you have to decide :)
This debug needs to be updated for a few things: 1. Use full YAML syntax, not `key=value` 1. `.pid` should be `.pids` 1. Instead of `','.join` please use the `|join` jinja filter.
add sample of pids like ```yaml sample: [ 10101, 12011 ] ```
sys is unused import
This will fail if `self.accounts_uri` is not initialized.
Useless loop that can be merged with the next one.
Not catching non-200 responses.
Not catching non-200 responses.
Will fail if `self.systems_uri` is not set yet.
This is useless, state can only be "absent" or "present".
I don't see the point of this.
It's better to have a single definition of this list and use it both for parameters and here.
Some wrapper modules are very light on this, and escalate the stderr output of the command to the user. I guess it depends on the complexity of the tooling and the possible impact of incorrect input. Is there a big risk of data-loss or data-corruption, then you may want to be more safe. Also if there's a big chance that valid options change more often, you may not want to restrict your module. But this is all mostly up to the maintainer. There's also a real concern related to supporting older/newer versions of the same tool too.
If it is not required, you don't have to add `'required: False`.
...The remote host **MUST** support...
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please add `type: bool`.
Ansible 2.7 dropped support for Py2.6
Presumably you want `It *will* always use`, or something to the effect
Are you sure this is OK ? Have a look at: https://github.com/ansible/ansible/pull/33315
`if expect_disk_spec.get('autoselect_datastore', False):`
Also, if the disk already exist, 'autoselect_datastore' shouldn't modify the disk.
add ``` datastore = None ```
You forget to make the change.
```suggestion - Note that to use dedicated tenancy you MUST specify a I(vpc_subnet_id) as well. ```
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
spec is also returned
Unless I'm missing something, this doesn't provide feature parity with the existing inventory script around tag groups. In my playing around, I wasn't able to get `tag_[key]_[value]` groups to generate with any of these by just specifying the tag (eg, group all instances by the Name tag)- I always just get tag_[key] groups. Not sure if it's a shortcoming of the boto filter stuff that we need to paper over, or just something I'm missing, but we'll definitely need to support the existing functionality (if not generating the exact same group names- that part's arguable).
Yep, that's how ec2.py works by default if you include tags, so I'd assume *someone* will want that behavior in the new script.
please use here self.param('version').get('base_template')
please use here `self.param('version')`
and please add space after `)`
this should be just: ``` numa_node_pins=[ otypes.NumaNodePin( index=numa_node.get('numa_node_pin') ) ] ``` In API it's designed as list, so shouldn't it be `numa_node_pins`? And something like: ```python numa_node_pins=[ otypes.NumaNodePin( index=pin ) for pin in numa_node.get('numa_node_pin') ] if numa_node.get('numa_node_pin') is not None else None, ```
```python otypes.Core(index=core) for core in numa_node.get('cores') ```
We can't do this, as this is break bacward compatibility.
"Netmask in case ..." -> "Subnet mask in case ..."
following task -> the following task
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
note, this is not a blocker but you can use a generator expression here instead of a list comprehension. it could save on some system calls (calling os.path.exists) but I doubt that will be a noticable optimization so it's really just style.
There is no need to make an api call just for checking that the zone exists. The ovh python package raise a ResourceNotFoundError that can be caught in the next api call to check if the zone exists.
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
the module in general is just a thin api wrapper, not really that useful for users, I'm not against having an 'expert mode' but this is in addition to actual options usage.
cacertpath should be cacert_path
For conciseness of the examples, maybe should we keep only 1 example with multiple option enabled / shown. I'd keep only your example
```suggestion target: /tmp/dump.sql ``` Adding an extra variable in the example may mislead the reader on how to use the module
```suggestion - name: Dump multiple databases ```
```suggestion name: db_1,db_2 ```
```suggestion - List of tables in the publication at the end of runtime. ```
`state`: a `choice` parameter should be used ([example](https://github.com/ansible/ansible/blob/6cdf91fd35fefec35dca4594db231cc6af5a8620/lib/ansible/modules/system/capabilities.py#L167))
`memlimit` and `memswaplimit`: allowed units could be mentioned.
`read_config_from_file` could return the content of the file or `None` if the file doesn't exist (instead of a tuple).
Don't use `except` without exception type ([ref1](https://docs.python.org/2/howto/doanddont.html#except), [ref2](https://docs.quantifiedcode.com/python-anti-patterns/correctness/no_exception_type_specified.html)). Here checking file existence could replace `try/except`.
What if the first line is missing ? The file might not have been created by this module.
Do not use print statement. All module output is supposed to be returned as JSON.
use `isinstance(obj, type)`
missing import `from ansible.module_utils._text import to_native`
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
```suggestion def _post_request(self): ```
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
If the result was a 4xx or 5xx then I think this fails.
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
The `options:` entry appears to be responsible for the `ansible-doc` failure.
Please also add whether filters that are listed in separate list items are an `OR` or an `AND`
You can use get_option() instead of accessing the dict directly.
The inventory still needs to be populated with the results from the cache. The cache plugins themselves get/set data, but do not use it.
That is largely the goal of that function. The file must still be named in a way that ends with `vmware.yaml` or `vmware.yml`. All of the plugins implement this mechanism and check for a namespaced filename. The `auto` plugin checks that they end with `yaml` or `yml`, the individual plugins implement more specific checks. I didn't write the behavior, so I cannot speak really more to it. @s-hertel might be able to provide more insight.
not sure why you are splitting a base class, this should not be geared for others subclassing the base from the plugin itself, if you really want a base class it should be moved to live with the others.
`kubectl` is a valid connection plugin, without looking into the code further I assume that's being used as the transport backend in that inventory plugin. https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/kubectl.py
you should probably put these check even before `super()` line
this produces an exception when binary cannot be found, you should capture and return parser error
This applies to a few places.
`This should be your GitHub ID, `author: "Anil Kumar Muraleedharan (@amuraleedhar)
Doesn't seem to have been done
Thanks, if you push those changes I can re-review
You can use `C(...)` for values, i.e. `C(all), C(hardware), C(config), and C(interfaces).`
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
You seem to have gone through the process of making this class a context manager, but don't use it as a context manager.
How is that? ``` self._arg_spec_filename = "FortiosAPIArgSpecs.json" ``` That defines the path to that filename as relative, which will be relative to the executing script. modules are executed in a temp dir that is then deleted, so this file should be deleted. If the file is kept around, I would be concerned with that. This is force creating a cache file without telling the user you are doing it, or giving them a way to opt out. The default should be no cache, and a user must opt-in, should this feature really need to exist.
Currently this file is created in the folder that you are running the playbook from. I can make the opt-in feature.
It's just an example. I just want it to be less scary.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Tell people where we are looking `CONFIG_FILES`
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
s/does not do anything/has no effect/
s/./ to avoid infinite hangs waiting for input./
ah, now I see why, but still, would prefer `command` to be required.
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
+1 to `psexec_command` just for clarity...
You can remove this since it's handled in module_utils/aws/core.py: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/aws/core.py#L98-L100
What is the reason for reordering all these parameters? This breaks `blame` attribution for these lines & doesn't improve the code.
Not tested, though this may lead to a similar issue as https://github.com/ansible/ansible/issues/20391 due to `timeout` having a default value
This condition can be removed
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
recommend renaming to `config` with alias to `running_config` for consistency
Please use two blank lines between functions (we are working toward pep8)
unless you need these arguments for other modules, i would highly recommend moving them directly into dnos10_config.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
I think this should be false (not a string)
No need to specify `choices`
Please remove this line.
Please remove this line.
Please remove this line.
Would be good to also see usage other than ceph.
we normally prefer to use the same tmp directory as the modules themselves are put into
finding it when not using pipeline is normally `dirname(__file__)` as module itself is located there.. but as discussed, need to create generic and then revisit modules doing this
not a requirement, but would be nice to validate all IDs before returning an error (in case more than one is wrong)
Either use `result['changed'] = ` and remove the `changed =` OR use `changed =` and remove the `result['changed']` but do not use both. That applies to all `main()` function.
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
specifying `type='int'` removes the need for this, so you only need to check the range.
vmware_host_config_facts â vmware_host_ntp
vmware_host_config_facts â vmware_host_ntp
vmware_host_config_facts â vmware_host_ntp
"state" is required or you should set a default.
As I understand it, this module isn't about gathering facts.
aws_ip_ranges -> aws_service_ip_ranges
```suggestion - David Taylor (@djtaylor) ```
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion version_added: "2.8" ```
```suggestion Supports the querying and modification of the link-level attributes of interfaces such as ```
This should be a list, not a dictionary. The dictionary key is just an incrementing index value, which is what a list is for. Having it as a dictionary just makes it harder to use (having to deal with an index generator, and dictionaries don't guarantee order).
@phemmer , We've discussed this in the weekly Ansible VMware meeting. In my opinion, having a dict is useful, IF the key is useful: * The reason to have facts is to use them in a task later on * With a list, to find the proper disk, it is harder to find the item you want to match on ( `{{ (disks | selectattr('label', 'search', 'Hard disk 1') | list | first) }}` for instance) * With a dict, if the key is useful, it doesn't require that. If you want to match on another criteria, the loop is still a possibility. Proposal is to have the label as the dict key as it is what is visible in vCenter and is orderable, does that make sense to you? Any other criteria you might find easier? (disk.key is another possibility, but less 'visible' in vCenter)
Wouldn't this end up returning `changed=200` to callers? Usually we keep this a boolean.
`datastore.name` requires access to the datastore itself, and thus might throw a permission error. This value should be wrapped in a try/except.
Also describe if it deletes the files or not
Not required, we already have method called `connect_to_api`. Also, I would recommend to use `from ansible.module_utils.vmware import PyVmomi` which base class for all VMware_* modules.
Not required as we can use connect_to_api method.
Remove redundant import
Add this at top after License. See example above.
```suggestion if self.state == "present": ```
Make this: ```yaml type: bool default: 'no' ```
Note: you can do it like this instead: ``` self.gpg = self.module.get_bin_path('gpg') if not self.gpg: self.gpg = self.module.get_bin_path('gpg2', required=True) ``` Saves a little bit of typing.
Would you please change this to type str with choices `[disable, enable]`? This would make bfd type consistent across all the modules.
```suggestion zabbix_user_info: ```
```suggestion - When used on earlier versions of HAProxy, it will be ignored. ```
`import_role` supports those keywords, but for inheritance, for include it applies to the task itself, the original phrasing was more accurate
`until:` is the proper keyword for those loops
These lines should probably be moved to `notes:` and not just deleted.
Please revise to "This is a feature of the Ansible Engine, rather than a module, and cannot be overridden like a module."
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
Add this to different PR.
```suggestion - The repository name. ```
```suggestion - The repository name. ```
You may be able to simplify this buy using the helper functions `required_one_of` `mutually_exclusive` `required_together` Have a look at existing modules for examples
Is reversing the order here ( from 'unsub then sub' to 'sub then unsub') going to cause any problems? Thinking about cases where a system/org may be out or almost out of available subs.
result is attempted to be used below, leading to the traceback: ``` The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py", line 1411, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py", line 1404, in main invocations[module.params.get('command')](module, conn) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py", line 1124, in modify_db_instance resource = await_resource(conn, result, 'available', module) UnboundLocalError: local variable 'result' referenced before assignment fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py\", line 1411, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py\", line 1404, in main\n invocations[module.params.get('command')](module, conn)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_DIc0Gu/ansible_module_rds.py\", line 1124, in modify_db_instance\n resource = await_resource(conn, result, 'available', module)\nUnboundLocalError: local variable 'result' referenced before assignment\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ******************************************************************************* localhost : ok=0 changed=0 unreachable=0 failed=1 ```
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
This doesn't support aurora snapshots. Besides that, this looks great.
It would be nice if the current tags were added to the response.
This should go in a facts module instead.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
correct, in any case i would advise using the open_url function that Ansible provides as it deals with many issues that httplib/urllib don't (versions, proxy, ssl, etc) and I would add a couple of options to allow users to deal with custom setups (validate_certs, etc).
Would be good to also see usage other than ceph.
The docs page you linked says it doesn't have to be in that format.
Might want to check `rc` status before return output.
Sorry, my bad. I didn't see the implementation of `_run`.
Please add types to every parameter in the argspec. So if you did not add it, it most likely should be: `type='str'`.
This should be enforced by the argument_spec, not sure how this would happen.
yes, this was 'old' way when they were not real imports, now they can be moved to top of file and used like normal python imports.
I think one should only import from `ansible.module_utils.basic` what's needed (e.g. `AnsibleModule`)
When failing, please include the traceback with the `exception` keyword arg to fail_json. `exception=traceback.format_exc()` so people know where the failure came from.
you could add supports_check_mode=True to AnsibleModule
probably? ```suggestion - Number of lost heartbeats to signal a failure (1 - 60). Increase to reduce false positives. ```
```suggestion - Time between sending heartbeat packets (1 - 20 (100*ms)). Increase to reduce false positives. ```
```suggestion - Cluster group ID (0 - 255). Must be the same for all members. ```
Default value not specified in argspec.
Default value not specified in argspec.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is not` vs `!=`? I may not be polished enough on my python...
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
Please add `type: bool`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
Mea culpa. I told them to take the defaults out for brevity. I'll keep your preference in mind in the future.
I prefer explicit types for all the parameters (unless they are multi-type parameters)
@dagwieers @s-hertel The default **is** str. It changed (from what is now type=raw) a while ago, maybe 2.0 or 2.1. One of the major drivers for the change was that while yaml has types, k=v parsing does not. things like ports and timeouts were then getting to the modules as ints if they were specificed via yaml or strings if they were specified via k=v parsing. There are a few parameters in a few modules (for instance, the infamous file mode parameter) which use type=raw so that the module can accept different types of values for the parameter. We try not to use that in modules if we can get away with it but there are a few places where it's needed.
@abadger I wasn't aware. I wonder why some of the modules with no type seem to work as if they have type='raw', and fix those. Sorry for the noise, case closed. PS Still I prefer to have the type written out for every argiment. It is the only option for arguments I think should be explicitly mentioned always.
type='str' is the default so I think you can remove those.
Can `_state_*` be changed to the class methods as it invokes methods from within the class? I don't see a reason to have these methods as `staticmethod`
`commands` should always be a list.
I think it is better to pass module as argument to build_xml() and handle lxml install check-in module_utils instead of having it in each module
Write a method to generate final diff so it can be used anywhere in the code when required.
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
Could dedent here if `else:` removed.
(but in case of function arg, you don't need additional braces)
You don't need to escape EOL. Just have two strings and Python will automatically know that it's in fact one string: this ```python ( "series " "of" " words" ) ``` equals ```python "series of words" ```
I think you could go for `elif:` here.
or entirely omit `else:` since it would fail in case of `if` part.
Because this is in a module_utils file that could be run on python2.4 we need to use the helper functions from six for this: ``` python from ansible.module_utils.six import b [...] os.write(tmp-fd, b('\n')) ```
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
Sure, a separate PR sounds good.
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
Typically I keep module options with `C` and only use `I` when referring to just the option name.
No really necessary but if you want to keep it I would capitalise it and add a full stop.
```suggestion to iterate use a C(with_) directive. ```
This wil fail, as there are 2 actions in the same task.
We expect all imports to happen at the start of the module. If it is possible this will fail because e.g. ucsmsdk is missing, then you add it as part of a try/except block and set HAS_UCSMSDK=True/False, and provide a proper fail_json error if HAS_UCSMSDK is False.
We already have a warnings mechanism in `module_utils.common.warnings` that is consumed on the module side, but we need to implement consuming of these warnings controller side. As such, it's not a completed feature yet.
I think we need to emit a deprecation warning so that it'd be discoverable by users and also the module docstring should be the first AST node in the module: ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ import warnings # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text warnings.warn( 'Importing to_bytes, to_native, to_text from _text ' 'has been deprecated. Please import them from ' 'ansible.module_utils.common.text.converters instead.', DeprecationWarning, stacklevel=2, ) ```
Alright, after seeing the messages on slack I think that adding warnings can wait but still the docstring must be relocated because it was a module docstring originally and we should keep it on the top of the module. ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text ```
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
I think you need `to_native` here.
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
I mean: ``` try: [use connection] finally: connection.close() ```
I mean: the current error isn't reported back (`e` is unused). I just pointed out that `display` is available and could be used to report the error.
still: https://github.com/ansible/ansible/pull/44070#discussion_r212981844 https://github.com/ansible/ansible/pull/44070#discussion_r213508181
There still are some references to `ampq`
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
Example fields doesn't match the real fields name (server,user, pass)
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
`required: false` is the default, can be omitted
`default: null/None` is the default, it can be omitted
there is no need to version params for new modules
unnecessary import - defaultdict is not used
unnecessary import - boto is not used in the script
No need for this to be a private method. rename to get_inventory().
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
From the way the docker modules currently operate, it probably makes sense to add a `AnsibleDockerSwarmClient` to `module_utils/docker_swarm.py`, which extends `AnsibleDockerClient`. Then `docker_swarm`, `docker_swarm_facts`, `docker_node` and `docker_node_facts` could use `AnsibleDockerSwarmClient` instead of using `AnsibleDockerClient` directly.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
No need to use quotes. We tend to not quote when it's not needed, as this helps people understand the YAML rules better.
@AlanCoding since most of those deal with 'after' and this is meant to deal with 'before' the signature is not expected to be consistent.
Any logic for handling `changed` should be in `_finish_task` instead of here.
nvmd, had not looked at the called method which already handles skipped coloring
Sounds good! The newest version looks good to me. And it also still works (just re-verified) ;)
Why not keep `C.DISPLAY_SKIPPED_HOSTS`? This breaks backwards compatibility, I think, because now the behavior of callback plugins derived from `default.py` can no longer be changed with the same env variables as the behavior of the default plugin itself.
please add `no_log=True` to avoid leaking the password in the logs.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
please add `no_log=True`
version_added and default value can be dropped as this is new module.
`file_copy` â `copy`.
I'd change this to `Module to copy a file to a VM, fetch a file from a VM and create or delete a directory in the guest OS.`
It people are trying to download a non-exiting file, the execution should fail, because this is unexpected behaviour and should clearly be mentioned.
recurse (boolean): Not required, default (false)
```suggestion pvdiplay_cmd_device_options = [pvdisplay_cmd, device] + pvdisplay_ops ```
```suggestion rc, pv_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pv_size"]) ```
```suggestion rc, pe_start, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pe_start"]) ```
```suggestion rc, vg_extent_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "vg_extent_size"]) ```
Line is too long.
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
For the author information we normally only keep name and GitHub handle.
Here add: ```yaml type: list ```
This is not a correct English sentence. Maybe do: `The DNS can only be...`
This parameter is required if C(cluster_name) is not specified.
``` lversion = get_version(module, lstdout) ``` same with rversion line 211
updatedâuptodate (or up_to_date)
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
Add absent as well.
Should have a default set to `present`.
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
It's not a big deal either way, but since import sanity actually has to run on 2.x, it'd be *nice* if the type hint support was getting exercised there as well. Honestly I don't have strong feelings either way- I'm happy to merge as-is and we can go fix it and turn on remote-side stuff later (or not), or we can wait for Matt C to be back late next week and see what he says. There are also a couple other ways to fix this for 2.x (but a bit gnarlier at the import sites). I suspect that having the blanket ignores present for 2.x's benefit could mask potential problems or missing typeshed stuff in 3.x, so we *might* want to look at the fully-inline options if/when we light this up for 2.x.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
```python if 'name' in self.params and self.params['name']: ```
```suggestion if 'name' in self.params: ```
Yes, `name` is basic parameter, but since we are `here` we can fix this as well.
Then: ``` user_folder = self.params['folder'] slashed_user_folder = user_folder if not slashed_user_folder.startswith('/'): slashed_user_folder = '/' + slashed_user_folder if not slashed_user_folder.endswith('/'): slashed_user_folder += '/' â¦ for vm in vms: â¦ if slashed_user_folder in actual_vm_folder_path: vm_obj = vm break ``` My point/remark/question wasn't about altering `user_folder` but about the `user_desired_path` computation and usage. The important part is that I suggest to replace: ``` if user_desired_path in actual_vm_folder_path: ``` by: ``` if slashed_user_folder in actual_vm_folder_path: ``` Again if you are sure about the user_desired_path computation, that's OK for me.
> For example, user_folder is '/DC0/vm' and actual_vm_folder_path for two VMs with same name is '/DC0/vm/finance' and '/DC0/vm/marketing' and user wants VM with '/DC0/vm/finance' path. So there are chances that user might end up in getting wrong VM if we just use user_folder. I think computation of user_desired_path might decrease this chance. How can you only get the VM in '/DC0/vm/finance' if `user_folder` is '/DC0/vm' ? If `user_folder` is `/DC0/vm` we fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So you get both VM from '/DC0/vm/finance' and '/DC0/vm/marketing'. ################ If you mean to write `/DC0/vm/finance`: If `user_folder` is `/DC0/vm/finance`, we still fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So using `user_desired_path` or `user_folder` is exactly the sameâ¦ I don't get your example.
Somehow this (+ the following line) doesn't work and prevent the module from working.I haven't digged deeper yet,
Can we remplace this line by the following three lines: ``` p = subprocess.Popen(['acme-tiny', '--account-key', self.accountkey, '--csr', self.csr_path, '--acme-dir', self.challenge_path], stdout=subprocess.PIPE) crt = p.communicate()[0] open(self.dest, 'w').write(str(crt)) ```
backupdest isn't defined anywhere
Replace `dest` by `path` to be consistent with the other modules (openssl_privatekey, openssl_publickey, openssl_csr)
Replace `csr` by `csr_path`, also change the type to `path`
I am not in favor of having fromPort and toPort in there. As we use snake_case in Ansible.
Also defaulting to `True` will always override the value, even if it was not specified. This is probably not what we want here.
I wonder if this should be a boolean, or a list of options. My worry is that in the future this gets extended to more than two options, and we're stuck with having it as a boolean.
All configuration values should not include default values, as that leads to accidental overwriting of existing configs that the end user did not expect.
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Technically this will never be `None` because of the defaults.
It might also be no IGWs found here.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
@pierremahot please reuse my snippet to have better correct parser.
Please change this to ```python for current_line, next_line in zip(lines, lines[1:]): ```
I'm not sure why you use exact index slices. Are they always this size? I'd say that it's much safer to do `.split()` and that work with chunks: ```python vlan_id, name, state, interfaces = [v.replace(',', '').strip() for v in current_line.split()] ``` please also note that in python we use so-called `snake_case` for variables, as opposed to `camelCase` (like in java or js)
You can use `module.deprecate` to throw a deprecation warning.
Same question for dropping lambda here as well.
Please do this for all parameters. ```suggestion - The iptables chain in which to insert the direct_rule, used with the C(direct_rule) option. type: str ```
Must be in Sentence case, and IP needs bee upper case. Also it should mention that the default is to be both ipv4 and ipv6.
Is this required anymore now that it is removed from the module.
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
You can delete this line.
@webknjaz we have no gaurantees that the artifacts are being built from a git checkout.
I think this may read better: ```suggestion if missing_keys: ```
Casting to list isn't needed here ```suggestion elif any(fnmatch.fnmatch(item, pattern) for pattern in ignore_files): ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
No need to quote, we prefer it as a list. ```yaml author: - Daniel SÃ¡nches FÃ¡bregas (@Daniel-Sanchez-Fabregas) ```
Please remove this. If it's not required you don't need to state it, but there's also a default value, so useless :-)
Add or remove are not declarative, but imperative. So I would rather state: Specified whether the computer should be present or absent in Active Directory. Beware that the current description is talking about access rules, which is weird because we are managing computers in AD.
This should become: ```yaml type: bool default: 'yes' ```
Also, it would be better of the description is split up over multiple items. A long blob doesn't make it easier to read. Usually the first item is the "meaning", and subsequent items detail what happens in different cases, explain options, specify the format or add one or more notes.
Also describe if it deletes the files or not
I understand what you're trying to do here, but managing both parent as child objects in a single module is going to be problematic IMO. This can only work if your childs are always fully listed (and replaced/updated).
Would add a note saying this does not deal with disk initialization and file system formatting.
call this just cluster, identical to the param we pass. Fixes inconsistency with other modules.
call this just pod, identical to the param we pass. Fixes inconsistency with other modules.
```suggestion import atexit import traceback ``` Please import `atexit` module
example should be removed.
```suggestion - List of user aliases to add in the group ```
@rubentsirunyan thanks a lot for taking a look at this! :)
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
please wrap in block ``` if __name__ == '__main__': main() ```
`type='int'` You can then remove your code to check that this is an int.
Awesome. This is much better now.
Are you only doing this to support Python 2.6? Those keys are already unique.
I'd do ```suggestion if not ignore_errors: raise ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
Use `self.assertEqual(d, d)` instead of `self.assertTrue(d == d)`.
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
Well you don't need the `if`, you can just run `.replace()` and it'll do the right thing regardless of whether there's a slash in the string.
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
This is also not needed, idem for all other parameters.
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
+1 to `psexec_command` just for clarity...
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
ah, now I see why, but still, would prefer `command` to be required.
don't forget to remove if you change default
s/does not do anything/has no effect/
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
need to separate ClientError and ParamValidationError as the latter doesn't have an e.response object. Both exceptions should have `exception=traceback.format_exc()` (you'll need to `import traceback` at the top)
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
`required=False` is the default, and thus not required
Please import only what you need, rather than `*`.
'Use "sudo pip install --upgrade avisdk" to install Avi SDK'
You've specified the default here and in `argument_specs` which doesn't seem right
you really dont need 2 datas here, a type='json' will take both a data structure or json doc
It would be good to combine these before the module gets released to avoid changing the module interface after release.
Ansible best practice is to specify `-name:`. This allows people to copy and paste the examples to use in their own playbooks. Therefore it's clearer to write this as: ``` - name: Get Pool Information using avi_api_session avi_api_session: controller: "{{ controller }}" ... ``` This applies all examples.
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
New unit test files should use `pytest` style tests instead of `unittest`.
These probably belong in the same section ```suggestion ```
After looking at this more closely I realized that boto3 does use local time here instead of UTC. However, boto3 is using `dateutil` instead of `tzlocal`. So this will work without any additional requirements: ```python import dateutil.tz value = datetime.datetime(2019, 4, 4, 11, 41, 0, 878000, tzinfo=dateutil.tz.tz.tzlocal()) ```
This should have a try/except around it as well, since `dateutil.tz` isn't in the standard library.
Net new tests should be "pytest style tests" rather than "unittest style tests".
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
Is this always avaliable? If not, try ```suggestion tags = self.node_attrs['Driver'].get('Tags') or '' ```
also, they are the ones that CREATE the ansible_env the use
this list can get long .. meta? include_role/include_tasks? .. sometimes 'include' ... shoudl really only affect initial fact gathering
The subset type has to be of type `frozenset` as the `minimal_gather_subset` is of type frozenset `runable_subsets = self.gen_runable(legacy_facts_type, frozenset(fact_legacy_obj_map.keys())`
This should be ` facts['gather_subset'] = list(runable_subsets)`
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
It would be nice to see the same msg in exit_json.
Move this to line 175
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
This should be `else`, looks like the logic got inverted accidentally.
`get_object` will get the full item (including the body) - instead I think we should use `head_object` here as it'll still give back the etag without getting the full item. http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.head_object To test this, you could make a 1-2GB object and then try this codepath. It should take a long time, and consume 1-2GB of memory.
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
This is not needed for parameters that are not required. Guideline dictates to leave it out.
Would it be possible to have this field accept a dict instead of `k=v` string? ```yaml - os_server_metadata: server: vm1 state: absent meta: hostname: '' group: '' ```
space looks unnecessary
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
I prefer a second (and perhaps even third) `from ansible.module_utils.ec2 import` line to a line continuation (brackets also work, but are subjectively less elegant). Not a blocker though
Good point :)
We don't need to pass tags here.
Missing period at end.
@kaneda-fr its a direct network. is there anything in particular you'd like me to pull for you in the config. i will warn you, i'm very new to VCD and pyvcloud so this is me trying to get to where i'm not just using the gui all the time. I did not set this up, it was already configured. are you in the irc channel? if so i am xaeth
This is probably just me but I had a hard time parsing that. I would change `notify_scope != 'per_loop_item'` into `notify_scope == 'task'` and put it all on the one or two lines maybe. Not a blocker, of course.
This doesn't account for invalid values. I'm wondering if this would be better as a boolean value rather than a string field. Something like `notify_per_item` with a default of `False`. Are there other values for this option that would make it better suited to a string than a boolean? If we do keep it as a string value, maybe the options could be `task, item` or `task, per_item`. Just throwing out ideas.
This is easier to read: ```python if self._task.notify is not None: if notify_per_loop_item: if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ``` Or using the existing string option: ```python if self._task.notify is not None: if notify_scope not in ['task', 'per_loop_item']: raise AnsibleError("Invalid option '{0}' given for notify_scope. Valid options are " "'task' or 'per_loop_item'".format(to_text(notify_scope))) elif notify_scope == 'per_loop_item': if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ```
The way we have done this before is via something like `_validate_debugger`. That method effectively does this, but for `debugger`
Nice. So I'd go with `_validate_$whatever_name_we_bikeshed` method to check for invalid values. Unless we decide to use a boolean.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
This should be: ```python if state == 'present': ```
It's better to have a single definition of this list and use it both for parameters and here.
If it is not required, you don't have to add `'required: False`.
Discussed in slack. We can use to_text(e).index('str') and to_text(e).index('tuple') to find where in the error message's string, the types occur. And then use that to decide which is the string and should be sorted after the other one. (The message changed between pyhton-3.5 and python-3.6 for those who are looking at this at home)
I think instead of comparing chunks like this, it might be better to sort the lists of policies first, following a heirarchy like: - SID - Effect - JSON-sort-key-dumped Action
Use the helper function in module utils for comparison. See AWS guidelines for details.
This example isn't a valid IAM policy, because statement IDs must be unique per-policy http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Sid
Add here that the `key_alias` or `key_arn` are both ways to provide it.
```suggestion version_added: '2.8' ``` This is a required fix as it states the first version this module ships with.
```suggestion short_description: Modify AIX stanza files ```
```suggestion type: str choices: [ absent, present ] ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion mode: '0644' ```
```suggestion - vmtx templates feature is introduced in vSphere 67U1 and APIs for clone template from content library in 67U2. ```
```suggestion - The content library description. ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion - If set to C(present) and library exists, then library is updated. ```
If we use `self.api_client` then this API will look like - ```suggestion self.datacenter_id = self.get_datacenter_by_name(datacenter_name=self.datacenter) ```
can be ignored
hm maybe that's what I've searched for
can be ignored
This logic seems ignore the use case of removing all tags.
Same order, type first.
Also, for check more to work properly, you have to put ``` fetch = create(session, collection(session), [200]) fetch = response_to_hash(module, fetch.get('vpc')) ``` below into an `if:`.
Please remove the `else: changed = False`. That doesn't make sense. Instead, de-indent the `changed = True` above. Once `are_dicts_different(expect, current_state)` is `True`, `changed` should be set to `True` no matter if check mode is active or not.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Please do imports globally
Instead of global exception, catch JSON errors and requests errors separately, as this block will apply to both.
Put the object creation out of this function in the `main` to be more readable. Then only pass the gitlab object to your function.
It's seems that this statement is useless ```diff - existing_variables = this_gitlab.list_all_project_variables() ```
Should be interesting to return data to the user, like variables `added`, `updated`, `removed
Authentication should be handled here and not inside of the class
Please follow best practice for this fail message ```python if not HAS_GITLAB_PACKAGE: module.fail_json(msg=missing_required_lib("python-gitlab"), exception=GITLAB_IMP_ERR) ```
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I'd also include a check for server errors (500)
If the result was a 4xx or 5xx then I think this fails.
```suggestion def _post_request(self): ```
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
```suggestion - name: Install python package using a proxy # Pip doesn't use the standard environment variables, please use the CAPITALIZED ones below ```
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
```suggestion aliases: ['login'] ```
+1 for this.
Add a sample dict returned by module.
Please add the following line directly below `required: false` `version_added: "2.3"`
I feel like 300 seconds is a long time to wait. Most droplets are created within 120 second range.
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
Looks like `monitoring:` has been added.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
You should raise `AnsibleOptionsError` instead of `ValueError`. Additionally, drop the `ansible-playbook: error: --` and maybe reword to be "Limit requires a non-zero length string"
Instead of indenting these lines to align with `hasattr` indent them 1 full indentation further than the next line. ``` if hasattr(self.options, 'subset') and \ self.options.subset != C.DEFAULT_SUBSET and \ isinstance(self.options.subset, string_types) and \ len(self.options.subset) == 0: raise ... ```
I would reverse order and have parse_kv go first, since it will also still be the most common usage, also the current detection will create many issues, we have used it before (still do for safe_eval). Use a try/fail approach on parse_kv to try yaml parsing afterwards and error out if all fail the module_require_args check should not be limted to kv, but also force skip yaml attempt
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
this func takes and returns single dict, not array of dicts.
"the relevant" not clear enough IMHO. something like "the type of the resource to which the profile should be [un]assigned" ? same for `resource_name` below.
now in utils, can drop from here.
If you like to replace `None` with `[]`, it sugguest to change it to `response.get('resources') or [] `. The difference is, currently with this code, `[]` will only returned if there is no `resources` key in `response`
Booleans should be checked using is instead of ==. ```suggestion if ci is True: ```
```suggestion if ci: ```
```suggestion npm.ci_install() ```
Should this be updated to elif when using ci mode? ```suggestion elif state == 'present': ```
``` python duplex = get_file_content(os.path.join(path, 'duplex')) if duplex is not None: interfaces[device]['duplex'] = duplex ``` get_file_content() will do a os.path.exists(), so no need to do it before the call to get_file_content
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
```suggestion - name: list hooks for a repository on GitHub enterprise (token auth) github_webhook_facts: ```
Bare `except:` is very rarely (if ever) what should be used. In this case, it means a `ctrl-c` will be caught and Ansible will keep going. I suggest using something more specific (at least `Exception`, which won't catch `ctrl-c`).
`_get_fs_size` method need to be modified in order to handle `pvdisplay` tools. It would be better to use a method instead of a string for the `fsinfo` value.
yes, type=raw will avoid type enforcement, but it is not normally a good interface
so the 'is' will only work with boolean values so you cannot set a jobs = 5 nor jobs = '', the original was not completely correct either: ``` if p[flag]: args.append(arg + to_native(p[flag]) ``` ^ this should work for all cases .. except 0 values
use to_native (module_utils._text) instead of str, it deals with py2/py3 compatiblity
At the point it is 'clear' i'm fine with either way, i am not going to force a style unless the code need de-obfuscation.
May want to use the configparser in 'ansible.compat.six.moves.configparser' here. Otherwise there are py2/py3 compat issues.
contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionRqstError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.LoginError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionError' imported but unused None of those imports appear to be used.
Missing full stop.
Missing full stop.
Please remove `required: false`
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion - The content library description. ```
```suggestion - The name of content library to manage. ```
```suggestion - content library id for which details needs to be fetched. ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
get_exception() is deprecated as Ansible does not support Python 2.4 version.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
Add absent as well.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion url = "/".join([base_url, index_set_id]) ```
New modules shouldn't have aliases, plus the alias seems to be wrong as this is the name of the storage account instance.
default: null doesn't need to be set and can be omitted
One thing we are trying to do with the Azure facts modules is to return both a curated and raw/api structure as specified by a `format` option. We want to favour the `curated` values and set that as the default output which means they need to be in place before we merge the module. The curated option is designed to flatten and make the return values from Azure a lot easier to view and access in Ansible.
You should fail here with `self.fail`. Currently you'll have `account_keys` as undefined if this exception is thrown.
That's fair enough, the code should be split out into a generic function so it can be used by other modules. There is nothing AWS specific about the camel_dict_to_snake_dict and the reverse function, it was only used there because on AWS had a need for it.
This is still needed.
Hmmm... okay. None is an implementation detail, though. So what we probably want is if we aren't given a remote_tmp either, then we should create a tmpdir in the system tempdir, store that in self._tmpdir and return it from this function.
Yes. That's the expectation if self._tmpdir is set to None when this property is accessed.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
Should also have trailing dot :-/
Should also have trailing dot :-/
You should probably mention in the module's description that it currently doesn't support upgrading plugins.
One question is whether `enable` includes `present` or not. There are two philosophies: either `enabled` and `disabled` assume that the plugin is installed, or they install the plugin if it isn't installed. You're currently following the first one. I don't care what you want to do in the end, I just want to mention this in case you didn't knew/thought about the second.
I'm not sure whether upgrade should be another state, or a flag (in the latter case, it's orthogonal to `present`/`enable`/`disable`).
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
This should be a @staticmethod and self removed.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Make this a regular function
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
```suggestion - You can not change the I(group) for a pre-existing group ```
```suggestion the I(group_id) parameter. ```
```suggestion - Removing aliases from an interface is not currently supported. ```
```suggestion - Note, when the interface changes namespace it loses ```
```suggestion into namespace I(netns). ```
Not needed with AnsibleAWSModule
you might want to call vault = self.exists(self.name) immediately after `create_vault`. Otherwise you are not returning what you say you are when creating a new vault.
You should handle BotoCoreError here instead of NoCredentialsError: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws Same applies for all of the following exception handling. BotoCoreError and ClientError together should suffice.
You need a paginator here still.
You're importing ClientError itself as well as botocore, but still using `except (botocore.exceptions.ClientError, ...` instead of `except (ClientError, ...`. Could remove this import. Or add , BotoCoreError to this too and save some line length in places below.
Just noting that this RETURN is incomplete
I don't know what the opinion of the upstream reviewers will be, but considering this parameter controls a host's inventory hostname and not just `ansible_host`, it might be the case that this should be somehow contained within the standard inventory plugin `inventory_host` parameter.
this is already a requirement for the Ansible controller, you can omit it
is this per connection or global? some options seem like they are overtly indented
This variable is never used in the code.
``` The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1353, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1342, in main create_changed, asg_properties = create_autoscaling_group(connection, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 967, in create_autoscaling_group update_asg(connection, **ag) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_modlib.zip/ansible/module_utils/cloud.py", line 153, in retry_func botocore.exceptions.ParamValidationError: Parameter validation failed: Invalid type for parameter DesiredCapacity, value: None, type: <type 'NoneType'>, valid types: <type 'int'>, <type 'long'> ``` Even though this is prettier, I think we might need to do what you initially did by checking if not None: `desired_capacity = desired_capacity if desired_capacity is not None else as_group['DesiredCapacity']` etc.
This doesn't work as expected, unfortunately. ``` >>> test_dict = {'one': 1, 'two': None} >>> print(test_dict.get('two')) None >>> print(test_dict.get('two', 2)) None >>> print(test_dict.get('three', 3)) 3 ```
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
`required=False` and `default=None` are defaults so you can eliminate them in every case below
Start by not using `\` and use proper indent
Please don't use `\`, there are better ways
Please don't use `\`, there are better ways Also use proper indent
Please don't use `\`, there are better ways
missing import `from ansible.module_utils._text import to_native`
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
space looks unnecessary
When required is false, it can be left out (since it is the default).
This seems to be a leftover, there is no state "updated" anywhere else in the code.
So by default Ansible modules use the system-configured proxy settings, unless you set **use_proxy** to **no**.
I'd rather have the standard behavior from other modules, which is to specify **use_ssl**. Check **uri** module.
I would expect a proper default here, probably `default: 'yes'`
So we have a default way of doing proxies. Normally it picks up the system settings, unless **use_proxy** is set to 'no'. The format of this parameter is best kept in line with other modules for simplicity.
The standard parameter for this is **use_ssl*, please change this.
*That said, I always preferred yes/no myself from a linguistic perspective. If we prefer a more human readable format, using true/false is less helpful (especially for non-native speakers or with negative key names). Using yes/no feels a lot more natural. But YAML 1.2 reduced boolean values to a minimum.*
@dagwieers Thanks for that information. I'm also a fan of `yes` and `no` for bools. I had heard that YAML 1.2 was moving away from `yes` and `no`, but I didn't know they were moving to lowercase `true` and `false`. I really don't like that, but it makes sense since YAML is a subset of JSON. Anyway, thank you for the detailed information. Now I need to go update all my roles. ð
Hi, can we please avoid having this discussions on PRs. A separate issues under github.com/ansible/community should be raised for coding style discussions. Our coding guidelines is what's enforced by CI, anything else doesn't matter in the great scheme of things as long as: * It's consistent (within module & related module) * It's readable @ribeiroit as long as what you uses is consistent with the rest of the module it's fine, apologies for the off topic discussion here.
Change `selinux` to `SELinux`. Explain this option a bit more, and when you may want to use it. You can use some of the language from the PR summary.
Same as `seboolean.py` module: add more information about this parameter.
This could be less nested once you apply `choices`.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
`check_rc` is false by default, no need to pass.
Please replace with `type: false`
`required: false` is default so you can remove this.
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
Examples need update to reflect rename
Little :bug: : In **check** mode, the `keycloak_realm` always returns `result['changed']: True` You need to add something like `result['changed'] = (before_realm != updated_realm)` here...
ditto `s/client/realm` :wink:
ditto `s/client/realm` :wink:
copy-paste issue: we should talk about **realm** object here, not a _client_. To be globally replaced in this file...
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
@nerzhul this 'feature' predates the RFC that introduced SRV and was used as a 'cheap' load balancing trick
i really don't like a such crap in DNS nsupdate should take care about all DNS implementation , and bind9 is the reference and doesn't support a such thing
``` ttl=dict(type='int', default=0), ```
`delete` and `create` are not valid states
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
```suggestion supports_check_mode=True, ```
I would like to add a choice list here `choices=[1, 2]`. You have already added a choice list in the docs section so I may was your plan to add one here too ;)
This param is already present on line 529 ;-)
By the way, fixing this will resolve all the checks problems
Please remove `required=False`.
My guess as to why the tests are failing to parse the docstring are due to this line. Since it contains quotes, you'll need to wrap the whole line in single quotes.
I'm not sure you need the `ctl_exist` variable.
Also describe if it deletes the files or not
This is undoing the example.
`Care should be taken ...`
```suggestion available. The default is C(False). version_added: '2.10' type: bool ```
AnsibleModule already has a `.debug ` property which can be enabled via configuration on the controller
I would remove the debugging from the module as user cannot enable it anyway.
Where possible, generally its a good thing to keep the parameter names the same as the linux module equivalent. is 'replace_dest' the same thing as 'force' in the git module https://docs.ansible.com/ansible/latest/modules/git_module.html ? If it is the same it would nice if it has the same name.
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
It is highly recommended to use `assert` statements in the pytest env because it integrates with its reporting better and more natively. ```suggestion assert len(ret) == 3 ```
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
You are right, it's not consistent as-is. @Akasurde What is the direction we are taking this ? Also, we should also define a sub-spec for the hardware-parameter at some point.
Ok, I am confused, about it being a 3rd level dict (and why that even matters) and it being complicated (why ?). Even if it is under hardware it could be a separate spec, I don't see why that would matter. To me putting everything as a top-level parameter is problematic, that's why we introduced the hardware parameter in the first place. The problem here is that if people add it the way they prefer, things will become very inconsistent (and I guess this is why we are having that discussion now, again).
Please add capability from #45953 to this PR, allowing for an existing virtual disk to be specified.
Also describe if it deletes the files or not
`Care should be taken ...`
Right, I see. But a warning is annoying if you run this on purpose like this. (Although one can surpress warnings on a per-task basis). I will leave this up to you to decide.
Sure, warnings are an option. But if it does work as non-root, I wouldn't add the warning.
Why don't you run `netstat -lnptu` instead and parse everything in one go ? Also beware that if this is run as a normal user, you may not get pid information.
What exceptions are you planning to catch here ? Because we prefer to catch only the exceptions we know can be raised. Blank statements like this one may hide real logic errors under the premise that it was a known issue all along.
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
What are the properties? * As other modules, we flatten the properties in the ansible module's parameter. * And for the second level of dict type, we can use `options` to specific another spec to define the key-value pairs in the dict. Like ``` py props_spec={ name=dict(type='str') } self.module_arg_spec = { props=dict(type='dict', options=props_spec) } ```
Is 'the name used in the DNS prefix' check required to create the traffic manager? Or the error is already handled by the create API? If so, I don't this this logic is needed here. If it is required, it should be include in check_mode
Make a method to determine constructing dict from which object will be confused
Fail here make the process exit, but we need to create it if the state is present
Duplicate with `get` method? This logic can be handled as `if get_traffic_manager_profile`
Ok we can use sysprep with from scratch VM. But if we run customization in all cases why this condition ? I think it should be : if we set customizations params : if len(self.params['customize']) > 0:
in fact, you are wrong @aperigault because if you add that you will break the guest_map customizations which are handled in customize_vm and doesn't require customize variable namespace
With this we can't customize from scratch vm. I think we only need: if len(self.params['customization']) > 0:
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
```suggestion if any([i in network for i in ['ip', 'domain', 'netmask']]) ```
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
probably want a to_text and u prefix.
replace this with `return`, the actual `exit_json` call happens later and there is some ssh_wrapper code in the main routine that should run. Where do you remove tempdir/new_archive? Maybe that code got lost in one of the last refactorings. Remove the temp part should also happen before the `exit`.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
The remove is in the wrong place and tempdir is not removed. Better: ``` tempdir = tempfile.mkdtemp() new_archive = os.path.join(tempdir, 'archive.' + archive_fmt) git_archive(git_path, module, dest, new_archive, archive_fmt, version) archive_unchanged = filecmp.cmp(new_archive, archive) shutil.rmtree(tempdir) if archive_unchanged: result.update(changed=False) else: ... ```
I am not sure if this will work because - if `find_obj` is not able find this object that means it does not exists. If it finds then you will not hit this condition. Let me know if I am wrong.
`if network['type'] != 'static' and ( 'ip' in network or 'netmask' in network):`
Thanks - I've replaced all uses of `filter` with comprehensions.
Okay, I see. (should not look at code before the first coffee)
Can you please include `uuid` as parameter for finding VM ? you can use `find_by_vm_id` API for finding VM using uuid just like other VMware modules do.
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
default is no need here
`Only application to an endpoint of I(type) C(nested_endpoints).
See my point in the non facts module around snake_case.
It's a bit more complicated. `test: ['NONE']` is equivalent to not having a healthcheck, which is something `comparsions` doesn't understand. We decided to use the `test: ['NONE']` syntax to disable healthchecks because the alternatives are kind of strange. Accepting `healthcheck: None` doesn't work (since that means "I don't care if the container has a healthcheck"), and `healthcheck: { }` (which we had before) is also kind of strange (and still needs the extra complexity with `disable_healthcheck` since the default comparison for dicts, `allow_more_present`, won't detect disabling in this case). Having the explicit `test: ['NONE']` seems like the best way (and the most compatbile one with `comparisons`).
No, because `None` is the same as not specified, and thus `None` always means that no comparison is done. We really need something which is explicitly not `None`.
Yes. It could happen that someone templates something and gets the wrong value. If docker_container barfs with an exception, we get an Issue, if it returns a nice error, the user will hopefully solve the problem without filing an Issue ;)
We can reduce the level of indents: ```python elif option == 'test': elif option == 'retries': else: result[option] = self.healthcheck.get(option) ``` And I don't thinks someone will be bored enough to specify a `test: ""` to get into the `elif self.healthcheck.get(value): ` check
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
Remove unsafe from the function signature since it's handled by the decorator.
You may want to drop the `2` from the function name to match the YAML tag
Yes, this should use `AnsibleUndefined` in order to get the recursive Undefined behavior introduced in that class.
Should we use `AnsibleUndefined` here instead? I know there is likely circular imports due to `AnsibleUndefined` existing in `lib/ansible/template/__init__.py`, but I've wanted to move it to `lib/ansible/template/undefined.py` to allow it to be imported more freely.
Talking about unsafe. Not the stuff needed for representing octal values.
There should be a newline at the end of the file
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
```suggestion if not os.path.exists(to_bytes(xdg_path, errors='surrogate_or_strict')) and euid != 0: ```
I'd keep the original style here: ```suggestion version_schema = { Required('removed_in'): deprecation_versions(), } ```
Once we have a client, I don't think we need to handle this exception again.
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
Include a `host=kwargs[Jail.modified_jailname_key]` kwarg when calling `display.vvv`. This will maintain consistency with other calls to `display.vvv` made by the `Jail` connection plugin.
It's important to have the same `host` kwarg value used for all calls to `display.vvv` for the same connection, whether that be the actual jail name or the iocage jail name. As written currently, the `display.vvv` call above is simply lacking the `host` kwarg. It can be added without making any changes to the message displayed.
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
Indentation doesn't seem quite right here.
This should use the existing `AzureRMAuth ` rather than requiring these keyvault vars only. Then auth using alternative ansible support methods works too. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/azure_rm_common.py#L971 This is how the other azure plugins work already (e.g. inventory plugin https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/inventory/azure_rm.py#L274 )
avoid putting quotes around values unless they are really needed
We are trying to move away from having the `state` key containing the raw Python SDK return values to just what is not known by the client. In this case I would just return the `id` of the object under the root level, e.g. ``` RETURN = ''' id: description: returned: success and keyvault exists type: str example: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX/resourceGroups/presentation_rg/providers/Microsoft.KeyVault/vaults/ozidatamanagement ''' ``` If the user wants to get more information about a resource that is what the facts module is for.
This shouldn't be set.
Can you add: ``` type: bool default: no ```
Can you add: ``` type: path ```
That's why I would also say `yes`. If someone thinks this is too much data, that person can simply turn it off with the option.
There are only two docker modules which do that: docker_swarm_facts and docker_node_facts. And there it's only for lists of objects returned. This is very different to for example the output of docker_node_facts, and all other _facts modules. So I don't think this is a good reason why the default should be `no`. @morph027 since we can't make up our minds, just pick whatever *you* prefer.
Please remove the list. `default` specifies one value, not a list. A list is only needed for `choices`.
We can remove import of `text_type` as well.
SyntaxError ``` lib/ansible/vars/__init__.py:41: in <module> from ansible.template import Templar E File "/home/adrian/src/ansible/lib/ansible/template/__init__.py", line 517 E for k in data.: E ^ E SyntaxError: invalid syntax ```
As a note, I just remembered that we had to preserve `NativeJinjaText` somewhere else too for the same reason. Trying to `join` a result from a lookup in https://github.com/ansible/ansible/blob/bf7d4ce260dc4ffc6074b2a392b9ff4d3794308b/lib/ansible/template/__init__.py#L1057 led to losing the type so we had to explicitly convert the result of `join` to `NativeJinjaText` (and further make it unsafe to `NativeJinjaUnsafeText`).
Grammar-wise, might as well remove the excalamation point here. All caps is already shouting and "DEFINED!: error" is improper punctuation.
I believe you need to wrap the exception types in parentheses
Use best practice to handler this error : ```python GITLAB_IMP_ERR = None try: import gitlab HAS_GITLAB_PACKAGE = True except Exception: GITLAB_IMP_ERR = traceback.format_exc() HAS_GITLAB_PACKAGE = False ```
Since each of your attributes have only one attributes, what's the point of making a list ? Usage of a simple dictionary should be more easier to understand. ```yaml vars: ACCESS_KEY_ID: abc123 SECRET_ACCESS_KEY: 321cba ```
Put the object creation out of this function in the `main` to be more readable. Then only pass the gitlab object to your function.
You are not returning this.
```suggestion description: JSON parsed response from the server ```
Why do you add `return` here (and below)? `self.client.fail()` terminates the program.
Which static analyzer are you using for this? If it is a good one, it should be possible to tell it that that function will never return. Anyway, if we want to do something like this, I'd rather write `raise self.client.fail(...)` to make sure this is not interpreted as a usual return (and type checkers won't have trouble because it returns the wrong type).
These comprehensions don't need `[]` around them - `set(str(user_id) for user_id in launch_permissions.get('user_ids', []))` because 2.6+ handles comprehensions in function calls without them.
we normally add more than the 'library' error as they tend not to be as helpful as giving a user context on what you were attempting to do exactly when the error occurred.
i don't see a need for this change
I missed this earlier, this module uses several classes to create a 'per system' object to handle the actions, you only updated the class for Alpine (which is derived from busybox, which is derived from user). We need to ensure that all variants get the update.
no need to be sorry (i'm the tpyoe king!)
```suggestion return (None, 'Key already exists, use "force: true" to overwrite', '') ```
`pexpect` could be used to provide the password to the subprocess on stdin.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
I used to do a lot of Perl before as well. You can take that as a good opportunity to get into the Python programming. I think it would be worth using the Python module instead of calling the shell command.
Please add spaces around the equal sign.
Please add spaces around the equal sign.
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
Indentation doesn't look right here. You can have upto 160 character lines
Please add `type: bool`
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
if it is an error, use `fail_json`, otherwise it is a warning, which `module.warn()` can take care of
then that should be the `msg=` to fail_json, the `error` key is not a good choice here, i could see a `'failed_pkgs' = [ list of failed]` as an additional key, but `error` seems to be part of a standard that does not exist.
I don't think it's safe to change when we use the yum api, however I don't remember the specifics. I would not change this behaviour just to change this as I think it exists for some cornercases.
Can we get away with setting stderr in the return here? ``` python res['stderr'] = err ``` The way stderr is the result is handled was changed recently, but not sure of the implication. But having the stderr in the result might be useful in these cases if it doesn't cause the task to fail.
this got named use_backend
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
Remove as not needed (default)
Remove as not needed (default)
This isn't really the case, the module seems to be installing the feature so I would mention that. Also mention that if a reboot is required then it will fail.
I think `state` is more ansibley
```suggestion check_failed(args, 'results indicate tests did not pass (result: %s)\n' ```
Feel free to ignore me here but `get_*_coverage_files()` is common between python and powershell, you could just have the 1 function and have ``` def _get_coverage_files(language): coverage_dir = ResultType.COVERAGE.path coverage_files = [os.path.join(coverage_dir, f) for f in os.listdir(coverage_dir) if '=coverage.' in f and ('=%s' % language) in f] return coverage_files def get_python_coverage_files(): return _get_coverage_files('python') def get_powershell_coverage_files(): return _get_coverage_files('powershell') ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
Right -- it shouldn't be needed because splitlines() will remove all "\n".
This isn't really the case, the module seems to be installing the feature so I would mention that. Also mention that if a reboot is required then it will fail.
I think `state` is more ansibley
We typically do `present` and `absent` to control the state of a resource.
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
Remove as not needed (default)
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
set type to 'path'
use a list type .. since that is what you want
create/remove are not really states, use 'present' and 'absent'
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
I believe using `utf-8` by default will be ok for this.
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Use `required_if(['state', 'present', ['recipients', 'actions']])` in the `AnsibleModule` arguments
this should be a common function in basic.py (i think there is this one or the reverse there already)
oy, thanks Github
should be superfluous unless you want to add a different command for check_mode support (since `supports_check_mode` is false)
same here with the collapse
Same here with exception handling collapse. You could use something like `type(exc).__name__` in the string if you don't want the whole stacktrace but still want to know what it was- I'm guessing that's not useful info to an end user, but might be for troubleshooting.
s/./ to avoid infinite hangs waiting for input./
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is not` vs `!=`? I may not be polished enough on my python...
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
```suggestion vmware_host_snmp: ```
Double quote around Author name.
I think this irrelevant, need to change according to SNMP output.
```yaml type: bool ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
```suggestion - The certificate in PEM format. ```
Same for other description.
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
For an info module you will only need the name as this will be the identifier. Please remove the other options
No longer need deepcopy
We have a one-line BSD statement, which is probably best to be used.
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Alright, after seeing the messages on slack I think that adding warnings can wait but still the docstring must be relocated because it was a module docstring originally and we should keep it on the top of the module. ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text ```
Not really - if people wanted to use tagging they'd need 1.4.4+ but otherwise any version of boto3 would pretty much work. (This is the same as your existing change) It's probably worth adding a warning if people try and use tagging with a version of boto3 that does not support tagging too (using `hasattr(client, 'create_tags')` or similar)
I can't see an import for camel_dict_to_snake_dict
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
just use ansible_dict_to_boto3_filter_list here
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
You don't need connect_to_aws, boto3_conn or get_aws_connection_info if using AnsibleAWSModule
This import isn't used.
These should be in ansible standard form (use boto3_tag_list_to_ansible_dict)
This logic seems ignore the use case of removing all tags.
can be ignored
hm maybe that's what I've searched for
can be ignored
Same order, type first.
this is an unsafe way to write the file, other processes might get incorrect/incomplete data and if it fails it leaves a corrupt file. write to a temp file and use `atomic_move` instead
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
Another regex that can be precompiled.
``` 'LaunchTemplateSpecification': launch_object["LaunchTemplate"] ```
This is very important. Otherwise nor creating nor updating will work.
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
Unnecessary line break
No wrap needed.
please call this `executable` for consistency used in other modules. e.g. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/packaging/language/pip.py#L117 or also https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/packaging/language/npm.py#L53. Optionally add an `php_path` as an alias.
One little bug here: executable_arguments is a list which is a mutable container. This adds ['--dry-run'] to that container. In python, mutable containers are passed by reference. So in the caller, after _is_package_installed() is called, executable_arguments should include '--dry-run'. That's obviously undesirable. The previous code rebound the identifier executable_arguments to a new list which contained a copy of the parameter executable_arguments with the additional element '--dry-run'. It's probably best to make it more obvious that this code should operate on a copy of executable_arguments. Perhaps: ``` python def _is_package_installed(module, name, easy_install, executable_arguments): # Copy and add to the arguments executable_arguments = executable_arguments[:] executable_arguments.append('--dry-run') rc, out, err = install_package(module, name, easy_install, executable_arguments) if rc: module.fail_json(msg=err) return 'Downloading' not in out ```
```suggestion - Whether an existing log group should be overwritten on create. - Mutually exclusive with I(purge_retention_policy). ```
Oops, the following sentence is now redundant and can be removed: > A previous version may be specified C(name-0.9) to downgrade a package.
Why change the example docs? The yaml dict style is the preferred format for EXAMPLES
I think `C()` should help with formatting and readability ```suggestion Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY:MM:DD | YYYY:MM:DD:HH:MM:SS | YYYY:MM:DD HH:MM:SS | forever) ```
I think it'd be better readable if you do `C(valid_from)` and `C(valid_to)`
```suggestion Time will always be interpreted as UTC. Mainly to be used with relative timespec for C(valid_from) and / or C(valid_to). ```
`type: list` is missing.
```suggestion - "Specify certificate options when signing a key. The options that are valid for user certificates are: ```
add a `mutually_exclusive` section
`Care should be taken ...`
Sounds a strange behavior to me to apply the change only on the first matched NICÂ when the definition does not indicate a single object. Either apply change on all matched NICs or fails sounds more logical to me.
Also describe if it deletes the files or not
s/does not do anything/has no effect/
Thanks. It's already fixed in `devel` ;-)
I think that this isn't doing what you expect, the code does `expand_path = ('~%s' % self._play_context.remote_user) or self._connection.default_user or ''` instead of `expand_path = '~%s' % (self._play_context.remote_user or self._connection.default_user or '')`
Move this condition up a level: ``` python if expand_path == '~' and not self._connection.remote_is_local: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
In other modules that support `authorize` we have some code here to check we are in the right context (privileged shell vs non-privileged). If you were to test the code with a task that requires privileged then one that requires non-privileged then I believe the current code would fail. `ios` supports `authorize` as well: https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L72-L86
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
```suggestion cpu_facts['processor_threads_per_core'] = int(data[1]) ```
Else part is not necessary since we are initialising `b_passwd` already.
Drop the `as e` since it's not used, and is not compatible with python 2.4.
I'm not sure if we need this sanity check. If `lscpu` exists, we should trust it.
```suggestion updates.extend(line for line in set_commands if line not in config) ```
```suggestion default: {'type': 'org.graylog2.indexer.retention.strategies.DeletionRetentionStrategyConfig', 'max_number_of_indices': 14} type: dict ```
```suggestion default: "org.graylog2.indexer.retention.strategies.DeletionRetentionStrategy" type: str ```
```suggestion default: False type: bool ```
```suggestion default: False type: bool ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
Same - please use `len`
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
Same - please use `len`
This would put the account in the creds file *above* the params directly passed to the module. This should probably be reversed, as we try to follow the order of specificity (preferring most specific) as: /etc file, $HOME file, environment variable, direct specification on task parameter.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
```python current_config['received'] = (current_config.get('received') == 'yes') ```
use sorted list. please use the sorted list in all relevant places
this is not a good test, and could cause bugs in the future
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
again, please sort according to severity
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
@bcoca noted the use of state=info in today's meeting... I think a year ago, or so, we discussed using a separate module named with an _info suffix (like sophos_utm_info.py) for things that are just for gathering info about something which doesn't relate to the host it is run on. (You also thought you might turn that portion into a lookup plugin. That would also be fine. The difference is just that a lookup can only be run o nthe controller whereas a module can be used on either the controller or a remote host).
Note that str() can fail if the object's __str__ method returns non-ascii characters. You probably control the objects being used here so you know whether that's the case or not. I usually use ```to_native(self.change_relelvant_keys, nonstring='simplerepr')``` in similar situations so I don't have to worry about it.
The return value is not strictly cookies. The return value is a dictionary of headers
Please add our boilerplate to the top of this file. One of those pieces of boilerplate makes all classes defined in the file new-style classes. Without it, a class definition which doesn't inherit from object is an old-style class. ``` from __future__ import (absolute_import, division, print_function) __metaclass__ = type ```
If it's not required, you don't have to state `required: false` That's implicit.
No need to quote this value.
Maybe add `default: present` here.
No need to quote.
No need to quote strings in YAML. (unless it's yes, no or null I guess)
Good that you default to TLS true!
The protocol has been named TLS for many years (SSL no longer exists) :-) At least I would suggest adding an alias of `tls`.
how can a port number default to 993 **or** 143? I think this should read "defaults to 143 or 993 if `ssl` is true)
I think it would also be useful to indicate what this module is actually intended for, by which I mean "why would I want to use it" in a configuration management scenario.
"rules and return"
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
Exception handling here too.
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
I would not add this alias. We tend to use aliases for backward compatibility or to add consistency between modules. But there's no value in adding this alias here. Rather stick to one parameter name.
All our parameters that accept lists, accept single items too. But we never offer both the plural and singular version for parameter name. A one-item list, is still a list :-) So I wouldn't bother. IMO offering both is more confusing as people may assume that: ```yaml ssh_key: my-ssh-key ``` means there is only one SSH key to add. That is why I would only have the plural form and no aliases. It will end up to be more consistent between users/playbooks and it's clear the parameter accepts more than one value.
```suggestion - Only required if no server I(id) is given or a server does not exists. ```
Maybe you should put the `BEWARE` part into a new paragraph (i.e. a new list item in `description`).
It's probably better to put each requirement into its own item.
You can also use `I(...)` here.
You should store the result in a variable (e.g. `self._cryptsetup_bin`).
Don't write `cryptsetup`, instead use `self._cryptsetup_bin` (or whatever variable you stored it into above). Otherwise, calling `get_bin_path()` is pretty much superfluous.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
please wrap in block ``` if __name__ == '__main__': main() ```
Here, you might want to return `out` if `re.findall` returns `[]`
please use explicit imports `from ansible.module_utils import AnsibleModule`
I don't understand this change.
Rather than doing the `if not cmd` dance, pass additional search paths to `get_bin_path()`: ```suggestion cmd = get_bin_path('iscsiutil', opt_dirs=['/opt/iscsi/bin'], required=True) ```
Please add spaces around the equal signs.
Please add spaces around the equal sign.
Please add spaces around the equal signs.
Would be good to also see usage other than ceph.
finding it when not using pipeline is normally `dirname(__file__)` as module itself is located there.. but as discussed, need to create generic and then revisit modules doing this
we normally prefer to use the same tmp directory as the modules themselves are put into
not a requirement, but would be nice to validate all IDs before returning an error (in case more than one is wrong)
Either use `result['changed'] = ` and remove the `changed =` OR use `changed =` and remove the `result['changed']` but do not use both. That applies to all `main()` function.
`inspect_service()` returns a `NotFound` exception if it cannot find the service ([CI error](https://app.shippable.com/github/ansible/ansible/runs/108392/51/tests)). Check out module_utils/docker/common.py, it catches that in a few cases I think.
there is a missing condition for check mode
there is a missing condition for check mode
there is a missing condition for check mode
`if network['type'] != 'static' and ( 'ip' in network or 'netmask' in network):`
Parameters that are not required don't need `required: false`.
If there's no default, `None' is implicit. (It means parameter undefined) So this is not needed.
No need to have the `required: false` lines, it's implicit.
Make this a separate item in the list.
Make this a separate item in the list.
@siwyd @alikins Such timing -- I was about to submit a PR against module_utils/facts/virtual/linux.py to check {{product_name}} to detect a DO droplet when I came across this PR. $ cat /sys/devices/virtual/dmi/id/product_name Droplet
Would like confirmation the droplets are KVM guests.
use an else here and you can have only 1 return at the end (even that is not needed)
This hackery with __new__ was something I always desired to get rid of with a facts refactor but I'll understand if you don't want to touch that until later.
What's the reason for using the shell here? There's no redirection, pipes, or other needs for the shell that I can see.
Note that this is also being removed in https://github.com/ansible/ansible/pull/68560
`import ansible.module_utils.parsing.convert_bool import BOOLEANS` and use that constant
Should we also do this in `JinjaPluginIntercept.__getitem__`? Since this comes from a config, in order to work with something from a collection it would have to go there too I think.
which was incorrect solution as the 'non templating' of pause shows
no, jimi-c has alternate solution and we'll probably go with that
I think we are fine with having the property and can do w/o the 'special dict key' which would show in the user's dict definition
You probably don't need `{}` fallback anymore.
```python if dc is None: module.fail_json(msg="Failed to find the datacenter %s" % module.params['datacenter']) ```
I meant, `return` as `module.fail_json` will return anyways.
This is unreachable code.
This should be a string: ```yaml version_added: '2.4' ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
Nowadays we do: ```yaml type: bool default: 'yes' ```
Wouldn't the choice be [ 'yes', 'no' ] as you'd expect from a boolean ? As per previous remark, this would become: ```yaml type: bool ```
Please rewrite the description what the task is doing in detail. E.g. **Disable the domain firewall profile.**
```suggestion - Only required if no server I(id) is given or a server does not exists. ```
We tend to have full descriptions, so that the meaning is more clear to the end-user. The first line is a description of the parameter. Subsequent lines clarify the value, its use or dependencies. All descriptions (except the short_description) should have a trailing dot, so please add those everywhere. ```suggestion - The ID of the Hetzner server to manage. ```
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
All our parameters that accept lists, accept single items too. But we never offer both the plural and singular version for parameter name. A one-item list, is still a list :-) So I wouldn't bother. IMO offering both is more confusing as people may assume that: ```yaml ssh_key: my-ssh-key ``` means there is only one SSH key to add. That is why I would only have the plural form and no aliases. It will end up to be more consistent between users/playbooks and it's clear the parameter accepts more than one value.
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
I learned recently that you can use actual separate literals to improve readability: ```suggestion @pytest.mark.parametrize(['url', 'expected'], [ ```
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
```suggestion # try to get collection world name first ```
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
This is actually one reason you want to use `MutableMapping` over subclassing `dict`. `.get()` does not use `.__getitem__()` in `dict`. Both methods duplicate code for performance: ```pycon >>> class VarsWithSources(dict): ... def __getitem__(self, key): ... val = super(VarsWithSources, self).__getitem__(key) ... print(('__getitem__', val)) ... return val ... >>> v = VarsWithSources() >>> v['foo'] = 'bar' >>> v['foo'] ('__getitem__', 'bar') 'bar' >>> v.get('foo') 'bar' ``` Notice that `.get()` doesn't cause the print to happen. As such, your implementation as is will only work with some accesses of keys, and not others.
And the same here
Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...
Should probably check if region exists before this line.
You can remove this (and the import) now that this uses AnsibleAWSModule.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
I think this can raise botocore.exceptions.ProfileNotFound too.
don't raise errors on import, expose them on `parse` see developer docs for examples
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
Maybe it makes sense to prefix the label-based groups by something like `docker_swarm-label-` or so, so that short/generic labels don't overwrite existing groups. Or maybe also make this prefix an option for the inventory plugin so users can overwrite it or leave it away if they don't think there will be collisions.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
```suggestion self._module.fail_json(msg=("An error occurred trying to get the ADOM Info. Error: " + to_text(resp_obj))) ```
```suggestion + to_text(err))) ```
hi Luke, I see from the code, you query the lock info and try to unlock the adoms upon logging out. however, I don't see any places where lock_adom() is called to lock a domain. if we don't explicitly lock the domain in our plugin, is it required to unlock it every time when the plugin is logging out? + @frankshen01 thanks, Link
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
Missing new line
Please don't call argument an attribute ;)
What about empty string? I'd modify clause to be `if not repo:` to catch all falsy values.
You may be able to simplify this buy using the helper functions `required_one_of` `mutually_exclusive` `required_together` Have a look at existing modules for examples
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
```suggestion state=dict(type='list', default='present', choices=['absent', 'allocate', 'commit', 'deallocate', 'installed', 'present', 'removed', 'reset']), ```
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
This statement seems useless.
`timeout` and `username` aren't the same thing.
Use `elif` instead of `if`.
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
Please test if `default=False` is the default value when using type `bool`.
No, the default is None. So you can tell if the parameter was set or not.
Add a break after setting pkg_mgr_name (and the same for dnf)
Better, but that string was just split on `.`, so there's still no guarantee it's parseable as an int, and the consequences of a potential future failure will break all fact collection for that distro, so extra-defensive is better. eg: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/facts/system/pkg_mgr.py#L70-L83 (and yes, I know there are other places that aren't doing it as carefully, but we shouldn't be making more of them ;) )
we should also return if we both delegate executions and delegate_facts
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
host_storage.type == otypes.StorageType.FCP
This `.close()` isn't needed, the context manager closes the file automatically.
I would add here fetch_nested=True, because we always want to return steps.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
s/write target file {0}/fetch file to {0}/
and convert filename to bytes again.
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
`type='int'` You can then remove your code to check that this is an int.
Do you need that step? `clients = client_list` should be enough
Please add the module as a function parameter and maybe replace `dest `trough the `filepath` in the error message error: global name 'module' is not defined
maybe you add the type `type='path'`
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
password and nopassword should be mutual exclusive
you should count keys, and restrict number of keys that exceeds limit
define login methods constants
add relations between the reset parameter. user_name is mandatory when reset_for is user
this validation can be done using spec relationships
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
credential is particularly problematic because it may be owned by a single user, in which case the organization will be null. This is a common case, and wouldn't be possible by assuming the organization is shared as you are doing here.
This is a pain point shared among all Tower / AWX clients, and I wouldn't say that any of them have ever gotten it right. I don't like 2 separate parameters. In my perfect world, I think it would optionally take a string or a dict (and there would be a type option to allow this), and using the dict you could specify both the project name & organization. This is unlikely to happen. The _primary_ fix you're getting in here, adding `organization` parameter to tower_inventory_source, and applying it to the inventory filter - that's really good. We need that. I would like to mostly focus from that and not worry too much about the other details which are still far from perfection.
for delete, you might want to consider the `fail_on_missing`, because I'm guessing that you want it to not fail on missing (OK, changed=False).
no, it's probably not fixable anyway
keys in lowercase
Isn't duplicate this loop in here? I also think we could simplify it here starting after the first line ```python for line in out.splitlines()[1:] ```
We don't need it. It could be simplified using: ```python keys = out.splitlines()[0].lower().split() ```
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
Needs changing to you
please change this statement to the appropriate entity
I am almost entirely sure this is not what you meant to have here
Please remove above two line and add your name as maintainer. Also, please update the year (applicable for header in other files as well.)
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
```suggestion - Can be a dict which contains I(name) and I(resource_group) of the virtual network. ```
```suggestion - Can be the resource ID of the virtual network. ```
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
```suggestion - Must be in the same resource group as VPN gateway when specified by name. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
no need to do this here, we already take care of it below, just update 'docs' variable and 353/635 will display
```suggestion # try to get collection world name first ```
Argh, I just realized the PluginLoader attribute stuffing (update_object) has been happening on `class_only` cases, which is broken for "same name, different behavior" cases (since subsequent loads will overwrite the class vars on the existing type object, not instance vars). It works here, since `all` is `yield`ing the plugin class immediately after calling `update_object` on it, but the whole pattern is busted for `class_only`, esp for things that might consult the class var during or after `__init__`. We've needed to rethink that for awhile, and this kinda sets it in a little more concrete. :(
Does this need to be a nested function? The overall cyclomatic complexity of this method is 8. I bet it could be reduced by removing this nested function. It would also make this method (and the function) easier to test.
> Are you suggesting to just duplicate the code from build_summary() within each for loop? Nope. It just seems like this nested function could be a method or a standalone function. > I don't see how having the nested function within _create_role_list() makes testing harder, In order to unit test `build_summary()` you would need an instance of `RoleMixin`, then call `_create_role_list()`, and then write the test in such as way as to only run `build_summary()`. It just makes it harder to get to _just_ `build_summary()` for testing, which makes it harder to throw tons of varying inputs at `build_summary()`.
@thomwiggers you also seem to like the "suggested change" feature :D
```suggestion The C(address_list) is a comma-separated list of one or more address/netmask pairs in CIDR format." ```
This isn't valid YAML. You have to quote it: ```.yaml valid_from: "2001:01:21" valid_to: "2019:01:21" ``` Also, using colons as date separators seems very strange for me. I would expect slashes or dots.
```suggestion - openssh_cert: ```
This task fails with `{"changed": false, "msg": "missing required arguments: valid_from, valid_to"}`
same for other lines below.
```suggestion # Copyright: (c) 2018, Scott Buchanan <sbuchanan@ri.pn> ```
Needs to include the platform. This string is used on https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion - David Taylor (@djtaylor) ```
Not really - if people wanted to use tagging they'd need 1.4.4+ but otherwise any version of boto3 would pretty much work. (This is the same as your existing change) It's probably worth adding a warning if people try and use tagging with a version of boto3 that does not support tagging too (using `hasattr(client, 'create_tags')` or similar)
it means the same thing, it's just the flow.
perhaps "if not region"? that keeps the standard flow from being in an "else", lets us bring the indenting back a level, etc. Otherwise this is fantastic. Thanks for pep8 and removing the stray code.
needs to be `startswith` here too
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
We probably don't want to make the *short* description that long. Maybe we can now change this to: ```yaml short_description: Provide Windows product and license information ```
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
please add `no_log=True`
Please add `supports_check_mode=True`. With this seeting, facts modules will also be executed in `--check` mode. ~~~ python module = AnsibleModule( argument_spec = dict( host=dict(required=True, type='str'), login=dict(default='Administrator', type='str'), password=dict(default='admin', type='str', no_log=True), ), supports_check_mode=True, ) ~~~
Mutually exclusive with I(domain_search).
Mutually exclusive with I(domain_name).
Can we rephrase it as "Host should support C(atomic) command"
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
don't forget to remove if you change default
https://docs.python.org/3/library/exceptions.html#TimeoutError says that `TimeoutError` is an `OSError` subclass that's been added in Python 3.3
Apparently, Python 2 does not have a `TimeoutError`
The docstring should probably explain that this is to be used in the main thread only... And the implementation should probably do the corresponding runtime checks.
Now that we're making this a module_util, this should no longer be considered a hack.
I think we should have an entry-check to protect from reuse: ```suggestion def __enter__(self): assert not self.timed_out ```
```suggestion # checksum filename ```
```suggestion (unless C(force) is C(true)). ```
Please remove this line, for various reasons. - We use examples to showcase possible values - It shows the old key=value syntax If you remove this, you also do not need to quote the whole paragraph.
Default was $null, which means unset. No need to add this. ```suggestion ```
add `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` to ensure all commands have an expected LANG
You are taking me wrong here. I am just saying that adding additional library will add overhead to people who are using this module and people who will maintain it. I am not saying to port other GitHub modules to use `PyGithub`. One way could be using GitHub REST APIs directly rather than relying on any third party Python modules.
Making this as resolved.
``` aliases: ['repo'] ```
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
```suggestion - name: list hooks for a repository on GitHub enterprise (token auth) github_webhook_facts: ```
No need to wrap import json in a try block as we already assume python 2.6+ for boto
this is definitely not right!
`ansible_dict_to_boto3_tag_list` likely better here.
what happens if a parameter is deleted? I think this would be missed.
Move to new style module imports
this should not be a new option, the initial approach to change to 'search' was correct, this might be 'stableinterface' but the current behaviour is a bug.
"...in version 2.11"
Wrap `contains_anywhere` in `C(contains_anywhere)` so it gets code formatted in the HTML docs.
Also capitalize the first word in both of these sentences, please.
Comma isn't needed --> 'beginning of a line in a file'
I would put all these variables inside the `main()` function as there is no reason to have them global because you don't share them across multiple functions.
The file path [should be](http://ansible-docs.readthedocs.io/zh/stable-2.0/rst/developing_modules.html#module-checklist) decorated by `C()`. The same for `software_packing`.
Add trailing comma.
You don't need to state default=None as this is the default value.
Please put this on a single line. Lines can be 159 characters wide.
```suggestion version_added: "2.8" ```
``` from ansible.module_utils.common.process import get_bin_path ```
i would use the find bin function and not assume it is in path
```suggestion - Whether the plugin should be installed. ```
catchall ignore ....
There's a lot of churn on changing double to single quotes, I could understand wanting to be consistent but it seems outside the scope of this change.
```python # warn when failing to skip due to lack of support for skipping only some versions display.warning('Including test "%s" which was marked to skip for --windows %s but not %s.' % (target, ', '.join(skip_valid), ', '.join(skip_missing))) ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Since this is controller code, this should probably be using ```to_text()``` here. The ```self.get_option``` also seems redundant since you just pulled that value into inventory_id above? So maybe: ```suggestion inventory_id = to_text(inventory_id, nonstring='simplerepr') ```
(Using nonstring is not necessary as simplerepr is the default but I like to use it to flag this as a case where we're using the function to get the textual representation of an object rather than a case where we're converting from bytes to text.)
I would really like to pull @matburt into the decision-making on this matter. It's not just the sourcing from the env var here, but also the use of the `license_type` parameter once it's received. What does this mean in practice? I think users would expect to be able to use the plugin as a part of the Ansible core CLI with any given type of target AWX or Tower instance.
should this really be 'endswith' or more like equal? `path.strip() == '@tower_inventory'`
ah, its seeing it as a file name ... weird since host_list 'works' .. i should look into that
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
Same typo as above
Maybe add `register: result` to one of the examples and then a `debug` task to view the result (or parts of it). That makes it easier for not so experienced people to use the module.
You will need to include the OAUTH_TOKEN environment variable also.
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
You can format this like this: ``` data = ( 'params=[{"Bugzilla_login":"%s","Bugzilla_password":"%s",' '"ids":[%s]}]' % (user, password, bug_id)) ```
In the `exit_json`, you should also return `changed` and `state`.
I see that the requirements lists python-2.6 as the minimum python version. Unfortunately, format strings in python-2.6 are more limited than in python-2.7 and later. So you need to be explicit about the position in the format args list you are looking at like this: ``` python response = rest.get('floating_ips/{0}/actions/{1}'.format(ip, action_id)) ``` There's a few other places with format strings that have to be fixed as well.
This is usually not needed
You mess up separate test cases into one. While they should show up separately. Also, one failure shouldn't affect other tests.
```suggestion @pytest.mark.parametrize( 'input_value,expected_outcome', ( (i1, r1), (i2, r2), ...etc ), ) def test_lenient_lowercase(input_value, expected_outcome): ```
Please use `pytest.mark.parametrize()` instead of a loop
Plz also use `match` arg here
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
Either 'license' has to exist (and be a non-empty list) or non-None 'license_file' is required. https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L236-L247
'readme' is required. Galaxy artifact import enforces that the field exists when validating the galaxy.yml. Later in the import process, it's verified that the file 'readme' points to exists in the archive (https://github.com/ansible/galaxy/blob/devel/galaxy/importer/collection.py#L102)
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
Oh, Cool. Thanks for information. Then we can use LooseVersion.
`distutils.version.LooseVersion` must be used instead of string comparison.
distutils version comparison in broken in Python 3
Error messages (here and below) should mention `FW_VERSION` value.
You're right: when `import_failure` is `True`, `FW_VERSION` could be not `None`. `import_failure` must be checked at the end, nothing needs to be changed here.
Should be a parameter of the task itself and not the module
```suggestion # with the same name and value but with a dm_ name prefix. ```
This has to be done only once, since the binary is always the same (`docker-machine`).
catchall ignore ....
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
ah, now I see why, but still, would prefer `command` to be required.
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
+1 to `psexec_command` just for clarity...
don't forget to remove if you change default
s/does not do anything/has no effect/
stray single quote
Would add a note saying this does not deal with disk initialization and file system formatting.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Don't add this, if the parameter is not required.
```suggestion version_added: 2.10 ```
Task seems irrelevant to me.
Wrap in try/except please.
import HAS_BOTO3 too and add a check for it in main()
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
You can refer ios_command module doc ``` - name: run commands that require answering a prompt ios_command: commands: - command: 'clear counters GigabitEthernet0/1' prompt: 'Clear "show interface" counters on this interface \[confirm\]' answer: 'y' - command: 'clear counters GigabitEthernet0/2' prompt: '[confirm]' answer: "\r" ```
Can add example with `prompt` and `answer` for more clarity
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion by setting the ``REGISTRY_AUTH_FILE`` environment variable. ``export REGISTRY_AUTH_FILE=path`` ```
Please remove this. /tmp might not be writable or available.
You should follow standard [Ansible AWS Exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#exception-handling-for-boto3-and-botocore)
`snake_dict_to_camel_dict` already exists in module_utils.ec2, it has recently been updated to allow a second parameter `capitalize_first=True` (because someone made the default dromedaryCase early on)
`camel_dict_to_snake_dict` already exists
use `trail['LogFileValidationEnabled'] = ct_params['EnableLogFileValidation']`
You may be able to modify sys.path, perform an import, and then restore sys.path. That will probably prevent it from causing issues for other unit tests, but I haven't verified that.
It's not safe to modify sys.path outside of unit test functions, as these changes will affect other unrelated tests.
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
You can place fixtures into a conftest.py file and then they will be loaded automatically instead of needing an implicit import.
This does not need to be wrapped.
I blame my `black` setting.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
Returning `minimal` will result in sanity tests being executed as appropriate on the files. By classifying them we're telling `ansible-test` it doesn't need to fall back to testing everything due to lack of classification. Tests shouldn't be using a `requirements.txt` in the root of the repository, and extra work is required to access files outside the current test target for integration tests, so it shouldn't happen accidentally.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Sure, a separate PR sounds good.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Actually result could be a property of the main object in this case.
Make this: ```python argument_spec = dict( state=dict(type='str', required=True, choices=['absent', 'default_bandwidth_reset', 'present']), data=dict(type='dict', required=True), ) ``` It's easier to read if there is one parameter per line, and we have 160 allowed columns on a line (and very wide screens these days). I also sorted the options in the list (order is not important) and added the type as the first option (as this one should always be set anyway). So it looks nicer (to the eye of the beholder).
So these examples don't have a `delegate_to: localhost`and I think you should have it there (unless you explain why/when it isn't needed).
So you put a variable there everywhere, but that's not really helpful. Most people would like to know what kind of file this is. What a typical naming-convention would be and where it would be typically located. Should it be an absolute path, or if it's relative, relative to what ? Things you need to explain and demonstrate through these examples.
There's still a few of these that are using double-underscore to mark private. We generally do that with single underscore instead. ``` python - def __present(self, resource): + def _present(self, resource): ```
Get rid of this.
Again, this should become: ```yaml type: bool ```
Please break this up in 2 distinct items. The first is an explanation what the option is, subsequent items clarify how to use it, etc.
Same here. No need to state this.
You probably want this here: ```yaml type: bool default: 'no' ```
not a required change, but it seems a 'difference' comparison between lists would give you any passed params that are not valid choices in 1 shot and a single error message.
Upon further reflection, I think these three lines along with `check_mutually_exclusive` are erroneous for subspecs. We don't currently have a way to specify `required_if/one_of/together` or `mutually_exclusive` for subspecs, so in every case *but* the networking "aggregate" thing, this is severely broken (as you'd be making nonsensical checks in most cases)
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
This is more efficient: ```suggestion key = next(iter(old[0]) ```
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
this should be a common function in basic.py (i think there is this one or the reverse there already)
Use `required_if(['state', 'present', ['recipients', 'actions']])` in the `AnsibleModule` arguments
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
cacertpath should be cacert_path
but you dont have full args till you read the file. I becomes specially fun when the from itself is a template
this does not seem like the correct change, instead we need to make sure that the vars_from are loaded before pasisng to param hashing
I haven't looked at this PR in depth yet, but the first thing I notice is that this should use `original_task.copy()` instead of `deepcopy`. Our `copy` methods are specifically designed for copying these objects. We will also need to closely monitor memory usage due to any changes that make copies of objects.
I think this is acceptable for now, but for the future, I think we should see if we can make use of post validating to cover all arguments in a single standard way.
And the same here
this would be equivalent of `if '-' in md5_remote:` since `etag_multipart` is never used other than this conditional.
Since we aren't sending the errormsg to an exception, we want to use to_unicode rather than to_bytes. to_bytes won't cause any problems with the code here in python2 but it will fail in python3 (because the string literals will be of the text type and so it won't match with errormsg as bytes then.)
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
For the author information we normally only keep name and GitHub handle.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
```suggestion - The name of the distributed vSwitch to manage. ```
This probably should use some internal ref, instead of absolute linking. I'm just not an expert on what that would look like. Maybe: ``` :ref:`FACTS_MODULES` ```
(Will obviously not be very helpful in ansible-doc text output, though.)
its also missing reference to the variables that can override that
I think this description is off :)
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
Indent isn't really necessary here: ```suggestion if already_loaded_vendored_modules: print( 'doh, some vendored stuff was already loaded: {0}'. format(already_loaded_vendored_modules), file=sys.stderr, ) ```
```suggestion print('hijacked sys.path to use ansible-vendored files, bwahaha', file=sys.stderr) ``` (because this log entry is added after the fact)
```suggestion print('hijacking sys.path to use ansible-vendored files, bwahaha ð£ð£ð£') ```
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Don't assign a lambda function, use def
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
minor typo - `expresisions` should be `expressions`
cool - I removed the line about how it used to be hardcoded and changed the note about whitelisting
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
```suggestion - Size of the domain. ```
Add github handle here. ```suggestion - Tzur Eliyahu (@tzurE) ```
You can add informative message like - * Domain 'sample' created successfully. * Domain 'sample' deleted successfully. * No Domain exists.
Return value is optional, but it will good to have sample values which this module returns.
```suggestion - The desired state of the domain. ```
I know, was just wondering if it's intended that it works that way.
```suggestion ({b'str'.encode(DEFAULT_ENCODING): b'str'.encode(DEFAULT_ENCODING)}, {u'str': u'str'}), ```
Having a class for just one test method is unnecessary.
task_uuid seems unused
If you expect this invocation to emit an exception, `assert`ion doesn't make sense here: ```suggestion ansible_json_encoder.default(test_input) ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
Is this even needed, we will be dropping py2 and `to_text` does not call `__unicode__`. You may as well just put this in `__str__`.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
How about: ```suggestion if not os.path.exists(file_path): continue ```
This will not do the right thing. Probably what you want is something along the lines of `if ('ipv4addr' in each) and ('ipv4addr' in proposed_object) and each['ipv4addr'] == proposed_object['ipv4addr']:`
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
use `get_exception()` instead
Ah, it's nice that the syntax checker caught this bug. This should be `network_interface['tags'] = boto3_tag_list_to_ansible_dict(tag_set_copy)`
You might need to use a paginator here if there might ever be more than 50 results
``` sanitized_filters = [key.replace("_", "-") for key in module.params.get('filters')] ```
It might also be no IGWs found here.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
We prefer also examples where we remove objects, query a single object or query all objects. Look at some of the other modules. We have at minimum 4 examples.
Please also remove this. Legacy ;-)
All configuration values should not include default values, as that leads to accidental overwriting of existing configs that the end user did not expect.
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
Don't add this, we are deprecating this for modules that predate v2.4. So very soon all modules will have this removed.
instead of 'comma separated list' just make 'list' , type=list will accept both types of list and always guarantee a list object to the module
This should be supports_check_mode=False.
for other modules we are already using `append=yes|no`
chack -> check
Try except blocks souls he as small as possible
I think this will fail in case of standalone ESXi server.
```suggestion destination_vcenter_password=dict(type='str', required=True, no_log=True), ```
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
You forget to make the change.
I suggest to add an example of this
In order to improve readability (meaning the change described below isn't required): * `delete_cert`, `import_pkcs12_path`, `import_cert_path` and `import_cert_url` never return (either `exit_json` or ` fail_json` are called) * it's quite disturbing that `changed` isn't set (and it doesn't need to be set) when `delete_cert` is called then i would rather call `module.exit_json(changed=changed)` here (then keep `module.exit_json(changed=False)` unchanged at the end the file.
```suggestion - Certificate content to load. One of I(cert_url) or I(cert_path) or I(cert_content) is required to load certificate. ```
Should not that be: ```suggestion msg="Using 'cert_content' argument requires 'cert_alias' argument.") ```
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
This is also not needed, idem for all other parameters.
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
not a blocker, but there would be a little helper code for this in basic.py https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L2301
not a blocker, this open_url/except has been used many times and it would be probably worth to create a function in a shared code module_util under module_utils/opennebula.py. Note that any code under module_utils has to be bsd licensed.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
note, the spelling of this word is: vacuumed. Probably should change it everywhere.
Is this (and `providers:` below) part of `property_attributes:`? Dedent if you want them to be example of top-level `providers` and `services` args.
"the relevant" not clear enough IMHO. something like "the type of the resource to which the profile should be [un]assigned" ? same for `resource_name` below.
may be nice to support description in addition to name.
Perhaps `required_if` can help.
no, this refers to the standard `changed=True` / `changed=False` and `msg="..."` results returned by ansible modules.
`across` has broken into two separate lines.
Typo in `aggressive`
Typo in `aggressive`
This line seems to have been split into two.
Looks like a split line.
Make this sentence to the first paragraph in the description, also declare in short_description
```yml - name: Gather metadata facts on Azure VM host azure_vm_metadata_facts: ```
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
updated or created isn't needed
that should be example of module usage, not return value
This doesn't remove any orphan, it only checks whether there are any.
```suggestion elif docker_object == 'networks': ```
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
These parens aren't necessary for unpacking the return values.
AFAIR the flag is `failed`, not `fail`
Please change this to 1.1
this was wrong in the previous module, should be `'status': ['preview'],`
Tiny typo here 'Waitis' -> 'Waits'
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
Should be 2.4 (as we don't backport new modules to older releases).
This could be less nested once you apply `choices`.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
This has to be done only once, since the binary is always the same (`docker-machine`).
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
catchall ignore ....
``` from ansible.module_utils.common.process import get_bin_path ```
```suggestion # with the same name and value but with a dm_ name prefix. ```
```suggestion description: JSON parsed response from the server ```
```suggestion description: The error message returned by the Gitlab API ``` The same for the next one.
You are not returning this.
You don't return this one as well. Only specify things in `RETURN` which you actually return!
If `purge` is `true`, it will be empty according to the code you pasted below.
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
These parens aren't necessary for unpacking the return values.
ipt_load_stderr doesnt appear to be defined anywhere.
Add traceback here as well (for line numbers).
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
catchall exception handling is generally not a good idea as it neither gives a better user message nor aids in debugging. If you feel you must do it this way, be sure to return the stacktrace (retrieve that using raceback.format_exc() and put it into the exception parameter to fail_json).
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
comma-separated should not bee needed, just make flags a type=list in argspec, it will accept both actual lists and comma separated strings
instead of flags_on/off just flags .. a canonical list
```suggestion search_base: "OU=Users,DC=contoso,DC=com" ```
```suggestion search_base: OU=Users,DC=contoso,DC=com ```
```suggestion filter: "sAMAccountName -like 'test*'" ```
```suggestion filter: "sAMAccountName -like 'test*'" ```
Shouldn't be needed
You can replace this line through line 363 with simply: `client = module.client('es')`
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
`'required': False` is the default so you can omit that. Same for any of the following.
The `join` here seems a little unnecessary, and the performance is worse than a printf like string format or using `.format` Although it is just 1 line, and not repeated, so that's just a little bit of a nitpick.
Updated to use percent formatting
Is the prefix necessary here? Why no let tempfile choose a location? Sudoing to non-root is fairly common and should work.
this is basically noop, unless you are under pipelining, in which you get None, tmpdir will still be populated though
also worthy noting, -G won't show actual ssh options used, just those configured
The `basedir` path will need to be bytes to avoid unicode errors. Something like this: ```suggestion b_basedir = to_bytes(context.CLIARGS['basedir']) collections_search_paths.update([b_basedir]) default_collections_path = [b_basedir] + default_collections_path ``` I did not test this. I'm just guessing from looking at the test failure.
you want to put basedir first to match normal precedence
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
Putting this under a conditional makes it undefined under the opposite condition.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
@zikalino thanks for submitting this module, I've been testing it and this should also be of type `bool` otherwise the changed check failed when comparing values
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
Why have 2 parameters to set the name or ID, surely we would just want to set the name and not worry about the ID. Is there a benefit to using the ID over the name, if not then this should just be removed.
You still have SDK speak in here like `serviceLevelObject`
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
```suggestion commit: no ```
```suggestion - name: Update all filesets to latest level from lpp_source lppsource_aix6109-06 ```
```suggestion - name: Deallocate all resources from the nimclient ```
unsure why we need mapping, need to look at original bug, the self.deprecate(d) should be able to handle dicts already
in any case, deprecations should always be a list, unsure how a dict is making its way here
ah, nvmd, misread the code, thought you were operating on the 'top level' ... yes it is a list of dictionaries but we allowed for pre-existing string cases
what if msg does not exist?, shouldn't it also be a get
It seems like no_log and deprecation are separate things and should be handled in separate functions.
Ooh, this is a nasty bug - if this wasn't in this PR,I wouldn't have spotted this. If this code happens elsewhere, it'll break when 2.4 goes out (because a now valid key is overwritten by the content of a now missing key)
camel2snake should indeed handle NotificationARNs properly (#25105)
```suggestion # require that the final recorded stack state was ROLLBACK_COMPLETE ```
```suggestion # require that the final recorded stack state was CREATE_FAILED ```
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
Use `to_text(line)` instead.
same here with the collapse
Same here with exception handling collapse. You could use something like `type(exc).__name__` in the string if you don't want the whole stacktrace but still want to know what it was- I'm guessing that's not useful info to an end user, but might be for troubleshooting.
should be superfluous unless you want to add a different command for check_mode support (since `supports_check_mode` is false)
With the removal of `$?` this shouldn't be needed.
so this looks like a problem `shutil.move(b_src, b_tmp_dest_name)`
You could either do an os.path.exists check here to decide based on whether b_src exists or you could abstract the unsafe_writes fallback into a helper method, and then write two try: excepts that target each section of code. If the code fails in shutil.copy2 pr shutil.move then call the helper function with b_src. If it fails in os.rename then call the helper with b_tmp_dest_name. atomic_move is getting rather long so the latter may be the better option.
are you sure this is what we want? b_src should be what we 'tried to copy to b_tmp_dest_name'
but it can also fail here `shutil.copy2(b_src, b_tmp_dest_name)`, so we might just need a flag on 'which to use'
probably want a to_text and u prefix.
SyntaxError ``` lib/ansible/vars/__init__.py:41: in <module> from ansible.template import Templar E File "/home/adrian/src/ansible/lib/ansible/template/__init__.py", line 517 E for k in data.: E ^ E SyntaxError: invalid syntax ```
I believe you need to wrap the exception types in parentheses
As a note, I just remembered that we had to preserve `NativeJinjaText` somewhere else too for the same reason. Trying to `join` a result from a lookup in https://github.com/ansible/ansible/blob/bf7d4ce260dc4ffc6074b2a392b9ff4d3794308b/lib/ansible/template/__init__.py#L1057 led to losing the type so we had to explicitly convert the result of `join` to `NativeJinjaText` (and further make it unsafe to `NativeJinjaUnsafeText`).
I think we should add an `allow_overwrite` or similar param.
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
For the author information we normally only keep name and GitHub handle.
Same for other description.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
```suggestion - The certificate in PEM format. ```
This will fix the testcase.
This does not need to be wrapped.
I blame my `black` setting.
This does not need to be wrapped.
This does not need to be wrapped.
Please remove this line
Mutually exclusive with I(domain_search).
Mutually exclusive with I(domain_name).
Please remove this line.
Please remove this line.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
My point is the self.credentials may not has a key named 'tenant' if not login
No update supported? As far as I know, the `azure-cli` supports update
Seems this is a list of `AccessPolicyEntry`, how about I want to have more than one `AccessPolicyEntry`
define a `poller` and `get_poller_result(poller)` as response
When using format, you will need to specify the index `{0}` so this would still work with Python 2.6
cool - I removed the line about how it used to be hardcoded and changed the note about whitelisting
you can just `return True`, no need for a var.
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
```suggestion self._display.debug("recursive_group_vars - Traversing dir : %s with groups : %s" % (path, to_text(groups))) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
Please add `type="str"`
Please add `type="str"`, and maybe list the possibilities as `choices=`.
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
type should be a 'int'
It would IMHO make more sense to move that near the other command, so we can verify both command at the same time.
Lets keep logic striate: you want set password if user already exist: ```if state == 'present': if user: if check_user_password(module, user_name, user_password): module.exit_json(changed=False) else: set_user_password(module, client, user_name, user_password) else: create_user(module, client, user_name, user_password, admin) ``` it's ok but lets look on logic above, you already have ```influxdb = InfluxDb(module) client = influxdb.connect_to_influxdb() ``` and when you call ```check_user_password``` you create another connection to db inside of this function. ```def check_user_password(module, user_name, user_password): influxdb = InfluxDb(module) client = influxdb.connect_to_influxdb() ``` Obviously you can pass to this function client object that was init in main() Next ```try: client.switch_user(user_name, user_password) client.get_list_users() except InfluxDBClientError as e: if e.code == 401: return False ``` why do you use```client.get_list_users()```? it returns a list of users : actually a list-object. I guess you can keep only ```client.switch_user(user_name, user_password)``` Another is about ```InfluxDBClientError``` its already part of InfluxDBClient that we import from influxdb in ```module_utils/influxdb.py``` and if you go deeper in ```influxdb-python/influxdb/client.py``` Any way let me try to work with your code and figure out how we can make this code more clean
take a look on drop_user() ``` try: client.drop_user(user_name) except client.InfluxDBClientError as e: module.fail_json(msg=e.content) ```
keep this but...
Don't need to import HAS_BOTO3 now.
I believe this is defined in the docs_fragment.
```suggestion default: no ```
```suggestion - Whether to remove or define a device including child devices. ```
```suggestion default: no ```
```suggestion required: true type: str ```
```suggestion - Use C(all) to rescan all C(present) devices (AIX cfgmgr command). ```
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
No need for this to be a private method. rename to get_inventory().
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a function.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import find_obj```
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
Format replacement strings with nothing inside of them, {}, are only available in python-2.7 or better. So you'll need to make sure that all your formats have numbers inside of them. For example, this line would then be: `record_ids = client.get('/domain/zone/{0}/record'.format(domain))`
``` ttl=dict(type='int', default=0), ```
You could add here an example to add a record to main A record => mydomain.com
Remove this as it is already declared above.
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Shippable doesn't like this line for whatever reason.
The value should not be quoted.
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
Missing period at the end of the sentence.
I ran the integration tests on this PR and they confirm that the code above works for both flatpak 1.2.0 **and** before. I mean, I like the fact that @JayKayy's solution is super simple. Even if it is possible that flatpak breaks it's output in future again, we don't know if they actually will. So maybe one could regard a solution like mine from #51482 as premature optimisation...
As asked by @gundalow, to avoid breaking compatibility with old releases, you should probably split on either space or tabs.
I'd convert `name` just one time instead of doing it on each iteration.
What if the flatpak name contained the string 'error' ? Seems a recipe for disaster.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
Everything from `for vm in vms:` to line 957 can be moved outside of the loop. Also, instead of computing user_desired_path (which is a bit complex and error-prone IMHO) what do you think of: ``` if not actual_vm_folder_path.startswith("%s%s" % (dcpath, user_defined_dc): continue if user_folder in actual_vm_folder_path: vm_obj = vm break ```
```python if 'name' in self.params and self.params['name']: ```
Then: ``` user_folder = self.params['folder'] slashed_user_folder = user_folder if not slashed_user_folder.startswith('/'): slashed_user_folder = '/' + slashed_user_folder if not slashed_user_folder.endswith('/'): slashed_user_folder += '/' â¦ for vm in vms: â¦ if slashed_user_folder in actual_vm_folder_path: vm_obj = vm break ``` My point/remark/question wasn't about altering `user_folder` but about the `user_desired_path` computation and usage. The important part is that I suggest to replace: ``` if user_desired_path in actual_vm_folder_path: ``` by: ``` if slashed_user_folder in actual_vm_folder_path: ``` Again if you are sure about the user_desired_path computation, that's OK for me.
> For example, user_folder is '/DC0/vm' and actual_vm_folder_path for two VMs with same name is '/DC0/vm/finance' and '/DC0/vm/marketing' and user wants VM with '/DC0/vm/finance' path. So there are chances that user might end up in getting wrong VM if we just use user_folder. I think computation of user_desired_path might decrease this chance. How can you only get the VM in '/DC0/vm/finance' if `user_folder` is '/DC0/vm' ? If `user_folder` is `/DC0/vm` we fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So you get both VM from '/DC0/vm/finance' and '/DC0/vm/marketing'. ################ If you mean to write `/DC0/vm/finance`: If `user_folder` is `/DC0/vm/finance`, we still fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So using `user_desired_path` or `user_folder` is exactly the sameâ¦ I don't get your example.
You should explicit the fact that vm_name is not a string, but a vmodl.â¦ object containing a propSet containing the VM name.
The module has required options, but you don't provide any in this example.
`api_token` parameter is missing.
It doesn't make sense to use `id` parameter with `state=present`. Currently when `state=present` is used and `id` is specified, a new IP with another `id` is created.
Most modules using public cloud providers offer a `validate_certs`/`validate` option[1][2]. I think the same apply here. [1] https://docs.ansible.com/ansible/latest/modules/ec2_snapshot_facts_module.html#ec2-snapshot-facts-module [2] https://docs.ansible.com/ansible/latest/modules/os_volume_snapshot_module.html#os-volume-snapshot-module
nit: I would scope/namespace this to `scaleway_snapshots` to ensure it doesn't overrite another `snapshots` in `ansible_facts` scope
I _think_ we're on the same page now. I initially thought about it as a simple wrapper just as `exec_command` is, but in the end it would have the same signature as `send_request`, so keeping the name would remove a lot of changes from the modules. Then again, we don't have any external consumers of the netconf plugin to my knowledge, so we're not tied to names as much as with network_cli, and renaming the function to make ithe intent clearer might be beneficial.
You shouldn't need `get_connection()` for that, you can just make a new connection to the socket_path and let the gc pick it up it at the end of the scope like `exec_command()` does... there isn't any particular reason to care about which NetconfConnection instance gets the message as far as I can tell.
`check_args` is present in other network platforms for legacy reasons and can be removed here if not used
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Rename this to `get_provider_argspec` to be in sync with other platforms
Hmm, that's pretty inconsistent. So now we got three different choices... :) I guess it's fine to leave it with 1.25.
How about: ```suggestion if not os.path.exists(file_path): continue ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
You can use get_option() instead of accessing the dict directly.
Please remove the default here. ```suggestion iam_type=dict(required=True, choices=['user', 'group', 'role']), ```
Same here. ```suggestion self.cron_file = os.path.join('/etc/cron.d', cron_file) self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict')) ```
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
catch all exception should be avoided
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
I don't recommend going the action plugin route, just make sure description points out that backup is where module executed. backups via action plugins are a bad pattern, now that include_role exists it makes more sense to move to a role.
docs, hint, hint. ~~~diff - "SSHKEYID": "5abf426403479", ~~~
the key is now `id` ~~~ "id": "5abf426403479", ~~~
remove `convert_to='int'`as it does not look like it can be converted.
Yes because this module use this specific API
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
For `mode == 'persist'`, you have to both check the current value *and* the value in the `mysqld_auto` config.
I wouldn't emit this warning. After all, the warning is just saying "the module is doing its job, nothing out of the ordinary".
Why not ```suggestion if mode in ('global', 'persist'): ``` ? :)
How about moving this in the main `if:` branch above? Then there's no need to do funny tricks for `mysqlvar_val` in the `elif:` branch.
I would remove the previous and the current line. If you write `persist_only`, you want to make sure that the variable is set in he `mysqld_auto` config. If it is not set there (but it is set in the running instance), you still want to execute the query.
I think this should be false (not a string)
No need to specify `choices`
Please remove this line.
Please remove this line.
Please remove this line.
Combine line 85 with this line: ```suggestion - May not be used with C(backrefs) or C(insertbefore). ```
```suggestion This behaviour was added in ansible-core 2.14. ```
Don't add this, if the parameter is not required.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
This feels to me like it would be better as a function that would take a dbinstance and convert it to the facts dict, then a separate one to diff dictionaries rather than a class.
These should be using the backoff tools, since I can see folks grabbing facts on large numbers of snapshots.
This doesn't work when list of projects is empty (example: exoscale.ch). It results with following error: `Traceback (most recent call last): File "./cloudstack.py", line 232, in <module> CloudStackInventory() File "./cloudstack.py", line 113, in __init__ data = self.get_list() File "./cloudstack.py", line 178, in get_list groups = self.cs.listInstanceGroups(projectid=project_id) File "/Library/Python/2.7/site-packages/cs/client.py", line 105, in handler return self._request(command, **kwargs) File "/Library/Python/2.7/site-packages/cs/client.py", line 157, in _request response.status_code), response, data) cs.client.CloudStackException: ('HTTP 431 response from CloudStack', <Response [431]>, {u'errorcode': 431, u'uuidList': [], u'cserrorcode': 9999, u'errortext': u'Unable to execute API command listinstancegroups due to invalid value. Invalid parameter projectid value= due to incorrect long value format, or entity does not exist or due to incorrect parameter annotation for the field in api cmd class.'})` It works, when I remove `projectid=project_id` form the API calls.
Perfect. Looks good!
Really not convinced by `show` Might be better to have an ssm_parameter_store lookup plugin for this need.
YAML check doesn't like this: `ERROR: lib/ansible/modules/cloud/amazon/ssm_parameter_store.py:0:0: E313 RETURN is not valid YAML. Line 131 column 83 (75%)` I would propose to change it to: `description: The type of parameter. Valid values include [ String, StringList, SecureString ]`
This needs to go through flake8, two character indents are very weird.
You can import HAS_BOTO3 from ansible.module_utils.ec2
`speed` should be `int`
Could we maybe sort this out so it's easier to see? I mean having something in the lines of {'config': {'options': {'system': And so. It'd be just so much more readable.
Applicable for other iosxr resource modules as well
what is TLV? it might be good to describe it at least once.
iirc other platform use `enable` option to enable/disable lldp
Having said that, I don't believe these two lines are required at all - we should only use multi_zone if it's explicitly set, and let the boto rds2 API handle the default (which it does - if you pass it multi_az=None (it's default), you'll get a non multi AZ RDS instance)
Same suggestion as above. .get() doesn't have to return a Nonetype so you can use it for "port" too.
Missing HostedZoneId here which is important if you want to set a route53 ALIAS record later
Rather than a try/except you could do: `old_port = self.data.get("endpoint", {}).get("port")`
Not required - added by doc fragement
Tiny typo here 'Waitis' -> 'Waits'
don't forget to remove if you change default
A lot of the entries here should be in the description of each relevant option. This is for a high level overview of what the module does. The `notes` entry can also be used for info about the module if it doesn't fit in a option.
This should be a string: ```yaml version_added: '2.4' ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
Do note that this only looks at the primary credential cache. This means that if you use a collection credential cache such as DIR, KEYRING or KCM (default in most distributions these days), you might not see a ticket that exists in a non-primary credential cache. Maybe consider using `klist -A`, or try a `kswitch -p <principal>`? The latter is easier to parse, but might break stuff if people are still using the old krb5 APIs (rather than GSSAPI) and were using the primary credential that you just made secondary.
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
s/run the/run in the/
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
s/./ to avoid infinite hangs waiting for input./
Please put all imports together at the top, and include only the stuff you are using, i.e. ```python from ansible.module_utils.basic import AnsibleModule ```
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
Line is too long.
Line is too long.
This line is too long. Max line length allowed in Ansible is 120 characters.
You've named this check_params in other modules. Not a major issue.
Can be simplified if you do `type='int'`.
Can be simplified if you do `type='int'`.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
This will fail if user provides `int` values. ``` >>> a = 1 >>> a.isdigit() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: 'int' object has no attribute 'isdigit' ``` you might want to add additional check like ```python timezone = self.params['customization'].get(timezone') if isinstance(timezone, int): ident.guiUnattended.timeZone = timezone elif isinstance(timezone, string_types) and timezone.isdigit(): ident.guiUnattended.timeZone = int(timezone) else: self.module.fail_json(msg="customization.timezone attribute should be an integer value.") ```
you force the adapter creation if we don't set ip/netmask, this is wrong. In my usecase we don't use this VMWare device
I thought about it and I would prefer to not set default value for this param. It could be better to explicitly enable joindomain or joinworkgroup.
Just a note that if you are in an environment where all strings should be text strings (controller-only code), there are several better ways to do this: ``` python # If you can require Python-3 only table = str.maketrans('', '', string.punctuation) table[ord(' ')] = None default_name = self.params['name'].translate(table) # If you can require Python-2.7+ table = {ord(c): None for c in string.punctuation} table[ord(' ')] = None default_name = self.params['name'].translate(table) # otherwise: from ansible.module_utils.six.moves import zip_longest table = dict(zip_longest((ord(c) for c in string.punctuation), None)) table[ord(' ')] = None default_name = self.params['name'].translate(table) ``` Just something to keep in your toolbox for the day when you'll eventually be able to use it :-)
Remove "a non-blank"
I think it would be best to refactor `use_old_user_mgmt` to handle all versions manipulation (ie returning a clear string stating which kind of user management we should use, for example `PASSWORD_ONLY` or `LEGACY`, `PASSWORD_OR_AUTH_STRING`, `MYSQL_8_PLUS` ...)
Would it be better to change the logic here to be: ```python query = "CREATE EXTENSION \"%s\"" % ext if cascade: query += " CASCADE" ```
Indentation level of `return` statement need to be increased.
please don't import here, import globally
just return pm.encrypt(password, user) != current_role_attrs['rolpassword']:
This needs to be a raw string (`r'''`) to fix the failing doc sanity check- otherwise it tries to interpret `C:\Users` as a Unicode hex literal. Ah, the joys of nesting escapes across multiple languages... :)
s/run the/run in the/
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Either 'license' has to exist (and be a non-empty list) or non-None 'license_file' is required. https://github.com/ansible/galaxy/blob/devel/galaxy/importer/models.py#L236-L247
'readme' is required. Galaxy artifact import enforces that the field exists when validating the galaxy.yml. Later in the import process, it's verified that the file 'readme' points to exists in the archive (https://github.com/ansible/galaxy/blob/devel/galaxy/importer/collection.py#L102)
This isn't incorrect in this code, but it might be worthwhile to use a different name (`license_id` etc) for the local `license` variable name just because `license` is also a python builtin so some static checkers won't warn if a local `license` isn't defined. (And using the builtin `license` by accident can cause some very obtuse errors and sometimes seem to "work")
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
vms -> VMs
vm -> VM
Below there are more like this, if you'd care :-)
This line does not need quotes. (nitpick)
s/fo/of/ + ('security' or 'distribution')
Indentation here doesn't look right
```suggestion via U(https://www.rabbitmq.com/ssl.html#automated-certificate-generation) and RabbitMQ ``` Also, there recently was a discussion in #ansible-docs about the word `via`; I think the result was to avoid it, since not everyone understands it.
Missing period at the end of sentence.
This should be quoted but please use double quotes.
The value should be quoted.
Why not sort these as well? Would require adjusting `test_laps_password.py` as well, though.
Since dict order is random: ```suggestion choices = ', '.join(sorted(choices.keys())) ```
full fix here: https://github.com/ansible/ansible/pull/29542/files#diff-0c625695bed181c8ccc287e78a55d40eR299
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
from ansible.module_utils.vmware import get_parent_datacenter
+1 for to_text
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Sounds a strange behavior to me to apply the change only on the first matched NICÂ when the definition does not indicate a single object. Either apply change on all matched NICs or fails sounds more logical to me.
I am pretty sure the rest of the code will blow up, since it assumes that `systems_uri` is a string and not an array.
This is just bad. Things are really not that complicated to warrant such complicated block of code. Just split the work into semi-independent steps and chain them. For example: # Collect all ids self.systems_uris = [m["@odata.id"] for m in data.get("Members", [])] # Perform error checking if not self.systems: # No systems available return dict(ret=False, ...) ...
If the `system_id` is not present on the Redfish service, this line will explode, since `systems_service` will not be initialized.
Not catching non-200 responses.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
```suggestion - Windows web apps support multiple frameworks at the same time. ```
```suggestion - Linux web apps support C(java), C(ruby), C(php), C(dotnetcore), or C(node). - Linux web apps support only one framework. ```
```suggestion - Linux web apps support only one framework. ```
```suggestion - C(python) supported value sample, C(5.5), C(5.6), C(7.0). ```
```suggestion - Supported only when I(frameworks=java). ```
```suggestion version_added: '2.10' ```
```suggestion Ansible 2.14 ```
can we keep `delivery_delay` for backwards compatibility? But I don't know if ansible can flag return keys as deprecated.
can be ignored
Use the helper function in module utils for comparison. See AWS guidelines for details.
Yeah, since it isn't being used there either I would probably do that.
`default=None` is the default (can be removed from the others too, along with `required=False`, if desired)
Please remove the default here. ```suggestion iam_type=dict(required=True, choices=['user', 'group', 'role']), ```
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
Please remove this default too ```suggestion policy_name=dict(required=True), ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
ah, then ansible_ssh_port is definitely wrong. I was hoping to get a `ansible_<plugin>_port` to be passed to each plugin w/o having to update play_context into 2.4 cc @nitzmahone
Bump this to `"2.5"` please.
I was thinking `_preload_content` is to get a non-blocking response for the polling below.
As per other PRs, you don't need to repeat the option name.
Since this is more of a special kind of "absent", maybe it would be better to have two "absent" states - absent and purged - since it seems odd to be allowed to specify "present + purged=true".
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Lines [434,441] are just plain wrong, since Redfish standard mandates that new user (or any other resource) is created by POSTing payload to the proper collection's path (`ManagerAccountCollection` in this case specifically). The returned response body and `Location` header will contain OData id of the user that is automatically generated (reference: http://redfish.dmtf.org/schemas/DSP0266_1.5.0.html#create-post-a-id-create-post-a-).
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
The following two items are inherited from skydive_capture. They should not be here
Please add `alias: ['trunk_vlans']` Bit confusing that the primary name is `trunk_allowed_vlans` though you use the aliased `trunk_vlans` in the examples.
Perhaps change to `ONLY` to make that statement stand out a bit more
Please include an aggregate example
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
I'd like to see some sanity checking in here to ensure the resulting `self.cloudforms_suffix` value contains a `.` character at `self.cloudforms_suffix[0]` and raise an `AnsibleError` exception if it does not. Otherwise I think this looks good.
https://github.com/ansible/awx/blob/9dbcc5934ee1a5774cec58b8f4ce08bea777dd7e/awx/main/migrations/_credentialtypes.py#L126 I can't figure out what happened to the names in this case. Oh, but credentials are `CommonModelNameNotUnique`. So the one thing that's clear is that this case is pretty hopeless.
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
No need to compile explicitly, `re` will hold compiled cache internally anyway.
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
ok, as pointed on irc, that's verified by check, so that's ok.
Wouldn't it be better to let `openssl dhparam` write into a temp file, and on success move the temp file to the real file (with `module.atomic_move()`)? Then in case of interruptions or errors, existing destinations wouldn't be trashed (except of course if `atomic_move` itself goes terribly wrong).
When this message is printed, it will contain a newline followed by a lot of spaces. You should compose it as follows: ``` .py module.fail_json(msg=('For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. ' 'Attempting to use bit lengths under 1024 will cause the module to fail.')) ```
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
Strange default. I would simply remove it.
This is implicit for parameters. Unless it is required, you don't have to add anything.
Why would you default to an empty string here ? Is an empty string actually useful ? The default is None, which is a good default so you know it was set or not. Simply remove this for the "default" default.
Please remove this. It is wrong. Don't add a default in this case.
Remove this. But do add: ```yaml choices: [ absent, present ] ```
`payload_from_wished_lb` could be called once.
Mention the unit (seconds), same for the same for `wait_sleep_time`.
This method is unused and must be removed.
test of `wait` parameter could be moved inside the `wait_to_complete_state_transition` method.
`creation_response.body` is empty I propose to use: ``` "%s: '%s' (%s)" % (creation_response.info['msg'], creation_response.json['message'], creation_response.json) ```
Same here, move it down the stack.
Move it down the stack.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
Not sure if this piece is doing exactly what you expect in all cases.
```suggestion - The VM to use as the source (template). ```
```suggestion - Will also define the VMs hostname. ```
```suggestion required: false type: str ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
Maybe better? Not certain, but I was running into the same error of `ERROR! a bytes-like object is required, not 'str' ` before making this edit ``` process = Popen(["sops", "--decrypt", filename], stdout=PIPE, stderr=PIPE, encoding='utf8') ```
``` ansible 2.8.1 config file = /Users/mhume/ansible-sops-roles-test/ansible/ansible.cfg configured module search path = ['/Users/mhume/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/local/lib/python3.7/site-packages/ansible executable location = /Users/mhume/Workspace/ansible/bin/ansible python version = 3.7.4 (default, Jul 9 2019, 18:13:23) [Clang 10.0.1 (clang-1001.0.46.4)] (ansible) ```
https://github.com/mozilla/sops/blob/afd073a5be0fe2232d7cd345b9b30edc70ccb962/cmd/sops/encrypt.go#L32 ```suggestion class SopsFileAlreadyEncrypted(SopsError): ```
```suggestion if exit_code in sops_error_codes: ```
I thought of something slightly different, but this is also much better. It also reduces the number of exceptions to a way shorter list.
Same for minor_api_version and rest.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
`validate_certs` and default should be `true`
I believe using `utf-8` by default will be ok for this.
Please add `, no_log=True`
`Undefined variable 'AnsibleModule'`
Not required with AnsibleAWSModule
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
```suggestion disk_result[property] = device[property] ```
Not catching non-200 responses.
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Useless loop that can be merged with the next one.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
a module should never end in exception, it should use fail_json instead (you can pass traceback info if needed in 'exception' key)
as explained in related ticket, catchall exceptions are not the best way to handle user errors
do not log due security concerns
catchall exception, does not give us good idea of exact action that was being attempted on the module's side, unless the underlying API is very friendly/precise we normally prefer to do specific exception catching closer to the source of the exception so we can tell module user what was being attempted i.e `failed to change name of schedule: %s' % e`
replace with fail_json() to show a user friendly error message
I'm not sure why you use exact index slices. Are they always this size? I'd say that it's much safer to do `.split()` and that work with chunks: ```python vlan_id, name, state, interfaces = [v.replace(',', '').strip() for v in current_line.split()] ``` please also note that in python we use so-called `snake_case` for variables, as opposed to `camelCase` (like in java or js)
Oh, I see. `run_commands()` runs list of commands and returns list of results.
This currently does not handle lists of items. We need to support it here.
just a small typo, serached->searched
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
You don't need to state default=None as this is the default value.
You can remove `required=False` as that's the default.
Please put this on a single line. Lines can be 159 characters wide.
You don't need to state `default=None` as this is the default value.
Please put this on a single line. Lines can be 159 characters wide.
Imported but unsed
you might want to hint at which versions of requests you require, as it varies wildly across systems.
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
May want to use the configparser in 'ansible.compat.six.moves.configparser' here. Otherwise there are py2/py3 compat issues.
timeout isn't defined in `argument_spec`
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
If you turn this into ```suggestion if not os.path.exists(collection_output): _build_collection_tar( collection_path, collection_output, collection_manifest, file_manifest, ) return ``` you could reduce some nesting which improves readability.
```suggestion b_colldirs = list_collection_dirs(coll_filter=coll_filter) ```
That's a really interesting piece of information I did not know.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
Same here, move it down the stack.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
Move it down the stack.
Not sure if this piece is doing exactly what you expect in all cases.
> would it make sense to publish this module as is (with dependency on unicon library and support for local connection type) as a short term solution and plan how to replace it with network_cli connection as a long-term plan and do it as a part of the next release? Yes, that should work IMO. FYI Ansible follows 4 version deprecation cycle that is if the code (options) available in a stable release is deprecated it can be removed after four releases, typical Ansible release cycle is around 4 to 6 months.
`Manage Cisco NSO configuration and service synchronization`
Fixed in https://github.com/ansible/ansible/pull/34186
Let's see if anyone else complains about that when reviewing ;)
I know, but I had the impression that there was a tendency to switch from `true`/`false` to `yes`/`no`. But maybe I'm also mistaken.
Use existing methods from `module_utils/vmware.py`
```suggestion self.module.fail_json(msg=to_native(e)) ```
```suggestion ip_pool_assoc = vim.vApp.IpPool.Association() ```
```suggestion ip_pool_data = vim.vApp.IpPool() ```
What happens if we have multiple IP pool with same name. In the past, we have seen a lot of issues due to the same name objects.
`# In case of wait=false and state=running, waits for VM to be created`
please add spaces around '=' operator
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
host_storage.type == otypes.StorageType.FCP
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
```suggestion - Add, delete and modify an IPA Password Policies using IPA API. - Omitted values are not changed during module execution. ```
```suggestion description: - The priority of the policy (higher number means lower priority). - Ignored if C(group=global_policy). ```
```suggestion description: State to ensure. ```
```suggestion - name: Ensure that /exports/nas key in auto.direct map is absent ipa_automountkey: ```
Add another example with `ipadefaultemaildomain`
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please test if `default=False` is the default value when using type `bool`.
type is a keyword and shouldn't be used
instead of: ```python servers.update({header_list[2]: server_entry}) ``` it is more efficient to call: ```python servers[header_list[2]] = server_entry ```
see remarks in the yaml section
no need for this mapping, you can change the current config dictionary to be aligned with the required config or vise-versa
you are calling ntp_peer.get("ip_or_name") too much times call it once
Yes, 'msg' key and value should always present on *_exit() calls
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
oh got it, I had it backwards. The goal here is to create a credential from data on the managed node.
Not convinced we need this example, particularly with `with_` going away.
`pipes.quote` is deprecated in Python 2.7 already. You should import `shlex.quote` if available. try: from shlex import quote except ImportError: from pipes import quote
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
When this message is printed, it will contain a newline followed by a lot of spaces. You should compose it as follows: ``` .py module.fail_json(msg=('For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. ' 'Attempting to use bit lengths under 1024 will cause the module to fail.')) ```
Thanks, that's the point I want to get. Your code is consistent among 2.x and 3.x, because `for line in f` returns `line` consistent with `r''`.
This portion is wrong. On python3 it doesn't do anything (because line is already text). On python2 it makes a byte string pattern compare to a text string. If there's no nonascii characters I think that will work okay but it will definitely fail to do the right thing if nonascii does creep into the data.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
copy-paste issue: we should talk about **realm** object here, not a _client_. To be globally replaced in this file...
ditto `s/client/realm` :wink:
Little :bug: : In **check** mode, the `keycloak_realm` always returns `result['changed']: True` You need to add something like `result['changed'] = (before_realm != updated_realm)` here...
ditto `s/client/realm` :wink:
CloudFormation Applies to multiple places
That would be ```suggestion version_added: '2.8' authors: ```
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
```suggestion ANSIBLE_METADATA = {'metadata_version': '1.1', ```
```suggestion - David Taylor (@djtaylor) ```
Spelling. Should be "partition"
Needs a period at end of the description
Since we're now targetting python-2.6+ we can just ```import json```
You can remove these imports except ec2_argument_spec
`read-onYly` should probably be `read-only`
Do you need expiration to be an int type as well or is it okay if it is a string repesentation (like: "10" )
I thought this initially too, looks like @sbj-ss is relying on the `if e.response['Error']['Code'] == 'NoSuchEntity'` for that use-case
is `ts` well known word for Traffic shaping? If yes, then I am ok. Otherwise, key name can be `traffic_shapping` or something similar.
as someone using this module, i would be surprised if the behavior when creating a new alert profile A, a separate unrelated profile B disappeared. a different way of saying this is if the product ships with profiles X and Y, then while creating a new profile A, i shouldn't have to provide (or know about) X and Y to the ansible module call when all i want to do is create/edit/delete my own alert profile A.
I absolutely did misunderstand then. For the primary use case, I think we do want an Ansible call to create/update profile X with alerts A and B to make sure that only alerts A & B are associated with profile X. There is an edge case where we may want to surgically append/remove alerts from profile X, but I don't think it is critical to support this use case at this time.
That may have to be `*string_types` and `list(string_types)`. Maybe create `string_types_list = list(string_types)` so you avoid recasting to a list multiple times.
@chouseknecht thanks a bunch, it makes sense to me. FWIW, I'm happy to help with the maintenance of the openshift client too. I'd like to help keeping the ansible module and the openshift client aligned with upstream kubernetes.
You appear to have dropped `Element`
I think I'd trim it right here rather than in tests ```suggestion """.lstrip() # noqa: E501 ```
aws_ip_ranges -> aws_service_ip_ranges
profile_name is mispelled (and there is a missing quote after profile_name as the tests suggest). No need for two spaces after the full stop.
Once we have a client, I don't think we need to handle this exception again.
I can't see an import for camel_dict_to_snake_dict
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
boto3_conn now handles region problems, no need to do it in the module
Please import only what you need, rather than `*`.
boto3_conn now handles region problems, no need to do it in the module
Not required with AnsibleAWSModule
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
This should not be removed.
This should probably be `docker.exec_command()`
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
s/write target file {0}/fetch file to {0}/
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I'd also include a check for server errors (500)
If the result was a 4xx or 5xx then I think this fails.
```suggestion def _post_request(self): ```
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
Also probably put that in the examples, for if users want that behavior but maybe don't know about `failed_when`.
It'd be better here to catch boto exceptions & other exceptions separately, since generic exceptions (like IOError if the network fails, for example) don't have status codes and other boto-isms.
Instead of infinite checking, please cap the amount of time to some (can be long) value. 5 or 10 minutes would be *plenty* for CFN to generate a changeset.
```suggestion # require that the final recorded stack state was CREATE_FAILED ```
Also, this would break while deleting a stack without providing a template.
```suggestion - "blkid (when I(label) or I(uuid) options are used)" ```
```suggestion - "With this option user can identify the LUKS container by UUID. ```
You can also use `I(...)` here.
I can add that in a subsequent PR, so we don't have to delay merging because of this :)
Yep - I'm not against the _notion_ that it be possible, it just shouldn't be possible _accidentally_. Most LUKS containers I've worked with only have one key on them, ever.
I think that relies on too much internal implementation details, and could be problematic down the line, if some change was made to not silently pop `None` from commands being executed. Should probably do: ``` cmd = [self.module.get_bin_path(command_name, True)] if self.force: cmd.append('-f') cmd.append(self.name) ```
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
The `type` value should be quoted: ```python force=dict(type="bool", default=False) ```
Line is too long.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
You want to swap these conditionals, so that check mode can actually report anything. `load_config()` should be the only thing gated by `if not module.check_mode`, that way the result is correct
Use `msg` instead of `result` attribute ```suggestion msg='Successfully created service %s' % service) ```
The return msg should be indentical in normal and check mode
Use `msg` instead of `result` attribute ```suggestion msg='Successfully updated service %s' % service) ```
Use `msg` instead of `result` attribute ```suggestion module.exit_json(changed=True, service=remote_service.attributes, msg='Successfully deleted service %s' % service) ```
This would be handled by the `AnsibleAWSModule` ```python try: import botocore except ImportError: pass # handled by AnsibleAWSModule ```
You should use `AnsibleAWSModule`, it has a lot of helpers around boto3
This will be handled by the `AnsiblleAWSModule`
You can remove these imports except ec2_argument_spec
snake_dict_to_camel_dict can be removed.
The Base64 decoding can be hoisted out of the loop
- You are producing a hex-encoded digest, decoding it back into binary, then encoding it as hex again. - `encode('hex')` (or rather the `hex` codec) is pretty nasty to use, as codecs as supposed to work with Unicode strings. (I suspect that's why you end up doing the encode/decode/encode dance) What about this: fingerprint[algo] = ':'.join(pubkey_digest[i:i+2] for i in range(0, len(pubkey_digest), 2))
exception classes should be defined after impotrs and constants and before helper functions.
I'm not certain that we want to name this *Module. Just from reading this PR it appears that it will be used more for managing keys and certs rather than managing a program (the ansible module).
Are check, dump, and generate always needed? If so, consider making this an abstractbaseclass: https://docs.python.org/2/library/abc.html
Awesome, thanks for making such a comprehensive post ð
Normally your full name here. Not sure what the policy is on commercially supported modules.
```suggestion - Parameters used for Updating or Deleting subscription. type: str ```
```suggestion - Type of desired protocol type: str ```
Replace line 81 to 97 - with ```yaml - name: Create an event subscription spotinst_event_subscription: account_id: token: state: present id: sis-e62dfd0f resource_id: sig-992a78db protocol: web endpoint: https://webhook.com event_type: GROUP_UPDATED event_format: { "subject" : "%s", "message" : "%s" } register: result ```
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
Ah, I think the point is that `os.remove()` raises an exception if the file isn't there, so `changed` won't be set to `True`.
This is 1:1 the same code as in https://github.com/ansible/ansible/blob/8a671f54ddc5ec114ef807dc71f49d61261d2107/lib/ansible/module_utils/crypto.py#L150-L160
if `self.path` doesn't exist, `self.path + ".pub"` will never get removed.
In case the file doesn't exist, `keypair.check(module)` returns `False`, whence `changed` is set to `True`. I don't think that's correct.
Note -- Looks like you have 'min' as a valid subset but in this current version of the code it's not being used to control whether this is run. Either need to make use of it or remove 'min' as an option so that it's clear that this portion of fact gathering is always run.
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
Better to do this transformation into a list via the setup module's argument spec rather than here.
Change this to `self.ansible_facts['ansible_net_gather_subset'] = list()` as it is `ansible_net_gather_subset` in legacy facts module.
The name as per conventions can be `existing_lag_interfaces_facts` and `get_lag_interfaces_facts`
I made a change to the content description now, @sivel please review
Could you add `.` to the end of the sentence, please.
fyi, its very very ironic i catch a misspelling ...
Maybe add that no checksumming of the content is performed in this case.
What's the behaviour when we are copying a folder, or multiple files? Looking at the code it seems like this only applies when copying a single file and when copying multiple files for going the traditional control -> remote but applies to multiple files when doing remote_src: True.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
Fails since message contains An error occurred (InvalidParameterValue) when calling the ModifyCacheSubnetGroup operation: No modifications were requested.\n instead have if 'No modifications were requested' in str(e):
This is duplicated 15 lines above that ;)
I think this would be more readable if you do: ```python org_id = self.get_org_id(org_name) net_id = self.get_net_id(org_name, net_name, data) path = '/organizations/{org_id}/networks/{net_id}'.format(org_id=org_id, net_id=net_id) ``` So using positional arguments where there's no discussion, moving different operations in separate steps, and bring the information together at the very end. The path-string could be coming from somewhere else (if this is something that is being reused, but probably not relevant here).
Beware that the fourth positional argument has shifted, so if people used this interface using positional arguments it may break. (I don't think there's a risk, as we can safely assume you're the only user of the interface...)
No need for the 'else' here either. The 'if' is the exit statement.
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
So this is not required, if payload=None it will work fine.
In fact, this has been supported since docker-py 1.10.0. There's no need to require docker-py 2.6.0. (https://github.com/docker/docker-py/commit/a75553b3)
(Finally: let's leave the `mode` / optional `name` parameter away and get this merged first; you can then add it in #50428 or a follow-up PR, so that you can use the new `module_utils` Python module.)
```suggestion - When identifying an existing node name may either the hostname of the node (as registered in Swarm) or node ID. ```
```suggestion - Must be executed on a host running as Swarm Manager. ```
One last thing: ```suggestion - Must be executed on a host running as Swarm Manager, otherwise the module will fail. ``` Whether the playbook task fails can be [configured](https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#controlling-what-defines-failure).
This does not need to be wrapped.
I blame my `black` setting.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
My main concern with this is that `futures` is not available in base RHEL, Satellite, or Ansible Engine subscription channels for Red Hat Customers. The only channels I see it currently available in is OpenStack for EL6 and both OpenStack and Gluster for EL7, both which are add-on SKUs and not available to customers who haven't bought those other products.. From a community upstream standpoint, this is perfectly fine. However, if the intent is for this to be used with the product version of Satellite (which I assume it is given the use of the product name in the PR) then that's problematic.
Whoaw, I knew there was an impact, but did not suspect this. This is ugly. cc @kbreit Opened a ticket for this. https://github.com/ansible/ansible/issues/52717
We tend to use HAS_REQUESTS as a standard way of doing this, but... We actually prefer that modules use *lib/ansible/module_utils/urls.py*, specifically **fetch_url()** or **open_url()** for anything HTTP/REST based.
You don't need to specify `default: null` as that is the default.
The json library entered the python stdlib with python-2.6. Code that runs on the controller (which includes dynamic inventory scripts) need python-2.6 or greater. So there's no need to fallback to simplejson here. the json stdlib library should always be available.
could be just `if module.params['dns_domain'] is not None:`
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
Should be interesting to return data to the user, like variables `added`, `updated`, `removed
As long as the input and ouput of the module are in snail_case, I don't see any issue.
```suggestion feed_client_cert: version_added: 2.10 ```
Either C(disk_id) or C(disk_name) is required when C(upload_image_path) or C(download_image_path) is specified.
You should mention that the default value is taken from `client_cert` if that's specified, and that this will change in Ansible 2.14.
Oops, would need to remove this part too. ```suggestion ```
/me hides his sles8 box Still, for other derivatives, it would still be better to not gate it specifically to 'SUSE' dist
Create address service object on PanOS devices This may need updating on existing modules
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
Capital letters & full stops please
`required: false` lines can be removed
No update supported? As far as I know, the `azure-cli` supports update
This shouldn't be set.
When using format, you will need to specify the index `{0}` so this would still work with Python 2.6
Not needed as it is already set to False
My point is the self.credentials may not has a key named 'tenant' if not login
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
``` ttl=dict(type='int', default=0), ```
Remove this as it is already declared above.
Typo. "Allows you to setup rules to quickly and easily block sets of ip addresses."
Perhaps we could add an example to show how to list zones (without filtering).
```suggestion - "You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)." ```
`PyOpenSSL>= 0.15` seems only required for `SelfSignedCertificate`, with other providers older PyOpenSSL versions should work fine: this information could be added here.
This needs to be C(validate_certs) which is the standardized parameter name.
default is no need here
See my point in the non facts module around snake_case.
updated or created isn't needed
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
Add code to check for this and do `fail_json` if needed just after `argument_spec`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
I think a brief sentence is worthy. Nothing is worse than trying something only to figure out the target API on the server isn't compatible. We should try to remember to ask this question of all new modules and substantial changes.
enabled/disabled for this as we are talking about a service (email)
Removing a parameter that people are using will break existing playbooks that depend on it. This is a definite NO-GO.
So the default option in Ansible is named validate_certs and it defaults to 'yes'. So I would prefer we do it like this.
Also, this was added for a specific reason which made the module fail for some users, so removing it will also make the module non-functional for those users. Another reason why this is a NO-GO.
please add `no_log=True` to avoid leaking the password in the logs.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
No update supported? As far as I know, the `azure-cli` supports update
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
My point is the self.credentials may not has a key named 'tenant' if not login
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
My fault, only 401 is handled.
```suggestion vmware_host_snmp: ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
```suggestion msg = "" ```
I would probably go for an immediate default: ```python command = "ps aux" if terms: command = "%s | grep %s" % (command, ' '.join(terms)) ```
You invoke it yourself, so do validation in lookup plugin class
Oh, and in Python we tend to avoid string concatenation with "+"
You'd probably want to do validation as a first thing in the function and then stop caring about checking things. This seems a logical thing to do.
I bet it's possible that this thing raises `IOError`
String or list are allowed here so no change is required.
`author` is a list, so it should be: ```yaml author: - Kairo Araujo (@kairoaraujo) ```
1) There is rarely more than one author. 2) The same principle is used elsewhere in Ansible that you can use either string or list.
```suggestion short_description: Manages AIX devices ``` The short description has no trailing dot, all other descriptions do.
Please order the options alphabetically.
should be list(attr.items())[0] to work with python3 too. ``` An exception occurred during task execution. The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 310, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 280, in main attrs = EcsAttributes(module, attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 131, in __init__ self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 151, in _parse_attrs name, value = attr.items()[0] TypeError: 'dict_items' object does not support indexing fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 310, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 280, in main\n attrs = EcsAttributes(module, attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 131, in __init__\n self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 151, in _parse_attrs\n name, value = attr.items()[0]\nTypeError: 'dict_items' object does not support indexing\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ********************************************************************* localhost : ok=0 changed=0 unreachable=0 failed=1 ```
This should have a blank line before and spaces around the assignment to meet PEP8
Need to use new-style Python 2 classes, as this Py3 class declaration won't behave right in Python 2 environments. Change to `class EcsAttributes(object):`
`import botocore` should be in the HAS_BOTO3 check. I'm not convinced that `boto` is required here - you don't seem to use it at all - can you remove all references to HAS_BOTO if that's the case.
CI failure due to PEP 8 issue: ``` 2017-02-14 22:18:30 ERROR: PEP 8: lib/ansible/modules/cloud/amazon/ecs_attribute.py:52:161: E501 line too long (197 > 160 characters) (current) ``` The PEP 8 tests can be run locally with `make pep8`.
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
Empty proxy-init doesn't make sense and should be removed.
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
```suggestion type: path required: yes ```
There is an inconsistency here, I actually prefer this over the implemented **ucs_port**.
```suggestion type: str default: https://intersight.com/api/v1 ```
No longer need deepcopy
You might want to specify a different error handler here. The default handler is surrogate_or_replace. When non-utf8 byte sequences are encountered, it either uses surrogateescape if available or replace. This can munge output on python2. Since we're sending this to json.loads (rather than displaying it to the user) it might be better to use surrogate_or_strict as the error handler here.
Connection plugins return bytes for stdout and stderr (the callers are responsible for transforming to text or not). So this needs to remain with to_bytes().
It would be awesome if buildah supported copying from a container.
and convert filename to bytes again.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Please modify this to `elif delta.get('peer-link') and not existing.get('peer-link'):`
nxapi will fail here when given a CustomNetworkConfig directly. In order to avoid this, call `.items_text()` before `load_config()` like so: ``` candidate = candidate.items_text() load_config(module, candidate) result['changed'] = True result['commands'] = candidate ```
@trishnaguha Trishna, I reviewed this code; LGTM except for this if block which removes optional (non-playbook) values from the device. My understanding from Mike is that (for existing modules) we should be merging playbook changes into existing device configs. What's your take on this? Thanks
You want to swap these conditionals, so that check mode can actually report anything. `load_config()` should be the only thing gated by `if not module.check_mode`, that way the result is correct
On all your parameters, if there are not required, there is no need to specify the `required=False`. But if they are, you should speficy `required=True`
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
Mutually exclusive is argument of AnsibleModule. ```python module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True, mutually_exclusive=[['username', 'service']], ) ```
add a sample here - ``` sample: { ... } ``
I get error while trying this example ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "ipa_host": "master.ipa.test", "ipa_pass": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "ipa_port": 443, "ipa_prot": "https", "ipa_user": "admin", "ipavaulttype": "symmetric", "replace": false, "state": "present", "validate_certs": false } }, "msg": "missing required arguments: cn" } ```
if requied is true, default does not make sense
host and verify_ssl are common settings in module auth, see other cloud/api modules for same. we normally have auth at module level and optionally at config file/env as options.
this is a bad pattern for a module, change to detect dict or string (assume path)
> set the default to be True (that way user have to force into an insecure setup, that's how other modules work) By default tower-cli will assume True by the same reasoning. The net effect after making that change should be the same.
`required: False` lines can be removed, as it's the default.
you want to put basedir first to match normal precedence
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
This could be less nested once you apply `choices`.
Please dedent this back to keep the nesting sane. It's better to use `continue` to skip it when necessary instead. ```suggestion continue # Display header fqcn_width, version_width = _get_collection_widths(collections) _display_header(collection_path, 'Collection', 'Version', fqcn_width, version_width) # Sort collections by the namespace and name for collection in sorted(collections, key=to_text): _display_collection(collection, fqcn_width, version_width) ```
The `basedir` path will need to be bytes to avoid unicode errors. Something like this: ```suggestion b_basedir = to_bytes(context.CLIARGS['basedir']) collections_search_paths.update([b_basedir]) default_collections_path = [b_basedir] + default_collections_path ``` I did not test this. I'm just guessing from looking at the test failure.
I guess it's best to remove the version number here (and in all the other copies of the config). Not sure whether that should happen in this PR though :)
pyyhon2 -> python2
This can be removed
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
Doesn't seem to be used anyway...
No point adding code to deprecate it in the future, please remove.
``` bd = module.params['bd'] ```
``` tenant = module.params['tenant']` ```
`aci_argument_spec` is now a function and needs to be called like: `argument_spec = aci_argument_spec()`
I would name the method `passwd_set`.
I would remove the emoji here ;o)
You can achieve this same result output with `module.exit_json(changed=True,**camel_dict_to_snake_dict(execution))` which can be imported from `ansible.module_utils.ec2`. That will automatically cover if AWS ever starts returning additional keys from this API and is generally easier to maintain.
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
docs should probably specify that deleting an infinite volume is not synchronous
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
Not possible to glean the volume type from the result of get_volume and choose the right operation automatically? If not, these admonitions need to be in the docs, not in the code...
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
Should have been module.fail_json
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Only import what you need, rather than `*`
Default needs adding to docs
Use `auth_token` to match the parameter name.
There is another way to handle this using ``` fallback=(env_fallback, ['DO_API_TOKEN', 'DO_API_KEY', 'DO_OAUTH_TOKEN']) ``` Check following - https://github.com/ansible/ansible/pull/29179/files#diff-9bd9b34e4d3833b922cb125ccc6085f7R193
Use same `env_fallback` as `X_AUTH_TOKEN`
If you use `env_fallback` then you don't require this check.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
host, username, password, timeout and vdom is already in fortios.py in module_utils
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Same typo as above
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
@sdodsley sounds good, thank you for the clarification
There are no assertions in the integration test to ensure this message is correct.
I was suggesting the ansible core could add an ipaddr argument type and validate it early enough that the concern from @pdellaert would be addressed both here and elsewhere in an easier way for everyone. It doesn't have to be done as part of this PR.
Input validation should be done before doing API calls to fetch information (you already fetch the hosts and the network stacks before we hit this). It's better to fail early and quick...
Why did it even get to the module at all? If there was an ip_addr (or ip_addr_v4, or ip_addr_v6) field type in the ansible core validator for module inputs, ansible would have rejected it before executing the module's main().
This code duplication is also candidate for refactoring.
This should fix the last error that you are getting: ```suggestion type: list elements: str ```
You need `choices` here, too.
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
Can be covered in the `AnsibleModule` instantiation by using `required_if`
`Host group` (copy/paste, i guess)
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Should be a string.
Starts a program is very specific. Why not just: > Run commands in a VMware guest operating system
I'd change this to `Module to copy a file to a VM, fetch a file from a VM and create or delete a directory in the guest OS.`
version_added and default value can be dropped as this is new module.
recurse (boolean): Not required, default (false)
Yes, this should use `AnsibleUndefined` in order to get the recursive Undefined behavior introduced in that class.
Should we use `AnsibleUndefined` here instead? I know there is likely circular imports due to `AnsibleUndefined` existing in `lib/ansible/template/__init__.py`, but I've wanted to move it to `lib/ansible/template/undefined.py` to allow it to be imported more freely.
You may want to drop the `2` from the function name to match the YAML tag
Remove unsafe from the function signature since it's handled by the decorator.
There shouldn't be any difference between octal, hex, and decimal for this case....
You don't fetch anything here but reconstruct broken input. You return a sequence of data, just lazily. So name the function like it would return a list. I think you could go for `_recover_package_names` here.
And, of course, it accepts `names`, not one name.
please note that behavior for non-caught exceptions is to return `None`, so please add another `return False` in the end and maybe replace this one with `pass` or a docstrinig with the explanation.
I'd also turn `name` into `names` because it's a list and variable name should reflect this detail.
> parses `parse`, because it's an action. But I'd go for smth like `get_packages_from_specs`.
Missing full stop
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
It looks to me like these URLs are better suited for a `seealso` section.
This description isn't what is happening in the code. It doesn't determine tags to remove. It just overwrites any existing tags or adds tags if there are none yet.
```suggestion # Copyright: (c) 2016, Loic Blot <loic.blot@unix-experience.fr> ```
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
This is not how it is used, the option used is `--check`.
If it's not required, you can leave out `required: false`.
nothing should use config_data, its only meant for 'extras not covered by get_option', but that is a preexisting problem here
also not needed, add `type: list` to configuration definition, nothing should be added back to config_data
I'm pretty sure this can use `is_sequence()`.
Paginators have a `build_full_result` method you can use, which is a little nicer than nested loops. So you could do: ``` current_executions = resp_iterators.build_full_result()['executions'] for execution in current_executions: if name == execution['name']: ```
I would aggregate both errors here, both 'uptime' and 'cat /proc..'
Allow filters ``` security_groups = cleanProtocol(cloud.list_security_groups(module.params['filters'])) ```
`delete` and `create` are not valid states
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
Remove the two extra double-quotes here.
Please remove this and add a note in the `description:` saying the default port will be based on the connection type, e.g. 80 or 443 for http or https respectively.
`C(api-path-CurrentConfig.json)` for formatting
this should be `backup_filename`
Please remove this line
Please remove this line.
Add Python3 boilerplate ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ```
`You must set C(PUREFA_URL) and C(PUREFA_API) environment variables`
Please use `to_native(e)` [1] instead of `str(e)`. [1] `from ansible.module_utils._text import to_native`
Do you want the same example for all modules? Normally we don't put any examples in `docs_fragment`
this should be `backup_path`
```suggestion - List of assignable scopes of this definition. ```
```suggestion - List of Role Definition permissions. ```
This one is correct.
```suggestion - List of denied data actions. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
s/write target file {0}/fetch file to {0}/
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
Yeah, a list is fine.
Mention the unit (seconds), same for the same for `wait_sleep_time`.
also the recent rule is to have choice values in snake_lower_case format
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
This should be more specific about the contents of the data structure that's returned.
I think this needs to move out one indentation level to match `Field`
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
No need to compile explicitly, `re` will hold compiled cache internally anyway.
You use `re.match` which already checks the beginning of a string. So caret `^` is not needed. https://docs.python.org/3/library/re.html#search-vs-match
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
These tests now run on python 2.7 (though fail on python3 still). I think if we're moving toward using placebo rather than just mocking, it may make more sense to do that here, especially since integration tests won't be run with CI (and running them manually may not happen terribly frequently). Shippable will notice if the placebo recordings lose compatibility with changes made in a PR.
This should have a try/except around it as well, since `dateutil.tz` isn't in the standard library.
Typo in `module_utils`.
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
Move import statements after Line 81 or after RETURN
No, I mean ``` except (vmodl.fault.SystemError, Exception) as e: ```
Also, add ```vmodl.fault.SystemError``` here,
No quote around list members.
Required is by-default set to False, no need to specify.
It's rarely appropriate to catch all Exceptions.
This should be more specific about the contents of the data structure that's returned.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
This is not quite the correct fix. We probably need to use something `os.access()` to check if the file exists and if we can access it: ```python if os.access(b_path, os.F_OK): # checks that the file exists, following symlinks if not os.access(b_path, os.R_OK): # check that we can read the file # probably warn, for now, then change to an error later
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Please change this to 2.5
I think this logic should be handled by service instead of ansible client side
What if the rest service_principal missing client/secret field
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
How about the rest items of `spnprofile`
doc typo, s/funcition/function
I think we should have an entry-check to protect from reuse: ```suggestion def __enter__(self): assert not self.timed_out ```
Looks like `@contextlib.contextmanager` embeds this behavior and this would be enough: ```python @contextlib.contextmanager def timeout(timeout, raising=False): signal.signal(signal.SIGALRM, _raise_timeout) signal.alarm(timeout) try: yield except TimeoutError: if raising: raise finally: signal.signal(signal.SIGALRM, signal.SIG_IGN) ```
this could just return ```suggestion return not self._raising ```
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
values in choices and default for bool should be `yes/no` according doc of ansible. it is a convention by Ansible. `required` should be true/false as it is a flag to show it is required.
I() for key and value
please quote version_added as well to not be a float.
the `f.close()` is implied as part of the with block. Also, I don't think this should be in the module since it looks like a debug statement.
Looks good. You can test this by specifying one but not the other in a task and ensuring you get a sensible error
`PyOpenSSL>= 0.15` seems only required for `SelfSignedCertificate`, with other providers older PyOpenSSL versions should work fine: this information could be added here.
Maybe add an empty line above this one and give it a name, it seems like the `assert` task is just a parameter of the `openssl_certificate_info` one.
```suggestion description: Returns a dictionary for every extension OID ```
as this is the default, it can be left off
Use `U()` for `acme`.
So let's just raise an appropriate exception...
This whole function could be rewritten as: ```suggestion def _validate_catalog_file(catalog_file_name): normilized_file_name = catalog_file_name.lower() if not normilized_file_name: raise ValueError('catalog_file_name should be a non-empty string') elif not normilized_file_name.endswith("xml"): raise ValueError('catalog_file_name should be an XML file') ``` (params arg is not needed, you just always get only params.get['catalog_file_name'] from it)
Hello, this is not golang. Please raise a `ValueError` or a `TypeError` instead of passing a tuple here and there.
Python is a language with encourages clear and human-readable communication. While keeping things short we don't sacrifice keystrokes. fw and nw are misleading for the reader (especially where this thing is called). firewall? northwest? ```suggestion def update_firmware_from_netshare(idrac, module): ```
Please use PEP257 style guide for good docstrings. The title should be a sentence with a period in the end and it should go one line above with one empty line separator from the long description.
Missing full stop.
You can removed all the `required: false` it's implicit
Missing full stop. One all the modules are updates you could raise a single PR to update any reference to another module with the `M(aos_login)` which will insert a link to the online docs for that module. e.g.
You can remove the `required: false` lines, it's implicit
Full stop, rather than comma at the end.
I think most if not all of this can be removed and replaced with argspec code https://github.com/gundalow/ansible/blob/docs-argspec/docs/docsite/rst/dev_guide/developing_modules_general.rst#main-and-ansiblemodule-argument-spec
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
duh :-) Something like ``dict with `msg` and `changed`.`` would be more informative
Can you test this on python3 please? I think python3 needs bytes.
Will info['body'] be json? Might be a string/HTML.
Do you support IPv6, if not then this should say IPv4 address.
`author: Gregory Shulov (@GR360RY)"`
Missing full stop. All `descriptions:` must be full sentences. This applies to a few other `descriptions:` in these modules.
For consistence please ensure all `description:` lines are full sentences (capital letters + full stop at the end)
The example uses `1T`, However later on you have `module.fail_json(msg='size (Physical Capacity) should be defined in MB, GB, TB or PB units')`
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
please wrap in block ``` if __name__ == '__main__': main() ```
Here, you might want to return `out` if `re.findall` returns `[]`
please use explicit imports `from ansible.module_utils import AnsibleModule`
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
You might need to do, if `supports_check_mode=True` ``` if not module.check_mode: response = client.delete_bucket(Bucket=space_name) ``` Same for Create and Update.
`RETURN = r''' # '''`
`EXAMPLES = r'''`
Please make this oauth_token.
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
Catch botocore.exceptions.ClientError instead of Exception here too.
This should be botocore.exceptions.NoCredentialsError.
If this is set to type='int' this should avoid the later type conversion
I think it might be good to have a `purge_roles` option to be able to only enable role_to_remove if desired. I think it's a little confusing that both state: absent and state: present can be used to remove roles. I like the logic in this section (particularly if there was a purge_roles option that works like purge_tags does for other AWS Ansible modules) better than for state absent.
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
You should store the result in a variable (e.g. `self._cryptsetup_bin`).
Don't write `cryptsetup`, instead use `self._cryptsetup_bin` (or whatever variable you stored it into above). Otherwise, calling `get_bin_path()` is pretty much superfluous.
You can also use `I(...)` here.
You also need to store this into a variable, otherwise you can't use the resulting path.
Instead of deriving from `CryptHandler`, why not pass `CryptHandler` as a constructor argument? Otherwise, I don't see why you need both a `CryptHandler` and a `Conditions` instance in the main module code (since you can use the `Conditions` instance for both).
Please can you rephrase this sentence? Something lile ```suggestion - Module doesn't reboot the host after changes, but puts it in output "rebootRequired" state. ```
```suggestion - python >= 2.7 ``` Pyvmomi requires 2.7
I think user can specify specific host from cluster. Cluster and host both arguments should be allowed
```suggestion - ID of the project, get it with U(https://api.ovh.com/console/#/cloud/project#GET) ```
```suggestion - Desired SR-IOV state on interface. ```
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
here you need just a 'steps' not whole module as well.
also please rename entity_id to job_id, no need to have it too generic here
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
use the `missing_required_lib` function from `ansible.module_utils.basic`
In the "Generate privatekey6 - standard - with non-ASCII passphrase" test, this fails with `'ascii' codec can't decode byte 0xc3 in position 16: ordinal not in range(128)`. Stacktrace: ``` File "/tmp/ansible_openssh_keypair_payload_kCnMbD/__main__.py", line 193, in generate tf.write("#!/bin/sh\necho %s" % quote(self.passphrase)) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 706, in write return self.writer.write(data) File "/usr/local/Cellar/python/2.7.12/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py", line 369, in write data, consumed = self.encode(object, self.errors) ``` It seems to fail in all Python 2 tests; in Python 3 it seems to work.
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
This could be `elif`.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
The the formatting argument is single value, it doesn't have to be in braces: ``` cmd += " --format=%s" % p["format"] ``` It improves the readability slightly. The same should apply across the whole code.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
This is not how it is used, the option used is `--check`.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
If it's not required, you can leave out `required: false`.
```suggestion - python >= 2.7 ``` Pyvmomi requires 2.7
Please can you rephrase this sentence? Something lile ```suggestion - Module doesn't reboot the host after changes, but puts it in output "rebootRequired" state. ```
I think user can specify specific host from cluster. Cluster and host both arguments should be allowed
```suggestion - Desired SR-IOV state on interface. ```
```suggestion num_virt_func: ```
``` result = dict() ```
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
There's a lot of copying going on here as well. Both on this line and on line 456. Copying is slow so you want to eliminate any that aren't needed.
This will fail if ```updated_list``` has items which are not present in ```original_list```. You probably want something like this instead: ``` python merged_items[item_key] = items_map.get(item_key, {}) merged_items[item_key].update(item) ```
generate it as frozenset at class level, to avoid hardcoded and redefining per invocation
py3.x-only code; can safely ditch the args to `super()`
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
This line should still be there (though probably one line down), while...
You're not setting the owner of the file until the end of this module (through `module.set_fs_attributes_if_different()`). I'd rather only change the mode to `self.mode` after writing the sensitive data, so that any early abort without cleanup will result in a key only being readable by the user `root` (and not any groups, for example).
I don't see why `chmod` should be necessary considering `module.set_fs_attributes_if_different` is used.
I wouldn't consider it the most elegant code, but it at least has no chance of exposing the private key with a wrong mode. I am not really concerned about in essence creating an empty file first. Performance wise, yes it'll be slower but I bet that the by far limiting factor of this module (next to network latency) is the private key generation, not a few filesystem calls. If this is actually of concern, the `_symbolic_mode_to_octal` function is something that might need a further look to work without a lstat call. For now I'd prefer @abadger's solution in combination with a default `0o600` mode - maaaaaybe even setting the initial mode already in `privatekey_file = os.open(self.path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)` hardcoded to `0o600`.
`0o600` is more readable than `384`.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
Please remove this line.
Please remove this line.
Would be nice to warn the user their configuration is being ignored because the specified value wasn't recognized.
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
The behavior of the inventory script was last match wins but I think first match wins is more intuitive for setting the selection_order variable.
I think this needs to be a dict since it's used as-is in the call to ansible_dict_to_boto3_filter_list().
Isn't paging for boto rather than boto3. This should just use standard boto3 pagination methods including build_full_result() I wrote this long before I understood boto3 pagination!
plugins should not error on import, capture the fact that it is missing the library and exit on 'parse' also see ` from ansible.basic import missing_required_lib` which gives users specific information.
```suggestion version_added: "2.10" ```
```suggestion type: str required: true ```
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
```suggestion choices: [yes, no] ```
```suggestion pn_admin_session_timeout: ```
```suggestion pn_admin_session_timeout: ```
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion cli += ' vrouter-show name %s format name no-show-headers' % name ```
```suggestion - Simple Network Monitoring Protocol (SNMP) to enable or disable. ```
You still don't need this branch ```suggestion ```
You don't need to branch on this, `_connect()` already does the check.
```suggestion "Error: " + to_text(err)) ```
```suggestion "Error: " + to_text(err)) ```
```suggestion except Exception as err: ```
```suggestion system = to_text(platform.system(), errors='surrogate_or_strict') if system == u"OpenBSD": ```
So, this doesn't verify anymore that user is set, unlike the previous PR, I think that should be corrected.
The other unit test failure is due to a difference between `uuid5` on Python 2 and Python 3. In Python 2, `uuid5()` needs `bytes`: ```python def uuid5(namespace, name): """Generate a UUID from the SHA-1 hash of a namespace UUID and a name.""" from hashlib import sha1 hash = sha1(namespace.bytes + name).digest() return UUID(bytes=hash[:16], version=5) ``` In Python 3, it converts to `bytes` so you can pass in `bytes` or text: ```python def uuid5(namespace, name): """Generate a UUID from the SHA-1 hash of a namespace UUID and a name.""" from hashlib import sha1 hash = sha1(namespace.bytes + bytes(name, "utf-8")).digest() return UUID(bytes=hash[:16], version=5) ``` ```suggestion # uuid.uuid5() requires bytes on Python 2 and bytes or text or Python 3 return to_text(uuid.uuid5(uuid_namespace, to_native(string, errors='surrogate_or_strict'))) ```
Then it is not secure. CTR mode requires an unpredictable and unique value as part of the counter. Previous code was correct in taking the full IV from PBKDF2 output.
yes, and the best way to make sure that the key-IV pair does not repeat when you can't have a full list of all IVs used is to use random values in both random seed for PBKDF2 is not enough, it just makes the key random, not unique
Removing these lines will re-break: https://github.com/ansible/ansible/issues/24169
this is incorrect, the caller is specifically asking to use shell
Do not move this. You may want to remove setting shell = True in the above conditional block, though.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
the shell itself would have done it before. but might have done it slightly differently.
Anyway, it's probably best to wait until #61603 is merged and then change this.
This will collide with #61522. Also, you should use a similar approach as in there, i.e. don't do an `if` with two copies of `self._run_command()`, but collect the options in a list and then finally call `self._run_command()`.
```suggestion if type is not None: ```
You also need to store this into a variable, otherwise you can't use the resulting path.
Yes, that's a better solution. BTW, why not put all functionality calling `cryptsetup` into `CryptHandler`, and giving `ConditionsHandler` a reference to `CryptHandler` for the calls it needs to do? Then there's a more clear separation into `CryptHandler`, which does all the `cryptsetup` calls, and `ConditionsHandler`, which contains most of the decision logic.
This is more efficient: ```suggestion key = next(iter(old[0]) ```
This assertion doesn't make sense: you're testing whether your fixture returns a Mapping instance which it always does. ```suggestion ```
No in docs
```suggestion assert ansible_json_encoder.default(m) == expected ```
`msg="'%s' device group not found in Panorama. Is the name correct?" % devicegroup)`
Sound, sound sensible
`IP` `Netscaler` - Applies to a number of places `Nitro` - Applies to a number of places
`Ansible control node` (Capital and remove double space)
Each example task should be a continuous block, please do not have blank lines between sections
`, no_log=True` here please
This is not [duck typing](https://docs.python.org/2/glossary.html#term-duck-typing), and is actually considered an anti pattern in Python. In python the general rule is [EAFP](https://docs.python.org/2/glossary.html#term-eafp) Catching the `AttributeError` is the preferred means of achieving this behavior.
I don't think I would have a problem with adding that information to `-vvv`. That is fairly typical style.
that is what orig_exc basically does, chaining it to any other tb in chain
Note that we've moved to asking people to use literal notation for empty dict, list, etc a few years ago.
```suggestion _vars_sources = {} ```
Can you please include `uuid` as parameter for finding VM ? you can use `find_by_vm_id` API for finding VM using uuid just like other VMware modules do.
no need to wipe `self.nic`, but return the nic you just have (or, in check mode, would have) removed. this functionality is required for integration testing.
add `return self.remove_nic()`
missing `if not self.module.check_mode`
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
That will come soonish, I hope. Whenever all more pressing things are done and I find time to work on my version_added PR again ;)
The schema check works correctly. (Which isn't necessarily the way you expect it to work :) ) The problem is the `author` function, which crashes for some inputs. It must not crash, and either return normally or raise a proper error like `Invalid`.
I think it's better to have `if not isinstance(line, string_types): continue`. That way all crashes are prevented, and not just the special case when `author` is `None` or a list containing `None`. The schema itself already checks whether `author` is either `None`, a string, or a list of strings, and will report everything that is none of these.
`None` is a valid value for `author` though, according to the schema. If the schema is correct, no error should be reported for the redshift module - or at least not for `author`. Once `version_added` is checked for collections, it would have complained about that one, since `"1.0.0 - \"Jens Carl (@j-carl), Hothead Games Inc.\" - \"Rafael Driutti (@rafaeldriutti)\""` is NOT a valid version number.
This PR adds `version_added` validation: #70869. It was already there for module options and return values, but not for the top-level `version_added` of a module in a collection.
i would add `: %s` and to_text(e)` to the end of msg
The try: except will lead to tracebacks on python3 as non-utf8 text will be left as bytes and then the byte strings will attempt to be combined with text strings later in the code on python3.
The file is opened in binary mode. So there's no reason to try converting here as data is already bytes.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
the shell itself would have done it before. but might have done it slightly differently.
use self._task instead (play_context is not updated per loop item)
can be removed, the call to 'supper' below already takes care of this
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
```suggestion version_added: `2.10` ```
There's a hanging PR implementing it in a nicer way: https://github.com/ansible/ansible/pull/44110/files#diff-d4702ee9f9f2977f8c82cb5b4e8b0e26R221. You may want to try borrowing some ideas from there.
You may try
don't leave a file descriptor open. use a context manager (via `with` block)
wrap these pieces of code into two try/except statements to be precise with what you're trapping. 1) one around with-block (with readfp call) catching `IOError` 2) the other one around creds dict constuction catching `configparser.NoOptionError`
As a note, I just remembered that we had to preserve `NativeJinjaText` somewhere else too for the same reason. Trying to `join` a result from a lookup in https://github.com/ansible/ansible/blob/bf7d4ce260dc4ffc6074b2a392b9ff4d3794308b/lib/ansible/template/__init__.py#L1057 led to losing the type so we had to explicitly convert the result of `join` to `NativeJinjaText` (and further make it unsafe to `NativeJinjaUnsafeText`).
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
You need to check the requirements (PyYAML and GlusterFS > 3.2) there.
`changed=True` would be better.
`force` parameter: use boolean type
According to https://setuptools.readthedocs.io/en/latest/setuptools.html#using-a-src-layout, the old version should be enough... Does it cause problems for you? ```suggestion package_dir={'': 'lib', ```
Hm.. This looks wrong
On slack, sivel had the idea that we can check whether setuptools supports these features and only add them to the call to setup if they're available. That sounds like a good idea to me. I don't know of an easy way to do a feature check with setuptools so you may have to figure out the version of setuptools that each of these showed up in and do a version check instead.
I lean towards this but am a little conflicted. With older setuptools, these will issue UserWarnings, for instance: ``` /usr/lib64/python2.6/distutils/dist.py:266: UserWarning: Unknown distribution option: 'project_urls' warnings.warn(msg) ``` I think some of our users will complain but I like the additional information it will upload to pypi... I'll ask on the core slack channel and if any of the other core team members have a problem with the tradeoff.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Fair engough. Then, if I haven't overlooked anything, there is no need to pass `privatekey` to `_check_signature()` as you can call `csr.verify(self.privatekey)` directly.
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
It might be also interesting to see if it would fail though.
This check doesn't work as-is and raises issues when running the following playbook two times in a row: ``` --- - hosts: localhost tasks: - openssl_privatekey: path: /tmp/private.key - openssl_csr: path: /tmp/csr.csr privatekey_path: /tmp/private.key commonName: www.ansible.com ``` This is due to the fact thatthe current code relies on `expected` being an array when it could be actually None, hence raising: ``` TypeError: 'NoneType' object is not iterable ``` Here is an alternative implentation that did what was expected, feel free to modify adapt/modify/get ideas from it: ``` usages_ext = [str(ext) for ext in extensions if ext.get_short_name() == extName] if (not usages_ext and expected) or (usages_ext and not expected): return False elif not usages_ext and not expected: return True else: current = [usage.strip() for usage in usages_ext[0].split(',')] expected = [long[usage] for usage in expected] return current == expected ```
It would be awesome if buildah supported copying from a container.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
we want want -> we want
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
I think it would be more helpful to the user to show them both errors by default rather than hiding one in `-v`. Ideally we could have templating errors take precedence over loop errors and only display the templating error first, but that may not make sense in all situations. If we don't want to display both as was done originally, then I'm fine with the current use of `-v` rather than using debug since debug is information overload for users.
Yeah, I had the same problem. I tried changing the exception type raised in `templar.template()` and catching that here, but still couldn't get it quite right. Seems like putting it in `-v` is an improvement over what we have now until we can come up with something better.
we cannot set remote_addr w/o post_validating first
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
Add that the user can specify the backend to use via the ```use``` parameter.
You should mention instead of this that the required API version is 1.24. ```suggestion - "Docker API >= 1.24" ```
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
Also, let's continue the discussion in #51939.
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
How about removing the `docker_` prefix from the return variables, and simplifying the names in general? I would use: - `swarm_facts` or just `swarm` - `nodes` - `services` - `tasks`
```suggestion version_added: '2.8' ``` This is a required fix as it states the first version this module ships with.
```suggestion short_description: Modify AIX stanza files ```
```suggestion type: str choices: [ absent, present ] ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion mode: '0644' ```
@CFSworks didn't got this, why are we creating a group with the Droplet ID, IP or name? I think you made this to keep the old behaviour but I'm afraid ansible will discard hostvars, which are using **_dest_** since they don't match **_do_id_** :/ I didn't tests this and maybe I'm confused.
and here, where actually I got the idea :)
This block is the same in the 3 cases, and assuming that we can use add_hosts, should we simple move this condition to function add_host? Then this can replaced by: ``` self.add_host(group, dest) ? ```
@BondAnthony yes the the entire if condition. No big deal tho.
catchall exceptions make for bad UI, we normally prefer a user friendly message, detailing what failed and hinting possible resolutions vs passing on API messages that are normally only useful to programmers
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion url = "/".join([base_url, index_set_id]) ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion default: False type: bool ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
In general argument_specs should be returned to the caller rather than subclassing AnsibleModule just to add it. AnsibleModule's behaviour could change in the future and subclassing makes it more likely that things would break than if you are simply passing an arg_spec to the module which it then uses to instantiate an AnsibleModule.
May be true but this is general speaking. What behavior specific changes would you expect? Can we possibly test against those? I don't think it is meaningful to duplicate code in n modules when using OOP style.
Please add our boilerplate to the top of this file. One of those pieces of boilerplate makes all classes defined in the file new-style classes. Without it, a class definition which doesn't inherit from object is an old-style class. ``` from __future__ import (absolute_import, division, print_function) __metaclass__ = type ```
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Include a `host=kwargs[Jail.modified_jailname_key]` kwarg when calling `display.vvv`. This will maintain consistency with other calls to `display.vvv` made by the `Jail` connection plugin.
It's important to have the same `host` kwarg value used for all calls to `display.vvv` for the same connection, whether that be the actual jail name or the iocage jail name. As written currently, the `display.vvv` call above is simply lacking the `host` kwarg. It can be added without making any changes to the message displayed.
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
Well, and put the `sys` import first.
Personally I prefer `is_ansible` or `is_ansible_install` as it makes it more obvious the `is_install` is referring to Ansible's install location and not the collection path. I'm not married to it but I definitely had to look at the code to make sure that is correct.
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
For consistency path pruning should be done the same as in the boilerplate test: https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L13-L14 https://github.com/ansible/ansible/blob/60a24bbdaae3a17bf20613810f347bfb8283f306/test/sanity/code-smell/boilerplate.py#L41-L42
Yeah, but does this code works well, when updating some attribute via that? As far as I read it correctly it doesn't.
So we don't wait for empheral VM? I think we should
Also we should still call this in case of check mode, and say whether it will be changed
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
I think it make sense to support running state for ephmeral VM, as well as stopped and absent. which would be same. The code will be more straighforward then without not needed ifs
You should probably mention in the module's description that it currently doesn't support upgrading plugins.
I'm not sure whether upgrade should be another state, or a flag (in the latter case, it's orthogonal to `present`/`enable`/`disable`).
One question is whether `enable` includes `present` or not. There are two philosophies: either `enabled` and `disabled` assume that the plugin is installed, or they install the plugin if it isn't installed. You're currently following the first one. I don't care what you want to do in the end, I just want to mention this in case you didn't knew/thought about the second.
Maybe add at least one more example where a plugin is activated.
I would return an explicit boolean flag which informs whether the plugin is activated or not (for `state != 'absent'`).
Use `to_native` rather than `str()`: ```suggestion cmd.append(to_native(calendar.timegm(self.expires))) ```
``` elif self.password_lock is not None: cmd.append('-U') ``` so we can 'unlock' also
Format the date string here so it's more human readable in the diff: ```suggestion self.changes['expires'] = (current_expires, time.strftime(self.DATE_FORMAT, self.expires)) ```
Looks like this will always report a change. Once the expiration date is removed, `current_expires = -1`, so `-e ''` always gets appended since it passes the first test here and the second test on line 555..
This value is a string in BSD, which means the conditional on line 962 will evaluate to True when it should not. `0.0s modify_user: type(current_expires)=<type 'str'>`
This can be a key-value map with key as the fact name and value as the pattern to be searched for
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
This applies to a few places.
`'get'` is in base_rpc already? ```suggestion ```
```suggestion m = re.fullmatch(r"(?:https:\/\/dev\.azure\.com\/ansible\/ansible\/_build\/results\?buildId=)?(\d+)", arg) ```
It's more about readability than performance in this case. I tend to prefer literals, but if using constructors make things more consistent, then it's fine to stick with that.
nit: Literals rather than constructor. ```suggestion print(json.dumps({"version": version})) ```
These will need to be module parameters if they need to be configurable. Constants are not available to modules.
Modules do not have access to get or set configuration values. An action plugin should be able to check the configuration before invoking the module, but I don't think that is something we're doing with any other modules currently. You may want to bring this up in tomorrow's Network Working Group meeting on IRC to see what thoughts the network team has on this.
bikeshed: its normally cheaper to catch the exception vs testing for attribute every time
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
Use **digital_ocean_argument_spec** form DO utils.
I believe this relates to team accounts. Users are able to create an image for their account and not expose it to additional team members.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
as discussed previously, no such thing "alert policies". every mention of "policy/ies" should be renamed...
If you like to replace `None` with `[]`, it sugguest to change it to `response.get('resources') or [] `. The difference is, currently with this code, `[]` will only returned if there is no `resources` key in `response`
"new" may sound as "to be added", suggest "desired" instead.
I absolutely did misunderstand then. For the primary use case, I think we do want an Ansible call to create/update profile X with alerts A and B to make sure that only alerts A & B are associated with profile X. There is an edge case where we may want to surgically append/remove alerts from profile X, but I don't think it is critical to support this use case at this time.
as someone using this module, i would be surprised if the behavior when creating a new alert profile A, a separate unrelated profile B disappeared. a different way of saying this is if the product ships with profiles X and Y, then while creating a new profile A, i shouldn't have to provide (or know about) X and Y to the ansible module call when all i want to do is create/edit/delete my own alert profile A.
I am not sure if this will work because - if `find_obj` is not able find this object that means it does not exists. If it finds then you will not hit this condition. Let me know if I am wrong.
`if network['type'] != 'static' and ( 'ip' in network or 'netmask' in network):`
`Host group` (copy/paste, i guess)
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
please use explicit import statements
In the `exit_json`, you should also return `changed` and `state`.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
This line is too long. Max line length allowed in Ansible is 120 characters.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
No need for the 'else' here either. The 'if' is the exit statement.
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
```suggestion message_text = self.get_deprecation_message(msg, version=version, removed=removed, date=date, collection_name=collection_name, warn_change=warn_change) ```
+1 to these variables, makes it a lot easier to read, thanks.
I'd keep the original style here: ```suggestion version_schema = { Required('removed_in'): deprecation_versions(), } ```
```suggestion elif date_string.match(self.when): ```
The `bool` is redundant, is it not? IIRC `any` always returns a `bool`
enabled/disabled for this as we are talking about a service (email)
Add code to check for this and do `fail_json` if needed just after `argument_spec`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
You can add the following to `argument_spec` `mutually_exclusive=(['name', 'channel'],),`
Maybe worth adding code to check this and call `fail_json` if it isn't allowed
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
Should have been module.fail_json
What if the flatpak name contained the string 'error' ? Seems a recipe for disaster.
Python 2.6 needs {0}, {1} - empty brackets in various other places too.
This could be `elif`.
The place where the `main()` function is called explicitly does `sys.exit(main(sys.argv[:]))`. So `return 0` should really be here. (And yes, returning nothing is equivalent to `return None`, and `sys.exit(None)` is equivalent to `sys.exit(0)`, but it's still nicer to have an explicit `return 0` IMO.)
```return 0``` and ```sys.exit(main(sys.argv[:]))``` should remain. Keeping those allows the script to return a different exit code on error and isn't unusual or confusing for someone who is used to UNIX programming.
We could add it to other scripts. modules have their own exit points (fail_json and exit_json) which already call sys.exit(1) and sys.exit(0) respectively.
Note though, I wouldn't add to other scripts in this PR.... it's a separate code cleanup from the main purpose of this one (to stop rebuilding already-built docs)
Anyway, removal of `return 0` was not related to the purpose of the PR, but related to my refactoring suggestion. So it fits next to your change :)
```suggestion if fail_on_autoremove: fail_on_autoremove = '--no-remove' else: fail_on_autoremove = '' ```
Shouldn't the default for autoremove be "False" rather than "None" ? (just nitpicking)
```suggestion cmd = '%s -y %s %s %s %s %s %s' % (apt_cmd_path, dpkg_options, force_yes, fail_on_autoremove, allow_unauthenticated, check_arg, upgrade_command) ```
"manual" is a recent occurrence, for older versions it was 'unmarkauto' iirc
```suggestion upgrade(module, 'yes', force_yes, p['default_release'], use_apt_get, dpkg_options, autoremove, fail_on_autoremove, allow_unauthenticated) ```
I would turn `notify_scope` parameter into an instance variable, `self._notify_scope`. That way you don't have to pass it around.
Squashing is fine in this case, I think, if a list of lists is effectively just another way of writing a list e.g. sometimes you might want to do: ``` yum: name: "{{item}}" state: present with_items: - "{{list_of_default_rpms}}" - "{{list_of_custom_rpms}}" ``` You can use union to join the lists of course, but I'm not sure what other use case drives this test that isn't amenable to squashing
Would this ever return false under normal circumstances? Seems like we'd lose items if it did...
which was incorrect solution as the 'non templating' of pause shows
no, jimi-c has alternate solution and we'll probably go with that
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Is there another option than this? If I give the parameters: ``` elb_target_group_facts: names: - validtargetgroup - notatargetgroup ``` and validtargetgroup exists and notatargetgroup doesn't, I'll get back no facts. Not sure if that's desired behavior or easily fixed if not.
Make this: ```yaml type: bool default: 'no' ```
ditto about s/no/'no'/
ditto about s/no/'no'/
This needs a trailing dot. The style police is watching...
If the present/installed options are the same, I'd rather just allow present/absent unless there's a compelling reason to support both.
Nice! Thanks for remembering this :) Oh, I think you just copied this from below!
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
Could this block (520-528) be a method on the AggregateStats class? something like AggregateStats.aggregate_custom_stats(data=result_item['ansible_stats'], host_list=host_list)
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
```suggestion data ```
If data is binary and not textual, then there is a good chance that passing this through to_text will mangle the binary data. I just tested this with a wav file, and it seems to mangle it - the textual headers are intact, but the audio content is garbled. I'll try to think of an alternative for this.
```suggestion return b'\r\n'.join(to_bytes(line, nonstring='passthru') for line in result) ``` (and import `to_bytes`)
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
Please add: `version_added: "2.4"`
The name of that parameter is bad, it's simply âDNS search domainsâ. Perhaps `search-domains`, or `resolvconf-domains` (but then rename `nameserver-addresses` to `resolvconf-addresses`)
Shorten to `mac` or use hyphens consistently (`mac-address`).
I think something like `device-name` would be more descriptive.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
HAS_PYVMOMI is unused.
Python 2.6 is unsupported so we can remove this try-except block.
We can remove this block since Python 2.6 is not supported.
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
Same classname as with the vm-vm rules, not sure if it might conflict/cause issues
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
All of them should be is None IMHO.
0 is technically valid, so this should be `self.prefix_length is not None`
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
its built into display.warnings and display.deprecated
i was just going to mirror the current module.warnings .. module.deprecated and consume it in callback with display.deprecated vs display.warnings
we should actually add a deprecation facility and not use warnings for this (its already on my list)
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
elif on each condition :) this will not change
Don't add `required: false`. It is implicit.
Don't add `required: false`. It is implicit.
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
This needs to be the **repo** parameter, with possibly **name** as alias.
I would simply call this `icon:` There is no other specific icon property for shortcuts.
I mean, you need to test that it properly fails if you raise the correct exception but with the wrong message. The last time I checked in shippable (but could have been as much as a year ago) pytest's match parameter didn't work. If I raised ```TypeError('Incorrect message')``` pytest.raises would have thought it was fine.
(It correctly fails locally, so I am pretty sure that the latest pytest doesn't have the problem. But I don't know if we're still pinning an older version of pytest in shippable which will not handle match right)
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
If you expect this invocation to emit an exception, `assert`ion doesn't make sense here: ```suggestion ansible_json_encoder.default(test_input) ```
changed is displayed as False by default so you don't even need to specify it at all. Can delete this line.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
Formatting nitpick. You can add this to the line above.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
Are these put/post/delete/patch/update methods used anywhere? I don't see uses of them.
You will need to include the OAUTH_TOKEN environment variable also.
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
catchall exception handling isn't very useful as it hides whatever might have gone wrong from sight. I'd probably just call core(module) here. If there is a specific class of errors that you are expecting, then catching those and returning a more informative error message could be appropriate. I often see the following pattern used which isn't so bad: ``` python import traceback from ansible.module_utils._text import to_native try: core(module) except SomeException as e: module.fail_json(msg="Helpful error message: %s" % to_native(e), exception=traceback.format_exc()) ```
I see that the requirements lists python-2.6 as the minimum python version. Unfortunately, format strings in python-2.6 are more limited than in python-2.7 and later. So you need to be explicit about the position in the format args list you are looking at like this: ``` python response = rest.get('floating_ips/{0}/actions/{1}'.format(ip, action_id)) ``` There's a few other places with format strings that have to be fixed as well.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
It might be better to do this check at the beginning of the module, so that in case `list_role_tags` is not available but `module.params['tags'] is not None`, the module fails right away and doesn't start applying *some* changes.
Only do this is module.params.get('managed_policy') is not None
Ping @willthames - other than this validation fix this is good to go.
I don't think you need the `list` here - `for` can iterate over a `set`
`policy` should be added to `argument_spec` to be usable.
> I don't get this sentence. we can say that the storage domain is attached to a DC although it > is not up. What is not UP. The search for the DC is being done using the following search: dc = search_by_attributes(dcs_service, storage=storage_domain.name, status='up') status='up' - We filter the data centers with 'up' status, so you might get an empty DC although oVirt will contain a DC with attached storage domain but not in 'up' status Since you mention that you will use the DC afterwards I suggest to fetch DC without the status filter: dc = search_by_attributes(dcs_service, storage=storage_domain.name) and check if the dc is with 'up' status or not, if it isn't 'up' then we can raise an exception
I see. If you desire to find the datacenter, only for the log, which the SD is attached to , then you should search the DC without the filtering of the status, as so: dc = search_by_attributes(dcs_service, storage=storage_domain.name) Then if the dc is empty then the storage domain is detached and if the dc is not empty, but we got an empty dc with the latest fetch (with DC status = 'up') then we can say that the storage domain is attached to a DC although it is not up. Alternatively, you can fetch the DC and check its status, the same logic which I explained before should apply here also.
I would think to rephrase the message since it suggests that the storage domain is not attached although we search for an active storage, but storage domain can also be in maintenance mode or inactive and still be attached to a DC. maybe something like "Can't bring storage to state `%s`, because no active storage domain found in DC"
Same for VMs.
```suggestion - name: Create an event ovirt_event: ```
just in case there's ever something not starting `/managed/`, safer to use `[0:2]` here. Also, consider extracting this list-of-lists to dict-of-sorted-lists transform to a separate method. After transforming desired & current, `have_same_values_nested_array` would become simple ==, merging would be simpler, and transform back is simple `.values()`.
Are these special cases (and some in the `merge_`) function intended to support None? IMHO it would simplify code to normalize them to `[]` or `set()` in caller.
Is this deliberately different from `merge_values_nested_array(current_managed, managed_filters)` below? Ouch, I see, belongsto is 1 level while managed is 2 levels: ``` "filters" : { "belongsto" : [ "/managed/area/1", "/managed/area/2", "/managed/area/3" ], "managed" : [[ "/managed/infra/1", "/managed/infra/2"], ["/managed/other/3"]] } ``` LGTM :+1:
None **if** no id ...
consider calling these `role`, `tenant` with _name suffix, to match module arguments.
We try to avoid the requests library as it has many issues across older versions and even major incompatibilities across it's own versions, look at using the ansible open_url/fetch_url functions instead.
Two blank lines between two top-level functions, sorry for not explicitly pointing this out before.
not sure if this is useful
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
correct, in any case i would advise using the open_url function that Ansible provides as it deals with many issues that httplib/urllib don't (versions, proxy, ssl, etc) and I would add a couple of options to allow users to deal with custom setups (validate_certs, etc).
Should be "Can't detect any" rather than "none" I think.
```suggestion description: Returns a dictionary for every extension OID ```
```suggestion sample: 3 ```
A sample would be nice I guess, so I know if it is `sha256` or `SHA256` for example.
Maybe add an empty line above this one and give it a name, it seems like the `assert` task is just a parameter of the `openssl_certificate_info` one.
Why do you return something when you are not doing nothing with it in the `main()` function? What about to use `module.exit_json()` only in the `main()` function? The same in other functions.
Do not call `exit_json()` from inside of this function. The function should return the `changed` value and you should use `exit_json()` at the end of the `main()` function.
You can keep the `fail_json()` in the functions. Only the `exit_json()` use from the `main()` only.
This should be on the function level to avoid multiple definitions of the same variable on multiple places in the same function.
You can remove this blank line.
Just style, but a blank lines between the boilerplate and the imports is good ``` python __metaclass__ = type import os ```
we should capture possible import exception and explain that this lookup requires the credstash python library when it fails
this should be in the run method, otherwise ansible itself will fail to run
AnsibleFailJson is not used and shouldn't be imported
You could use: ``` CLIPASSWORDSDK_CMD = os.getenv('AIM_CLIPASSWORDSDK_CMD', '/opt/CARKaim/sdk/clipasswordsdk') ``` or even `ansible.constants.get_config`. `get_config` allows to define a default value and will search a defined value in an environment variable and the config file).
I would omit the 3, it seems like in the internal API you can set as many recovery actions as you want. It's just the GUI that limts to 3.
I would simplify this by saying the list order is the order of actions to take, i.e. first entry is the first action and so on.
In the code, you enforce setting all 3
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
If you enclose this in `EXAMPLES = r'''` you don't need to escape the `\`. Standard practice for all module doc blocks is to use `r''' '''`
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
`Can be configured form the CLI via the C(--user) or C(-u) options.`
`Can be configured form the CLI via the C(--user) or C(-u) options`
`Sets the connection time, in seconds, for the...`
IMO this really should be defined in action_common_attributes, to help ensuring that all collections use the same description there.
```suggestion description: Supports being used with the C(async) keyword ```
also potentially end this block with `raise`
Please change this to `client = self.connect_to_aws(rds, region)`
Thanks for your work on this! It works as expected (although I wish describe_db_instances() could filter by tags as it would be simpler not to filter out the results while retrieving them).
C/P error, should be `AWS ElastiCache is down`? Same on L450
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
Ansible 2.7 dropped support for Py2.6
Presumably you want `It *will* always use`, or something to the effect
...The remote host **MUST** support...
typo... It should be I(text)
Please check this.
Since you're updating the docs, can you update the Examples to use multi-line YAML? ```yaml - debug: var: mypassword vars: mypassword: "{{ lookup('passwordstore', 'example/test create=true')}}" ```
Should be "Overwrite" rather than "override"
I don't recommend going the action plugin route, just make sure description points out that backup is where module executed. backups via action plugins are a bad pattern, now that include_role exists it makes more sense to move to a role.
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
oy, thanks Github
Lines don't need to be wrapped so short since we allow up to 160 characters.
Use a `main()` function for the body of the test.
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
You're checking two separate properties here. This should be in a separate test.
Description should be a full sentance, e.g. starts with a capital and ends with a full stop.
state should be string with choices enabled/disabled
set_state: enabled/disabled in accordance with state
I'm curious as to whether this needs to be in upper case or if it works in lower case as well.
use full names read-only, read-write
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
makedirs_safe already does this, just use that function
I learned recently that you can use actual separate literals to improve readability: ```suggestion @pytest.mark.parametrize(['url', 'expected'], [ ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
instead of forcing templating here, when you don't have task_vars yet, just set run_once based on 'bypass' and then template below in 890 with full task_vars. That way you avoid a 2nd very expensive call for vars and actually get the complete ones (with host).
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
My concern about this really needing to be two modules, one for settings_facts and one for settings, has not been addressed.
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
*be a string
@jainnikhil30 and I took a look at the tower_cli code which is backing this tonight and decided that tower_cli is trying to coerce the types from a schema that it retrieves from the tower server. So it looks like the module code does not have to worry about this conversion.
supports_check_mode still needs to be toggled to False
But that can be addressed in a separate PR :)
This limits you to 1000 hosts where previously it iterated all the pages.
I'd also include a check for server errors (500)
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
If the result was a 4xx or 5xx then I think this fails.
Yes, good catch. We can delete one of the two functions, they are now identical.
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
see previous discussion on renaming idempotently
`display` won't work in module code, hence this line should be removed
Ah. lambda is prettier though :). maybe we can run pep8 with ignore lambda error.
print statement can be removed
`wait_for=dict(type='list'),` (remove waitfor)
IMHO this will always return changed as False. `Changed` should be change according to action module performs.
```suggestion version_added: "2.10" ```
```suggestion C(state=present). This option is no longer required as of Ansible 2.9. ```
```suggestion C(state=present). This option is no longer required as of Ansible 2.9. ```
I think this would be 2.7.
can be ignored
Your code breaks the loop, so it doesn't continue. This assumes that `Datacenters` is always the root folder in all cases, and nothing else above it exists. If that's a certainty, your code is good. Otherwise the question becomes how we should handle something above the `Datacenters` folder
Cool. Let me know results for this.
How about ```Python while True: try: thisobj = thisobj.parent except (IndexError, AttributeError) as err: break if isinstance(thisobj, vim.Folder): paths.append(thisobj.name) paths.reverse() return '/' + '/'.join(paths) ```
This works in both Python 2 and 3. Here are few [tests](https://github.com/Akasurde/pyvmomi_examples/blob/master/compile_path_example.py#L54)
I assume line 916? That looks good for now ;-)
verify length of snapshot_op dict instead of __not_None__ else you will trigger snapshot_op on non absent condition
So most people will declare the VMs that should exist, with the power-state it should be in. If a user then reconfigures the declaration for that VM, and e.g. changes something to the VM, the powerstate will still be stated and he will expect the VM to be reconfigured, and powered on if it wasn't powered on. So yes, the module should be able to reconfigure and change power state in a single call. And because of the above, we should not simply use the result of the set_powerstate function, but we have to merge some of the return values, as was originally done. I think someone changed **vmware_guest**, not understanding people may want to make a change to a VM and setting power state.
This will replace everything in the result dict. This is not correct. I see now that the logic is wrong, and I am not sure when or why this is like this. In all states (except absent) we should perform a reconfigure. That is why in the case of a specific power state, it may not replace the result dict.
I think we should add an additional check to check for this parameter only if powerstate is `poweredon` or `rebootguest` otherwise in other options module will wait for IP address.
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
something like ``` python custom_filters = templar._get_filters() custom_filters.update(e.filters) e.filters = custom_filters ```
:+1: this seems like a sensible approach.
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
facts modules can trivially support check mode (#23107)
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
don't remove the quotes, otherwise yaml parses it as a number, we want string
Thanks for adjusting this! I'll create a PR for the other two plugins.
```suggestion version_added: "2.10" ```
both forms are valid ... string is more descriptive to users (non programmers)
+ type: str
```suggestion choices: [ full list, top sites ] ```
Spaces ! ```suggestion choices: [ absent, present, query ] ```
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
`speed` should be `int`
A couple of commands here would be good.
since xml list is returned this can be modified to `sample: ['xml 1', 'xml 2', 'xml 3']`
Applicable for other iosxr resource modules as well
There's some mixed spaces and tabs here, please remove the tabs and use spaces only.
please keep line length pep 8 compliant
This is no longer relevant.
fObj => f_obj please to respect PEP
`dcpath` probably got to the incorrect context scope
Sorry, hadn't seen this else here, and it's fine to have it like now.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Loop above is useless and can be merged with the next loop.
Again, building dictionary piece by piece makes little sense if we have all required data at hand.
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
You might want to move that in `module_utils` because all lxca modules will reuse it (Then `HAS_PYLXCA` could be moved too).
since `has_pylxca` method is used, `HAS_PYLXCA` doesn't need to be defined here. * [X] Done
Isn't `ImportError` sufficient ? ```suggestion except ImportError: ``` * [X] Done
Which function calls ? `has_pylxca` handles case when `pylxca` Python package is missing.
In order to simplify the code, `main` could call `execute_module` directly (and then `run_tasks` method should be removed), apart from that module behavior seems fine.
```suggestion - "Datacenter to search for given cluster. If not set, we use first cluster we encounter with C(cluster_name)." ```
```suggestion - "Name of Host group to use with rule." ```
```suggestion - "Name of VM group to use with rule." ```
`vmodl` is unused.
```suggestion Class to manage VM HOST DRS Rules ```
Please use `has` in the beginning. Also, I feel like this should be a `@property`.
1. `@property`. 2. It's not an installation command, it's a version spec. 3. You don't need it, as it's stringified automatically during string interpolation, under 3.6.5: ```python In [3]: from pkg_resources import Requirement In [5]: rqc = Requirement('cherrypy') In [11]: '%s ' % rqc Out[11]: 'cherrypy ' ``` 2.6.9: ```python $ python Python 2.6.9 (unknown, Apr 10 2018, 17:32:50) [GCC 7.3.0] on linux4 Type "help", "copyright", "credits" or "license" for more information. >>> from pkg_resources import Requirement /home/wk/.pyenv/versions/2.6.9/lib/python2.6/site-packages/pkg_resources.py:17: DeprecationWarning: the sets module is deprecated from sets import ImmutableSet >>> rqc = Requirement('cherrypy') Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> rqc = Requirement.parse('cherrypy') >>> '%s ' % rqc 'cherrypy ' >>> ```
Apparently, it will not work well under Python 2.6.9. It seems to be requiring you to call `Requirement.parse()` to construct an instance of this class. So we'll need to shuffle a couple of things around to make it work.
please note that behavior for non-caught exceptions is to return `None`, so please add another `return False` in the end and maybe replace this one with `pass` or a docstrinig with the explanation.
You don't fetch anything here but reconstruct broken input. You return a sequence of data, just lazily. So name the function like it would return a list. I think you could go for `_recover_package_names` here.
they don't need to, but can be as long as they are acurate
The the formatting argument is single value, it doesn't have to be in braces: ``` cmd += " --format=%s" % p["format"] ``` It improves the readability slightly. The same should apply across the whole code.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
Please add dot at the end. The same applies to the descriptions bellow.
s/./ to avoid infinite hangs waiting for input./
s/does not do anything/has no effect/
oy, thanks Github
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
s/run the/run in the/
```suggestion # the variable if it hasn't been set by the user already. ```
Please use 'msg' for returned messages, this is a standardized return value.
Just for sanity sake maybe pull out ```python "copr:{0}:{1}:{2}".format(copr_server, copr_user, copr_project) ``` into its own var, since it's duplicated 5 times.
> Would this be better as `if key not in module.params` so we don't capture the case where the user explicitly sets things to `null`? The ansible way for the user to skip an upon is `{{ omit }}`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
eewww .... ... if there is no other way .. fine, but do add in more explicit terms when you say it saves the 'current config' that it MAY also include other changes that are not related to this task.
This may seem obvious, but it'd be nice to add to this doc something like "WARNING: if the stack does not exist, it will be created. If the state is `absent`, the stack will be deleted immediately with no changeset." since I can see people missing that part.
If one sentence is written in two lines, the quotes are required. ð
`required: false` is not needed.
Ditto about the deprecation notice
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
This is more than a docs change.
Do note that this only looks at the primary credential cache. This means that if you use a collection credential cache such as DIR, KEYRING or KCM (default in most distributions these days), you might not see a ticket that exists in a non-primary credential cache. Maybe consider using `klist -A`, or try a `kswitch -p <principal>`? The latter is easier to parse, but might break stuff if people are still using the old krb5 APIs (rather than GSSAPI) and were using the primary credential that you just made secondary.
`Current host '%s' can not be rebooted...`
`Current host '%s' can not be shut down...`
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
> Descriptions should always start with a capital letter and end with a full stop. Consistency always helps.
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
Missing full stop > Descriptions should always start with a capital letter and end with a full stop. Consistency always helps.
I think a brief sentence is worthy. Nothing is worse than trying something only to figure out the target API on the server isn't compatible. We should try to remember to ask this question of all new modules and substantial changes.
You can remove `type='str'` as that's the default type.
I would rather remove this exception here and put it around the `ldap.initialize()` and `self.connection.passwd_s()` above with a more specific error message.
I think it should look like this: ``` python from ansible.module_utils._text import to_native [...] def enable_ds(module, array): """Enable Directory Service""" try: array.enable_directory_service() changed = True except Exception as e: module.fail_json(msg='Enable Directory Service failed: Check configuration: %s' % to_native(e)) module.exit_json(changed=changed) ``` One thing I'm not sure about is how we tell if array.enable_directory_service() made a change or not. Our users generally define Ansible's idempotence as: * they describe the state they want in a playbook task * the module makes the state match what is in the playbook * the module returns changed=True if something had to be changed to achieve the desired state or changed=False if the state was already as desired. This code probably does the first two but it's not doing the last one. I'm not sure how to fix it because I don't know what array.enable_directory_service() does. If it returns a specifc exception if the directory_service was already enabled, then we catch that specific exception and set changed=True for that. If it returns a status code telling whether it had to make a change or not, then we can use that to set changed. If neither of those, we would have to query the current state of the toggle first. If the toggle is already enabled, then set changed=False and call module.exit_json(). If the toggle is not yet enabled, call array.enable_directory_service(), set changed=True, and then call module.exit_json(). (Also note, these notes on changes also apply to the other verbs you have in this module: disable_ds, delete_ds, and create_ds)
I think things like this will traceback in check-mode because changed hasn't been set to a default value (Should default to True). Also, for this particular module, check_mode doesn't seem to be doing anything so you probably just want to say supports_check_mode=False when creating the AnsibleModule.
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
This should be `b_output_path` to indicate it is a series of bytes. Even if the caller is sending in bytes, this function should convert it to bytes just like `b_collection_path` at the beginning. That allows our `b_` naming convention to hold, making this code look incorrect (trying to join `bytes` and `str`).
I'd do this unconditionally.
maybe just ```suggestion part_boundary, b"--", ```
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
How about: ```suggestion if not os.path.exists(file_path): continue ```
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
Use `I()` around parameter names. ```suggestion - I(url) and I(host)/I(port)/I(user)/I(pass)/I(vhost) are mutually exclusive, use either or, but not both. ```
Not sure how the lazy loading of variables, the example would be simpler to just have the one task instead of 2 in the examples. ``` - name: Get 2 messages off a queue debug: msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}" ```
There still are some references to `ampq`
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
Only one space after periods.
`Telemetry data not capture` to `Telemetry data not captured.` as per below.
you should not need to checked disabled, as the plugin itself wont be called at all if true
How about: ```suggestion from ansible.module_utils.parsing.convert_bool import boolean as to_bool try: verify = to_bool(option) except TypeError: # it wasn't a boolean value verify = option # Set to a CA bundle: finally: if verify is False: # is only set to bool if try block succeeds requests.packages.urllib3.disable_warnings() self._display.warning( u"SSL verification of %s disabled" % self.foreman_url, ) return verify ```
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
I have concerns that that will be extraordinarily slow with large results.
I think this will just lead to more errors later (as we're now returning either text or bytes rather than always returning text. @jimi-c is it okay to replace bytes with unicode replacement characters here? If wo, we can just use to_text's default error handler.
dont do this, now we have 3 parsers, we shoudl move parsing/json to module_utils and use from there
if you are using loader, just use `get_file_contents`
task_uuid seems unused
It's just a helper function. So everyone reinventing it would not have to do this again.
Now that #39924 has been merged into devel you can: ```python from functools import partial from ansible.module_utils.common.collections import is_sequence test_list = partial(is_sequence, include_strings=False) ```
Find better var name
Tripple double quotes (`"""`). No spaces around the sentence. Period in the end of the sentense.
@dagwieers `str` is also `Sequence`. So it's either docstring or the check is misleading. You might want to add `and not isinstance(value, str)`
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
```suggestion ``` I don't think you should do this, case is meaningful: ``` max@mde-oxalide % pacman -Q libreoffice-en-US libreoffice-fresh 6.1.3-1 max@mde-oxalide % pacman -Q libreoffice-en-us error: package 'libreoffice-en-us' was not found ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
```suggestion cmd = "%s --query --quiet --explicit --info" % pacman_path ```
`filter(lambda x: x, map(self.validate_query_parameters, self.query_filters))` could be used here (in order to avoid calling twice `validate_query_parameters`).
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
I did think about that yesterday, but since that's called only once, that should be ok. But it could be a good idea to handle the case, in case the code start to do use extract_name more than once.
fObj => f_obj please to respect PEP
Duplicate entry in the list, I guess one need to be removed.
This can also be an ARN, right? In which case the length can be up to 140 characters.
required=False, default=None is default for an argument
get rid of this if it's empty
None is the default.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
plugins should not error on import, capture the fact that it is missing the library and exit on 'parse' also see ` from ansible.basic import missing_required_lib` which gives users specific information.
```suggestion self.endpoint = os.getenv("HCLOUD_ENDPOINT") or "https://api.hetzner.cloud/v1" ```
```suggestion from functools import partial ... def _filter_servers(self): def server_entry_is_valid(s, l, t, i): return ( s.datacenter.location.name in l and s.server_type.name in t and s.image in i ) server_entry_matches_lti = partial( server_entry_is_valid, l=self.get_option('locations'), t=self.get_option('types'), i=self.get_option('images'), ) self.servers = [s for s in self.servers if server_entry_matches_lti(s)] ```
don't raise errors on import, expose them on `parse` see developer docs for examples
Following PEP 257, this should be: ```suggestion """Return the possibly of a file being consumable by this plugin.""" ``` ref: https://www.python.org/dev/peps/pep-0257/
Will this command work on all supported platforms? I tried this patch on mac and it failed. Example I used: ``` - git: repo: 'https://github.com/ganeshrn/ansible.git' dest: /var/tmp/ansible archive: yes ``` ``` TASK [git] ************************************************************************************************************************************************ fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "msg": "Failed to perform archive operation"} ```
@willthames yep, thats the only way I see of doing that, create in tmp dir, md5sum both of them, if match OK, if different CHANGED. Although that does add some complexity.
This is going to bite people if they run this module twice. Ideally, on second run through, the changed should result in False if the archive hasn't changed, although I'm not sure of a particularly feasible way to do this (other than to generate the new archive in a temporary directory and compare the hashes of the archives)
This will fail if the destination exists. Is that the desired behavior? Since it is making a directory, maybe it should check if the directory already exists and if not create it? If it does exist, maybe we should be able to continue onto the archiving step. In addition, here's a hypothetical scenario: if this archiving fails the first time because the user uses an invalid URL to archive this part of the operation will succeed and the directory will be created. When the URL is fixed and this operation will run a second time it will fail here and not be readily apparent why. I think importing traceback and then failing with `module.fail_json(msg="Failed to clone source", exception=traceback.format_exc())` would be really helpful here for future debugging.
Adding traceback (`module.fail_json(msg="Failed to perform archive operation", exception=traceback.format_exc())`) to help here too would be nice, since git archive doesn't always work right out of the box.
```suggestion pvdiplay_cmd_device_options = [pvdisplay_cmd, device] + pvdisplay_ops ```
```suggestion rc, pv_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pv_size"]) ```
```suggestion rc, pe_start, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "pe_start"]) ```
```suggestion rc, vg_extent_size, err = module.run_command(pvdiplay_cmd_device_options + ["-o", "vg_extent_size"]) ```
Line is too long.
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
I would imagine the same issue is possible for other states also, i would solve this in a generic way instead of only for one of them.
Line is too long.
Line is too long.
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
```suggestion # try to get collection world name first ```
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
This should be ` facts['gather_subset'] = list(runable_subsets)`
The subset type has to be of type `frozenset` as the `minimal_gather_subset` is of type frozenset `runable_subsets = self.gen_runable(legacy_facts_type, frozenset(fact_legacy_obj_map.keys())`
`load_fixture()` takes the module name as the first parameter now, so you can lose the `os.path.join()` above and just have `load_fixture('nxos_switchport', filename)`
`No reason given` is fine
Indentation doesn't look right here
Please add `type: bool`.
slience -> silence
` 'metadata_version': '1.0'`
This should be an error by default, created #17902 to allow this to be configurable so this change should be removed from here.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
Ah, I see. Thanks for clarifying!
The `stderr` should be used in the `exception=stderr` keyword. The same applies to all places where you use `stderr` in this module.
This needs to be addressed.
Not really as there might not be any `[0]` and if there is there might not be any `uuid` in it. The right way of checking that is: ``` if len(json_output) > 0 and 'uuid' in json_out[0]: return ``` There is no need for `else:` as the default return value is `None` which is what we want if it fails.
i would use the find_bin function in modules, in case someone decides to move it in the future or run their custom version from a different path
since you use this multiple times I would either make it global to the script or attach it to the module object you are passing
Actually someone can sent for example '123213321321321', which isn't valid name nor ID, so it will fail with HTTP 404.
Check this: https://github.com/ansible/ansible/pull/29175/files If you will do it the same we can close that PR.
@maorlipchuk Can you please use `get_entity` from `./lib/ansible/module_utils/ovirt.py`? ```python from ansible.module_utils.ovirt import get_entity dc = get_entity(dcs_service.service(self._module.params['data_center'])) ``` No need for `try-except` then.
%s is not UP"
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
oh I see, it makes sense then.
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
This should probably be in the same if statement as `if self.state == 'present'`, this way you know the disk exists and so the initial present check is not required and you never really want to run this additional operation if `state: absent`.
Nowadays we list all the functionality we use from a specific library explicitly. So: ```python from ansible.module_utils.basic import AnsibleModule ```
This is handled by `argument_spec`
If you provide non-existing DVSwitch then `self.dvs` will be `None` and module will fail with error saying ``` "'NoneType' object has no attribute 'EnableNetworkResourceManagement'" ```
This should be monitoring for the task to be successful, and if not, exit with a failure and error message (wait_for_task with try/catch and exit in failure)
This is not required if using `super`
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
Should not be quoted. It might confuse people to think this is needed. It is not.
I'd prefer `runlevel` instead of `run_level` in this case. It is a matter of taste obviously.
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
Keep the `r`
I'm not really a fan of this approach, and generally speaking, we have tried to stay away from it. I am more in favor of just doing: ``` try: sock = socket.create_connection(address) except AttributeError: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect(address) ```
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Types are missing above. token, msg and api are of type "str", port is of type "int". So something like: ```python token = dict(type='str', required=True) ... port = dict(type='int', default=80) ``` Please also add check-mode support. In whatever form you think is appropriate (either log messages adding check-mode run, or not sending messages but e.g. still attempt to connect).
check is redundant as you already flagged as 'required'
set this as the default, then you dont need to do checks yourself
Same here - this return should probably be `{items: [{id: ....}, ....]}`
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Shouldn't have `required: true` for things that have a default.
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
Ansible prefers native yaml syntax over the `a=b` notation, so I would keep the old version here.
This doesn't match argument_spec
`action=dict(required=True, choices=['get_status']),` So this should be `required: false`
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
```suggestion EXAMPLES = r''' ```
```suggestion - name: Install latest version of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion - Additional C(installp) flags to use. ```
```suggestion default: yes ```
```suggestion commit: no ```
This function can be removed altogether. Change calls to `_create_connection()` to call `socket.create_connection()` directly.
Use our `to_bytes()` function. ```suggestion connect_socket.sendall(to_bytes(send_string)) ```
```suggestion params = dict(timeout=timeout) if PY3: params['host'] = host params['port'] = port smtp = smtplib.SMTP_SSL(**params) code, smtpmessage = smtp.connect(host=host, port=port) ```
Again self_host is not defined for winrm.
I would probably go for "Exit" here, but that's more cosmetic than functional.
```suggestion # just get value from attribute itself as normal ```
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
Maybe better? Not certain, but I was running into the same error of `ERROR! a bytes-like object is required, not 'str' ` before making this edit ``` process = Popen(["sops", "--decrypt", filename], stdout=PIPE, stderr=PIPE, encoding='utf8') ```
``` ansible 2.8.1 config file = /Users/mhume/ansible-sops-roles-test/ansible/ansible.cfg configured module search path = ['/Users/mhume/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/local/lib/python3.7/site-packages/ansible executable location = /Users/mhume/Workspace/ansible/bin/ansible python version = 3.7.4 (default, Jul 9 2019, 18:13:23) [Clang 10.0.1 (clang-1001.0.46.4)] (ansible) ```
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
I confirmed the ZAPI accepts both False and false, or True and true, so this is OK as is. It's only when making comparisons with returned values (get), that we need to be case sensitive.
add an alias to `domain` as `domainname`
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
This is always a tough question, and I'm not sure what's the best solution :) In Ansible, things are usually lower-case. I guess you have to decide what you want in the end :)
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
```suggestion default: False type: bool ```
```suggestion default: False type: bool ```
```suggestion default: {'type': 'org.graylog2.indexer.retention.strategies.DeletionRetentionStrategyConfig', 'max_number_of_indices': 14} type: dict ```
```suggestion default: "org.graylog2.indexer.retention.strategies.DeletionRetentionStrategy" type: str ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
List of Names & GitHub IDs please ``` author: - Nicolas Thomas (@thomnico) - Miguel Angel Munoz (@mamunozgonzalez) ```
Default value not specified in argspec.
Default value mentioned but not added in argspec.
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value mentioned but not added in argspec.
```suggestion - State the action to perform. Use C(update) to modify the igmp-snooping. ```
```suggestion - State the action to perform. Use C(update) to modify the ```
```suggestion C(absent) to delete cpu-class C(update) to modify the cpu-class. ```
```suggestion C(absent) to delete dhcp-filter and C(update) to modify the dhcp-filter. ```
```suggestion - Web SSL (HTTPS) to enable or disable. ```
For `mode == 'persist'`, you have to both check the current value *and* the value in the `mysqld_auto` config.
Why not ```suggestion if mode in ('global', 'persist'): ``` ? :)
I would remove the previous and the current line. If you write `persist_only`, you want to make sure that the variable is set in he `mysqld_auto` config. If it is not set there (but it is set in the running instance), you still want to execute the query.
How about moving this in the main `if:` branch above? Then there's no need to do funny tricks for `mysqlvar_val` in the `elif:` branch.
I wouldn't emit this warning. After all, the warning is just saying "the module is doing its job, nothing out of the ordinary".
CI failure due to syntax error (missing `:`).
Typo in `module_utils`.
So, is there a plan later to use include_private ? (as the current patch don't use it)
These tests now run on python 2.7 (though fail on python3 still). I think if we're moving toward using placebo rather than just mocking, it may make more sense to do that here, especially since integration tests won't be run with CI (and running them manually may not happen terribly frequently). Shippable will notice if the placebo recordings lose compatibility with changes made in a PR.
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
i don't think we want roles in roles
Sure, a separate PR sounds good.
Tell people where we are looking `CONFIG_FILES`
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
if self.state == "absent" should be explicitly checked before unregistering the VM, just to be safe.
```suggestion folder=dict(type="str"), ```
Use `get_vm` API
```suggestion changed, info = wait_for_task(task) ```
```suggestion changed = False ```
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
Extra spaces before and after `local-ssd#local_ssd_limits`
Shouldn't have `required: true` for things that have a default.
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
Needs return docs.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
This is just style but we try to follow standard python naming conventions. So function and method names should be underscore separated like this: ```get_resources```.
Doesn't really matter since you're not likely to instantiate more than one PasswordManagerPro object in this short script but these should be instance variables, not class attributes. Move setting of default values into the ```__init__```
I'd also default to True for validate_certs as that is a safer default.
It's safer to quote unvalidated strings with, e.g., [`urllib.quote`](https://docs.python.org/2.7/library/urllib.html?#urllib.quote) before concatenating them into a URL.
Also, it would be better of the description is split up over multiple items. A long blob doesn't make it easier to read. Usually the first item is the "meaning", and subsequent items detail what happens in different cases, explain options, specify the format or add one or more notes.
This should become: ```yaml type: bool default: 'yes' ```
Nowadays we do: ```yaml type: bool default: 'yes' ```
to *be* assigned
Add or remove are not declarative, but imperative. So I would rather state: Specified whether the computer should be present or absent in Active Directory. Beware that the current description is talking about access rules, which is weird because we are managing computers in AD.
```suggestion <html> ```
```suggestion <body> ```
```suggestion Hello world. ```
```suggestion returned: When return_content is TRUE. ```
```suggestion </html> ```
```suggestion type: path required: yes ```
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
You can do this all in the argspec `node_ip=dict(fallback=(env_fallback, ['rubrik_cdm_node_ip'])), `
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
As far as I can tell, the 'in_use' is never used.
should be `type='path'`
TODO add Exception handling for login error
Missing full stop.
Missing from docs
The value should be quoted.
This should be quoted but please use double quotes.
Missing period at the end of sentence.
The value should not be quoted.
The values in the array should not be quoted.
and another bad fail_json_aws call
Sorry for the late update, just spotted this (caught me out somewhere else) [fail_json_aws is defined](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/aws/core.py#L191) as `fail_json_aws(self, exception, msg=None):` You can simplify this to ``` module.fail_json_aws(e, msg="Unable to delete user {0}".format(user_name)) ``` Probably worth swapping out most of the fail_json calls for similar fail_json_aws calls too.
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
`required=False` is the default, and thus not required
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
(In order to optionally not make frequent, redundant, probably unnecessary requests to the COPR API)
```suggestion # the variable if it hasn't been set by the user already. ```
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
> Would this be better as `if key not in module.params` so we don't capture the case where the user explicitly sets things to `null`? The ansible way for the user to skip an upon is `{{ omit }}`
Just for sanity sake maybe pull out ```python "copr:{0}:{1}:{2}".format(copr_server, copr_user, copr_project) ``` into its own var, since it's duplicated 5 times.
This will concatenate all chunks into a single-line string. Try multiline: ```suggestion self.module.fail_json(msg=textwrap.dedent(""" Failed to add vSwitch '%s', this can be due to either of following: 1. vSwitch Name exceeds the maximum allowed length, 2. Number of ports specified falls out of valid range, 3. Network policy is invalid, 4. Beacon configuration is invalid : %s """) % (self.switch, to_native(invalid_argument.msg))) ```
This can be set, but not in the netflow/ipfix, config. It can be set on the dvSwitch itself using its configSpec: https://code.vmware.com/apis/358#/doc/vim.DistributedVirtualSwitch.ConfigSpec.html#switchIpAddress
Mix tab and spaces in identation.
@ckotte you're right about wholesale exceptions in general. However, there's one case when it's okay: on the top level layer of the app (in this case the module). The thing is that if the process will just crash it won't return a failed json struct to the Ansible controller, which won't be able to handle this better then. So I'd put such handler around (some part of?) main func.
Yeah, smth like that. Input args might also be useful there. Basically any details you're able to retrieve is good :)
I'm pretty sure this can use `is_sequence()`.
The `hosts` validation behavior changes quite a bit based on whether or not `name` was defined in the playbook. That should be handled outside of this method.
This fix is on the right track, but it is too specific. This should use `module_utils.common.collections.is_sequence` to verify it is the correct type.
I've been looking through the code as well as poking at `hosts: ` and breaking things in various ways. It seems like the whole conditional here needs to be reworked and simplified. It is doing too much, which makes fixing this cleanly more challenging.
Closer but I'm still not sure it's all the way there. Checking for `AnsibleMapping` specifically is a bit narrow. Instead we should check for valid types.
call this just cluster, identical to the param we pass. Fixes inconsistency with other modules.
call this just pod, identical to the param we pass. Fixes inconsistency with other modules.
yes, None values are excluded by the lib cs underneath
can be simplified to ~~~ cluster = self.get_cluster(key='id') ~~~ and following lines can be removed ~~~ if cluster: args['clusterid'] = self.get_cluster(key='id') ~~~
identical here for pod,
Same note as above about 'rb'
exception classes should be defined after impotrs and constants and before helper functions.
I'm not certain that we want to name this *Module. Just from reading this PR it appears that it will be used more for managing keys and certs rather than managing a program (the ansible module).
Are check, dump, and generate always needed? If so, consider making this an abstractbaseclass: https://docs.python.org/2/library/abc.html
The usual idiom I see with these *Module type of classes is that they hold onto module in an attribute. I happen to think that's the wrong thing to do (as it leads to calling self.module.fail_json() instead of raising exceptions that are then handled at a higher level). But if you aren't going to hold onto module, you shouldn't pass it into the constructor. Instead pass in the specific parameters that you care about: ``` python def __init__(self, path, state, force, check_mode): ```
TBH I prefer `cert_validation` as it uses namespace prefixes (and related options sort together). Maybe we ought to fix the **httpapi** connection plugin instead ? ;-)
For the **httpapi** plugin the parameter is `validate_certs` and config item `ansible_httpapi_validate_certs`.
Isn't the option for modules `validate_certs` ? It feels strange to introduce something new here. Looking through sources I can only see *module_utils/azure_rm_common.py* doing this.
Just because requests conflates validation and the source of validation truth doesn't necessarily mean we should- I've always disliked that in requests, as it prevents more granular cert validation behavior in the future (or at least makes it more complicated by requiring more config args). That's why I did the pywinrm one the way I did (left the separate arg for CA path and made validation mode a string/enum-y thing rather than boolean)
should probably be `message_encryption` just to be clear
`default=True` (as it's a bool, not a string)
`default=True` (as it's a bool, not a string)
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
`pipes.quote` is deprecated in Python 2.7 already. You should import `shlex.quote` if available. try: from shlex import quote except ImportError: from pipes import quote
In addition to the error message from boto, can you include a nice message like "ClientError while listing SSH public keys" for users? Also, please catch a generic exception and fail with the traceback, like `module.fail_json(msg="Could not list SSH public keys", exception=traceback.format_exc())`
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion - The content library description. ```
```suggestion - The name of content library to manage. ```
```suggestion description: library creation success and library_id ```
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
Please add `type: bool`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
Indentation doesn't look right here. You can have upto 160 character lines
Yes, `YYYY-MM-DD` should be perfect. Thanks for the xkcd link ;-) @lolcube I'm still curious where `:` is used; I'm really not aware of anything where it is used (or I completely forgot :) ).
There are indeed, but this is not about i18n; Ansible should not use the date format of some random locale, but something which is common (to the area where the module belongs to, or something from a RFC). I've never seen this notation, but maybe I'm missing something, that's why I'm asking :)
LOL ok :) Good luck on getting it back...
Why are you using `:` for date formatting? To me, that's highly unusual and something I would not expect.
I just don't ask questions about date formatting anymore, there are way too many locales :joy:
Wrong Github handle :-)
Has this actually been tested ? (Also move that list item to the start of the line)
The `notes` is a list of items, and each note must end with a trailing dot. Please also make this an full English sentence: ```yaml notes: - The tenant used must exist before using this module in your playbook. The M(aci_tenant) module can be used for this. ```
I would simple make this `tenant`. If you still prefer backward-compatibility, you can add `tenant_name` as an alias.
Add a trailing dot.
state should be string with choices enabled/disabled
set_state: enabled/disabled in accordance with state
use boolean type, "yes" and "no" are supported for boolean types
choices: [3, 4]
use full names read-only, read-write
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
@webknjaz I don't believe anyone has said it's dangerous. It's discouraged.... the Python idiom is "consenting adults" meaning, use the single underscore convention to tell people not to use something rather than trying to outright stop them. The double underscore isn't really an attempt for private methods and variables (the automatic rename is just another convention to be followed if you really need access, for instance), it's meant to prevent conflicts between methods in things like helper methods for mixin classes (ie: you have a mixin that's generic and could be used with other classes that you don't control. Using double underscore there makes it so the other class doesn't accidentally overwrite the mixin's private methods.) I would say that our style probably should be to use single underscores to denote private methods and attributes but I would not go so far as to say that double leading underscores are "dangerous".
Any reason not to use a CM? ```suggestion with codecs.open(os.path.join(*file_paths), 'r', 'latin1') as f: info_file = f.read() ```
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
Argh, I just realized the PluginLoader attribute stuffing (update_object) has been happening on `class_only` cases, which is broken for "same name, different behavior" cases (since subsequent loads will overwrite the class vars on the existing type object, not instance vars). It works here, since `all` is `yield`ing the plugin class immediately after calling `update_object` on it, but the whole pattern is busted for `class_only`, esp for things that might consult the class var during or after `__init__`. We've needed to rethink that for awhile, and this kinda sets it in a little more concrete. :(
```suggestion # try to get collection world name first ```
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
I think this message should just be `botocore and boto3 are required for this module`.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
To enable the debugger to work, please rewrite as ``` if __name__ == '__main__': main() ```
I suggest you use [`shutil.move()`](https://docs.python.org/3/library/shutil.html#shutil.move)
I'd prefer this to be in a separate function.
Please use `[ ]`: ```python result['changed'] = True ```
Instead of lots of if/else, you could follow EAFP principle and do: ```python try: if git_version(git_path, module) < LooseVersion('1.7.5'): separate_git_dir_fallback = True else: cmd.append('--separate-git-dir=%s' % separate_git_dir) except TypeError: # will happen when comparing `None` module.fail_json(msg="Cannot find git executable at '%s'" % git_path) ```
We might want to introduce new/old git dir path in the result.
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
ok, missed that!
No need to wrap.
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
what happens if it's not `> 0`? There will be a lot of `IndexError`s in the following code. We should set `launch_config = launch_configs[0]` if we know there is a result.
`dict((k, v) for k, v in launch_configs[0].items() if k not in ...)` is probably a bit more readable.
Random musing. I wonder why boto3 isn't returning CreatedTime sometimes. I made a launch configuration in us-east-1 with ami-9be6f38c. It has a creation time in the console. Hm.
I think we need more info here what are possible choices.
use `from ansible.module_utils.six import iteritems`
And here... Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
Same as above. Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
~~~diff - if self.hcloud_volume.size <= size: + if self.hcloud_volume.size < size: if not self.module.check_mode: self.hcloud_volume.resize(size).wait_until_finished() self._mark_as_changed() + elsif self.hcloud_volume.size > size: + self.module.warn("Shrinking of volumes is not supported") ~~~
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Could this block (520-528) be a method on the AggregateStats class? something like AggregateStats.aggregate_custom_stats(data=result_item['ansible_stats'], host_list=host_list)
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
host_storage.type == otypes.StorageType.FCP
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
Line is too long.
Line is too long.
Please add `monitoring` and pass this argument to the request.
Too long line.
If it is not required, you don't have to state it as it's the default.
The list of option could be ordered alphabetically.
The `RepoIDs` is not the module option and therefore it should not be decorated in `C()`.
This is indented only by one character. Please indent it by two chars like elsewhere.
The default value is "None", so this is not needed.
Maybe mention it's the default action again
Maybe 'Windows firewall profile default action automation'
I would drop all these. A module shouldn't return information already known to them by the user. If you want to have a way to report on existing profile settings then it should go into a separate module like `win_firewall_profile_info`.
Please rewrite the description what the task is doing in detail. E.g. **Disable the domain firewall profile.**
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
move this into main so you only need to define on load instead on every call
You can make the list a frozenset at the toplevel of the file to speed this up slightly..
~should this be `if not`?~ nvmd, avoiding keywords
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
So we have a default way of doing proxies. Normally it picks up the system settings, unless **use_proxy** is set to 'no'. The format of this parameter is best kept in line with other modules for simplicity.
I would expect a proper default here, probably `default: 'yes'`
Remove this. Unclear what the purpose is of this parameter.
Don't specify this. It's implicit.
The standard parameter for this is **use_ssl*, please change this.
```suggestion mode: '0644' ```
To me it seems more logical if the format is not a list, but a dictionary. ```yaml options: SYSTEM: LDAP registry: LDAP logintimes: :0800-1700 ``` The only reasons for using a list here, would be to ensure a specific order for processing, or to ensure that a specific key can be duplicate (so provided keys are not unique). But I don't think these are no applicable here.
It's probably better to loop over the items and check the value before changing, so you can report back if there was a change or not.
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
Resource path should not be manipulated by hand, since we should only use paths that Redfish API returns (with one exception that has been actually removed from the latest version of the Redfish standard).
As before, this will not catch non-200 statues of response.
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
Does the data model / json of the scaleways api ever change? A chained set of accessors like that tends to be a little fragile if the server response change. Could potentially use some defense against that. Afaict, KeyErrors or IndexErrors here would not be caught elsewhere and would cause a fatal error instead of a semi-graceful json_fail.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
With the latest change this import is no longer needed: ```suggestion from ansible.module_utils.six import text_type ```
We should probably put this into ansible.utils.unicode with a note about when to use it and what sort of literals to use it with for those that don't understand the native string distinction.
Please use `load_provider()` defined [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network_common.py#L340). You can refer [this](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L48) action plugin.
You can just `return` without `else`.
`IGNORE[xxx]` is used as something iterable, and I don't think any of the calling code wants a list of letters :)
+1 for this.
Add a sample dict returned by module.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
check e.response['Error']['Code'] here too
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
Little :bug: : In **check** mode, the `keycloak_realm` always returns `result['changed']: True` You need to add something like `result['changed'] = (before_realm != updated_realm)` here...
ditto `s/client/realm` :wink:
ditto `s/client/realm` :wink:
copy-paste issue: we should talk about **realm** object here, not a _client_. To be globally replaced in this file...
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
I suggest you use [`shutil.move()`](https://docs.python.org/3/library/shutil.html#shutil.move)
I'd prefer this to be in a separate function.
Please use `[ ]`: ```python result['changed'] = True ```
Instead of lots of if/else, you could follow EAFP principle and do: ```python try: if git_version(git_path, module) < LooseVersion('1.7.5'): separate_git_dir_fallback = True else: cmd.append('--separate-git-dir=%s' % separate_git_dir) except TypeError: # will happen when comparing `None` module.fail_json(msg="Cannot find git executable at '%s'" % git_path) ```
I'd call it `needs_separate_git_dir_fallback`
Please put this on a single line. Lines can be 159 characters wide.
You don't need to state default=None as this is the default value.
You can remove `required=False` as that's the default.
You don't need to state `default=None` as this is the default value.
Please put this on a single line. Lines can be 159 characters wide.
Please separate this into separate lines for maximum readability. Something like: ``` if inst.image is not None: image = inst.image.split('/')[-1] else: image = None ```
Please separate this clause into separate lines for maximum readability (like above).
Please separate this clause into separate lines for maximum readability (like above).
Please separate this clause into separate lines for maximum readability (like above).
What do you think about making this required=True and removing the default? I think it would be best to make sure that users are fully aware of which zone they're using. Many users don't use the us-central1-a zone.
Example is using the wrong module name, should be "vcenter_license"
I suggest showing two examples, one for present, one for absent
Examples need update to reflect rename
Use connect_to_api from vmware.py
There is a deprecation marker, you could add here see Dag's PR
```suggestion assert wrap_var(dict(foo=None))['foo'] is None ```
```suggestion assert isinstance(wrap_var(b'foo'), type(b'')) ```
```suggestion assert isinstance(wrap_var(set(['foo'])), set) ```
```suggestion assert isinstance(wrap_var(('foo',)), tuple) ```
```suggestion assert isinstance(wrap_var(('foo',))[0], type('')) ```
escape with `r'''` and you don't need to escape `\` in the string itself.
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
If you enclose this in `EXAMPLES = r'''` you don't need to escape the `\`. Standard practice for all module doc blocks is to use `r''' '''`
Bump to 2.8.
All descriptions (except the short_description) have a trailing dot. *(Same for the other modules)*
This information is redundant, I would remove it
s/Create, update and manage/Create and delete
Suggestion: Create, update and __delete__ cloud subnetworks on the Hetzner Cloud.
```suggestion - Create, update and attach/detach block volumes on the Hetzner Cloud. ```
Typos, should be: `The ID or Name of the Hetzner Cloud Network.`
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
add a check if vm_id_type is vm_name and not folder then present error "Folder is required parameter when vm_id_type is inventory_path"
Use to_native instead of str
Could you please handle basic exception for this operation and other file_manager methods as suggested in [docs](https://code.vmware.com/apis/196/vsphere#/doc/vim.vm.guest.FileManager.html#makeDirectory)
This should be `module.fail_json(...`, not an Exception
Same as above, can be done with sub options
Again, path concatenation is bad. And in this case it is not needed at all, since we have a path stored in `device["@odata.id"]`.
`Name` field does not need to be unique (and on the Lenovo recording I have all the disk firmwares have the same name "Disk firmware"), so this has the potential to overwrite data from previous iterations, returning only the last non-unique entry.
Again, path concatenation is not something that would be used much when dealing with Redfish. And in this particular case, we may get invalid path from the concatenation, since `self.manager_uri` can have a trailing `/` (and on most systems I encountered, this is actually true).
Last six lines can be simplified to `return dict(ret=True, entries=response["data"]["Attributes"])`.
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Because the longdesc and requirements are read from files, we should still move all of those outside of the toplevel as well. So line 134 on can move into main() (or helper functions of main() if you prefer that).
This should not be opened with "+" (as that allows writing the file). I can't remember off the top of my head whether python2/python3 setuptools expects text strings or byte strings for longdesc. My guess is text strings. Since there isn't any non-ascii characted in README.rst I think we can ignore that for now and just use native strings but we might need to figure it out in the future.
Instead, please set `self.index = json.load(f)`. The JSON library uses the `.load` function to stream straight from files without needing to `.read()` first. This also avoids pesky encoding issues with Python2/3.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
Keep a blank line between examples for readability.
This is wrong, already explained.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
Since we're intending to backport this fix, it'll have to remain a `try/except OSError:` with a double-check in the exception handler. Once it's landed in devel and our CI is able to handle py3-only controller tests (which is still WIP), we can update to use py3-only bits.
@cloudnull see `makedirs_safe` for older python compatibility (probably will be in backport), but since we require python >=3.8 on controller, `exist_ok=True` should be good enough
It involves `unfrackpath` among other things ... :fearful:
in [py3](https://docs.python.org/3/library/os.html#os.makedirs) we can use `os.makedirs(lookup_path, exists_ok=True)`. With that we can get rid of the try/except and check condition, condensing everything here into a single line.
You shouldn't even need to try it again- the only case we want to recover from is if another worker already created it, so if we got this error, just ensure that it exists and continue on happily, otherwise re-raise the original exception. I guess there might still be a tiny remaining race condition in that case, since `os.makedirs` is unlikely to be atomic, but adding a retry makes it more possible for workers to trip on each other, and could ultimately repeat a different incarnation of the same race for each level of the path (though *far* less likely). If we really want to solve that potential problem, either the $controller_term_replacement_tbd needs to create the cache dir in a serialized pre-fork code path, or we'll need a dedicated lock for the creation of the tempdir. I'd probably vote for the former, since adding a new resource lock makes deadlock possible (and managing more locks is ultimately a lot more expensive than a tempdir creation).
Should be metadata_version
Name needs to be updated here.
I would format this like this: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.0' } ```
All `description` should start with a capital letter, and end with a fullstop.
`short_description:` for modules should include the company & product name. It makes searching for modules easier
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
Please add `type: bool`
Indentation doesn't look right here. You can have upto 160 character lines
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
If one of both is required, it is better to force this as part of the argspec.
This would turn everything into a string, not sure if that's what you want for e.g. booleans). Same for the other values that are not strings. Probably not what you want.
This is fine, but we should only update (all labels) if one changed, misses or should be added.
Unessecary blank line
I mean not to actually shrink it but doing a "no-op" but showing a warning to the user, that volumes can not be shrinked.
State what you're trying to do when failing ``` module.fail_json(msg="Couldn't set assign-ipv6-on-creation: " + e.message, ...) ```
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Technically this will never be `None` because of the defaults.
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
There is a slight issue with your proposed fix (`.passwd()` isn't a synchronous interface), I will fix that in a jiffy.
I would remove the emoji here ;o)
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
You can remove `type='str'` as that's the default type.
I would rather remove this exception here and put it around the `ldap.initialize()` and `self.connection.passwd_s()` above with a more specific error message.
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
I'd move this block into it's own method since fetch_file will likely need it as well.
also need to return AnsibleOptionsError if the value of the config is incorrect
i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
`for key, value in (doc.get('options', {}) or {}).items():`
instead of this check, you can do: ```python for key, value in doc.get('options', {}).items(): ```
yes, as well as `None`
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ```
`for k, v in opt.items():` <-- gives you key-val pair
Just noting that this RETURN is incomplete
If you pipe this through to the URL, then this should really be "resource". In Kube "kind" is the schema, "resource" is the thing you access via a client. Kind is always a constant (uppercase), resource is always the lowercase RESTful name. I would recommend `resource: service` (if you're doing discovery) or `resource: services` (if you're hardcoding). Mapping `kind` to `resource` is something we explicitly do on the client by looking up a Kind in the discovery doc, so overlapping them can be dangerous.
Am I correct that we've still got no tie-in with the advanced 3-way merge logic currently baked into the kubectl/oc client binaries? That functionality seems so important for Ansible, and rumored to head for the API server soon but still may be a few releases out.
I completely missed that, apologies
It's addressed here https://github.com/ansible/ansible/pull/47803/files#diff-4e0a09d18f6dfe19eb9d0b30c0a53bafR16
I wonder if it'd be hard to title-case the matched admonition. They are case insensitive. One can do any of ```rst .. Note:: .. notE:: .. NOTE:: .. NOTe:: ```
And with `\1` you preserve what's matched but I'd argue it should always be normalized to `Note:`.
I thought we decided on titlecase, no? ```suggestion t = cls._RST_NOTE.sub(r"Note:", t) # .. note:: to note: ```
I'd go for underlining.
Looking at how this is handled, I wonder if this could be turned into a sequence of transformations. ```python _RST_TRANSFORMATIONS = ( (re.compile(r".. seealso::"), "See website for:"), # seealso directive (re.compile(r".. note::"), "Note:"), # note admonition (re.compile(r":\w+?:`"), "website for `"), # any role (re.compile(r".. \w+?::"), ""), # any directive ) ``` And then just ```python for regex, replacement in cls._RST_TRANSFORMATIONS: t = regex.sub(replacement, t) ``` (below)
It would be nice to sort the options alphabetically.
i thought i had asked to remove this option in favor of keep remote files
Please add dot at the end of the description.
This needs to be addressed.
The indentation doesn't look right here (or on the other `descriptions`)
Could you please add a trailing comma here? ```suggestion "job_wait": {"required": False, "type": bool, "default": True}, ```
`update_status` should be a separate key in return structure, so you can still add some msg text string: ```suggestion module.fail_json(msg='Firmware update failed', update_status=msg['update_status']) ```
Maybe still return update_status in this case? It's probably simplify debug. ```suggestion module.fail_json(msg=err_msg, update_status=msg['update_status']) ```
JFYI you can accept such "change suggestions" right from GitHub UI :)
```suggestion module.fail_json(msg=str(e)) ```
```suggestion default: yes ```
```suggestion - Additional C(installp) flags to use. ```
```suggestion EXAMPLES = r''' ```
```suggestion - name: Install latest version of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion commit: no ```
You should be able to use `self.vmware_test_platform` here.
This should be ` facts['gather_subset'] = list(runable_subsets)`
The subset type has to be of type `frozenset` as the `minimal_gather_subset` is of type frozenset `runable_subsets = self.gen_runable(legacy_facts_type, frozenset(fact_legacy_obj_map.keys())`
Same for net_res_choices - `frozenset(net_res_choices)`
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
What's the point of `'elements': 'str'` in this parameter? This is only used for sub options. This appears to be regular list parameter.
@felixfontein > elements can be used for every type: 'list' parameter. I didn't know that. I've only ever seen this used for suboptions. I didn't know we handled it anywhere else. Now I know. ð
That used to be the case, but it changed somewhen this year (IIRC). I searched a bit, here's the PR which implemented validation: #50335
> What's the point of `'elements': 'str'` in this parameter? This is only used for sub options. This appears to be regular list parameter. `elements` can be used for every `type: 'list'` parameter. In this case, Ansible will make sure that the list contains strings (and not booleans, numbers, lists, dictionaries, ...).
Use literals rather than constructors: ```suggestion argument_spec={ 'executable': {'type': 'str', 'default': 'podman'}, 'name': {'type': 'list', 'elements': 'str'}, }, ```
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
I think most if not all of this can be removed and replaced with argspec code https://github.com/gundalow/ansible/blob/docs-argspec/docs/docsite/rst/dev_guide/developing_modules_general.rst#main-and-ansiblemodule-argument-spec
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
Is this deliberately different from `merge_values_nested_array(current_managed, managed_filters)` below? Ouch, I see, belongsto is 1 level while managed is 2 levels: ``` "filters" : { "belongsto" : [ "/managed/area/1", "/managed/area/2", "/managed/area/3" ], "managed" : [[ "/managed/infra/1", "/managed/infra/2"], ["/managed/other/3"]] } ``` LGTM :+1:
It looks like this should be added possibly or something similar? ```python if 'channel group' in config: return True elif 'channel-group' in config: return True ```
Works as it should! Great job!
Please modify this to `elif delta.get('peer-link') and not existing.get('peer-link'):`
Not sure if we need `normalize_interface` when fetching interface names from running-config.
should probably be validating whichever components aren't part of the vlan's "primary key" (seems like parent interface/node/interface_name, but not sure off the top of my head) and either allow them to be modified or at least warn/error if they're not in the requested state
And the same here
Note: you don't have to use set explicitly here. The set methods can work with an iterable (which tuple is)
I think this is acceptable for now, but for the future, I think we should see if we can make use of post validating to cover all arguments in a single standard way.
but you dont have full args till you read the file. I becomes specially fun when the from itself is a template
this does not seem like the correct change, instead we need to make sure that the vars_from are loaded before pasisng to param hashing
Please remove all `version_added:` under `options:` : Only needed if this option was extended after initial Ansible release, i.e. this is greater than the top level version_added field.
```suggestion - Remove tags not listed in I(tags) when tags is specified. ```
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
These values should all be type `int`
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
While this works, I think the list version is better because it is easier to extend.
```suggestion type: dict ```
`state`: a `choice` parameter should be used ([example](https://github.com/ansible/ansible/blob/6cdf91fd35fefec35dca4594db231cc6af5a8620/lib/ansible/modules/system/capabilities.py#L167))
```suggestion query=dict(type='list', elements='str'), ```
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
Use `get_vm` API
```suggestion changed, info = wait_for_task(task) ```
```suggestion changed = False ```
```suggestion folder=dict(type="str"), ```
Remove parans for every if ```suggestion if find_vm_by_name(self.content, self.name, folder=folder_obj): ```
Can you line up `src`, `dest` and `overwrite` please.
It people are trying to download a non-exiting file, the execution should fail, because this is unexpected behaviour and should clearly be mentioned.
Do we need to do any check on this? Can this fail due to permission issues, or due to the file already existing? I'm fine with this always overwriting the destination file, and coming up `changed=True` every time, i just wonder if there is a risk of exceptions (pretty sure both `fetch_url`, `open` and `write` can throw a bunch of exceptions.)
Same as above, can be done with sub options
Same as above, can be done with sub options
```suggestion - The host IP address for object-group network. ```
```suggestion - The object group type. ```
```suggestion - The description for the object-group. ```
```suggestion - Name of the object group. ```
```suggestion - The group-object for network object-group. ```
this forcibly creates/removes the files w/o checking if they exist or not, doing so would allow you to offer a 'changed' s state. Also it is encouraged that modules are safe to re-run w/o affecting systems when not needed.
this is a non atomic operation and can lead to file corruption, write to a temp file and use shared 'atomic_move' to put the file into place
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
If you like, something like this can be redone as `if protocol in ('tftp', 'ftp', 'sftp', 'scp'):`
ð on get_config for clarity.
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
import errors should not be fatal, look at hipchat plugin and how it handles this, the plugin will not work but will not stop play while it issues warnings about it.
task_uuid seems unused
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
I would format this like this: ``` ANSIBLE_METADATA = { 'metadata_version': '1.0', 'status': ['preview'], 'supported_by': 'community' } ```
This should be indented only by 2 spaces.
This should be indented only by 2 spaces.
Actually this shouldn't be indented at all. Lists can start from the same indentation as their parent. And the general rule is, don't add things that aren't needed (so don't quote strings if they're not needed, or don't indent if it's not needed).
You can drop the backticks around the `http(s)`.
This can be removed. If a parameter is required, there is no default.
If a parameter is not required, we don't have to state that explicitly. It is implicit. Only when parameters are required, you need to add `required: yes`.
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
Again, the name for that task was a copy-and-paste from the integration tests. It would probably better to use, eg. ```yaml - name: Enable 'telnet-client' windows feature ```
Ah, I think it's a copy-and-paste error from the integration tests. Good catch :-)
There's still a few of these that are using double-underscore to mark private. We generally do that with single underscore instead. ``` python - def __present(self, resource): + def _present(self, resource): ```
Maybe add `default: present` here.
If it's not required, you don't have to state `required: false` That's implicit.
No need to quote strings in YAML. (unless it's yes, no or null I guess)
Ok, so I may have given you the wrong advice before. I was under the impression that these modules were talking to a backend, but (at least) this module seems to run on the remote target (over SSH ?). So delegate_to: localhost` will not work correctly.
Same as for other modules, use `Group has been updated`
I'm not a big fan of this self recursion. We're a bit limited since boto doesn't give any way to get the entire tree, but it would be nice if this could be broken out differently.
```suggestion description: The Organizational Unit details. ```
```suggestion parent_ous = paginator.paginate(ParentId=parent_id).build_full_result().get('OrganizationalUnits', []) for child_ou in parent_ous: ``` You could remove the outer loop here by using the paginator's `.build_full_result()` method and retrieving the OrganizationalUnits from it.
This is correct.
```suggestion - C(number_of_workers), number of workers for app service plan. ```
```suggestion - C(name), name of app service plan. ```
Are all five parameters required for the dict to work? ```suggestion - Can be a dict containing five parameters, defined below. ```
```suggestion - Can be the resource ID of an existing app service plan. For example, ```
```suggestion - Resource id, eg. /subscriptions/<subs_id>/resourceGroups/<resource_group>/providers/Microsoft.Web/serverFarms/<plan_name>) ```
You could `mock.patch` it to do so :)
This needs to go outside of CM. If `ipsubnet` will raise exception it will interrupt code block within `with`.
``` self.assertRaises(ValueError, get_ip_version, '192.168.0.1') ``` should work with python 2.6 but you can't check the error message.
Please keep your code style consistent: first you assign vars for some time, then you pass lots of function args directly. There's a better way.
We expect all imports to happen at the start of the module. If it is possible this will fail because e.g. ucsmsdk is missing, then you add it as part of a try/except block and set HAS_UCSMSDK=True/False, and provide a proper fail_json error if HAS_UCSMSDK is False.
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
heads up, `r` is undefined.
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
No need to set this, or check it.
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
change this to return `customer_gateways`
not needed with AnsibleAWSModule
Summary option is available only in the latest versions. Let us not rely on that, please use heal info and check the count.
Nit - Change the message to: "Operation aborted, self-heal in progress." removing the capitalisations.
Nit: Do not capitalize Aborted. Keep the message like: "Operation aborted, self-heal in progress."
When reducing the replica count, the force option is mandatory. This will fail if force is not set. Also for remove brick can you check there are not pending heals. If we are removing a brick from a volume which has pending heals and if that brick had the only good copy, we have data loss.
@sabose we do not validate the bricks since validation is done by gluster. We'd be duplicating the efforts. Plain distribute is supported, data migration is triggered when we remove the brick. However, commit is tried 12 times with 10 second gap. If the data migration is not complete by then, we give up and it is upto the user to commit. This is because depending on the data migrated it might sometimes take days together to complete.
Hello and thank you for your PR! Sorry for the lag time on this but this would need to be updated to `2.6` if you can get it done today, otherwise it will be `2.7` because today is dev freeze for `2.6`.
2.7 at this point, we don't add features in minor versions, only bugfixes
The value should be quoted.
So the new plan is to use `name` which is unique. Creating from ansible, we can control both name and description. Creating from UI only asks for description; it currently sets name to a GUID, will be changed to equal description.
As I understand it, this module isn't about gathering facts.
I think you need to first merge to devel, and then you can backport to stable-2.7. I think the core team says they don't backport features, so... the backport might not work either.
I could have sworn I remembered some pattern for requiring one out of a list of fields, but can't find it now.
instead of 'comma separated list' just make 'list' , type=list will accept both types of list and always guarantee a list object to the module
for other modules we are already using `append=yes|no`
Try except blocks should be as small as possible. In this case, if is only needed around the calls to modify and delete. Perhaps put the try except around the if state conditional to limit the statements that it surrounds
Would be good to also see usage other than ceph.
The docs page you linked says it doesn't have to be in that format.
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
Might want to check `rc` status before return output.
Sorry, my bad. I didn't see the implementation of `_run`.
I see you fixed this one. :+1:
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
Use connect_to_api from vmware.py
Check if self.dc_obj is not None. We have seen "AttributeError" failures in past related to this.
Could you please correct docstring? There is no boolean value in return value.
Perhaps, `Will ensure the datacenter resource exists and its properties are compliant with HPE OneView` Or something along those lines. As it is right now I'm not sure if it is clear that this resource can actually be created if it does not exist.
So you added an extra maintainer. Very good :+1:
The more the merrier. Take that literally, because if you have 2 maintainers adding 'shipit' to a PR, the PR is automatically merged. That means you need at least three maintainers if one of the maintainer creates a PR.
Maybe add `default: present` here.
This should default to `present`, not be `required`
I don't like the `: ` here
Please remove this line.
Please remove this line.
Please remove this line.
Presumably you want `It *will* always use`, or something to the effect
`loose_driver_version = LooseVersion(PyMongoVersion)` <-- it's already calculated above. I think this case could go to the dict above if done carefully. This could be some hack like `{'-inf': '2.5'}`. But, looking at the error message, I'd say it'd be just `{'2.4': '2.5'}` and the error message would be normilized as well then.
```suggestion msg = ' (Note: you must use pymongo >= {0} with MongoDB {1})'.format(loose_srv_requirement, loose_srv_version) ```
This logic tried to enforce a minimum version requirement, which the new code does not. Since it doesn't sound like you have added compatibility with older versions (or have any reason to), why not do something like: ``` min_version = '2.4' if loose_srv_version < LooseVersion(min_version): module.fail_json(msg='MongoDB {0] found, the minimum version supported by this module is {1}'.format(srv_version, min_version)) ```
pymongo does not match mongodb version here. we'll need a mapping in the variable above, not just a sequence.
don't leave a file descriptor open. use a context manager (via `with` block)
My guess as to why the tests are failing to parse the docstring are due to this line. Since it contains quotes, you'll need to wrap the whole line in single quotes.
Ah yes sorry, ~~prefix~~ suffix
I would add a note saying this does not relate to the partitions file system formatting.
Would add a note saying this does not deal with disk initialization and file system formatting.
If we have an explicit map we should be using snake_case for this, e.g. `system_partition`, `microsoft_reserved`, and so on.
So, I think on failure this output would be useful as well. So maybe it's better to create a new dictionary `debug_result` which you can then provide to fail_json calls related to fetch_url failing, and you can merge it with result before exit_json. ```python debug_result = dict( url=url, method=module.params['method'].upper(), headers=headers, payload=payload, ) ``` Then add the response and status: ```python debug_result['status'] = info['status'] debug_result['response'] = resp.read() ``` Then call fail_json using it: ```python module.fail_json(msg=str(e), **debug_result) ``` And exit_json: ```python if module.params['output_level'] == 'debug': result.update(debug_result) module.exit_json(**result) ```
I'd go for: ```python output_level=dict(type='str', default='normal', choices=['normal', 'debug']), ```
I prefer this: ```python host=dict(type='str', default='api.meraki.com'), ```
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
I think it's better to refrain from abbreviations in formal/written text. (At least that's what we learned at school) So make that: ```python module.fail_json(msg="DNA Center did not return JSON compatible data")` ``` So it doesn't look like nested quotes.
This is handled by the Azure module utils so isn't needed in the module arg spec
ah, ok... yes, i think when original azure_rm_virtualmachine was done, as_dict() was not available yet. that's why there's serialize_vm function in there. I will actually try to check how it differs from raw REST API response....
i meant that maybe you don't need serialize_vm function at all, you could just use as_dict() which is available from vm object
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
Can be removed after an alias for uidnumber is added.
do not log due security concerns
We tend to not add quotes where they are no needed in YAML. Here they are not needed.
non-blocker: this doc should be improved, I would have no idea how to use `status`
Generally we don't treat usernames as secrets, so no need to mask
Remove redundant round brackets after = sign ``` msg="Cannot connect to database %s on %s : %s" % (database_name, hostname, to_native(e)) ```
`str` is superfluous here, it should be removed.
format is python2.6+ So keep using %. If you want to you can also switch from str(e) to to_native(e) where you to_native by doing from ansible.module_utils._text import to_native. (to_native will be more resistant to tracebacks than str).
Ping @willthames - other than this validation fix this is good to go.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
I pushed this change in my commit to the code
Okay... We shouldn't let tests drive implementation (unless it's a case where the implementation is more modular, easier to read, or more flexible once it's adapted to the test case). let me take a look at updating the test case.
This should probably be `docker.exec_command()`
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
Probably worth using `C(replace_batch_size)` here
Are there any disks apart from system disks? If so then this should be named `system_disk_category` and remove the aliases.
I'd define the (common) `vars:` just once and list the different examples one after each other within the same `tasks:` section.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
What does this method name mean? No need to do anything, I'm just curious.
If I am reading it correctly, `debug_mode` is a specific thing for a whole Zabbix API and not just for this module. This is not something we use in other zabbix modules and its usefulness for lets say an automated playbook is questionable. From the point of user's view, I shouldn't be expected to debug anything if only thing I am interested in is to create a few user groups. Can you provide some reasoning behind this please? I can understand that it is a good help for development purposes.
Ok, my bad. Thanks for clarification! :)
```suggestion version_added: "2.10" ``` The current devel version is 2.10, so I think `version_added` is `2.10`. https://github.com/ansible/ansible/blob/devel/lib/ansible/release.py
Thanks for the quick fix :)
update description, remove dump
`required: false` is the default, can be omitted
`default: null/None` is the default, it can be omitted
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
Example fields doesn't match the real fields name (server,user, pass)
there is no need to version params for new modules
(Alternatively, you could remove the line above this one, and let the module fail if the user does not exist, `state` is `present` and the password not specified.)
I don't think you need this line: `password` (and `update_password`) are only needed when `state` is `present`, and in that case, `password` is already required.
IMHO this should be just as follows because check mode is not relevant if no action is taken. ~~~python if user['enabled'] == args['enabled']: return(retvals) ~~~
There is a small difference: if `_set_password` is `True`, the module should set the password and not return here. Setting the password is done later in the code. It's probably better to not return here at all, neither in check mode nor outside check mode, since otherwise `changed` is not set correctly. After all, `update_password` has check mode support built in.
That's not how `diff` should look like. It should be a `dict` with elements `before` and `after`. These will be converted (depending on the callback plugin, i.e. JSONify or YAMLify) and then diffed.
same here msg="" is missing.
Space missing between "arguments" and "are"
'fail_json' takes 'msg' otherwise it will raise error ``` module.fail_json(msg="YOUR MSG") ``` '+' is redundant in round brackets.
Please use `to_native(e)` [1] instead of `str(e)`. [1] `from ansible.module_utils._text import to_native`
We generally don't mask the usernames, just passwords.
note: in the future this should just be 'distance from current' instead of a specific version number to avoid having to update manually
Added to docs checklist, hope we can implement the "distance from current" thing with the release of 2.8.
You can use [`env_fallback`](https://github.com/ansible/ansible/blob/8f41270a010c00d058c70bdccdc611df8b454139/lib/ansible/module_utils/basic.py#L726)
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
If you're only going to get `APSCOOKIE_` _or_ `ccsrftoken`, then you can just return `None` if you don't find anything and the existing token will be reused. If you are expecting to have both, then I would just dedent the next line to be outside the for loop, so that the token is always added to the dictionary on every run. Then you should be able to at least remove the manual headers building in `send_request`.
ignore if it is missing, warn if we fail to remove
I'm not sure we want to traceback on a failure to remove the tmpdir. We should probably wrap this in a try/except, and either explicitly ignore the exception, or warn.
but this all in a try/except/pass to avoid leaving other temp dirs if one fails all way through
I think you might want to rollback at this point.
> wirte write
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
since force-push ate my previous commit to fix this: s/coloon separated path(s)/path(s) (colon-separated)/
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
` or result > 255`
It might also be no IGWs found here.
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
You cannot move this outside of the `if not callback_sent:` block, because it will send a debug log that the callback is being sent, before we know that it is. This applies to other lines as well. Just move the templating outside, and leave the debugs in the `if` block.
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
Your module is named `gitlab_project_variable` don't use plural in your example
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
If `purge` is `true`, it will be empty according to the code you pasted below.
Above you said "They are present before the module ran". In that case, this list should not be empty if `purge` is `true`, but contain the list of variables which were there before the module ran.
```suggestion description: A list of variables whose values were changed. ```
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value mentioned but not added in argspec.
Default value not specified in argspec.
> set the default to be True (that way user have to force into an insecure setup, that's how other modules work) By default tower-cli will assume True by the same reasoning. The net effect after making that change should be the same.
host and verify_ssl are common settings in module auth, see other cloud/api modules for same. we normally have auth at module level and optionally at config file/env as options.
if requied is true, default does not make sense
i would consider moving this to a module_utils/tower as I expect other modules will need to use the same auth
this is a bad pattern for a module, change to detect dict or string (assume path)
Lets keep logic striate: you want set password if user already exist: ```if state == 'present': if user: if check_user_password(module, user_name, user_password): module.exit_json(changed=False) else: set_user_password(module, client, user_name, user_password) else: create_user(module, client, user_name, user_password, admin) ``` it's ok but lets look on logic above, you already have ```influxdb = InfluxDb(module) client = influxdb.connect_to_influxdb() ``` and when you call ```check_user_password``` you create another connection to db inside of this function. ```def check_user_password(module, user_name, user_password): influxdb = InfluxDb(module) client = influxdb.connect_to_influxdb() ``` Obviously you can pass to this function client object that was init in main() Next ```try: client.switch_user(user_name, user_password) client.get_list_users() except InfluxDBClientError as e: if e.code == 401: return False ``` why do you use```client.get_list_users()```? it returns a list of users : actually a list-object. I guess you can keep only ```client.switch_user(user_name, user_password)``` Another is about ```InfluxDBClientError``` its already part of InfluxDBClient that we import from influxdb in ```module_utils/influxdb.py``` and if you go deeper in ```influxdb-python/influxdb/client.py``` Any way let me try to work with your code and figure out how we can make this code more clean
take a look on drop_user() ``` try: client.drop_user(user_name) except client.InfluxDBClientError as e: module.fail_json(msg=e.content) ```
keep this but...
Don't need to import HAS_BOTO3 now.
I believe this is defined in the docs_fragment.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
instead of forcing templating here, when you don't have task_vars yet, just set run_once based on 'bypass' and then template below in 890 with full task_vars. That way you avoid a 2nd very expensive call for vars and actually get the complete ones (with host).
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
`required=False` is not needed as it's the default
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
I would make it a list so user can pass more versions
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
`changed=False` (this module doesn't do any change).
Can be covered in the `AnsibleModule` instantiation by using `required_if`
`Host group` (copy/paste, i guess)
Why isn't the parameter `mode` also defined here in the argspec? It's listed in the docs but not here.
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
Those lemurs at shippable sure need to work harder! ;-)
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
regarding backup, the way this is implemented will backup the file to the location where the module is executed. When we exeucte this as local_action or `ansible_connection=local`, it will backup the file to the control machine, however we run this module with `ansible_connection=ssh` it will be backuped to the remote machine. This is probably not what is intended. So this should be solved as "action_plugin" (identical to ios_config) which will ensure, the backup is going to the control machine.
Format replacement strings with nothing inside of them, {}, are only available in python-2.7 or better. So you'll need to make sure that all your formats have numbers inside of them. For example, this line would then be: `record_ids = client.get('/domain/zone/{0}/record'.format(domain))`
``` ttl=dict(type='int', default=0), ```
You could add here an example to add a record to main A record => mydomain.com
Remove this as it is already declared above.
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
It would be nice to see the same msg in exit_json.
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Should have a default set to `present`.
s/fo/of/ + ('security' or 'distribution')
Suggest adding a combined example that also uses win_credential.
oy, thanks Github
Do not change the variable name throughout the code. That is not necessary.
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Note that str() can fail if the object's __str__ method returns non-ascii characters. You probably control the objects being used here so you know whether that's the case or not. I usually use ```to_native(self.change_relelvant_keys, nonstring='simplerepr')``` in similar situations so I don't have to worry about it.
please use explicit imports `from ansible.module_utils.basic import AnsibleModule`
please wrap in block ``` if __name__ == '__main__': main() ```
please use explicit imports .... `from ansible.module_utils.basic import AnsibleModule` ... etc
please wrap in `if` block
please use explicit imports
I wonder if there are more correct than wrong uses of `get` :) I mainly know its use in `route53`, where it shouldn't be a state.
(if that doesn't work, change `&` with calling `set.intersection()`)
Ah. I thought you're talking about `dict.get()` being not enough for the validator.
Looks like the CI failure is caused by the set literal under Python 2.6: ```suggestion bad_states = set('list', 'info') & set(data.get('choices', set())) ```
After the refactoring, it's probably okay to inline it back since it's used in one place now: ```suggestion bad_states = {'list', 'info'} & set(data.get('choices', set())) ```
You should use something like this: ``` HAS_JSON = True try: import json except ImportError: try: import simplejson as json except ImportError: HAS_JSON = False ``` And then in the `main()` display proper message if the package wasn't found: ``` if not HAS_JSON: module.fail_json(msg='Cannot import JSON package.') ```
I would prefer explicit imports.
This is wrong, already explained.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
Since the value of `mutually_exclusive` and `required_if` is empty it can be removed and is not required to be passed to `AnsibleModule`
You can avoid the need to import boto3 by just importing HAS_BOTO3 from module_utils.ec2
You can actually skip all the expanduesr business by using `type='path'` instead, then Ansible will parse out a fully qualified path automatically.
There are a lot on non PEP8 assignations here. Basically, in a dictionary or method call, there shouldn't be a space around the `=` operator. For assignments, there should be a space around the `=` call. So line 171 here is wrong, lines 168 and 172 are right
everything below here should be in a create_api_gateway_deployment function. That function should only be called if state is present. Might be worth raising a NotImplementedError if state is absent (or just failing with a similar message)
I know we tend to ask for main to be the last function. I don't see that as a blocker (but not sure).
``` tenant = module.params['tenant']` ```
All of them should be is None IMHO.
0 is technically valid, so this should be `self.prefix_length is not None`
facts modules can trivially support check mode (#23107)
`aci_argument_spec` is now a function and needs to be called like: `argument_spec = aci_argument_spec()`
Same for minor_api_version and rest.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
`validate_certs` and default should be `true`
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
Don't add `required=False` because that is the default. The required parameters will stand out.
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
I'm going to add a commit to do `if os.path.exists(module.params.get('cert')):` instead of try/except.
This module doesn't support check mode. I'm not sure if this is the best method to do this either though.
Please, at most one alias, even better none. Having a long list of aliases is really bad UX IMO.
The corresponding option for restart is called `force_restart`. Calling this one `force_recreate` would be much better.
Space missing before `(megabytes)`.
This should really be a `dict` with `suboptions`.
This should also be a `dict`.
Isn't `raise` missing there ? Calls to `str` are useless.
Might want to check `rc` status before return output.
Sorry, my bad. I didn't see the implementation of `_run`.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
do not log due security concerns
Import custom packages in try/except and handled with fail_json() in main() e.g.:: try: import foo HAS_LIB=True except: HAS_LIB=False
I would prefer the syntax `[7, 8]` comma separated can be confusing
non-blocker: this doc should be improved, I would have no idea how to use `status`
non-blocker: probably some examples would be helpful
use the `get_exception` function in ansible.module_utils.basic instead ``` from ansible.module_utils.basic import get_exception ..... except PanXapiError: exc = get_exception() module.fail_json(msg=exc.message) ```
doesn't match actual return string
not needed when `required=True` is specified
not needed when `required=True` is specified
use `get_exception()` instead
problem with original, but still `str` is not portable, use `to_text`.
use `to_text()` instead of `str()` as its py2/3 portable
Two times boot_mode
I see there is no grouping in this inventory. Is this intentional for the first patch? Fine to me but I'd like to raise that grouping based on `os_name` of `offer` allow greater flexibility when dealing with a fleet of machine, might be interesting to add.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
Nowadays, we do: ```yaml type: bool default: 'no' ```
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
Doesn't look like this got merged intime, so `2.8` here (and other places
s/like C(mail)/(e.g., C(mail))./
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
Make this a regular function
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
Typo in `command`.
If we allow non-Mutable mappings here, then we need to put a try: except around the call to reduce in the if recurse: later as giving it two non-mutable mappings will throw an error. I dislike that non-mutable mappings would be accepted with recurse=False but cause an error with recurse=True so perhaps we should track down why we're getting non-mutable mappings or perhaps we should enhance merge_hash to be able to operate on non-mutable mappings.
If this is needed, just replace MutableMapping with Mapping. (MutableMapping is a subclass of Mapping that adds additional features). OTOH, I wonder why we're dealing with something that's just a Mapping instead of a Mutable Mapping in the first place....
I would switch the statements, test for dict, test for list, else raise error.
These 2 lines can probably just be collapsed into an `elif`
I think we should add an `allow_overwrite` or similar param.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
shouldn't this be like the following? ~~~python if rule == _rule['rule'] or rule == _rule['id']: ~~~
Making `name` optional is probably a good idea.
Please rewrite dict creation using literals (with curly braces)
This thing is also repeated.
```suggestion - This is checked after I(creates) is checked. ```
```suggestion - A filename or (since 2.0) glob pattern. If it exists, this step B(will) be run. ```
I'm not sure how/why anyone would think that creation would happens outside of `dest` since that is where we are targeting to create/unarchive the files. I don't think this item is needed.
Since this is a new feature, the "(since 2.0)" statement can be removed. The description is incorrect. This only controls task change reporting, not whether or not the command will be run. The command will always run (except in check mode), but the task will only report changed if the file changed. This is an import difference in behavior from `creates` and `removes` that should be explained. ```suggestion - Path to a file or glob pattern. If a match exists and it is a file, the command will B(always) be run except in check mode. If any files matching the path or pattern are changed after running the command, the task will report a change. ```
whether* A wether is a castrated goat. Correct spelling under this though. ð
please quote version_added as well to not be a float.
I() for key and value
values in choices and default for bool should be `yes/no` according doc of ansible. it is a convention by Ansible. `required` should be true/false as it is a flag to show it is required.
s/will created/will be created/
not a blocker, but there would be a little helper code for this in basic.py https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L2301
You probably should just exit here with `changed=False`
This method can be simplified to: ``` return [{"ParameterName": str(k), "ParameterValue": str(v)} for (k,v) in params.items] ```
having `main()` call `run_module()` feels a bit redundant, I see no reason to not put all of the main logic in `main` (and splitting actions into functions where it makes sense)
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
```suggestion print('hijacking sys.path to use ansible-vendored files, bwahaha ð£ð£ð£') ```
```suggestion print('hijacked sys.path to use ansible-vendored files, bwahaha', file=sys.stderr) ``` (because this log entry is added after the fact)
Indent isn't really necessary here: ```suggestion if already_loaded_vendored_modules: print( 'doh, some vendored stuff was already loaded: {0}'. format(already_loaded_vendored_modules), file=sys.stderr, ) ```
This could be moved inside the conditional that follows to avoid checking when there are no vendored modules.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
```suggestion - Specifying C(present) is the same as running C(docker-compose up) / C(docker-compose stop) (with I(stopped)) / C(docker-compose restart) ``` `I(...)` is used for Ansible option names, `C(...)` is used for option values and other stuff. (Also applies to many other changes.)
```suggestion - Use with C(state) I(present) to stop all containers. ``` similarly to `restarted`.
Why not keep the `all`? It should be clear that this is about the containers belonging to this service.
Yes, that would be better.
```suggestion - This module was called C(docker_service) before Ansible 2.8. The usage did not change. ``` This can stay `C(...)`. It's not an option name, and the same formatting (of the same sentence) is used in many other modules :)
Are `vmss_name` and `name` different? I'm guessing they are: ```suggestion - Virtual machine extension name. ```
```suggestion - Virtual machine extension name. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
```suggestion - Whether gateway links can be used in remote Virtual Networking to link to this Virtual Network. ```
```suggestion - Whether the VMs in the linked Virtual Network space can access all the VMs in local Virtual Network space. ```
We probably should use that function since it's doing some additional text conversion to ensure it's text type.
i would execute AFTER getting module's shebang so you can find the 'right interpreter' also check that ansible_x_interpreter does not exist already
Add that the user can specify the backend to use via the ```use``` parameter.
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
Bad name again, since body of the method only sets one attribute.
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
Jobs seems to be Dell specific, since standard does not talk about jobs at all. What standard does talk about is that some actions may be asynchronous and that in such case `Location` header value points to the `TaskMonitor` for this action. And again, constructing OData ids using concatenation is just bad.
Ah, I misread that. Totally makes sense :)
I can add that in a subsequent PR, so we don't have to delay merging because of this :)
Yep - I'm not against the _notion_ that it be possible, it just shouldn't be possible _accidentally_. Most LUKS containers I've worked with only have one key on them, ever.
Sounds fine to me. I don't think I can say shipit yet, but if this gets wrapped up in another PR the rest looks fine to me.
I don't know if I like this approach. I can't think of a time when this would ever be desired behaviour, and not a mistake - even so, I feel like we should require a force flag to remove the *only* key on a container, rendering it useless.
Even better use it in `import_external_network` method
This method don't handle idemptency and dry-mode.
`network = on_service.networks_service().network_service(search_entity().id)`
call create, so we are sure the disk is up to date with parameters provided by user.
please use here: ```python self.changed = True if not self._module.check_mode: auth_keys_service.key_service(key).remove() ```
```suggestion self._prefix = 'ansible_host%s' ```
construct a local dict in this method and add result to to this dict, finally return it. DON'T modified a complicated global variable in different methods, this makes the code hard to read and maintain.
IMO, there is no sense to add an additional method call for `self.fetch`, putting the logic to `self.run` is enough. Then the fetch should maintain a local dict rather than changing a global variable frequently
Replace this method with `fetch`, with return value.
```yml - name: Gather metadata facts on Azure VM host azure_vm_metadata_facts: ```
they don't need to, but can be as long as they are acurate
The the formatting argument is single value, it doesn't have to be in braces: ``` cmd += " --format=%s" % p["format"] ``` It improves the readability slightly. The same should apply across the whole code.
Please add dot at the end. The same applies to the descriptions bellow.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
This is the wrong way of doing Ansible. The user should describe the desired state, not instruct modules to perform actions. The module itself should determine what actions the specific state needs based on the current state and the desired state. That is what is needed for idempotency anyway. So rather than action=install, it should be state=present. Also, check-mode support and diff support are very important for a tool like this one IMO.
typos: persistent / reboots
Please rename **follow** to **insertafter**, that is an existing parameter already used by **lineinfile** and better describes what it does.
BTW The most important reason for not adding that parameter, is because it can cause real idempotency issues.
Should be: - Tested on AIX v7.1
After thinking about this more, it's probably more reliable and easier to maintain if we just default to always using our version of `ismount()` rather that trying to evaluate the Python version. Ideally we could probe somehow and fallback to this version rather than doing a version comparison, but it's really hard to probe for a bugfix. ```suggestion ```
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
print can be replaced using sys.exit Except this looks good to me.
Please fix: '... if it doesn't exist:'
if not handling become methods update the class variable to indicate this
If you want to use self.skeleton everywhere, the skeleton assignation 2 lines up need to be removed/changed somehow.
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
No need for this to be a private method. rename to get_inventory().
`f` variable isn't used in this 2nd `try` block: it seems a `for` loop is missing.
You're using the result object to smuggle this around, but it should probably be an instance field instead, since we don't actually want it in the results. Probably the same for the other cases where we're using the result dict as intermediate storage- put them in fields and just construct the result object at the end before it's returned.
`delay_min_macos = delay_min | 1`
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
if not handling become methods update the class variable to indicate this
s/write target file {0}/fetch file to {0}/
This shouldn't be set.
No update supported? As far as I know, the `azure-cli` supports update
My point is the self.credentials may not has a key named 'tenant' if not login
When using format, you will need to specify the index `{0}` so this would still work with Python 2.6
Not needed as it is already set to False
ð To explaining limitations rather than discouraging outright.
how about ```suggestion installed_packages = defaultdict(list) ```
Use a more clear name to better reflect what the function is actually doing. It doesn't just check availability but also mutates state. ```suggestion def try_import(self): ```
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
```suggestion - The kind of storage. ```
```suggestion - Allows https traffic only to storage service when set to C(true). ```
```suggestion - Status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - Status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - URLs to retrieve a public I(blob), I(queue), or I(table) object. ```
Just noting that this RETURN is incomplete
If you pipe this through to the URL, then this should really be "resource". In Kube "kind" is the schema, "resource" is the thing you access via a client. Kind is always a constant (uppercase), resource is always the lowercase RESTful name. I would recommend `resource: service` (if you're doing discovery) or `resource: services` (if you're hardcoding). Mapping `kind` to `resource` is something we explicitly do on the client by looking up a Kind in the discovery doc, so overlapping them can be dangerous.
Am I correct that we've still got no tie-in with the advanced 3-way merge logic currently baked into the kubectl/oc client binaries? That functionality seems so important for Ansible, and rumored to head for the API server soon but still may be a few releases out.
Really like this raw access to the kubernetes yaml, personal preference I don't want a layer of declarative config on top of a layer of declarative config so it's great to see this available.
I completely missed that, apologies
Is the docsite bug that causes strangeness when rendering complex types resolved? I don't recall the issue number, but I think @willthames pointed it out.
Ah, great, that looks like we fixed complex representation!
``` cd docs/docsite; MODULES=ec2_vpc_subnet make docs ```
This should `subnet` with type `complex` and `contains:` the rest of the information
This should never happen as `subnet_ids` is empty list by default, according to the argument_spec.
`Specify authentication algorithm.` No need to repeat what's in `choices:`
We tend to use snail_case, so all parameters should be snail_case.
This is no longer needed. Ansible adds traceback information automagically. ```suggestion ```
There's a hanging PR implementing it in a nicer way: https://github.com/ansible/ansible/pull/44110/files#diff-d4702ee9f9f2977f8c82cb5b4e8b0e26R221. You may want to try borrowing some ideas from there.
This should be using `module.fail_json()` instead.
This variable is causing an `undefined variable` error. ```suggestion command = ["sops", "--decrypt", lookupfile] ```
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
Indeed :) I totally missed that...
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
https://github.com/mozilla/sops/blob/afd073a5be0fe2232d7cd345b9b30edc70ccb962/cmd/sops/encrypt.go#L32 ```suggestion class SopsFileAlreadyEncrypted(SopsError): ```
eewww .... ... if there is no other way .. fine, but do add in more explicit terms when you say it saves the 'current config' that it MAY also include other changes that are not related to this task.
This may seem obvious, but it'd be nice to add to this doc something like "WARNING: if the stack does not exist, it will be created. If the state is `absent`, the stack will be deleted immediately with no changeset." since I can see people missing that part.
If one sentence is written in two lines, the quotes are required. ð
`required: false` is not needed.
Ditto about the deprecation notice
Another (and possibly cleaner) way to do this is to use `pytest-mock`: ```python class SpiedOnTarget: @staticmethod def do_a_thing(): return None def test_empty_retry_iterator(mocker): decorate_with_no_retries = retry_with_delays_and_condition(backoff_iterator=[]) spyable = mocker.spy(SpiedOnTarget, do_a_thing) invoke_retriable = decorate_with_no_retries(SpiedOnTarget.do_a_thing) invoke_retriable() assert spyable.call_count == 0 ```
Always use raises with `match=` or you'll catch false positives. Especially because almost any exception is a subclass of `Exception`. ```suggestion with pytest.raises(Exception, match='Error'): ```
It'd be interesting to see a test case for something inheriting a `BaseException` too.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
Could you add the oauth_token parameter to the example
Also could you add to the example... I think something like this would be valuable for users to see. Hopefully it will help explain when to use this module over the `digital_ocean_sshkey` module. ``` - digital_ocean_sshkey_facts: oauth_token: "{{ my_do_key }}" - set_fact: pubkey: "{{ item.public_key }}" with_items: "{{ ssh_keys|json_query(ssh_pubkey) }}" vars: ssh_pubkey: "[?name=='ansible_crtl']" - debug: msg: "{{ pubkey }}" ``` I'm not sure the `register` command provides much value since your returning ansible_facts. Users can directly access `ssh_keys` as an ansible fact but this module spits out an object that will need a filter applied to it. Still useful if your trying to get a pub-key for additional operations on your servers. Might be helpful when seeding more keys on already running droplets.
Could we included the word `Droplet Sizes`? That will clear up any confusion on what sizes.
Change sample to `data` that will represent what is being returned to the user. Example task: ```yams - debug: var: resp.data ``` Outputs: ``` "resp.data": { "droplet_limit": 100, "email": "sammy@digitalocean.com", "email_verified": true, "floating_ip_limit": 20, "status": "active", "status_message": "", "uuid": "b0ea118ed29548573729203027a0442f9" } ```
I'm just trying to think of a simple use case for these facts.
```suggestion - Password for the user in guest operating system. ```
It is available in PR. Added on https://github.com/ansible/ansible/pull/55059/files#diff-2c15779308a54e8ac33b5eba806f6e5bR84
```suggestion - Must include VM name, appended to 'folder' as would be passed to M(vmware_guest). - Needs to include C(vm) between the Datacenter and the rest of the VM path. - Datacenter default value for ESXi server is C(ha-datacenter). - C(vm) is not visible in vSphere Web Client but necessary for VMware API to work. ```
```suggestion ansible_vmware_validate_certs: False # default is True ```
Nothing specific, wanted to match other module style.
`type='str'` and `required=False` are both defaults, and neither is required in the argument spec (this applies anywhere either might occur)
Looks like you went a bit far addressing this - now you don't import botocore at all You need the above code
You can import HAS_BOTO3, and you don't need to import boto3. You can also assume that boto3 and botocore are installed at the same time, and then it just looks something like this: ``` from ansible.module_utils.ec2 import HAS_BOTO3 try: import botocore except ImportError pass # caught by HAS_BOTO3 ```
Use `required_if(['state', 'present', ['recipients', 'actions']])` in the `AnsibleModule` arguments
everything below here should be in a create_api_gateway_deployment function. That function should only be called if state is present. Might be worth raising a NotImplementedError if state is absent (or just failing with a similar message)
```suggestion self._prefix = 'ansible_host%s' ```
construct a local dict in this method and add result to to this dict, finally return it. DON'T modified a complicated global variable in different methods, this makes the code hard to read and maintain.
IMO, there is no sense to add an additional method call for `self.fetch`, putting the logic to `self.run` is enough. Then the fetch should maintain a local dict rather than changing a global variable frequently
Replace this method with `fetch`, with return value.
```yml - name: Gather metadata facts on Azure VM host azure_vm_metadata_facts: ```
`# In case of wait=false and state=running, waits for VM to be created`
please add spaces around '=' operator
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
host_storage.type == otypes.StorageType.FCP
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
not a blocker, but requried=false is the default and can be omitted.
New person will be confused when you refer to `msg`, adding a brief description will help.
Return is not compulsory but will help end user to understand return value of module.
Use `env_fallback` ``` from ansible.module_utils.basic import env_fallback ... api_key=dict(fallback=(env_fallback, ['HEROKU_API_KEY', TF_VAR_HEROKU_API_KEY']), type='str', no_log=True), ```
`no_log=True` is argument spec will handle this.
An example of using values would be good to have.
Can we rephrase it as "Host should support C(atomic) command"
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
Mispelling of "region"
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
you want to put basedir first to match normal precedence
The `basedir` path will need to be bytes to avoid unicode errors. Something like this: ```suggestion b_basedir = to_bytes(context.CLIARGS['basedir']) collections_search_paths.update([b_basedir]) default_collections_path = [b_basedir] + default_collections_path ``` I did not test this. I'm just guessing from looking at the test failure.
This should be moved inside `execute_list_collection()` for consistency â all other code accesses `context.CLIARGS` directly so it's unnecessary to have an injection here.
``` > ansible-doc -t role --list caddy ERROR! Invalid collection name (must be of the form namespace.collection): caddy ```
```suggestion url = "/".join([base_url, index_set_id]) ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
but to_boolean doesn't convert values to booleans. It's really normalize_options(). It's just that the only implemented normalization at the moment is for boolean values.
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
yes, as well as `None`
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ``` (https://github.com/ansible/ansible/pull/41158#pullrequestreview-128452262)
We use term `mapping` here.
```suggestion - Desired SR-IOV state on interface. ```
I think user can specify specific host from cluster. Cluster and host both arguments should be allowed
```suggestion num_virt_func: ```
```suggestion - number of functions to activate on interface. ```
```suggestion - python >= 2.7 ``` Pyvmomi requires 2.7
I would switch the statements, test for dict, test for list, else raise error.
`if credential and ...` could be used here. With Python 3.5, the call to `endswith` raises an exception: `TypeError: endswith first arg must be bytes or a tuple of bytes, not str`.
Unnecessary blank lines here, removing these blank lines is preferable.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Wouldn't it be better to let `openssl dhparam` write into a temp file, and on success move the temp file to the real file (with `module.atomic_move()`)? Then in case of interruptions or errors, existing destinations wouldn't be trashed (except of course if `atomic_move` itself goes terribly wrong).
`current_version` could be mentioned in the error message.
`return not owner or owner == publication_info['owner']` could be used.
This expression do look a bit suspcious, can you explain a bit more what you try to achieve ? (cause that's if "A and B or A and B" and I am a bit unsure on the order to which I need to evaluate things)
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
If it is not required, you don't have to state this explicitly. (Makes it easier to see which parameters are required when skimming the list)
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
Well this would be for 2.4 so maybe that is the better path
Make this a separate item in the list.
Make this a separate item in the list.
Parameters that are not required don't need `required: false`.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
self.cache contains function `get_all_objs` which already does this, so we can reuse it directly rather than modifying `find_obj`
I have a strong feeling that this `for` should be inside if/else logic. For cluster/host we simply looking for first non-empty entries.
It's more readable to have outside DC loop inside `if cluster_name` and `elif host_name` conditions since they are independent within overall context and can be interchanged.
Hmm, nevermind. It seems that if I remove the `resource_pool` argument altogether then everything works fine. Previously this value was set to `Resources` even though we don't have any explicit resource pools, but without the value an error was thrown previous to this commit.
if self.state == "absent" should be explicitly checked before unregistering the VM, just to be safe.
```suggestion - IP associated with the access list. ```
```suggestion - State the action to perform. Use C(present) to create cpu-class and ```
```suggestion - State the action to perform. Use C(update) to modify the igmp-snooping. ```
```suggestion - State the action to perform. Use C(update) to modify the ```
```suggestion - Access List Name. ```
Also, for check more to work properly, you have to put ``` fetch = create(session, collection(session), [200]) fetch = response_to_hash(module, fetch.get('vpc')) ``` below into an `if:`.
Please remove the `else: changed = False`. That doesn't make sense. Instead, de-indent the `changed = True` above. Once `are_dicts_different(expect, current_state)` is `True`, `changed` should be set to `True` no matter if check mode is active or not.
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
Please do imports globally
Instead of global exception, catch JSON errors and requests errors separately, as this block will apply to both.
features dont get backported
its the specific entry 'that env var' that was added, not the 'env' section, this way we can add/deprecate/remove specific entries and have multiple ones
ansible-doc doesnt need it cause its 'current version' that is mostly for the html docsite
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
this is a property as well
Oh,I just realised this module's still AnsibleModule rather than AnsibleAWSModule. #66863 might be the better version here since it includes some other cleanup.
It requires `botocore>=1.13.21`
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
You should always have `type='str'` (or whatever type you have) in all of argument spec.
`changed = True` should also happen in this branch.
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Could this block (520-528) be a method on the AggregateStats class? something like AggregateStats.aggregate_custom_stats(data=result_item['ansible_stats'], host_list=host_list)
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
I know, was just wondering if it's intended that it works that way.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
don't raise errors on import, expose them on `parse` see developer docs for examples
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
Maybe it makes sense to prefix the label-based groups by something like `docker_swarm-label-` or so, so that short/generic labels don't overwrite existing groups. Or maybe also make this prefix an option for the inventory plugin so users can overwrite it or leave it away if they don't think there will be collisions.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
```suggestion import atexit import traceback ``` Please import `atexit` module
Extending of ZabbixAPI class was used with very old zabbix-api module versions. I am trying to get rid of this in #53334 as it is now working fine with just a base class. Please remove this as well. Your code will work fine without it :)
Handle NoCredentialsError as well
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
This one still needs to be swapped.
```suggestion subnetids=dict(type='list', required=True, elements='str'), ``` Except if you want the list elements to be of another type.
I think it's not good style to use `global`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
since force-push ate my previous commit to fix this: s/coloon separated path(s)/path(s) (colon-separated)/
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
You should use `module.add_cleanup_file()` (somewhere above) instead of manually trying to clean up.
`pexpect` could be used to provide the password to the subprocess on stdin.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
but this all in a try/except/pass to avoid leaving other temp dirs if one fails all way through
ignore if it is missing, warn if we fail to remove
I'm not sure we want to traceback on a failure to remove the tmpdir. We should probably wrap this in a try/except, and either explicitly ignore the exception, or warn.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Added this to the guideline docs https://github.com/ansible/ansible/pull/38978
This will cause a KeyError on untagged EIPs; 'Tags' is only returned when an EIP has tags.
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
This import isn't used.
just use ansible_dict_to_boto3_filter_list here
this line could now use a linebreak
For things with this many arguments, I'd really like to see keywords used to avoid any order mixups in the future.
This `.close()` isn't needed, the context manager closes the file automatically.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
It would be good to have some tests for check mode too.
The alternative would be to always report `changed=False` in check mode, but that could result in an unexpected change during normal execution when you were expecting no change. I would rather Ansible report a change in check mode, but do nothing in normal mode to be on the safe side.
Should we add here that the win_copy module is not a very efficient transfer mechanism and if possible using HTTP downloading using *win_get_url* or *win_uri* is preferred.
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
```suggestion self.module.fail_json(msg="Invalid start VLAN id %s." % vlan_id_start) ```
So if both `portgroup_type` and `port_binding` are defined, it ignores `port_binding`? I think it should check for this and if they are not the same from the API perspective, it should fail with an error
Yeah, i understand the backward compatibility, can you add in the description of `port_binding` that it takes precedence over the deprecated `portgroup_type` value? That way people understand the precedence.
Ah, so the goal is to do a back/forth translation between the values you want the user to use/see, and the actual API values. Sure Could probably be improved by just using dicts instead of all the if/else clauses, but that's just details
Been thinking about this, the easiest solution would probably be a dict: ``` port_binding_modes = { 'earlyBinding': 'static', 'static': 'earlyBinding', 'lateBinding': 'dynamic', 'dynamic': 'lateBinding', 'ephemeral': 'ephemeral' } ``` It's not a lot better, but it gets rid of those if/elif statements
Another regex that can be precompiled.
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
Let boto3_conn handle region failures - region can be picked up in a number of ways that mean that the `region` variable doesn't get set but the connection is fine.
create_vault returns a dict with `location` and `ResponseMetadata`. You'll probably need to call describe_vault to return the expected parameters (and please use camel_dict_to_snake_dict, and don't forget to also call list_tags_for_vault, convert the tags using boto3_tag_list_to_ansible_dict and then add those to the results too) Edit: no need to call boto3_tag_list_to_ansible_dict as tags are actually in the right format for once. This service must be unique!
Sure, but I don't believe it ever happens (and if it does ever happen, use `.get` to return an empty list)
You haven't answered my question :). It just seems unlikely that you'd get a response object with a list of vault objects that don't happen to havethe `VaultName` key, without some other exception being thrown.
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
Lets deprecate the "old" param: ~~~diff - affinty_type=dict(), + affinty_type=dict(removed_in_version='2.9'), + affinity_type=dict(),
You can remove `, required=False`
not a blocker but default=None is not needed because it is already the default and can be omited.
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
`get_config` is not implemented in the cliconf plugin. This function is not used and will only ever return `"None"` if tried.
Wouldn't this create a conflict if someone ran this task twice with the same params, thus resulting in the same name (and a conflict)? Generating the name this way seems good, but can you add a check to make sure there isn't a changeset with that name already? If there is one, then you could return unchanged because the changeset already exists so this task's work is already done.
Prefer `del` over `pop` when not using the return value.
Needs to be `changeset_name = stack_params['ChangeSetName']` to match PEP8 style of whitespace around operators.
```suggestion # require that the final recorded stack state was DELETE_COMPLETE ```
It'd be better here to catch boto exceptions & other exceptions separately, since generic exceptions (like IOError if the network fails, for example) don't have status codes and other boto-isms.
I'd prefer `runlevel` instead of `run_level` in this case. It is a matter of taste obviously.
s/run the/run in the/
+1 to `psexec_command` just for clarity...
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
This should be on a single line.
No blank line here.
`author` is a list, so it should be: ```yaml author: - Kairo Araujo (@kairoaraujo) ```
1) There is rarely more than one author. 2) The same principle is used elsewhere in Ansible that you can use either string or list.
String or list are allowed here so no change is required.
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
Again nitpicker - sentence sounds a bit weird. Maybe something as follows would be better? ``` Nested keys must be quoted when specified in abbreviated form (e.g. C("DesktopViewSettings:IconViewSettings:arrangeBy")), since colons are treated as part of YAML syntax itself. ```
I think it makes sense - the user is responsible for making sure the library is available for specified Python interpreter. Similar to how user is required to install necessary prerequisites for modules, for example.
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
also potentially end this block with `raise`
Please change this to `client = self.connect_to_aws(rds, region)`
Thanks for your work on this! It works as expected (although I wish describe_db_instances() could filter by tags as it would be simpler not to filter out the results while retrieving them).
C/P error, should be `AWS ElastiCache is down`? Same on L450
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
`camel_dict_to_snake_dict` already exists
`snake_dict_to_camel_dict` already exists in module_utils.ec2, it has recently been updated to allow a second parameter `capitalize_first=True` (because someone made the default dromedaryCase early on)
Seems this is only returned when state=present.
I prefer another from line to a trailing slash. So line 69 would be ``` from ansible.module_utils.ec2 import ansible_dict_to_boto3_filter_list, camel_dict_to_snake_dict, HAS_BOTO3 ```
Wrap in try/except please.
Ok we can use sysprep with from scratch VM. But if we run customization in all cases why this condition ? I think it should be : if we set customizations params : if len(self.params['customize']) > 0:
in fact, you are wrong @aperigault because if you add that you will break the guest_map customizations which are handled in customize_vm and doesn't require customize variable namespace
With this we can't customize from scratch vm. I think we only need: if len(self.params['customization']) > 0:
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
```suggestion if any([i in network for i in ['ip', 'domain', 'netmask']]) ```
this would make it incompatible with the service interface
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
`check_rc` is false by default, no need to pass.
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
We try not to use "_" as an identifier just in case we want to internationalize the modules someday (the convention for gettext is to mark strings using the function _(). So we don't want to inadvertantly override _ with another identifier).
Nowadays, we do: ```yaml type: bool default: 'no' ```
I don't think the new description is any more clear. The module does manage files, not just attributes. (So the original file module description is suboptimal IMO)
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
Doesn't look like this got merged intime, so `2.8` here (and other places
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion url = "/".join([base_url, index_set_id]) ```
```suggestion response, info = fetch_url(module=module, url=base_url, headers=json.loads(headers), method='GET') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion returned: success and I(ev_eligible) is C(true) and I(domain_status) is C(APPROVED), C(RE_VERIFICATION) or C(EXPIRING). ```
```suggestion sample: true ```
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
This is always a tough question, and I'm not sure what's the best solution :) In Ansible, things are usually lower-case. I guess you have to decide what you want in the end :)
`Runner has been updated`
Use `missing_required_lib` from `ansible.module_utils.basic`
Same as for the updated, I'd rather say `has been deleted`
use `missing_required_lib` from `ansible.module_utils.basic`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
This check can be also moved to `module_utils`.
```python if state == 'present': if not volume: create_volume(module, array) elif volume: update_volume(module, array, volume) elif state == 'absent' and volume: delete_volume(module, array, volume) else: module.exit_json(changed=False) ```
`delete_volume` does not require size. This check will force user to specify size even if he/she is deleting the volume. I feel this is not intuitive UI/UX.
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
I'm concerned with this being the default behavior. In general we should not be creating files on users machines that didn't ask for. Maybe a flag to enable this, but it should be off by default. I'm also questioning why this should be set to `DEBUG` also. Maybe it should only be enabled with `ANSIBLE_DEBUG` is enabled. Regardless, I think this should be changed or removed.
Please add ``` try: from fortiosapi import FortiOSAPI HAS_FORTIOSAPI = True except ImportError: HAS_FORTIOSAPI = False ``` before `is_error, has_changed, result = fortios_cmdb_set(module.params)`
no worries, let's make it for 2.10, but I think that debug option would be nice ;)
it might be worth adding an option to configure debugging, unless it's explicitly needed by the module.
`state` argument is probably missing for this module.
Why not make module a property from the connection object (maybe change that into a UCS object instead ?). Make it automatically log on if there's no handle already, and keep the handle of the UCS object as well. Then you can simply call the setup_macpool function, and it would have access to both the module as well as the login handle, making the module much cleaner.
Why not put the real meat directly here in main() ? I don't see a good reason to have 2 layers of abstraction (main -> setup -> setup_macpool) if it is unique to the module anyway.
The advantage is that you can simple call module.fail_json there where is fails, without the need to pass everything back. I think it improves readability.
This could be part of the setup_macpool function in this case. Although it would also be nice if somehow we could register calls like this automatically so that whenever the module breaks down, it would automatically disconnect. I know this is not yet possible today, but would be very useful. Especially since UCS is very sensitive to open/unused handles.
This line does not need quotes. (nitpick)
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
I'd do ```suggestion if not ignore_errors: raise ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
i would just keep a templar object and change 'get_handler_templar' to get variables and set it, avoids creating N templar objects and the 'dummy' becomes the main templar object.
i would specifically check for 'string_types' and then `elif its not list`, raise an error.
`listen = FieldAttribute(isa='list', default=list)` <= i would also check why this is not working as intended
This should be an error by default, created #17902 to allow this to be configurable so this change should be removed from here.
this still has the #73643 issue, we might want to store the 'raw' notification instead and reprocess handler matching so we always get the 'latest' version of that handler
If I am reading it correctly, `debug_mode` is a specific thing for a whole Zabbix API and not just for this module. This is not something we use in other zabbix modules and its usefulness for lets say an automated playbook is questionable. From the point of user's view, I shouldn't be expected to debug anything if only thing I am interested in is to create a few user groups. Can you provide some reasoning behind this please? I can understand that it is a good help for development purposes.
Ok, my bad. Thanks for clarification! :)
@rubentsirunyan thanks a lot for taking a look at this! :)
```suggestion - List of user aliases to add in the group ```
example should be removed.
This is a bit of a bad way of checking wether it is IPv6 or IPv4: `::` only occurs if one of the hexadectets is `0000`. You can easily end up with `2001:db8:1:2:3:4:5:6`, which does not contain `::`. quick fix: check for `:` in `ipaddress`. Clean fix: use the `ipaddress` python module (python 3.3+ native https://docs.python.org/3/library/ipaddress.html; or https://pypi.org/project/ipaddress/ for 2.6, 2.7 and 3.2, which is a backport (so same functionality). This is the interesting part: > ipaddress.ip_address(address) > Return an IPv4Address or IPv6Address object depending on the IP address passed as argument. Either IPv4 or IPv6 addresses may be supplied; integers less than 2**32 will be considered to be IPv4 by default. A **ValueError** is raised if address does not represent a valid IPv4 or IPv6 address. ```python >>>ipaddress.ip_address('192.168.0.1') IPv4Address('192.168.0.1') >>> ipaddress.ip_address('2001:db8::') IPv6Address('2001:db8::') ```
The 2 `if` can be merged.
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
+1 for to_text
You just need to catch ClientError and BotoCoreError. If you want, you can rebase on devel and use the pattern ``` from ansible.aws.core import is_boto3_error_code try: return client.get_application(applicationName=name) except is_boto3_error_code('ApplicationDoesNotExistException'): return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, "Could not get CodeDeploy application.") ``` Note: BotoCoreError does not have a .response so if you don't want to use the pattern above you should add ``` except BotoCoreError as e: ``` on line 169
AnsibleAWSModule incorporates ec2_argument_spec so you could remove this import and specify the arg spec as a dict.
Should be able to remove this import and just use `fail_json_aws`
Remove this line
No need to import boto3
no, really, remove the deprecated files from your commit
You need two more entries `['interface', 'interface_in']` and `['interface', 'interface_out']`.
```suggestion interface=('direction', ), ``` Otherwise it is simply a string :)
Do not change the variable name throughout the code. That is not necessary.
I don't think we can fail out on this without a deprecation cycle first.
This is not a good practice, use module.debug or module.log , you can even check module.verbosity to figure out the level you want.
you dont need to include most of the defaults here (nor in docs), `default=None`, `type=str` and `required=false` are all redundant
no real docs, but you can look at other modules that do it, i.e copy
the module can run on systems in which Ansible itself is not installed, that is why you should always put any 'non core' python library in requirements, even if you alert later on it is 'nicer' to inform the user when he reads the docs vs only when executing the plugin.
You are missing 'pyyaml' and vdo CLI tool (as much as it should be obvious) as a part of 'requirements'. modules are not guaranteed to run on the controller, so you cannot expect pyyaml
```suggestion tuple: First element is True if valuemap exists and False otherwise. ```
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
`final_interface = dict((k,str(v)) for k,v in final_interface.iteritems())` seems to be required here since the values from new_interface may contain non-strings while the values returned by the API are always strings. With this added line, the module becomes idempotent with passive proxies.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
```suggestion status_down = self.client.check_if_swarm_node_is_down(node_id=self.client.module.params['node_id'], repeat_check=5) ```
Or store it in `SwarmManager`'s `__init__()` and use `self.node_id`.
I think it makes sense to fail here instead. (Or return `[]`.)
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
This one will fail, since selfsigned_notBefore and selfsigned_notAfter have changed their meaning from the initial draft and don't have default values any more.
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
Boolean parameters: add default value (`False` is default value for `has_expired`, `extendedKeyUsage_strict`, `subjectAltName_strict`).
Use `C` formatting function for the sample list.
Use `U()` for `acme`.
too many apis
Please split into under 160 character length lines
All `description:` MUST be full sentences (capital letter and full stop)
It would be good to combine these before the module gets released to avoid changing the module interface after release.
you really dont need 2 datas here, a type='json' will take both a data structure or json doc
facts modules can trivially support check mode (#23107)
required=False is default, so this can just be `dict()`
`show` state would probably be better as a separate '_facts' module.
Well I would at least enable check mode in the module so people can 'show' in check mode.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
I think we should add an additional check to check for this parameter only if powerstate is `poweredon` or `rebootguest` otherwise in other options module will wait for IP address.
So most people will declare the VMs that should exist, with the power-state it should be in. If a user then reconfigures the declaration for that VM, and e.g. changes something to the VM, the powerstate will still be stated and he will expect the VM to be reconfigured, and powered on if it wasn't powered on. So yes, the module should be able to reconfigure and change power state in a single call. And because of the above, we should not simply use the result of the set_powerstate function, but we have to merge some of the return values, as was originally done. I think someone changed **vmware_guest**, not understanding people may want to make a change to a VM and setting power state.
This will replace everything in the result dict. This is not correct. I see now that the logic is wrong, and I am not sure when or why this is like this. In all states (except absent) we should perform a reconfigure. That is why in the case of a specific power state, it may not replace the result dict.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
Parameters that are not required don't need `required: false`.
If there's no default, `None' is implicit. (It means parameter undefined) So this is not needed.
Make this a separate item in the list.
Make this a separate item in the list.
Parameters that are not required don't need `required: false`.
``` if "floppy" in self.params and self.params["floppy"]: ``` -> ``` if self.params.get('floopy', None): ```
@pdellaert I am not sure about this check. Could you please let me know if it is correct ? Thanks.
Just hardcode the value: `cdrom_ctl = 'ide'`
I don't think it make sense to actually allow the user to set a controller_type since only 'ide' is supported. ``` if cdrom_spec.get('controller_type', 'ide') != 'ide': self.module.fail_json(msg='Show up an error here.') ```
I'm not sure you need the `ctl_exist` variable.
`datastore.name` requires access to the datastore itself, and thus might throw a permission error. This value should be wrapped in a try/except.
@phemmer , We've discussed this in the weekly Ansible VMware meeting. In my opinion, having a dict is useful, IF the key is useful: * The reason to have facts is to use them in a task later on * With a list, to find the proper disk, it is harder to find the item you want to match on ( `{{ (disks | selectattr('label', 'search', 'Hard disk 1') | list | first) }}` for instance) * With a dict, if the key is useful, it doesn't require that. If you want to match on another criteria, the loop is still a possibility. Proposal is to have the label as the dict key as it is what is visible in vCenter and is orderable, does that make sense to you? Any other criteria you might find easier? (disk.key is another possibility, but less 'visible' in vCenter)
This should be a list, not a dictionary. The dictionary key is just an incrementing index value, which is what a list is for. Having it as a dictionary just makes it harder to use (having to deal with an index generator, and dictionaries don't guarantee order).
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
use ```from ansible.module_utils.vmware import find_obj```
https://github.com/ansible/ansible/blob/cd988f645aaf774c55a98a90e3ef42cc5b1a1563/lib/ansible/module_utils/urls.py#L1147 gives all options.
Add a sample dict returned by module.
+1 for this.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Not sure if we can license module code as Apache License.
```suggestion - The name of content library to manage. ```
```suggestion - content library id for which details needs to be fetched. ```
Thanks for that clarification. Upon reviewing the code, it wasn't obvious to me that this module is actively using both connection paths (to the k8s API and also to the Upload Proxy.) I've taken your word for it and updated my related PR.
Description should be: _Fetch running virtual machines from KubeVirt clusters_ Reasoning: 1. This only returns *running* vms. 2. We've decided to hide the internal implementation of VMs/VMIs (as much as possible) from ansible users.
Beware that in your examples, you are actually using `application_profile_name` not `app_profile_name`
For the examples I think it's better to add proper input as if this is a real-world action. If you put text (with spaces) in there, it will confuse people as to what input is allowed. And just adding the description text for the parameter does not give any valuable information.
Add a trailing dot.
I would simple make this `tenant`. If you still prefer backward-compatibility, you can add `tenant_name` as an alias.
The `notes` is a list of items, and each note must end with a trailing dot. Please also make this an full English sentence: ```yaml notes: - The tenant used must exist before using this module in your playbook. The M(aci_tenant) module can be used for this. ```
this should be in the run method, otherwise ansible itself will fail to run
we should capture possible import exception and explain that this lookup requires the credstash python library when it fails
You could use: ``` CLIPASSWORDSDK_CMD = os.getenv('AIM_CLIPASSWORDSDK_CMD', '/opt/CARKaim/sdk/clipasswordsdk') ``` or even `ansible.constants.get_config`. `get_config` allows to define a default value and will search a defined value in an environment variable and the config file).
You are definitely right! For the sake of consistency, PEP8-incompliance is never a problem. I won't give this advice if I were more familiar with the Ansible source code. Sorry for my self-approbation ;-(
One space around an assignment operator will be better. Sorry for my OCD of PEP 8 ;-)
`str` is superfluous here, it should be removed.
`str` is superfluous here, it should be removed.
I think you need `to_native` here.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
Thanks - I've replaced all uses of `filter` with comprehensions.
Same change needs to be made to many other uses of filter.
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
If the above is an issue we can make all return the exception and consistently handle them in the module.
```suggestion - The plugin also sets standard host variable I(ansible_ssh_common_args) to C(-o StrictHostKeyChecking=no). ``` C(...) is also commonly used for general "code"/"teletype" markings
First, use `yes`/`no` or `true`/`false` for booleans in YAML, not `True`/`False` or other of the myriad allowed forms. Second, don't add `required: false`; only specify `required` if it is `yes`/`true`.
```suggestion - The plugin also sets standard host variable ansible_ssh_common_args to '-o StrictHostKeyChecking=no'. ``` Same in the line below.
You should add something on how the labels look and into what they are converted. That makes it easier for people to understand how this feature works.
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
```suggestion # with the same name and value but with a dm_ name prefix. ```
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
How about ```suggestion kv_pairs = [kv_pair.strip() for kv_pair in tags.split(',') if kv_pair.strip()] for kv_pair in kv_pairs: ``` That avoids empty strings showing up in the result, and also allows users to separate with `, ` instead of `,`.
If `tags` is the empty string, you will get one `kv_pair` which equals the empty string. That's probably not what you want.
Maybe we can remove the `if min_version:`? min_version has a useful default, and if `min_version=None` is passed, it is OK to explode, from my point of view.
> Did you read the stacktrace mentioned in the description of this PR and in the first commit ? Sure, but I did not understand how this is related, but with your additional exlaination, I understand now. The commit message could be improved by writing something like "`openstack.version.__version__` expression raises an AttributeError exception when openstacksdk < 0.10.0 is used. openstack.version is now imported as a module, which works for all openstacksdk versions.
This has broken OpenStack ansible modules in 2.8.9. min_version should be a string, not a StrictVersion. We get the following error: TypeError: expected string or buffer This affects kolla-ansible, and probably a few other things too. https://bugs.launchpad.net/kolla-ansible/+bug/1866181
The old comparison is doing <=, not just <. So we need min_version='1.9.0' I believe.
Another <= comparison, so min_version = '1.10.0'.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
this should look like this instead: ``` result = super(ActionModule, self).run(tmp, task_vars) if result.get('skipped', False) or result.get('failed', False): return result ```
Please add `, no_log=True`
Make sense to me. Thanks for info.
~I do not think so `check mode` is required for facts module.~
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
I think I'd handle purge_listeners at the consumer end of this method. Just seems easier than passing it in and handling it here. But not a blocker
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
Add traceback here as well (for line numbers).
Add `exception=traceback.format_exc()` here as well please.
Can `state` default to `present`? I usually expect this, I'm not sure if the flaw is with me or not :)
```suggestion - A list of tags to be remove from the resources. ```
I(....) adds the highlighting that this is an argument name.
```suggestion - Either I(tag_keys) or I(tags) is required when the state is absent. ```
```suggestion type: list elements: str ``` It's helpful to define that the list is a list of strings (or what ever).
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
you just described check mode in general
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
docs say name is required, spec does not
a better message might start 'Failed to update the organization: `<execinfo>`' ... also It would be nice to make the distinction between retrieval and update, as they could pose separate permission issues. i.e. I can read but not update the organization.
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
It'd be nice to hint users about what version is not old.
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
can delete this line
ansible.module_utils.ec2 sets HAS_BOTO3 to the correct value.
this is too aggressive as it removes all ACLs, not just the ones we added take into account that directories can have 'default acl' to be added to all new files in a directory, this would wipe those along with the one we added to copy the file into place
```suggestion pass # Handled by AnsibleAWSModule ```
It may not be forward compatible then, but it seems unlikely AWS would change it unless they introduced something new.
before continuing here, check that fields is actually populated as a list, or try/except the following code
use an else here and you can have only 1 return at the end (even that is not needed)
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
which was incorrect solution as the 'non templating' of pause shows
no, jimi-c has alternate solution and we'll probably go with that
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
Omit these lines please.
This is easier to read: ```python if self._task.notify is not None: if notify_per_loop_item: if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ``` Or using the existing string option: ```python if self._task.notify is not None: if notify_scope not in ['task', 'per_loop_item']: raise AnsibleError("Invalid option '{0}' given for notify_scope. Valid options are " "'task' or 'per_loop_item'".format(to_text(notify_scope))) elif notify_scope == 'per_loop_item': if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ```
```suggestion - name: Show variables with 'hosts' in their names ```
```suggestion - name: Find several related variables that end specific way ```
You should probably note that these patterns are expected to be regex (vs. globs). The examples show this, but it doesn't hurt to be explicit. It also wouldn't hurt to mention that the patterns are not implicitly anchored.
```suggestion - List of the variable names requested. type: list ```
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
You should handle the case that `time_str` is not actually a string.
This is a private function, so its name should start with a `_`.
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Return ```suggestion return [ (data_0, expected_0), (data_1, expected_1), ] ``` And then have just one invocation.
Also, in Python, you have to specify a list of base classes when declaring a new one or omit the braces completely. ```suggestion class TestAnsibleJSONEncoder: ```
you can use modules for namespacing. using classes for this is overkill
That's not true. This class is used only to namespace things. Not for testing. Also, [stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0). It's not worth it, not in this case.
no, it's in the method. it shouldn't be re-declared on every method invocation.
I would rather add all other fields to the error message.
while this might make sense for dictionaries, since shell doesn't really support them, for lists it might not as they are supported by shells
Here you ignore the fractional parts (milliseconds, microseconds). You need to add `1000 * timedelta(**time_params).microseconds`. (Also, you should store `timedelta(**time_params)` in a variable, instead of `time_in_seconds`, and work with that one.) I.e. something like: ``` .py time = timedelta(**time_params) time_in_nanoseconds = (time.seconds * 1000000 + time.microseconds) * 1000 ```
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
If you use `to_text(xxx, errors='surrogate_or_strict')` it won't throw exceptions.
Spurious `else:` Breaking the tests.
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
In other modules that support `authorize` we have some code here to check we are in the right context (privileged shell vs non-privileged). If you were to test the code with a task that requires privileged then one that requires non-privileged then I believe the current code would fail. `ios` supports `authorize` as well: https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L72-L86
Not required after above `load_provider()` change
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
`version_added` should be `"2.7"`
~you don't seem to use 'cli' why import it? also the base class does this already.~ v1 compatibility it seems.
this whole section is not needed, just use `self._plugin_options[<option name>]`
its new in 2.4 so it doesn't apply to older versions
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
You should set the default value for this like ``` create_mode: description: - ... choices: - ... - ... default: default ```
s/createMode/I(create_mode)/ When referencing other options, enclose it in `I()` and the docs will do the formatting for you.
This really needs to be split up instead of just one long paragraph that seems copied from the Azure Docs. Set each options under the options key and Create a new description category for each option. ``` create_mode: description: - Specifies the mode of data creation. - When C(default) means a regular database creation. - When C(copy) will create a database as a copy of an existing data. I(source_database_id) must be specified. - When C()..... default: default options: - default - copy - non_readable_secondary - online_secondary - point_in_time_restore - recovery - restore - restore_long_term_retention_backup ``` I would also convert the options to use snake_cake and not CamelCase as that is what Ansible usually does.
updated or created isn't needed
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
Since this is controller code, this should probably be using ```to_text()``` here. The ```self.get_option``` also seems redundant since you just pulled that value into inventory_id above? So maybe: ```suggestion inventory_id = to_text(inventory_id, nonstring='simplerepr') ```
(Using nonstring is not necessary as simplerepr is the default but I like to use it to flag this as a case where we're using the function to get the textual representation of an object rather than a case where we're converting from bytes to text.)
I'm a little iffy about the ungrouped or all group here. I would skip ungrouped.
should this really be 'endswith' or more like equal? `path.strip() == '@tower_inventory'`
ah, its seeing it as a file name ... weird since host_list 'works' .. i should look into that
remove `default: None` as default is set to None by-default.
Double quote around Author name.
The short_description never has a trailing dot. Help keep the index clean !
Required is default to false, so this line is not required.
Mispelling of "region"
You could add the minimum required version (`>= 1.0`) here too.
```suggestion - When used on earlier versions of HAProxy, it will be ignored. ```
```suggestion - This parameter is required, if C(state) is set to C(poweredoff), C(poweredon), C(powered-off), C(powered-on), C(present), C(restarted), C(suspended) ```
`Current host '%s' can not be rebooted...`
`Current host '%s' can not be shut down...`
Do you need expiration to be an int type as well or is it okay if it is a string repesentation (like: "10" )
There doesn't appear to be any way for `sha1sum_old` to be `None`.
`default=None` is the default (can be removed from the others too, along with `required=False`, if desired)
There doesn't appear to be any way for `sha1sum_old` to be `None`.
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
It's correct where it is
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
```suggestion re.compile(br'[\r\n]?<.+>(?:\s*)$'), ``` And so on for all the entries of both `terminal_stdout_re` and `terminal_stderr_re`.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Could you please keep the same string quoting style across the module? ```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('UTC')), '2019-06-15T14:45:00+00:00'), ```
@machacekondra still, it requires the docs also that module would not have passed review, it got merged w/o it so it is not a good example to follow
It's addressed here https://github.com/ansible/ansible/pull/47803/files#diff-4e0a09d18f6dfe19eb9d0b30c0a53bafR16
you are also missing doc fragments for classes using constructable and cacheable
This variable is never used in the code.
is this per connection or global? some options seem like they are overtly indented
None is the default.
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
This can also be an ARN, right? In which case the length can be up to 140 characters.
required=False, default=None is default for an argument
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
What about to format this like this: ```yaml with_items: "{{ rhsm_repository.repositories | map(attribute='id') | difference(['rhel-7-server-rpms']) }}" ```
Please format this like this: ```python state=dict( choices=['enabled', 'disabled', 'list', 'list_enabled', 'list_disabled'], default='enabled'), ```
Listing data should be in a lookup plugin, not a module.
Or a facts plugin would also work.
I wonder what should happen when disks is [].
I think it's not worth to create the temp var here, maybe just pass the `self._connection.follow_link(template.disk_attachments)` directly in `for`, also it's not strict to use 80 chars/line and I think here the newline makes it less readable, so if you want to use temp var then I think it would be more readeble, to not use new line, but up to you.
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
Here as well: ```python console=( otypes.Console(enabled=self.param('serial_console')) ) self.param('serial_console') is not None else None, ```
You can replace line 1284-1293 by: ```python vms_service = self._connection.system_service().vms_service() vm_id = get_id_by_name(vms_service, self.param('srcvm')) vm_service = vms_service.vm_service(vm_id) ```
not sure if its just me but i still find it confusing, wouldn't it be cleaner as?: ```python flag_val = p[flag] if flag_val: args.extend((arg, to_native(flag_val))) elif flag_val is not None: args.append(arg) ```
At the point it is 'clear' i'm fine with either way, i am not going to force a style unless the code need de-obfuscation.
use to_native (module_utils._text) instead of str, it deals with py2/py3 compatiblity
yes, type=raw will avoid type enforcement, but it is not normally a good interface
so the 'is' will only work with boolean values so you cannot set a jobs = 5 nor jobs = '', the original was not completely correct either: ``` if p[flag]: args.append(arg + to_native(p[flag]) ``` ^ this should work for all cases .. except 0 values
```suggestion - This is a only when I(type=private). ```
not a blocker but the convention is to have `present` as default, please also consider this for your module.
In this case I would just manually do it, especially turning `Id` to `pid` to match the option names. Otherwise there is https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/powershell/Ansible.ModuleUtils.CamelConversion.psm1.
I don't like the fact these aren't snake_case, surely we can convert
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
basically #53869 does same for vultr plugin
yes, since that is what you specifically are doing with the new option 'setting ansible_host' while the compose system gives you a generic way of setting any/all kinds of variables, you really only need this type of option for 'inventory_hostname'
maybe I am not being clear, my point is you do NOT need THIS specific option, using compose any user can decide exactly what `ansible_host` value is set to, as well as any other connection or non connection specific variable.
Instead of hardcoding this choice, why not use constructed/compose functionality to allow user to set `ansible_host` and similar variables to anything they need.
Ah, right, got it :+1:
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
To be consistent with other modules, this should be validate_certs, not validate_cert.
"This should only set to no used on" - sounds awkward. I also don't recommend reasons for when to turn this off. I'd just warn them it's not recommend. Even personally controlled sites using self-signed certs can fall victim to MITM attacks.
Please remove `required: false`
Example appears to add, rather than delete.
``` default: true type: bool ```
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
I learned recently that you can use actual separate literals to improve readability: ```suggestion @pytest.mark.parametrize(['url', 'expected'], [ ```
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Can you just catch `AttributeError` here instead.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
@tzurE In a follow up PR could you please update all your modules to be in the form `- Tzur Eliyahu (@tzurE tzurE)` This allows Ansibulbot to know who to contact if their are follow up issues or PRs
```suggestion - Name of the domain to be managed. ```
```suggestion - This module can be used to add domains to or remove them from IBM Spectrum Accelerate storage systems. ```
```suggestion - The desired state of the domain. ```
```suggestion - Size of the domain. ```
Maybe add "ansible versions below 2.10" or something so it's clear this is a one-time problem, not that they can never upgrade `ansible` again...
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
better commit message would be ``` pamd args_present: properly update args, avoid dupes fixes #47197 ```
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is not` vs `!=`? I may not be polished enough on my python...
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
I would not assign it w/o validation: 1) it might cause errors happening in some other place, which would be hard to spot 2) it might be a weak place, vulnerable to injection attacks (security issue)
Also, in case of not match `gitconfig` would have `None` value, which would've broken this module in some place being executed later.
should the line start with `gitdir` or should it be in the end of line with smth prefixed? you might want to prefix the regex with `^`. On the other hand, taking into account that regexps are expensive, you could just use str.split or partition with bits of validation on top, like: ```python try: ref_prefix, separate_git_dir = data.split('gitdir: ', 1) if ref_prefix: raise ValueError('.git file has invalid git dir reference format') if not os.path.isdir(separate_git_dir): raise TypeError('%s is not a directory' % separate_git_dir) os.environ['GIT_DIR'] = separate_git_dir except (TypeError, ValueError) as err: """``.git`` file does not have a valid format for detached Git dir.""" module.fail_json( msg='Current repo does not have a valid reference to a ' 'separate Git dir or it refers to the invalid path', details=str(err), ) ```
Please dedent all the following code, so that it would be outside of `with`-block.
Yes, but it is still unrelated to the env var.
I think this needs to be `create_vpn_gateway(**params)` so that we don't always pass the AmazonSideAsn when the user doesn't specify it.
Ah. lambda is prettier though :). maybe we can run pep8 with ignore lambda error.
Make this `elif`.
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
All configuration values should not include default values, as that leads to accidental overwriting of existing configs that the end user did not expect.
Please update the sample commands.
A couple of commands here would be good.
`version_added` is not needed, because the module itself will be added in `2.10`.
There's some mixed spaces and tabs here, please remove the tabs and use spaces only.
`speed` should be `int`
I'd lean towards making it an optional module arg as well. Mostly for testing purposes but also to support if the url does change users could handle it with just playbook updates instead of requiring a new module version.
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
`pipes.quote` is deprecated in Python 2.7 already. You should import `shlex.quote` if available. try: from shlex import quote except ImportError: from pipes import quote
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
You should really have at least one example with `state=absent`.
You probably should add yourself to the authors list as well.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
Sounds fine to me. I don't think I can say shipit yet, but if this gets wrapped up in another PR the rest looks fine to me.
I don't know if I like this approach. I can't think of a time when this would ever be desired behaviour, and not a mistake - even so, I feel like we should require a force flag to remove the *only* key on a container, rendering it useless.
I can add that in a subsequent PR, so we don't have to delay merging because of this :)
Yep - I'm not against the _notion_ that it be possible, it just shouldn't be possible _accidentally_. Most LUKS containers I've worked with only have one key on them, ever.
Ah, I misread that. Totally makes sense :)
This needs exception handling.
Needs exception handling here too.
This needs BotoCoreError and ClientError exception handling: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to terminate job flows for cluster {0}".format(cluster_id)) ```
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
`state` shouldn't be an action. This should just have the choices `present` and `absent`.
(and there's no need to have this var outside or this loop or increment it manually, then)
```python for line_number, line in enumerate(lines, 1): ```
I think, guard-expression style would fit better here: ```python if not import_name in module_utils: display.warning('%s:%d Invalid module_utils import: %s' % (path, line_number, import_name)) continue imports.add(import_name) ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Use Jinja variable instead of IPs.
What you just said is the same as saying it is okay to add technical debt to the project. There's no excuse for repeating those large code blocks. It impacts future sustainability.
Curious that the inputs are dictionaries, but the outputs are not.
@Akasurde, as the main maintainer, what's your view on this? So we can close the discussion, i think for me this is the only thing i'd change, the refactoring or early failure is less important to me and are nice to have's.
This could be refactored into a method, since the logic is identical. Same for the next two large blocks.
It seems network integration test is failing because of PR #47345, hence reverting the PR
```suggestion else: ``` I'm trying to make sure I understand what's happening here, will this change have the same intended effect? (I don't know if anyone else likes for-elses as much as I do, but it would allow you to get rid of the `ignore_line` sentinel variable)
I think this should be 'exit' instead of 'abort'
What is the reason to add second while loop here? Does the call to `recv_ready()` increase the delay amount. How about chaging it to ``` while True: if self._ssh_shell.recv_ready(): data = self._ssh_shell.recv(256) <--snip--> ```
It is not recommended to log commands executed on the remote device due to security reasons.
(Additional whitespaceânumber of spaces not multiple of 4.)
`{}` is not compatible across python versions that support format, use `{0}` or `%` instead
no need to specify required=False or type=str as these are defaults
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
Like above, I think this should be `userid, name, password, group, email`
I'm fine with shipping as is, but i'm not the best person to say.
This can be set on OpenStack network level also. So my thought would be that the default should be None, in which case the port will inherit the setting from the network. This is similar to how OpenStackSDK itself, and "openstack port-create" CLI, behave. I guess that setting the default to True would override that always, and enable it even if it the user did not specify it and the network default was set to "False". Also, in case of port update we presumably want to leave this parameter as-is unless it is explicitly specified.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
I think we also want to require `encryption` be specified anytime `encryption_key_id` is passed. That way users won't accidentally pass the key_id and assume that it's being used when it may not be.
The rebase brought the default back. This just needs deleting, then I think we're ready.
Not needed with AnsibleAWSModule
you might want to call vault = self.exists(self.name) immediately after `create_vault`. Otherwise you are not returning what you say you are when creating a new vault.
You should handle BotoCoreError here instead of NoCredentialsError: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws Same applies for all of the following exception handling. BotoCoreError and ClientError together should suffice.
You need a paginator here still.
You're importing ClientError itself as well as botocore, but still using `except (botocore.exceptions.ClientError, ...` instead of `except (ClientError, ...`. Could remove this import. Or add , BotoCoreError to this too and save some line length in places below.
task_uuid seems unused
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
ipt_load_stderr doesnt appear to be defined anywhere.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
s/Disk quota ID/Virtual Machine quota ID
Perfect, we should keep msg as well with message.
He meant - return dictionary may / can contain previous state of properties and current state of properties so user can distinguish between action.
The security group rule and the trunk are not present in any of the resources' contents here: https://github.com/openstack/openstacksdk/tree/master/openstack/cloud, consequently using the `cloud.get_<resource>` call fails. Instead the `could.network` call can be used.
Could try running the command with the env setup to use LANG=C You can specify the env for the command either with the 'environ_update' arg to run_command() or by setting module.run_command_environ_update before the run command.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please check this.
Please check if this is still valid for `icx` parameter since current release is 2.9
resue the function here https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L73 to avoid code duplication
There in no module in VMware space, which is absent / present for enable / disable but we can add `state` with multiple choices like `[ absent, present, enabled, disabled ]` .
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
Here add: ```yaml type: list ```
We prefer that examples show sensible values, so people understand what is expected. If you add variables like this, there's no clue what the actual content would be.
The aim of having a `vcenter` connection plugin, would be that the connection information of the guest would store the vcenter info/credentials, so that we wouldn't need to repeat this information. And we should probably use the same connection variables for both the `vcenter` and `vmware_tools` connection plugins. cc @dericcrago
This could be less nested once you apply `choices`.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Ah, it's nice that the syntax checker caught this bug. This should be `network_interface['tags'] = boto3_tag_list_to_ansible_dict(tag_set_copy)`
Why the loop here? `if match` should be sufficient
What is the reason to use kwargs here? Since the argument list is defined I don't see a reason to use kwargs. Applicable at other places as well in this file
Since replaced is equivalent to deleted of existing attributes in want and after that merged, can this be refactored to reuse the state=deleted logic Something similar to ``` commands.extend(Interfaces._state_deleted(want, have)) commands.extend(Interfaces._state_merged(want, have)) ```
Can `_state_*` be changed to the class methods as it invokes methods from within the class? I don't see a reason to have these methods as `staticmethod`
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
ditto about s/no/'no'/
Please remove `, no_log=True` from the username line
If this is going to be common to other DellEMC modules then you can move this method to `module_utils/dellemc.py`.
```suggestion match your environment." ```
Sorry, I was still about to reply to this, but then I got sick (unrelated to this PR ;) ) and forgot about this... It is indeed a mamoth block, and I'm not really happy with it; as you said, this complex beast isn't the best idea for a docs example. I guess we should try to simplify/shrink it a bit, though no longer in this PR ;)
```suggestion {% if no_proxy | regex_search('\/') and ```
Use `false` or `no`, never `False`. (Same below.)
there is no need to version params for new modules
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
You can definitely add yourself here as well.
This should be a string: ```yaml version_added: '2.4' ```
```suggestion - "This module can be used to create or delete an event in oVirt/RHV." ```
The short_description never has a trailing dot. Help keep the index clean !
Should be 2.4 (as we don't backport new modules to older releases).
As exclude_tags could be an empty set, I would directly check `if exclude_tags and set(server_tags).intersection(exclude_tags)`. This way, it should also work when exclude_tags and server_tags are empty.
Keep the `r`
Same as earlier, I would check that `if mandatory_tags and not set(mandatory_tags).issubset(set(server_tags))`.
for other modules we are already using `append=yes|no`
instead of 'comma separated list' just make 'list' , type=list will accept both types of list and always guarantee a list object to the module
```suggestion """Test that a new lock can be created within a Process.""" ```
I don't think another var is necessary. If the first iteration to start the processes succeeds and won't interrupt the control flow, all of them will be active. ```suggestion processes = [ Process(target=_run_threads, args=(_,)) for _ in range(1, 6) ] for t in processes: t.daemon = True t.start() for t in processes: t.join() ```
```suggestion Test that the returned value for timezone consists of only uppercase ```
OTOH, this does nothing since the module is already cached by the time this gets executed. So it's a no-op.
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
Oh, you're right.
You don't need the if/else block here.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
We don't need tags in this function, I think.
```suggestion choices: [ full list, top sites ] ```
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
Keep a blank line between examples for readability.
This is wrong, already explained.
Don't add `required: false`. It is implicit.
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
Can get rid of required=False.
we normally add more than the 'library' error as they tend not to be as helpful as giving a user context on what you were attempting to do exactly when the error occurred.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
I would prefer that this defaulted to None, otherwise someone might find their existing key rotation suddenly gets disabled when they just want to tweak the tags.
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
The rebase brought the default back. This just needs deleting, then I think we're ready.
A message string would good to say that image is not preset or something similar.
having `main()` call `run_module()` feels a bit redundant, I see no reason to not put all of the main logic in `main` (and splitting actions into functions where it makes sense)
This should be `fail_json()`.
Please order the parameters alphabetically.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
`check_args` is present in other network platforms for legacy reasons and can be removed here if not used
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
print statement can be removed
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
I'm not that sure it is a broken feature, my expectation is closer to what you expressed, but i still don't see this as broken .. at most, misleading. As for actual contract, no, nothing singed, it is an understanding that things don't change arbitrarily unless they are clearly a bug, to be honest, this is on the line for me.
By break, we mean that the result is different than current expectations and that breaks the contract with current users, not that it causes an actual code failure.
@jmighion would be great if you can update ios_config as well. Thanks!
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
Please add a comma to the last element. This makes diffs easier to read and makes syntax errors less likely when adding or reordering items. ```suggestion non_unique=dict(type='bool', default=False), ```
I think if you revert this part of the code and remove the getattr defaults below, it should be fine.
Looks like we could keep this pretty much as-is if you also remove the getattr() defaults. That will cause line 284/285 to throw an error, and then we can rely on later code to warn the user that the secrets.py file wasn't found.
We use `pytest` to run tests and the helpers from `unittest.TestCase` should be avoided (ideally, `unittest.TestCase` should never be used because it limits the compatibility with `pytest`). Instead, use `pytest.raises()`: ```suggestion expected_error_msg = ( r'^The --prompt option is not supported if ' r'also reading input from stdin$' ) with pytest.raises(errors.AnsibleOptionsError, match=expected_error_msg): cli.parse() ```
My point is the self.credentials may not has a key named 'tenant' if not login
No update supported? As far as I know, the `azure-cli` supports update
The `type` value should be quoted: ```python force=dict(type="bool", default=False) ```
I would remove this blank line.
I would remove this blank line.
Here should be two blank lines.
This has been resolved.
you might also want to explain that 'msg' (now an alias) was the main way to use the parameter pre 2.7
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
Well this would be for 2.4 so maybe that is the better path
it absolutely is but "New in version 2.3." so I didn't make use of it yet.
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
This line is too long. Max line length allowed in Ansible is 120 characters.
Line is too long.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
asa_argument_spec import is no longer needed
Please move this below the future import statement, to keep the module consistent.
Please remove this statement. Provider has been deprecated since 2.5. New modules should not have it.
```suggestion - The port range for port-object. ```
```suggestion - The IP address and mask for network object-group. ```
OTOH, this does nothing since the module is already cached by the time this gets executed. So it's a no-op.
Having such complex logic inside of tests makes them fragile. You may want to consider just using `@pytest.mark.skipif(six.PY2)`.
```suggestion """Test that a new lock can be created within a Process.""" ```
I don't think another var is necessary. If the first iteration to start the processes succeeds and won't interrupt the control flow, all of them will be active. ```suggestion processes = [ Process(target=_run_threads, args=(_,)) for _ in range(1, 6) ] for t in processes: t.daemon = True t.start() for t in processes: t.join() ```
I think I'd still prefer a single assertion ```suggestion expected_type = dict if six.PY2 else DictProxy assert type(ACTION_WRITE_LOCKS) == expected_type ```
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
Please add `type: bool`.
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
`collection_from_task, _, module_name = self._task.action.rpartition(".")` will always work regardless of whether a collection is present or not. So: `"ansible.builtins.eos_config"` returns `("ansible.builtins", ".", "eos_config")` `"eos.eos_vlans"` returns `("eos", ".", "eos_vlans")` but also `"eos_l3_interfaces"` returns `("", "", "eos_vlans")` which avoids the weirdness with `split`
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
task_uuid seems unused
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
Not sure if it would be useful for something later, but should we have a class attr with the name of the plugin in it? Some plugin types do this others don't.
_load_name gets appended by loader itself
```suggestion b_colldirs = list_collection_dirs(coll_filter=coll_filter) ```
no, if the variable is set but empty, you should empty out the options
py3.x-only code; can safely ditch the args to `super()`
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
If a parameter is not required, no need to explicitly put this in. (If you would put in all possible values here, you'd be defining a handful of defaults)
Make this two entries in your description. Especially because the first entry is the description of the option, the next entries are specifications or additional notes.
Don't add a trailing dot to the `short_description` ! Keep the index clean.
Not needed. The module is new in version 2.4.
@logan2211 you are incorreclty assuming that this is a toggle for each plugin's validation, it is not, it is for the global validation. Each inventory plugin is free to add it's own validation on top, most do and it is not controlled by that toggle. This PR alters the behaviour of the plugin which was always meant to filter the invalid names, the plugin itself never allowed - in group names.
Tested your suggested change snippet. It still mangles group names when `ANSIBLE_TRANSFORM_INVALID_GROUP_CHARS=never` is set in environment. The PR does the fix the bug as-is though.
Should likely be `prefix, sep, key`
Need to ensure that the group actually exists - currently when using this, the inventory plugin fails here because the previous code containing ``` if group_name not in self.inventory.groups: self.inventory.add_group(group_name) ``` has not been added here.
parent name also needs to be 'safe'
```suggestion if subexpr.endswith(')'): ``` I am concerned here that if subexpr is empty, it may cause an exception. For that reason I prefer to do this.
Fine by me. I would still add that note related to child-namespaces so people skimming the code understand the limitations and/or can contribute a more comprehensive fix for this.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Not necessary but exception handling (since this is ansible-2.4+) cna be written as: ``` except etree.XMLSyntaxError as e: module.fail_json(msg="Error while parsing path: %s" % to_native(e)) ```
Sorry, i was unclear, I didn't mean just this line, meant the vars copy/update block . Revisiting this line, I would actually put outside loop, after it ends. Also the existing `variables.copy()` will bypass your efforts as 'container types' will copy by ref, making modifications persist across not only invocations but in returned vars. see deepcopy or deepish_copy.
the moving is more stylistic (prep on top), so you can ignore
if you are using loader, just use `get_file_contents`
Additionally, the use of encode can raise an error if there are characters in the template which are not present in the encoding. We'll want to catch that exception and display a nicer error.
We do not want to do it this way because it means resultant could be a text string or could be a byte string later on. As the internal APIs evolve one of those two cases is sure to throw an error. I think that we probably need to leave the output as text here and convert to bytes later.
Please add `note: Version 4.4.3 or high required.`
`Manage Cisco NSO configuration and service synchronization`
Fixed in https://github.com/ansible/ansible/pull/34186
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
Fair enough. It is not a hard requirement.
This condition can be removed
As per naming convention, the name is `get_lldp_global_facts`
Name as per convention can be `lag_itnerfaces_facts`
Not sure if we need `normalize_interface` when fetching interface names from running-config.
The name as per conventions can be `existing_lag_interfaces_facts` and `get_lag_interfaces_facts`
I don't think we want to have environment variables overriding parameters. What is okay is for environment variables to set defaults if the parameters are not given. To do that you probably want the parameters to set a default value of None in the argument_spec. Then in here you can check whether they are None. If so, then try to set from the environment. If it's still None and you have a sensible default (doesn't look like we would here except maybe for ssh_keyfile) then set it to that value here. Also, could shorten this code slightly like this: ``` python for key, env_var in env_overrides.items(): params[key] = os.environ.get(env_var, None) ```
This argument is marked as being removed in the same version it is introduced. This makes no sense.
This function is not required as it is not doing extra arg validation. For other network platforms, this function is present due to legacy reason and will be removed in subsequent refactor.
You don't need this function
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
Missing from docs
As far as I can tell, the 'in_use' is never used.
should be `type='path'`
Should this be `type='bool'`, or is it more complex? If it's more complex then it might be worth expanding the description for this option.
TODO add Exception handling for login error
Hmm... that's a good point. Since everything being called here is from the stdlib, it's possible that any exceptions raised will be well behaved. (e.__str__() will always yield a byte string, for instance). module.fail_json and module.exit_json take care of turning all elements in a dict into text strings before passing them to the jsonify module. So probably this is safe.
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
It would be awesome if buildah supported copying from a container.
and convert filename to bytes again.
One option would be to pass add an arg for the local fs path (or even an open file handler).
We now have a one-line GPL license statement.
No longer needed.
FYI you can replace this with `type: bool`
```suggestion - The administrator password for the BIG-IP device. ```
The short_description never has a trailing dot. Help keep the index clean !
Indeed :) I totally missed that...
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
```suggestion version_added: "2.10" ```
```suggestion author: Edoardo Tenani (@endorama) <e.tenani@arduino.cc> ``` (Same for the other PR. This will make sure that you will be notified about issues / PRs for this plugin by ansibot.)
```suggestion - Name of the package to install, upgrade or remove. - The C(all) package can be used to .... ```
```suggestion - This module creates clones for libvirt. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
Please add spaces around the equal signs.
Please add spaces around the equal signs.
Suggestion: `"""Retrieve a certificate using the ACME protocol."""`
``` >>> asntime1 = "2017010100000+1000" >>> asntime2 = "2017010100000Z" >>> asntime1 >= asntime2 False ``` Also minutes and seconds are optional in ASN.1, as well as an additional 3 digit millisecond precision... The real proper way would be to parse the ASN.1 format to a datetime, but that would require another library (cryptography can do it, or pyasn1) which is a quite high requirement for just making sure that some edge cases or weird certificates work. I think it could be ok to just keep it like this for now and if it really causes issues, either include a few edge cases that are found in the wild or maybe by then some of the slow moving stable distros have dropped out and the module can be rewritten anyways. :-) PS: pyOpenSSL depends on cryptography and if pyOpenSSL is installed, cryptography will also be installed already.
if you change it to snake, it would be possible to add an alias like `notAfter=dict(type='str', aliases=['not_after']),` and in the docs you can change it the other way around (to not to touch everything): ~~~yaml not_after: required: false aliases: [ notAfter ] description: - The certificate must expire at this point in time. The timestamp is formatted as an ASN.1 TIME. ~~~
It might be also interesting to see if it would fail though.
Read operation: ditto
Can be removed, indeed, check other newer modules :)
A sample of output would be helpful.
`A list of virtual machine names starting with the given regex`
Period at end.
Period at end.
Perhaps make this a list? - C(endpoints) (...) - C(wwn) (...)
Probably worth it to use `username`, `password`, `hostname`, etc in the examples instead of `config`
Perhaps, `Will ensure the datacenter resource exists and its properties are compliant with HPE OneView` Or something along those lines. As it is right now I'm not sure if it is clear that this resource can actually be created if it does not exist.
As mentioned on IRC, please remove this (from here and other examples) and update https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/oneview.py#L210 to be `password=dict(type='str', no_log=True),`
This should default to `present`, not be `required`
s/like C(mail)/(e.g., C(mail))./
s/will be used/will be used by default if not otherwise specified/ - or could be handled like `scope` (no default, must be specified on new group)
to *be* assigned
s/fo/of/ + ('security' or 'distribution')
Examples need update to reflect rename
Let boto3_conn handle region failures - region can be picked up in a number of ways that mean that the `region` variable doesn't get set but the connection is fine.
create_vault returns a dict with `location` and `ResponseMetadata`. You'll probably need to call describe_vault to return the expected parameters (and please use camel_dict_to_snake_dict, and don't forget to also call list_tags_for_vault, convert the tags using boto3_tag_list_to_ansible_dict and then add those to the results too) Edit: no need to call boto3_tag_list_to_ansible_dict as tags are actually in the right format for once. This service must be unique!
You haven't answered my question :). It just seems unlikely that you'd get a response object with a list of vault objects that don't happen to havethe `VaultName` key, without some other exception being thrown.
Sure, but I don't believe it ever happens (and if it does ever happen, use `.get` to return an empty list)
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
No need to add quotes around this line.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Rename DO to DigitalOcean to avoid acronyms
Should have a default set to `present`.
Rename DO to DigitalOcean to avoid acronyms
I'm not sure if we need this sanity check. If `lscpu` exists, we should trust it.
```suggestion cpu_facts['processor_threads_per_core'] = int(data[1]) ```
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
This needs to go through `get_bin_path()` in order to get the absolute path to the executable since the execution `PATH` in the remote environment is far from consistent. ```suggestion try: cmd = get_bin_path('nproc') except ValueError: cpu_facts['processor_nproc'] = processor_occurence rc, out, err = self.module.run_command(cmd) ```
Also using recursin isn't really needed here, please use normal iteration.
Please pass wait module parameter, and do no try to retry the removal in case wait is false.
`continue` isn't necessary
update_ntp_settings â update_ntp_servers (or re-change the update_ntp_servers method name)
If self.desired_state is 'present' and all the ntp servers are already present (so host_ntp_servers == []), state take the value "absent"â¦ so self.results[host.name]["current_state"] = "absent"â¦ which is not what's expected.
This needs to be an `int` to be consistent with what we return currently. And if we split on colon, we can get the second list element rather than the last element. ```suggestion cpu_facts['processor_count'] = int(data[1]) ``` You can use the `type_debug` filter to check the type of Jinja variables.
```suggestion cpu_facts['processor_cores'] = int(data[1]) ```
```suggestion cpu_facts['processor_threads_per_core'] = int(data[1]) ```
Use `get_bin_path()` from `ansible.module_utils.common.process`, make this command required, then catch the `ValueError` returned when the command is not present. ```suggestion try: cmd = get_bin_path('lscpu', required=True) # existing code than returns cpu_facts except ValueError as e: # existing code to process `/proc/cpuinfo` ```
I'm not sure if we need this sanity check. If `lscpu` exists, we should trust it.
This limits you to 1000 hosts where previously it iterated all the pages.
this is a property as well
Do we have PEP257 linter in CI? It should've failed here.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
The behavior of the inventory script was last match wins but I think first match wins is more intuitive for setting the selection_order variable.
This applies to a few places.
It's probably better to use MiB instead of Mb or MB. (Here and few more times below.)
FYI, all these RETURN items will end up as rows in a table and will not be grouped by default, hardware, etc. I can't think of a better way of doing this, no action, just so you are aware.
Thanks, if you push those changes I can re-review
Doesn't seem to have been done
Do we still need kind? For service I think it should always be v1
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
s/will created/will be created/
There's no need to wrap this in a `try`/`except`.
I think we need more info here what are possible choices.
I wonder if this should be done in module_utils.ec2.boto3_conn rather than here - it seems like it should be reusable elsewhere (I really don't know how common local implementations of AWS services are, but guess dynamodb isn't the only one - it might (or might not) help with some of the S3 URL problems we've had recently)
This will fail on python 2.6
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
botocore.exceptions.PartialCredentialsError can also occur on connection creation.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
This is not a blocker, just a thought on the interface.
The only odd behavior I can create is if I set 'collections_paths = :' (an empty list) ``` ini [defaults] collections_paths = : ``` In that case, the collection ends up getting installed into $PWD/ansible_collections/. But I suspect that is a general issue with config types of 'pathspec' and not specific to collection_path.
Yeah, this should probably be an error if the config has explicitly removed the paths...
add a method for a file, then /dev/stdin will be a subset of that
Sure, a separate PR sounds good.
it seems inconsistent as you do capture it in some cases
If the above is an issue we can make all return the exception and consistently handle them in the module.
I vote for consistency of "except DimensionDataAPIException as e"
a) was just note, not required to pass review b) if libcloud already requries 2.6 we can make an exception in the check as we do for other cloud modules.
Note: I'm assuming libcloud requires python >2.6, as such you can use `Exception as e`, the exc_info is only required for modules that are 2.4 compatible, which most cloud modules cannot be due to library dependencies.
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
```suggestion version_added: '2.8' ```
Please replace with `type: false`
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
`If not specified, will fall back to the C(MCP_USER) environment variable or credentials specified in C(~/.dimensiondata).`
```suggestion # Copyright: (c) 2018, CloudGenix Inc. ```
```suggestion short_description: Login to the CloudGenix API endpoint ```
```suggestion - Login to the CloudGenix API endpoint, to obtain an AUTH_TOKEN for use in later calls. ```
```suggestion - The email of the account to login with. ```
```suggestion - The password of the account to login with. ```
Default not set in argspec.
I think this should be a single line, rather than three
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
Are these the only valid options, in which case you should add `choices: ['SG_TYPE_STRING', 'SG_TYPE_KEYVAL'] and similar in `argument_specs`
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
```suggestion sample: true ```
```suggestion returned: success and I(ev_eligible) is C(true) and I(domain_status) is C(APPROVED), C(RE_VERIFICATION) or C(EXPIRING). ```
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
This can be simplified as ```python VROUTER_EXISTS = '' if out else None ```
```suggestion cli += ' vrouter-show name %s format name no-show-headers' % name ```
```suggestion if VROUTER_EXISTS is None: module.fail_json(msg='Vrouter does not exist', failed=True) ```
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion - Access List Name. ```
Keep `vswitch_name` for backward compatibility.
Like I said I don't remember exactly where it happened but that is why I added that if block. I am ok without if block if it is working on your systems.
This will fail when there is no vlanId or vswitch in portgroup. I don't remember the exact reason, but I encountered error here sometimes in past.
is `ts` well known word for Traffic shaping? If yes, then I am ok. Otherwise, key name can be `traffic_shapping` or something similar.
Removal of this line broke one of my scripts, which was relying on the field "name" to contain the portgroup name.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
I was actually thinking of moving it closer to the AnsibleModule part, so it would fail immediately (not after 3 minutes). But that means pieces logically belonging together are torn apart.
If you are cloning from a template, there is no guest_id parameter. So we should also check the current vm's guestId setting.
you force the adapter creation if we don't set ip/netmask, this is wrong. In my usecase we don't use this VMWare device
```suggestion self.module.fail_json(msg="The hostname you have set it not valid for use with vmware guest customization for Linux." ```
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
```suggestion sample: false ```
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
For integers please: use `type='int` remove the `isdigit` check from `check_params`
`type='int'` You can then remove your code to check that this is an int.
Maybe use ```suggestion type: path ``` instead? Then Ansible will replace things like `~` IIRC.
```suggestion - Required when I(release_state) is set to C(present) ``` Use `I(...)` for option names, `C(...)` for option values.
Afaik the `version_added` line is not necessary for new modules
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
Maybe add a link to PyPi or something, one of these is a Python library and the other one an external binary.
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
This task fails with `{"changed": false, "msg": "missing required arguments: valid_from, valid_to"}`
```suggestion - openssh_cert: ```
You should also add an example with `options:`.
This isn't valid YAML. You have to quote it: ```.yaml valid_from: "2001:01:21" valid_to: "2019:01:21" ``` Also, using colons as date separators seems very strange for me. I would expect slashes or dots.
task_uuid seems unused
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
This applies to the other functions where a list is the default value as well.
ð on get_config for clarity.
task_uuid seems unused
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
`Can be configured form the CLI via the C(--user) or C(-u) options.`
`Sets the connection time, in seconds, for the...`
I think this needs a `version_added: "2.5"`
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
becoe_user -> become_user
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
It would be awesome if buildah supported copying from a container.
No longer using a temporary file. This issue is resolved
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
Fair enough, should have actually gone to that link and read it properly
doc typo, s/funcition/function
Doesn't seem to have been done
Thanks, if you push those changes I can re-review
Please use: ``` type: bool default: 'no' ```
It would be nice if the current tags were added to the response.
This should go in a facts module instead.
You can add required=True here too and remove the check below.
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
1. `@property`. 2. It's not an installation command, it's a version spec. 3. You don't need it, as it's stringified automatically during string interpolation, under 3.6.5: ```python In [3]: from pkg_resources import Requirement In [5]: rqc = Requirement('cherrypy') In [11]: '%s ' % rqc Out[11]: 'cherrypy ' ``` 2.6.9: ```python $ python Python 2.6.9 (unknown, Apr 10 2018, 17:32:50) [GCC 7.3.0] on linux4 Type "help", "copyright", "credits" or "license" for more information. >>> from pkg_resources import Requirement /home/wk/.pyenv/versions/2.6.9/lib/python2.6/site-packages/pkg_resources.py:17: DeprecationWarning: the sets module is deprecated from sets import ImmutableSet >>> rqc = Requirement('cherrypy') Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> rqc = Requirement.parse('cherrypy') >>> '%s ' % rqc 'cherrypy ' >>> ```
Please use `has` in the beginning. Also, I feel like this should be a `@property`.
please note that behavior for non-caught exceptions is to return `None`, so please add another `return False` in the end and maybe replace this one with `pass` or a docstrinig with the explanation.
You don't fetch anything here but reconstruct broken input. You return a sequence of data, just lazily. So name the function like it would return a list. I think you could go for `_recover_package_names` here.
And, of course, it accepts `names`, not one name.
All descriptions should have a trailing dot. Except the short_description.
version_added and default value can be dropped as this is new module.
recurse (boolean): Not required, default (false)
Same as above, can be done with sub options
recurse = bool(module.params['directory']['recurse'])
Please switch back to just using `%r` here instead of `'%s'` as that assists in providing more information about the original type.
Remove the quotes from around `%r` as that may cause a something like `''foo''` to appear in the output.
Since we are updating this now, let's switch `'%s'` to `%r` for the default values.
IMO the previous block is not needed, and this error should become error 325.
But to be honest, the types should be identical, it shouldn't matter what it is.
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
`default: null/None` is the default, it can be omitted
Example fields doesn't match the real fields name (server,user, pass)
This function looks like it should be in `module_utils`.
This file will be kept locally and will not be deleted. It's to reduce amount of API calls during the execution.
Currently this file is created in the folder that you are running the playbook from. I can make the opt-in feature.
How is that? ``` self._arg_spec_filename = "FortiosAPIArgSpecs.json" ``` That defines the path to that filename as relative, which will be relative to the executing script. modules are executed in a temp dir that is then deleted, so this file should be deleted. If the file is kept around, I would be concerned with that. This is force creating a cache file without telling the user you are doing it, or giving them a way to opt out. The default should be no cache, and a user must opt-in, should this feature really need to exist.
What is the need here for writing and reading from a JSON file? Seems this file would be created during execution, but in a temporary directory, and deleted immediately. Not sure what benefit there is to doing this, as opposed to just storing in a variable for use.
That is correct, argument spec is dynamic. If it is not dynamic, then any change to the API would render this module useless. Also, it would require me to write modules for every single API endpoint. There are some specific modules - https://github.com/willwagner602/ansible/tree/will-devel/lib/ansible/modules/network/fortios but there are a lot more of endpoints. So it made sense to let this core module build dynamic argument spec based on the data received from the API.
What happens when module asks for boto3 but HAS_BOTO3 is False? I believe we should either default to boto2 and give a warning or otherwise a fatal error.
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
This can be removed, just add required =True in `acs_common_argument_spec`
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
You might need to do, if `supports_check_mode=True` ``` if not module.check_mode: response = client.delete_bucket(Bucket=space_name) ``` Same for Create and Update.
`exec_command` is unused
`deepcopy` is unused
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
These values should all be type `int`
Should be type `int`
It would be nice to see the same msg in exit_json.
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
Move this to line 175
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
```suggestion msg = "" ```
You should either use ```suggestion cmd = self.docker_cmd[:] ``` or ```suggestion cmd = list(self.docker_cmd) ```
If the line would be `cmd = self.docker_cmd`, the original value of `self.docker_cmd` (which is a list) would be modified by the `cmd += ...`'s below. That's why a copy must be created.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
It would be awesome if buildah supported copying from a container.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
+1 for this.
IMHO this should be just as follows because check mode is not relevant if no action is taken. ~~~python if user['enabled'] == args['enabled']: return(retvals) ~~~
There is a small difference: if `_set_password` is `True`, the module should set the password and not return here. Setting the password is done later in the code. It's probably better to not return here at all, neither in check mode nor outside check mode, since otherwise `changed` is not set correctly. After all, `update_password` has check mode support built in.
s/does not do anything/has no effect/
Your module is named `gitlab_project_variable` don't use plural in your example
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
If `purge` is `true`, it will be empty according to the code you pasted below.
Above you said "They are present before the module ran". In that case, this list should not be empty if `purge` is `true`, but contain the list of variables which were there before the module ran.
```suggestion description: A list of variables whose values were changed. ```
I see some more without trailing dot.
```suggestion - The privilege of the dashboard administrator on the network. ```
No, we have a construct for this already. Please use `suboptions`, check any of the modules using, like: *lib/ansible/modules/network/aci/mso_site.py*
Rename DO to DigitalOcean to avoid acronyms
please quote version_added as well to not be a float.
This one is wrong... needs to account for both text strings and byte strings. So probably have to compose it from individual constants in six. ``` python shell=isinstance(cmd,(text_type, binary_type)) ```
this is not recommended since we are using pipes, this can cause blocking if the output to the pipes exceeds the buffer size. in any case the 'wait' is implied in the `p.communicate` below. It seems that a sleep would allow the 'double execution' that is happening in the background and not block/break the communicate + pipe usage below. Still not a great fix but I would need to look closer into what is actually going on to come up with better.
This should probably be `docker.exec_command()`
No longer using a temporary file. This issue is resolved
Yeah, a list is fine.
This should be modeled in the same way that all other modules within ansible currently work. Variables can be set per host and applied to tasks.
I don't believe this parameter should exist. I believe we should rely on the ability for libraries to use environment variables for `http_proxy` and `https_proxy`. Both `ansible.module_utils.urls` and `requests` can both utilize these environment vars. Setting these values via the `environment` keyword on a task is accepted. The module should not have a deviating method for applying proxies.
Here you pass the variable `label`. You have never defined it, though (you defined `ch_label` -- maybe you meant that one?). That's the first of the sanity checks which fails. You might already get that output by running `flake8` on your module.
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
I mean: the current error isn't reported back (`e` is unused). I just pointed out that `display` is available and could be used to report the error.
I saw the same problem. However we constrained because "no_extra_spaces" is already in use (ini_file). If we go with a better name here, we should deprecate no_extra_spaces in in_file and replace it with the better name as well.
`notes:` is wrongly indented and looks like an option, rather than it's own list of notes. And that is why CI fails.
Use the following to format his as code: `C({"key":"value"})`
Missing boto3 will be automatically handled by AnsibleAWSModule, this should just be: ``` try: import botocore.exceptions except ImportError: pass ```
The way to do examples changed. Now your EXAMPLES section can simply be a list of tasks, or a play.
multiple dictionary access: instead of ```python if required_config.get('rotation', None): rotation = required_config['rotation'] ``` use: ```python rotation = required_config('rotation') if rotation is not None: # do your stuff ``` use this rule for all dictionary access below
```python freq = current_config.get('Log rotation frequency') # daily (Once per day at midnight) if freq is not None: ```
```python elif max_num is not None and () ```
```python if size_pct is not None ```
please give more description about the structure of the upload url: ` protocol://username[:password]@server/path `
type is a keyword and shouldn't be used
instead of: ```python servers.update({header_list[2]: server_entry}) ``` it is more efficient to call: ```python servers[header_list[2]] = server_entry ```
no need for this mapping, you can change the current config dictionary to be aligned with the required config or vise-versa
see remarks in the yaml section
you are calling ntp_peer.get("ip_or_name") too much times call it once
``` BaseException +-- Exception | +-- TypeError | +-- AnsibleFilterTypeError +-- AnsibleError +-- AnsibleRuntimeError +-- AnsibleTemplateError +-- AnsibleFilterTypeError ```
Use a more clear name to better reflect what the function is actually doing. It doesn't just check availability but also mutates state. ```suggestion def try_import(self): ```
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
Chances of not finding datastore is also possible even when user passes the datastore name. Change the error message
Mark params as required=True which for the required params
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
Add code to support check mode.
the module will always fail. Use `module.exit_json` and `module.fail_json` based on `result`
I've been playing around with this a bit; the problem seems to be loading the PKCS12 file with OpenSSL. When simply dumping the result of both runs via `openssl pkcs12 -info`, the output is the same for both. Also, the certificates show up in the correct order, and friendly names are correct. I'll go look at how OpenSSL loads PKCS12 files next...
The distinction between cert and CA cert is made by OpenSSL itself: https://www.openssl.org/docs/manmaster/man3/PKCS12_create.html https://www.openssl.org/docs/manmaster/man3/PKCS12_parse.html That's really strange, since OpenSSL both writes and reads the PKCS12 file, I would expect the order to be preserved.
About the naming `ca_certificates` vs. `other_certificates`: how about renaming the option to `other_certificates` (and keeping `ca_certificates` as an alias)? That should reduce confusion a lot.
Hmm, if the certificate is found in `pkcs12_other_certificates`, I think you still have to return `False`, since you want the certificate to be the leaf certificate and not part of the chain.
You should wrap this in a `try/except` and return `False` if it raises an exception.
This is also why shippable is failing.
Should be `from ansible.utils.unicode import to_bytes, to_unicode`
This can be directly imported from six: ``` python from ansible.module_utils.six.moves import configparser ```
you should just import from defaults plugin
s/CONSTURCTOR/CONSTRUCTOR/ (and usages)
i'm not sure that makes sense, if handler was not included, it would not be available for notification already. Since it should already add the conditionals inherited (only on import or include + apply) you should not need to check any other conditions.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
I would prefer to say name. But Iâm ok if you want to stick with this here. Or maybe client_config_name.
Please add `, no_log=True`
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
change to data
I'm just trying to think of a simple use case for these facts.
We should no longer need this token validation if PR #36352 is merged before.
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
Remove this because is already inside DO utils
Rename this to `get_provider_argspec` to be in sync with other platforms
With cliconf the `get_config()` implementation and other similar api implementation is moved to platform-specific cliconf plugins [here](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/cliconf).
Please rename it as `get_provider_argspec()` to be in sync with other platforms
This extra check is not required after above provider spec changes
This check is not required after above `provider` spec change as `no_log=True` in auth_pass and passwords sub-options will take care to mask password.
I think this should probably be `'auto'` instead of `None` ... unless I missed something (which I'm always open to the possibility that I have): ```python use_backend = self._task.args.get('use', self._task.args.get('use_backend', 'auto')) ```
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
remote_src is a boolean, but you are using it as a path here, I think you have confused how this feature works elsewhere. it is just a flag indicating that project_src is on the target (True) or on the controller (False) look at copy or assemble to get this working right.
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
This is a private function (starts with an underscore) so I'd hope we could move this without having to leave a stub for backwards compatibility. If you want to remove the stub in a separate commit/PR just in case, though, I can live with that.
does not resolve inheritance https://github.com/ansible/ansible/issues/25097
Upon further reflection, I think these three lines along with `check_mutually_exclusive` are erroneous for subspecs. We don't currently have a way to specify `required_if/one_of/together` or `mutually_exclusive` for subspecs, so in every case *but* the networking "aggregate" thing, this is severely broken (as you'd be making nonsensical checks in most cases)
this seems like it should be shared with the main one rather than duplicated here
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
Since all of these appear to be constants, it seems to me that making them tuples instead of lists would be good to avoid accidentally modifying them.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
For these to be a tuple you need a trailing comma, like `opsworks_fields = ('layer_id',)` for all single-item tuples.
Generally I'm not so happy with this long list of if statements. What I would rather have is a set of named objects (like the `eg.policy`) and a set of lists of relevant parameters (`eg_policy_params=['policy_name', 'namespace....`) and then iterate through the list to build the object from the original policy object. I think this would be easier to maintain in future.
`required=False` and `default=None` are defaults so you can eliminate them in every case below
I would move this blank line above the `HAS_LDAP`.
Exactly. The new line should be right after the import and not after the global variable.
I would format this like this: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.0' } ```
Can be replaced with https://github.com/ansible/ansible/blob/a3390b63fe317eb2fea5d78fb99c8a5e8fc8eaf3/lib/ansible/modules/cloud/vmware/vmware_host_ntp.py#L93
```suggestion author: Edoardo Tenani (@endorama) <e.tenani@arduino.cc> ``` (Same for the other PR. This will make sure that you will be notified about issues / PRs for this plugin by ansibot.)
```suggestion self.mock_run_nvos_commands.stop() self.run_check_cli.stop() ```
Sorry @rajaspachipulusu17 I think this should be `self.mock_run_check_cli.stop()`
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
Yeah, we still can't use dict comprehensions until 2.6 is formally dropped, sorry.
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
@davidharrigan Nice spot, thanks. From a quick Google I've found * https://github.com/TAXIIProject/libtaxii/commit/59e18912e90550e2248779518fb63fac77d2f5a1 * https://bugs.python.org/issue4773
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Isn't `raise` missing there ? Calls to `str` are useless.
that won't work with config values
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
You should not need this anymore, you should have `self.get_option('api_version')` starting in 2.4 (rest of plugin needs updating)
Consider `open_url` from `ansible.module_utils.urls` as an option to remove the dependency on `requests`.
This is not py2.6 compatible. You will need to index these.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
Well, how do you determine which action was just run if you only return `changed`? The `state` is standard key which is expected to be return by any module. Please add it (`state=state`).
There should be period at the end of the `msg`. Check the other occurrences.
Format this like this: ``` module.fail_json( msg='Error while performing wildfly operation', details=info['msg']) ``` The same anywhere else in the code.
You are not returning `state` in any of the `exit_json`. You should drop the `status` as that can be determined from the `state` and the `changed` values.
```suggestion ANSIBLE_METADATA = {'metadata_version': '1.1', ```
Short description shouldn't have a period.
This is now `'2.10'`
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion - David Taylor (@djtaylor) ```
```suggestion - name: Add tags to a distributed virtual portgroup ```
```suggestion action: remove ```
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
If we use `self.api_client` then this API will look like - ```suggestion self.datacenter_id = self.get_datacenter_by_name(datacenter_name=self.datacenter) ```
I think in check mode is like dry-run without any action. so Enable hyperthreading in check mode should have current_state and desired_state as enabled.
Probably want to change this to your standard DO argument spec. This will handle testing the `oauth_token` and finding the token in the users environment. ``` argument_spec = DigitalOceanHelper.digital_ocean_argument_spec() module = AnsibleModule(argument_spec=argument_spec) ```
Use **digital_ocean_argument_spec** form DO utils.
I believe this relates to team accounts. Users are able to create an image for their account and not expose it to additional team members.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
Actually, that is plumbed through already. Should be okay.
The count here is important. Without it any file loaded by dataloader will be loaded entirely and entire contents ran through a to_bytes(to_text())
Not sure if it matters, but the existing behavior was to read from the current position instead of resetting to the beginning. I think everything that actually called it did so with file pointer at 0, so not sure it matters.
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
I think you need `to_native` here.
This should be sufficient.
@sieben please include the BSD license header in this module_utils file in this PR.
Previous URLs didn't end with a slash, this might create double slash URLs.
Not sure if `module.debug` should be used instead.
To match the headers in https://github.com/sieben/ansible/blob/b119f2652a160707ee718566ad1e49a510935553/lib/ansible/module_utils/scaleway.py#L40 `Content-Type` must be `Content-type`
This method is technically deprecated from Microsoft, if the executable manifest hasn't been set correctly it will always return `6.2` (Windows 8) even when it is newer. I don't see a need for this to be done in Windows and can potentially return None or a blank value as we shouldn't care there.
Change the default to `self.DEFAULT_BOOT_TIME_COMMAND` instead of `self.BOOT_TIME_COMMANDS['linux']`.
`delay_min_macos = delay_min | 1`
One issue with this is that `win_reboot` uses this same method. So if the windows `DEFAULT_BOOT_TIME_COMMAND` results in an rc != 0, it will then try this `cat` command, which will gloriously fail. The previous conditional which runs `uptime -s` won't ever match on Windows because that string will never match the output of `(Get-WmiObject -ClassName Win32_OperatingSystem).LastBootUpTime`. This is the point where it would be helpful to have platform/dist as a class attribute, either as an additional check here, or to look up the correct boot time command based on platform/dist. I'm also open to other ideas.
If we don't go with a default regex value, this can just be `None`. ```suggestion filter_re = self._get_value_from_facts('BOOT_TIME_FILTER_REGEX', distribution, None) ```
does this make sense with a stop? in most cases 'reload' is just sending a signal to the daemon ... not sure it applies to that action either.
I would imagine the same issue is possible for other states also, i would solve this in a generic way instead of only for one of them.
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
This line is too long. Max line length allowed in Ansible is 120 characters.
Remove as not needed (default)
Remove as not needed (default)
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
This isn't really the case, the module seems to be installing the feature so I would mention that. Also mention that if a reboot is required then it will fail.
I think `state` is more ansibley
```suggestion type: str required: True ```
vm -> VM
vms -> VMs
Create vm pool and override the pool values.
```suggestion - The state of Virtual Machine deployed. ```
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Sure, a separate PR sounds good.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
Thanks - I've replaced all uses of `filter` with comprehensions.
Same change needs to be made to many other uses of filter.
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
Yes, the revisions you'v emade to this look good to me.
it seems inconsistent as you do capture it in some cases
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
``` state=dict(type='str', default='present', choices=['present', 'absent']), ```
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
You can move this check to `module_utils` as well.
Seems to be unreachable code to me.
I think it's better to refrain from abbreviations in formal/written text. (At least that's what we learned at school) So make that: ```python module.fail_json(msg="DNA Center did not return JSON compatible data")` ``` So it doesn't look like nested quotes.
catchall ignore ....
This has to be done only once, since the binary is always the same (`docker-machine`).
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
i would use the find bin function and not assume it is in path
``` from ansible.module_utils.common.process import get_bin_path ```
Is this correctly handled? I think right now, you're trying to determine whether a database called "all" exists or not.
Don't add this, if the parameter is not required.
```suggestion - List of tables in the publication at the end of runtime. ```
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
No really necessary but if you want to keep it I would capitalise it and add a full stop.
No longer need deepcopy
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
```suggestion type: path required: yes ```
Oh sorry, I should have mentioned, how to specify metaclasses changed between python2 and python3. So there's a helper in six so that you can do this acroos both versions. ``` from ansible.module_utils.six import with_metaclass [...] class OneViewModuleBase(with_metaclass(ABCMeta, object)): ```
The phrase "unless within a playbook adjacent collections directory" is a mouthful. It's also not immediately apparent what that means unless the reader is well versed in Ansible jargon. > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection may not be picked up in an Ansible run. If there is a strong desire to mention adjacency (I know this was explicitly requested in the related issue, but I don't think it's the clearest phrasing), then something like this is probably best: > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection will not be picked up in an Ansible run unless adjacent to a playbook.
Putting this under a conditional makes it undefined under the opposite condition.
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
I think this may read better: ```suggestion if missing_keys: ```
Are you only doing this to support Python 2.6? Those keys are already unique.
you need to skip value from parent if include_tasks/include_role, but still inherit
```suggestion # just get value from attribute itself as normal ```
should be list(attr.items())[0] to work with python3 too. ``` An exception occurred during task execution. The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 310, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 280, in main attrs = EcsAttributes(module, attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 131, in __init__ self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 151, in _parse_attrs name, value = attr.items()[0] TypeError: 'dict_items' object does not support indexing fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 310, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 280, in main\n attrs = EcsAttributes(module, attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 131, in __init__\n self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 151, in _parse_attrs\n name, value = attr.items()[0]\nTypeError: 'dict_items' object does not support indexing\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ********************************************************************* localhost : ok=0 changed=0 unreachable=0 failed=1 ```
If `name` is an alias of `display_name`, and the user sets `name: xxx`, `params['display_name']` will be `'xxx'`. Ansible does that internally so no module has to do that.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Strings don't need to be quoted in YAML.
A golden rule I use is to alphabetically sort items in a list if the order is of no importance. It helps compare lists or finding items in a list more easily.
Yes, present usually is the default state. In some cases there is no default state (which means the user is expected to provide it explicitly).
Typo: persent Also, I find it strange to have values surrounded by round brackets.
You can use `L(UCS Platform Emulator,https://communities.cisco.com/ucspe)` to get named links.
```suggestion - Resource ID of the subnet. ```
Here too, should either be "Success" or "Succeeded".
```suggestion - Name of the subnet. ```
```suggestion - Provisioning state of the subnet. ```
This should be either "Success" or "Succeeded".
with_ anything that returns an empty list has this effect, this is not just first_found
you can just remove the first phrase, 'skip' just causes the lookup to return empty list if no file is matched
```suggestion this reason, it is recommended to use ``errors='ignore'`` when used in a template with ``lookup`` or ``query``. """ ```
Omit these lines please.
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
This isn't used in the examples. Is it possible to do this by name instead of URL? It seems a little complex to have to provide a full URL to use non-default networks.
Same here. Looks like some strange linewrapping is going on.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
I think changed needs to be set to True here.
Extra spaces before and after `local-ssd#local_ssd_limits`
should use choice
```suggestion module = AnsibleModule(argument_spec=argument_spec, mutually_exclusive=[['retention', 'purge_retention_policy', 'overwrite']]) ```
This should probably just be `required_if`
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
So, I think on failure this output would be useful as well. So maybe it's better to create a new dictionary `debug_result` which you can then provide to fail_json calls related to fetch_url failing, and you can merge it with result before exit_json. ```python debug_result = dict( url=url, method=module.params['method'].upper(), headers=headers, payload=payload, ) ``` Then add the response and status: ```python debug_result['status'] = info['status'] debug_result['response'] = resp.read() ``` Then call fail_json using it: ```python module.fail_json(msg=str(e), **debug_result) ``` And exit_json: ```python if module.params['output_level'] == 'debug': result.update(debug_result) module.exit_json(**result) ```
should be exception=last_traceback
you could line that up with msg
Using the `match` parameter saves you from having to do an `assert`. ```suggestion with pytest.raises(FailJson, match='Unable to find required'): z = ZipArchive( src="", b_dest="", file_args="", module=fake_ansible_module, ) ```
Looks like `@contextlib.contextmanager` embeds this behavior and this would be enough: ```python @contextlib.contextmanager def timeout(timeout, raising=False): signal.signal(signal.SIGALRM, _raise_timeout) signal.alarm(timeout) try: yield except TimeoutError: if raising: raise finally: signal.signal(signal.SIGALRM, signal.SIG_IGN) ```
this could just return ```suggestion return not self._raising ```
You want to swap these conditionals, so that check mode can actually report anything. `load_config()` should be the only thing gated by `if not module.check_mode`, that way the result is correct
duplicate get calls, fix for all occurrences
http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#new-module-development There is written: ``` # during the execution of the module, if there is an exception or a # conditional state that effectively causes a failure, run # AnsibleModule.fail_json() to pass in the message and the result if module.params['name'] == 'fail me': module.fail_json(msg='You requested this to fail', **result) ``` AFAIK module should return with `module.exit_json` or `module.fail_json`, not `raise ValueError` for example.
Will this parsing also work when gluster isn't installed at all? In that case any meaningfull message would be nice.
I meant `IndexError` not `ValueError`, but it don't really matter. What I meant is, that isn't it better to have this safe contruct there: ```python try: main() except Exception as e: module.fail_json(msg=str(e), exception=traceback.format_exc()) ``` It's then better to debug issues.
I've even tried doing some benchmarking and the results are about the same.
I don't mind. But I still don't understand why you think it's O(1).
we probably want to move this 'adhoc list' into constants.py anyways
this probably needs updating to ansible.legacy.X see constants.py for function that deals with the multiple possible names
Having such complex logic inside of tests makes them fragile. You may want to consider just using `@pytest.mark.skipif(six.PY2)`.
Since you return above, unnest the `raise` here.
`del` is a builtin, not a function. These parens don't have to be here
You can add required=True here too and remove the check below.
I think this needs to be a dict since it's used as-is in the call to ansible_dict_to_boto3_filter_list().
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
Extending of ZabbixAPI class was used with very old zabbix-api module versions. I am trying to get rid of this in #53334 as it is now working fine with just a base class. Please remove this as well. Your code will work fine without it :)
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
Instead of checking this dictionary directly, update `check_pyyaml` to return a bool based on the result.
I realized last night my suggestion to make this an error is inconsistent with how the other sanity tests handle missing requirements. To maintain consistency it should be a warning instead: ```python display.warning("Skipping sanity test '%s' due to missing libyaml support in PyYAML." % self.name) return SanitySkipped(self.name) ``` I still see value in making missing test requirements an error, at least under some circumstances. We'll need to think more about how that should behave, and make sure it's consistent for all the tests.
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
instead of flags_on/off just flags .. a canonical list
Should not return a fail, just a `changed=False`
Same as above, can be done with sub options
Could you please handle basic exception for this operation and other file_manager methods as suggested in [docs](https://code.vmware.com/apis/196/vsphere#/doc/vim.vm.guest.FileManager.html#makeDirectory)
recurse = bool(module.params['directory']['recurse'])
Do we need to do any check on this? Can this fail due to permission issues, or due to the file already existing? I'm fine with this always overwriting the destination file, and coming up `changed=True` every time, i just wonder if there is a risk of exceptions (pretty sure both `fetch_url`, `open` and `write` can throw a bunch of exceptions.)
I wouldn't dive into that just yet. That would be very hard to do elegantly. I'm not even sure if it really philosophically makes sense.
my other issue is if user has an actual 'tower_inventory' file in cwd ... i would use something more like `@tower_inventory` or some other symbol to disambiguate from 'actual file'
Are other plugins supporting any kind of file-less use? It seems like that's more of where this was trying to go.
you can also just have a config file with `plugin: tower` as it's only entry
why force either/or? you should be able to read some things from the config file, others from env vars, user might not wan't all eggs in one basket
```suggestion - Tenant ID to make requests on. If not set, the C(TENANT_ID) environment variable is used if set, otherwise the ID ```
```suggestion - Enable strict verification of CloudGenix API SSL Certificate. ```
2.6 or 2.7? Also you `requirements` listed here and the modules.
```suggestion - The email of the account to login with. ```
```suggestion - The password of the account to login with. ```
provisioning_state is readonly as well, so let's remove it from parameters
needs sample value
we can remove this one, it's readonly
same here, snake case, and convert value to lowercase
change this to `vault_tenant`. `tenant_id` is too close to the base option `tenant` used as a credential arg.
Total time, in UNITS, to run stress for.
timeout isn't defined in `argument_spec`
`U(https://github.com/StackIQ/stacki)` will generate a link in the docs
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
Don't add `required: false`. It is implicit.
While there isn't much risk, this would match "UMASKFOO". The 2nd part regarding '#' is also not correct, since '#' need to be the first non space characters, I would recommend to use strip() and verify the first char.
`f` variable isn't used in this 2nd `try` block: it seems a `for` loop is missing.
Another regex that can be precompiled.
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
boto3_conn now copes with RegionNotFound errors for you
All AWS API calls should have exception handling
HAS_BOTO3 errors are handled by AnsibleAWSModule (and before that, you could import it from module_utils.ec2). No need to import boto3.
That's definitely better, but it might just be simpler to do ``` def create_placement_group(connection, module): name = module.params.get("name") if module.check_mode: module.exit_json(changed=True, placement_group={"name": name, "strategy": 'cluster'}) try: connection.create_placement_group(GroupName=name, Strategy='cluster') except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Couldn't create placement group [%s]" % name) etc... ```
Don't use DryRun - you're not handling the exception that will be returned. With check_mode, we usually just don't make the API call at all and return something suitable in the results.
please fill this in
s/will created/will be created/
Create vm pool and override the pool values.
Rename DO to DigitalOcean to avoid acronyms
Same, `device-mac` or `device-mac-address`.
Shouldn't the default for autoremove be "False" rather than "None" ? (just nitpicking)
```suggestion build_dep=False, fixed=False, autoremove=False, fail_on_autoremove=False, only_upgrade=False, ```
```suggestion fail_on_autoremove=dict(type='bool', default=False), ```
```suggestion fail_on_autoremove = p['fail_on_autoremove'] ```
```suggestion cmd = '%s -y %s %s %s %s %s %s' % (apt_cmd_path, dpkg_options, force_yes, fail_on_autoremove, allow_unauthenticated, check_arg, upgrade_command) ```
```suggestion - The application secret to use. ```
```suggestion - The application key to use. ```
```suggestion - Determines the type of record to use. ```
```suggestion or deleted. ```
```suggestion - The TTL of the record to manage. ```
For encrypted you should be able to assert something about the format: ``` >>> crypt = getattr(passlib.hash, 'pbkdf2_sha256') >>> crypt.encrypt(u'asda') '$pbkdf2-sha256$20000$PUeoVar1/h8jxNjb./8fgw$UzKj5pfmKEDtguOh.XEvHCqQr2b4AHPgwL/M8BEzez8' ``` Initial string, number of "$", length of the salt and length of the hashed value.
Could make this into a generated testcase if you were so inclined.
This does not need to be wrapped.
I blame my `black` setting.
This does not need to be wrapped.
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
Mutually exclusive is argument of AnsibleModule. ```python module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True, mutually_exclusive=[['username', 'service']], ) ```
add a sample here - ``` sample: { ... } ``
```suggestion - name: Ensure that /exports/nas key in auto.direct map is absent ipa_automountkey: ```
If you use `env_fallback` then you don't require this check.
Use same `env_fallback` as `X_AUTH_TOKEN`
That's a really interesting piece of information I did not know.
You can move this check to `module_utils` as well.
That's quite a strange (and un-pythonic) way to indicate failure. But if the library does that, there's not much you can do :)
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
This is still something we shouldn't really want to explicitly support.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
Please add an example below that shows you how get the newer NuGet provider version.
This supports more than just URLs, I would add more points talking about what it actually supports.
Use `I()` around parameter names. ```suggestion - I(url) and I(host)/I(port)/I(user)/I(pass)/I(vhost) are mutually exclusive, use either or, but not both. ```
End with period
Not sure how the lazy loading of variables, the example would be simpler to just have the one task instead of 2 in the examples. ``` - name: Get 2 messages off a queue debug: msg: "{{ lookup('rabbitmq', url='amqp://guest:guest@192.168.0.10:5672/%2F', channel='hello', count=2 ) }}" ```
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
Best to not link to a versioned doc but the stable/latest branch https://pika.readthedocs.io/en/stable/.
The description should have a trailing dot. (Only the short_description must not have it)
The quotes are not needed and not wanted here.
For consistency in the examples, I would do this: ```yaml - name: Gather vmware host facts vmware_host_facts: hostname: esxi_ip_or_hostname username: username password: password register: host_facts delegate_to: localhost ```
If there's no sample, please remove that line.
We tend to sort the various imports, so swap those two lines.
I think, guard-expression style would fit better here: ```python if not import_name in module_utils: display.warning('%s:%d Invalid module_utils import: %s' % (path, line_number, import_name)) continue imports.add(import_name) ```
```python for line_number, line in enumerate(lines, 1): ```
(and there's no need to have this var outside or this loop or increment it manually, then)
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
If an unknown keyword is specified, `kdata` has not yet been assigned at this point.
I meant, `return` as `module.fail_json` will return anyways.
This is unreachable code.
```python if dc is None: module.fail_json(msg="Failed to find the datacenter %s" % module.params['datacenter']) ```
Yeah -- just for info, to_native() is preferable because, with default arguments, it won't traceback if non-ascii values end up in the exception message. In some cases, non-ascii will traceback with str() and with ```'%s' % e```.
I would prefer to see the `to_native()` call done here, rather than as it's passed in below. Fix that and we'll merge this.
use `str(e)` (this is not the optimal, but that is true for most of this file) cc @abadger
yeah, to_native is the way to do this correctly. Otherwise sooner or later we will end up with UnicodeErrors being thrown. Gotta start somewhere so might as well start with new code.
same here with the collapse
Please use the camel_dict_to_snake_dict to fix the camelcase in the boto3 responses here.
Say "botocore/boto3" since boto isn't used in this module.
Traceback please ð
Same here - please include a traceback.
You can import HAS_BOTO3 from ansible.module_utils.ec2 below, instead.
You should mention instead of this that the required API version is 1.24. ```suggestion - "Docker API >= 1.24" ```
Also, let's continue the discussion in #51939.
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
How about removing the `docker_` prefix from the return variables, and simplifying the names in general? I would use: - `swarm_facts` or just `swarm` - `nodes` - `services` - `tasks`
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
We can't do this, as this is break bacward compatibility.
"Netmask in case ..." -> "Subnet mask in case ..."
following task -> the following task
This is a bit too much, it needs to be simplified somehow so it is easier to understand.
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a function.
```suggestion - "Whether to purge the retention policy or not." - "Mutually exclusive with I(retention) and I(overwrite)." ```
'so this value may be overriden'
```suggestion - Whether an existing log group should be overwritten on create. - Mutually exclusive with I(purge_retention_policy). ```
might as well get rid of any `required: false` and `default: null`s
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
My bad, I forgot that [dict comprehensions were added in Python 2.7](https://www.python.org/dev/peps/pep-0274/). Feel free to ignore my suggestion.
Remove the `if` and make `_parse_healthcheck_options()` handle `self.healthcheck == None`.
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('Europe/Helsinki')), '2019-06-15T14:45:00+01:40'), ```
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
This snippet looks just like one in `role_find`. It probably deserves being moved into a reusable function.
refactor: ```python additional_kwargs = ( {'showAuthenticationRestrictions': True} if authentication_restrictions_supported else {} ) result = db.command( 'rolesInfo', role, showPrivileges=True, **additional_kwargs ) ```
You may try
don't leave a file descriptor open. use a context manager (via `with` block)
wrap these pieces of code into two try/except statements to be precise with what you're trapping. 1) one around with-block (with readfp call) catching `IOError` 2) the other one around creds dict constuction catching `configparser.NoOptionError`
``` diff diff --git a/lib/ansible/galaxy/collection.py b/lib/ansible/galaxy/collection.py index caa22308eb..52272cde52 100644 --- a/lib/ansible/galaxy/collection.py +++ b/lib/ansible/galaxy/collection.py @@ -381,6 +381,12 @@ def publish_collection(collection_path, api, wait, timeout): :param timeout: The time in seconds to wait for the import process to finish, 0 is indefinite. """ import_uri = api.publish_collection(collection_path) + if 'v3' in api.available_api_versions: + parsed = urlparse(api.api_server) + import_uri = parsed._replace(path=import_uri).geturl() + else: + import_uri = import_uri + if wait: display.display("Collection has been published to the Galaxy server %s %s" % (api.name, api.api_server)) with _display_progress(): ```
That diff is a light reworking of this PR. When I made it I saw that it still had most of the problems of this one (to be fair, we probably can merge my changes with that initial attempt and fix some of those problems) and additionally split the responsibilty for compatibility between GalaxyAPI and the caller. So I discarded that and pushed most of the changes inside of GalaxyAPI instead. I did parse the data from the API and normalize it (as a task_id) before sending it into the class, though. That seemed like the best way to split the responsibility.... The caller ends up knowing about the information that was returned to it. The GalaxyAPI class knows how to turn the normalized data into a url on each of v2 and v3.
I also found `n_url` to be a bit confusing and collide with our string type prefixes for bytes, native, and unicode. It would be good to change `n_url` to something more descriptive, but probably in a separate PR.
I've been meaning to ask... what's the deal with n_url? I thought at first that it needed to be a native string for the APIs it's being used with but the more places I see it, the less that looks like the case. Is it "normalized_url"? If so, could you start using that? We do not want to use `n_` or `b_` prefixes for anything other than variables containing native strings and variables containing byte strings. It will defeat the purpose if we start doing this in other places.
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
`action=dict(required=True, choices=['get_status']),` So this should be `required: false`
This doesn't match argument_spec
```python if 'name' in self.params and self.params['name']: ```
This is undoing the example.
VMware may add new resources in the future and if we don't hardcode a list, the user will be able to use it without any update of the module. So I would prefer to avoid the `choices` key.
it seems inconsistent as you do capture it in some cases
If the above is an issue we can make all return the exception and consistently handle them in the module.
I vote for consistency of "except DimensionDataAPIException as e"
a) was just note, not required to pass review b) if libcloud already requries 2.6 we can make an exception in the check as we do for other cloud modules.
Note: I'm assuming libcloud requires python >2.6, as such you can use `Exception as e`, the exc_info is only required for modules that are 2.4 compatible, which most cloud modules cannot be due to library dependencies.
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
This is already possible by prompting on the TTY instead of stderr, and is the mechanism used elsewhere and recommended in this case.
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
No longer using a temporary file. This issue is resolved
I think defaulting to `false` is the safest option, and would be consistent with the purge_tags defaults in other modules.
This is unnecessary change.
it should be `minor_vers = int(version[1])`
Note that `LooseVersion` could be used there: ``` from distutils.version import LooseVersion [...] return LooseVersion(version) < LooseVersion('3.2') ```
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
the community has decided that modules should be named "_facts" when providing host facts, otherwise the sufix should be _info. That is why this module should be renamed `cs_resourcelimit_info`
also replace the word "facts" with "info" in the docs
we could U() the link
Perhaps we could add an example to show how to list zones (without filtering).
Perhaps we could add an example to show how to list instances (without filtering).
Here please use C(custom_compatibility_version) instead of `custom_compatibility_version`.
Same for VMs.
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
Add a `required_one_of` for name/uuid (the mutually exclusive is good, but this adds in module robustness as well)
Do not use default value for folder. This has caused lot of troubles in the past. It will be easy to fail rather than assuming something about user environment.
Use module.fail_json_aws(e), which will handle calling ansible.module_utils._text.to_native() on e for you.
You can make use of some of the helpers in AnsibleAWSModule ```suggestion connection = module.client('cloudwatch') ``` This then moots the pieces below.
Could add to the line above rather than lots of line breaks
Same order, type first.
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
Please don't add new options in this PR, please remove this
```suggestion - When set to true, pool member FQDNs are instead resolved on service engines in this cloud. ```
```suggestion - By default, pool member FQDNs are resolved on the controller. ```
I'm happy for you to raise one PR that fixes that across any/all modules it affects at a later point.
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
```suggestion # just get value from attribute itself as normal ```
Also we should still call this in case of check mode, and say whether it will be changed
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
So we don't wait for empheral VM? I think we should
@mmazur I think that Ondra's suggestion is correct. We need to be consistent how we present vm state to the user. At some point users will be confused if they not understand ephemeral vs stateful vm. For ephemeral vms stopping means delete and it is fine.
~if not keeping encryption, remove the __ansible_vault key, just assign the value directly~ nmvd, misread the if to the opposite ...
dont do this, now we have 3 parsers, we shoudl move parsing/json to module_utils and use from there
Okay, so to implement the examples like this: ``` with_cyberark_password: appid: 'Application1' query: 'safe=...;' output: 'password ....' ``` We'll want to take the dict from terms instead of from kwargs. terms will hold the dict that the user passed in so you should be able to drop in replace it in your constructor like so: ```CyberarkPassword(**terms)```
s/write target file {0}/fetch file to {0}/
Yeah, a list is fine.
Because this parameter was added for backward compatibility with **vmware_dns_config**. We could add it as an alias and keep it forever, but I am not in favor of keeping lots of aliases for the same purpose.
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
If we are creating a new module then why to add old parameters which we don't want in first place.
add an alias to `domain` as `domainname`
It would be good to call out a reboot is required to make it active
remove added space
typo: thier -> 'their'
Perhaps, `Will ensure the datacenter resource exists and its properties are compliant with HPE OneView` Or something along those lines. As it is right now I'm not sure if it is clear that this resource can actually be created if it does not exist.
```suggestion - This module creates clones for libvirt. ```
Each option entry should be a full sentence, i.e. it starts with a capital and ends with a full stop.
```suggestion short_description: Local Backup Utility for Alpine Linux ```
```suggestion - List of paths to exclude. ```
```suggestion - List of paths to include. ```
Should be `type: str`
```suggestion Supports the querying and modification of the link-level attributes of interfaces such as ```
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
double space between `and` and `self.options.subset`
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
This limits you to 1000 hosts where previously it iterated all the pages.
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
Are these the only valid options, in which case you should add `choices: ['SG_TYPE_STRING', 'SG_TYPE_KEYVAL'] and similar in `argument_specs`
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
Example appears to add, rather than delete.
This should be a string. ```yaml version_added: "2.3"
How about selecting a semantically better exception? ```suggestion raise LookupError( 'File "{target_path!s}" not found in collection path "{coll_path!s}".'. format(target_path=path, coll_path=ANSIBLE_COLLECTIONS_PATH), ) ``` P.S. `str()` is unnecessary since the specifier does that already.
Putting this under a conditional makes it undefined under the opposite condition.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I think this may read better: ```suggestion if missing_keys: ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
Sorry @rajaspachipulusu17 I think this should be `self.mock_run_check_cli.stop()`
```suggestion self.mock_run_nvos_commands.stop() self.run_check_cli.stop() ```
Typo, this looks like it should be `pn_dscp_map_pri_map` here and in several places below.
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
Yeah, we still can't use dict comprehensions until 2.6 is formally dropped, sorry.
```suggestion module.fail_json_aws(e, msg="Boto failure") ``` Boto/API exceptions should use fail_json_aws
```suggestion module.fail_json_aws(e, msg="Failed to create organizational unit") ``` and here
```suggestion parent_ous = paginator.paginate(ParentId=parent_id).build_full_result().get('OrganizationalUnits', []) for child_ou in parent_ous: ``` You could remove the outer loop here by using the paginator's `.build_full_result()` method and retrieving the OrganizationalUnits from it.
This is correct.
I'm not a big fan of this self recursion. We're a bit limited since boto doesn't give any way to get the entire tree, but it would be nice if this could be broken out differently.
This should be executed only `if module.check_mode:`.
Move this condition above the `changed = True` and inside the `if module.check_mode:`.
Remounting would require another option to do / not do a remount.
This would be nice to have implemented from the beginning.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
I think we don't need to patch `datetime.datetime.fromtimestamp()` and `datetime.datetime.utcfromtimestamp()` methods as they just return a datetime object from patched `time.time()`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
@akatch please add version in which this option is being added. like ``` version_added: 2.5 ```
(If you're interested in the funny things which can happen because of this, look at #50503...)
Yes. I think you can even use `1`/`0`, `y`/`n`, and maybe some more.
The default to an empty list may result in a unexpected behaviour, if users don't use this param (default empty list) and have set grants manually, the grants would get deleted with this implementation. I would change it in a way to only handle it if a list (be it empty) is set and ignore it if None (param unset): ~~~python if grants is not None: if set_user_grants(module, client, user_name, grants): changed = True ~~~
You also need to add the choices in the `argument_spec`.
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
if not handling become methods update the class variable to indicate this
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
su requires a tty, that is why most 'subprocess' plugins don't support it.
As we no longer care about 2.4, I think this can be cleaned
```suggestion fc_ports = module.params.get('fcaddress', []) ```
If `ports_expand` took a rule rather than the value of its `ports` key this entire function could be replaced with ``` return [ports_expand(rule) for rule in rules] ``` Edit: of course `ports_expand` returns a list, so you need to flatten the result: ``` return [rule for expansion in ports_expand(rule) for rule in expansion] ```
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
Why not do this in a single statement ? ```suggestion result = dict( changed=False, ansible_facts=dict( tcp_listen_violations=list(), udp_listen_violations=list(), tcp_listen=list(), udp_listen=list(), ), ) ```
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
I don't see how this is a simplification, we just give modules the information about the dir the controller would have used, but it doesn't force the module to do anything. While this change will alter the behaviour of existing modules that rely on it.
that still happens no matter what info you pass to the module ... unsure how removing this info for the module to CHOOSE to share the dir is a simplification. Speaking of the end user, we CAN show them the tempdir being used since that info is available on the controller, but not when the module itself generates it (and many do).
The thing is that you are removing an existing feature, not simplifying anything, nothing FORCES modules to use this, many don't, that is why we ALSO supply remote_tmp (though that value is not always usable depending on become and other circumstances). Many modules don't use either value and opt to handle it completely on their own. But those that do use it, rely on this behaviour and making this change won't 'break' things in a way that alerts anyone, it will start leaving dangling temp files or attempt to create them in an unexpected directory. Which IMHO is worse, since it is a 'silent break'.
this should not be None, it should already have resolved to the configured system_dirs, so should be changed anyways
Heh, I just meant this code to show that setting _ansible_tmpdir = None was what we needed to do. I think that it's a bit too big a change to set this to None unconditionally. Probably better to revert the changes to how we call tempfile.* until we figure out how to implement this only for privilege descalation.
Feels a little long, maybe something like ```suggestion short_description: Retrieves CyberArk vaulted credential using PAS Web Services SDK through the Central Credential Provider ``` or ```suggestion short_description: Retrieves CyberArk vaulted credential using PAS Web Services SDK ```
Indentation doesn't look right here.
indentation doesn't look right here
Please use: ``` type: bool default: 'yes' ```
Please use: ``` type: bool default: 'no' ```
Both `ipfix_override` and `live_port_move` are still available through the API in vSphere 6.7 and can still serve a purpose, this should not be removed: https://code.vmware.com/apis/358#/doc/vim.dvs.DistributedVirtualPortgroup.PortgroupPolicy.html#livePortMovingAllowed https://code.vmware.com/apis/358#/doc/vim.dvs.VmwareDistributedVirtualSwitch.VMwarePortgroupPolicy.html Suggest adding it back
Ok, sounds good, i get that :).
`rolling_order` should not be removed, it is still a valid setting in vSphere 6.7 API: https://code.vmware.com/apis/358#/doc/vim.host.NetworkPolicy.NicTeamingPolicy.html#rollingOrder
according arg spec, required=False
Been thinking about this, the easiest solution would probably be a dict: ``` port_binding_modes = { 'earlyBinding': 'static', 'static': 'earlyBinding', 'lateBinding': 'dynamic', 'dynamic': 'lateBinding', 'ephemeral': 'ephemeral' } ``` It's not a lot better, but it gets rid of those if/elif statements
Could try running the command with the env setup to use LANG=C You can specify the env for the command either with the 'environ_update' arg to run_command() or by setting module.run_command_environ_update before the run command.
Use [get_bin_path](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L1908) to get path of file
why not take only `module` as parameter, we can derive all values from it.
ditto as `required_if`
I think for this case, this should work: ``` python required_if = [('state', 'present', ('value', 'value_type'))] ``` But haven't tested that...
This will throw an exception every time when a server is down. When glusterfsd is down the output looks like this: Brick 10.70.43.200:/mnt/engine Status: Transport endpoint is not connected Number of entries: - And you'll be trying to do int('-') which will throw ValueError. And the module throws error: fatal: [10.70.42.25]: FAILED! => {"changed": false, "msg": "Invalid heal status option."} in the function main.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
```suggestion out = run_gluster(['volume', 'heal', name, 'info'], environ_update=dict(LANG='C', LC_ALL='C', LC_MESSAGES='C')) ```
If rc != 0 it is always err. You don't need out or err.
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
```suggestion - name: Show variables with 'hosts' in their names ```
```suggestion - name: Find several related variables that end specific way ```
```suggestion - List of the variable names requested. type: list ```
You should probably note that these patterns are expected to be regex (vs. globs). The examples show this, but it doesn't hurt to be explicit. It also wouldn't hurt to mention that the patterns are not implicitly anchored.
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
The default value for state should be `present`.
This basically adds the provider dict to the module argspec, please remove this.
@FedericoOlivieri I just raised a PR which should mitigate this problem. This is the one https://github.com/ansible/ansible/pull/54783. Once this is merged, please fetch, rebase and try again.
Please move this below the future import statement, to keep the module consistent.
asa_argument_spec import is no longer needed
```suggestion - The broadcast (L2) address for the interface. ```
```suggestion - This is the L3 MTU (limit on size of IP packets). ```
```suggestion support (for example 'type vcan'). ```
```suggestion - To identify an existing interface within a namespace, use the I(namespace) option. ```
```suggestion into namespace I(netns). ```
CI failure due to: ``` 2017-02-15 21:58:57 Traceback (most recent call last): 2017-02-15 21:58:57 File "/root/ansible/bin/ansible-playbook", line 103, in <module> 2017-02-15 21:58:57 exit_code = cli.run() 2017-02-15 21:58:57 File "/root/ansible/lib/ansible/cli/playbook.py", line 156, in run 2017-02-15 21:58:57 results = pbex.run() 2017-02-15 21:58:57 File "/root/ansible/lib/ansible/executor/playbook_executor.py", line 89, in run 2017-02-15 21:58:57 self._tqm.load_callbacks() 2017-02-15 21:58:57 File "/root/ansible/lib/ansible/executor/task_queue_manager.py", line 196, in load_callbacks 2017-02-15 21:58:57 self._callback_plugins.append(callback_plugin()) 2017-02-15 21:58:57 File "/root/ansible/lib/ansible/plugins/callback/junit.py", line 76, in __init__ 2017-02-15 21:58:57 self._task_class = os.getenv('JUNIT_TASK_CLASS', 'False').to_lower() 2017-02-15 21:58:57 AttributeError: 'str' object has no attribute 'to_lower' ```
This should be `lower` instead of `to_lower`.
task_uuid seems unused
there should be no need to implement these when using callback base, also you should use v2_ events as the old ones are not guaranteed to work, in some cases they get slightly different data or lack the data they had in pre 2.0 Ansible.
this is never invoked as the v2_ method that would forward to this in the callbackbase is overridden below
This is still only one certificate. The name of the module, and the return value should be changed.
These imports aren't needed but you will need `camel_dict_to_snake_dict` from `ansible.module_utils.ec2`
This function could probably just be replaced by `camel_dict_to_snake_dict(acm_certificates)`
Sorry, use `camel_dict_to_snake_dict` from `ansible.module_utils.ec2`
Use module.fail_json_aws(error, msg="Couldn't obtain private certificates")
`for k, v in opt.items():` <-- gives you key-val pair
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ```
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
but to_boolean doesn't convert values to booleans. It's really normalize_options(). It's just that the only implemented normalization at the moment is for boolean values.
yes, as well as `None`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ``` Should `whitelist_file` and `blacklist_file` be `mutually_exclusive` `mutually_exclusive=(('blacklist_file', 'whitelist_file'),),`
pyyhon2 -> python2
Required is default to false, so this line is not required.
Please remove this line
Add double quotes to Author name.
```suggestion - The friendly name of the monitor. ```
Add a note stating that `created` and `absent` are added in version 2.10 Also, `created` can be alias to `present` to match other modules.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
This can be moved to `check_dict` method.
Make a common method in class to get url and return json loads response.
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
Targeting 2.7.10. Updated to reflect that.
Please change `remount` to `remounted`. The same bellow.
can delete this line now I think.
should we say `will also unmount the device (if mounted) and remove the mount point`
I think this is clear enough.
I don't see a reason to rename this option to `fstab_file`. Please change it back to `fstab`.
This does not belong in here. Since you took it out of a function in task_executor, it might belong in there.
Module arg building doesn't take place here. This file packages up a module. It doesn't handle construction of module parameters at all. Action plugins sit in between module arg construction and here.
Doing this inline is OK for beta- it makes the feature function, but it's a performance problem. Post-beta, we'll want to move most of this to an intermediate lazy indexing process during playbook parsing when a module_defaults clause references a group, where we'd build that global "sieve" I was talking about for O:1 lookup. At that point, we can probably get rid of the transformation in the collection metadata canonicalization phase entirely and just store it plain.
I guess this one's not as obvious because of the "pre-chewed" format, so `action_group` isn't the right name for the current impl either...
This doesn't currently appear resilient to missing collection(s) in the group's list (eg, you only have `amazon.aws` and not `community.aws` available).
`current_grants[i] = v` is useless (as we don't use current_grants later), just add v to parsed_grants at the end of the loop : `parsed_grants.add(v)` Anyway, that's the solution I was going to purpose after hitting the same bug.
[textwrap.dedent](https://docs.python.org/2.7/library/textwrap.html?#textwrap.dedent) could be used here.
This is a bit magic as in "where did this method come from" but of course, we're still importing `*`. Would be good to get that tidied up.
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
```suggestion # require that the final recorded stack state was CREATE_FAILED ```
```suggestion module.fail_json_aws(e, msg="Failed to create organizational unit") ``` and here
```suggestion module.fail_json_aws(e, msg="Boto failure") ``` Boto/API exceptions should use fail_json_aws
```suggestion parent_ous = paginator.paginate(ParentId=parent_id).build_full_result().get('OrganizationalUnits', []) for child_ou in parent_ous: ``` You could remove the outer loop here by using the paginator's `.build_full_result()` method and retrieving the OrganizationalUnits from it.
This is correct.
I'm not a big fan of this self recursion. We're a bit limited since boto doesn't give any way to get the entire tree, but it would be nice if this could be broken out differently.
You should really have at least one example with `state=absent`.
You probably should add yourself to the authors list as well.
You don't have to quote this string.
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
I would name the method `passwd_check`.
framwork_spec doesn't look like it requires `settings`, so potentially KeyErrors in several places here if not specified (probably should use `.get('settings', {})` or something similar, depending on usage.
`str` -> `six.text_type` I guess? cc @abadger ^
```python def toml_dumps(data): return toml.dumps(convert_yaml_objects_to_native(data)) ```
```python toml_dumps = partial(toml.dumps, encoder=AnsibleTomlEncoder()) ```
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
```suggestion - Name of container, for example C(imagename:tag). ```
```suggestion - List of supported values maintained at U(https://docs.microsoft.com/en-us/rest/api/appservice/webapps/createorupdate#scmtype). ```
```suggestion - Sample values for C(Tomcat), C(8.0), C(8.5), C(9.0). For C(Jetty,), C(9.1), C(9.3). ```
```suggestion - Supported only when I(frameworks=java). ```
```suggestion - Supported only when I(frameworks=java). Sample values C(Tomcat), C(Jetty). ```
Spaces ! ```suggestion choices: [ absent, present, query ] ```
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
So I am interested to know the difference between PUT and POST. And highlight that here.
Keep a blank line between examples for readability.
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion if VROUTER_EXISTS is None: module.fail_json(msg='Vrouter does not exist', failed=True) ```
```suggestion cli += ' vrouter-show name %s format name no-show-headers' % name ```
This can be simplified as ```python VROUTER_EXISTS = '' if out else None ```
```suggestion msg='vRouter with interface %s does not exist' % ip ```
`ansible_dict_to_boto3_tag_list` likely better here.
what happens if a parameter is deleted? I think this would be missed.
Default needs adding to docs
Only import what you need, rather than `*`
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
comma-separated should not bee needed, just make flags a type=list in argspec, it will accept both actual lists and comma separated strings
instead of flags_on/off just flags .. a canonical list
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
`short_description: Manage VLANs on VyOS devices`
Mutually exclusive with I(domain_search).
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
Please remove this line. `waitfor` was used in older modules, we've since standardized on `wait_for`
Please remove this line
Odd -- on python3, to_str should just be an alias for to_unicode so there shouldn't be any difference. On python2, they'd be different but it should work because of automatic coercion of byte strings to unicode strings in python2.
I understand, theses are really nice functions you got there, thanks a heap for your reply !
to_str will work here but probably for cleanness sake, want to use to_unicode here, like this: ``` python err = to_unicode(err) if u'Bad configuration option' in err or u'Usage:' in err: ```
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
Yeah, a list is fine.
Please add `version_added: "2.4"`
Remove the `try` block, it is unused.
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
`timeout` and `username` aren't the same thing.
The next `if` should come first. The module should die if not all DBs exists no matter whether it's in check mode or not.
Finally, `db_exists` checks whether **all** DBs in the list exist. This doesn't really help here. You really need to work with `existence_list` and `existence_list`.
Also, why do you need to call `db_exists` again at all? You already have `existence_list` and `existence_list`, that should be enough for the rest of the module.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
```suggestion default: {'type': 'org.graylog2.indexer.retention.strategies.DeletionRetentionStrategyConfig', 'max_number_of_indices': 14} type: dict ```
```suggestion default: False type: bool ```
```suggestion default: False type: bool ```
```suggestion default: "org.graylog2.indexer.retention.strategies.DeletionRetentionStrategy" type: str ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
It probably makes sense to clean-up flags before exiting this method.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
and convert filename to bytes again.
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
You can move this check to `module_utils` as well.
I would replace these 3 lines by: ``` # Add these imports from ansible.module_utils.compat import ipaddress from ansible.module_utils._text import to_text ### prefix = ipaddress.ip_network(data["prefix"]) network = to_text(prefix.network_address) mask = prefix.prefixlen ``` This way, it will not fail if `data["prefix"]` doesn't have a netmask (default it to /32 for ipv4, /128 for ipv6).
All `descriptions:` should be full sentences, and therefore end with a full stop.
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
Mispelling of "region"
vm -> VM
vms -> VMs
enabled/disabled for this as we are talking about a service (email)
Add code to check for this and do `fail_json` if needed just after `argument_spec`
Add code to check for this and do `fail_json` if needed just after `argument_spec`
You can add the following to `argument_spec` `mutually_exclusive=(['name', 'channel'],),`
Maybe worth adding code to check this and call `fail_json` if it isn't allowed
define a `poller` and `get_poller_result(poller)` as response
use ` KeyPermissions, SecretPermissions, StoragePermissions, CertificatePermissions` model in `key_vault_management_client_enums` intead of str
Seems this is a list of `AccessPolicyEntry`, how about I want to have more than one `AccessPolicyEntry`
My point is the self.credentials may not has a key named 'tenant' if not login
No update supported? As far as I know, the `azure-cli` supports update
the community has decided that modules should be named "_facts" when providing host facts, otherwise the sufix should be _info. That is why this module should be renamed `cs_resourcelimit_info`
also replace the word "facts" with "info" in the docs
correction: It's not a byte string, it's a raw-string literal
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
```suggestion - "You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: U(https://dash.cloudflare.com/)." ```
(As in â we should drop the vm/vmis)
Description should be: _Fetch running virtual machines from KubeVirt clusters_ Reasoning: 1. This only returns *running* vms. 2. We've decided to hide the internal implementation of VMs/VMIs (as much as possible) from ansible users.
missing 'type: list'
you might want a `suboptions` key here, they are not implemented in config (yet) but eventually they should work the same as module suboptions.
I don't know what the opinion of the upstream reviewers will be, but considering this parameter controls a host's inventory hostname and not just `ansible_host`, it might be the case that this should be somehow contained within the standard inventory plugin `inventory_host` parameter.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
just call scaleway.ini we are in ansible conflict should not occur
Initialized must go first.
self.get_stack_info returns a string. I don't think this will work as expected. You probably want it to return a list.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
We have no intention of adding attrs as a dependency.
https://github.com/ansible/galaxy/ and https://github.com/ansible/mazer use a CollectionInfo model based on https://www.attrs.org/en/stable/. The intention being to help keep them aligned (and eventually share the code) so all the tools use the same data validation. I don't know if 'attrs' is an option for ansible-galaxy, but it may be worth trying to keep them consistent. Granted, CollectionInfo is the fairly complicated use of 'attrs', with lots of uncommon validators involved to enforce the spec for galaxy.yml, but overall 'attrs' has been useful.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ```
`for key, value in (doc.get('options', {}) or {}).items():`
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ``` (https://github.com/ansible/ansible/pull/41158#pullrequestreview-128452262)
`for k, v in opt.items():` <-- gives you key-val pair
Ah... I think I see what you are doing... (About None) You're trying on convert_bool.boolean to raise a TypeError if it's not one of the recognized values.... If you're intentionally using that strategy, do the following: * In the call to Boolean(), explicitly set strict=True. That way everyone knows that you're telling on the TypeError and your protected in case the default changes in the future. * Move this check into your normalization function. It's part of determining what the value of the key should be normalized to, so it belongs with the other normalization code, not out at the caller where it looks like error handling.
Instead of repeating the import try/except here, just add `cmd_quote` to the `from lib.util import` below.
This one looks good except that it should be placed i nthe ImportError handling instead of the finally. (I'm not sure if it makes a difference for this particular case... I think that python will print the exception with the traceback regardless of whether we call sys.exc_clear() in the finally. But conceptually, if ```from shlex import quote``` raised something other than ImportError we would want to see the traceback from that so calling sys.exc_clear() in that case doesn't seem correct.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
Please fix url to` 'https://api.telegram.org/bot' + token + '/sendMessage?text='` and examples descriptions to `token: '9999999:XXXXXXXXXXXXXXXXXXXXXXX'` Because BotFather return token without "bot" string
i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
Here be dragons. I don't see check-mode being tested anywhere in the module. So I expect the module to perform a reboot in check-mode. Probably not what people expect.
Why not simply do: ```python match_first = (self.params.get('name_match') == 'first') ```
The `failed=False` is assumed, so I wouldn't add it by default. The only reason when this has to be add explicitly is when you return a non-zero return code (rc-value) and don't want it to fail.
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
I'm not sure how it works with `dnf`, but with `yum`, the name of the package you're trying to install doesn't necessarily need to be an exact match for what's in `exclude` for the package to be excluded. It's better than nothing, though.
Nevermind me, I follow. Your control flow is better :+1:
don't like such hacks, would be better if you will write RFE for DNF to make API for autoremove...
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
In Python, we avoid adding unnecessary brackets.
Note that there are other pieces of code that need this same fix.
If we don't know whether a change would be made or not, we should always return changed=True. It's better for a user to run their playbook unnecessarily than for a user to miss out on running a playbook to make changes because check_mode reported False.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
There's other places that unknown exceptions are handled. You should modify those similar to this.
Anytime you handle an unknown error, it's good to include the traceback. Do it like this: ``` python import traceback [....] module.fail_json( msg=("Unknown error while performing userAddToGroup." "\n*** end_point=%s%s\n%s" % (api_base_url, end_point, to_text(unknown_exception))), payload=payload, headers=headers, exception=traceback.format_exc(), status_code=-1) ```
There are only two docker modules which do that: docker_swarm_facts and docker_node_facts. And there it's only for lists of objects returned. This is very different to for example the output of docker_node_facts, and all other _facts modules. So I don't think this is a good reason why the default should be `no`. @morph027 since we can't make up our minds, just pick whatever *you* prefer.
That's why I would also say `yes`. If someone thinks this is too much data, that person can simply turn it off with the option.
Please remove the list. `default` specifies one value, not a list. A list is only needed for `choices`.
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
Can you add: ``` type: bool default: no ```
Where possible, generally its a good thing to keep the parameter names the same as the linux module equivalent. is 'replace_dest' the same thing as 'force' in the git module https://docs.ansible.com/ansible/latest/modules/git_module.html ? If it is the same it would nice if it has the same name.
You have `git>=2.19.0` in `requirements`
there is no need to version params for new modules
Use a raw string to avoid issues with backslashes: ```suggestion EXAMPLES = r''' ```
Please use `- name: ` with examples
This should be called tags for consistency with the other AWS modules. It also appears tags are only changed/added by this module when first creating the job flow but it should be modifiable since the API supports this with add_tags() and remove_tags(). Here are some general guidelines for dealing with tags. https://github.com/ansible/ansible/blob/bf304832ffb8fc723c4d2f755e2e45ba17809f73/lib/ansible/modules/cloud/amazon/GUIDELINES.md#dealing-with-tags Here are a couple module examples, though there are many: https://github.com/ansible/ansible/blob/ab96a841542478189a6195a05ff748565613056f/lib/ansible/modules/cloud/amazon/ec2_ami.py#L568-L585 https://github.com/ansible/ansible/blob/1905a6e8fb38a6d85eed5632c45250aa676715d9/lib/ansible/modules/cloud/amazon/ec2_vpc_route_table.py#L337-L360
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
`state` shouldn't be an action. This should just have the choices `present` and `absent`.
This needs BotoCoreError and ClientError exception handling: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to terminate job flows for cluster {0}".format(cluster_id)) ```
Needs exception handling here too.
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value not specified in argspec.
Default value mentioned but not added in argspec.
Default value mentioned but not added in argspec.
Default value not specified in argspec.
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
```suggestion - name: Install bottle for Python 3.3 specifically, using the 'pip3.3' executable ```
It would be easier if RPM and DEB were to give the same structured reply, or having an agnostic module would not be very useful (in cases like "if upstream version is greater than x.y"). Comparing versions is a complex operation and there is no filter around `dpkg --compare-versions`. Also having the full version (epoch+upstream+release, following the standard distro notation) along with the upstream version would be useful I think.
`str` isn't needed here.
I feel like this should be moved to `else:`
A general remark: you should always use complete sentences. So this should end with a period.
Please use formatting like `C(<device-on-host>[:<device-on-container>][:<permissions>])`, and `(e.g. device C(/dev/sdc:/dev/xvdc:rwm))` in the line below.
I would remove this `device` here, and similar the option name in the examples for `device_read_bps`, `device_read_iops` etc.
(In general, I don't think modules should have such options.)
(Same for the related options.)
handle import error
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
No longer need deepcopy
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
It is available in PR. Added on https://github.com/ansible/ansible/pull/55059/files#diff-2c15779308a54e8ac33b5eba806f6e5bR84
```suggestion ansible_vmware_validate_certs: False # default is True ```
Nothing specific, wanted to match other module style.
```suggestion - Password for the user in guest operating system. ```
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
Is there a reason to sort this? Since we're just putting it into a set (to uniquify the list I assume) it doesn't seem necessary to sort. Since we're just iterating over sd_instances, a frozenset is more appropriate than a set.
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
Another regex that can be precompiled.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
Yeah, a list is fine.
s/write target file {0}/fetch file to {0}/
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Please put this on a single line. Lines can be 159 characters wide.
You can remove `required=False` as that's the default.
No, the default is None. So you can tell if the parameter was set or not.
Please test if `default=False` is the default value when using type `bool`.
This is useless unless you also return it as a value.
```suggestion import traceback ```
```suggestion if not HAS_OVH: self.fail_json(msg=missing_required_lib('python-ovh'), exception=OVH_IMPORT_ERROR) ```
```suggestion - ovh_monthly_billing: project_id: 0c727a20aa144485b70c44dee9123b46 instance_id: 8fa89ad2-8f08-4220-9fa4-9695ea23e948 ```
```suggestion - ID of the instance, get it with U(https://api.ovh.com/console/#/cloud/project/%7BserviceName%7D/instance#GET) ```
```suggestion - ID of the project, get it with U(https://api.ovh.com/console/#/cloud/project#GET) ```
```suggestion import atexit import traceback ``` Please import `atexit` module
example should be removed.
```suggestion - List of user aliases to add in the group ```
@rubentsirunyan thanks a lot for taking a look at this! :)
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
No need for the try/except, `get_resource_group` already handles this.
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
This isn't really how we usually go update operations in Ansible. Is there way of checking if a change needs to occur and then making or rather than making a request and seeing if it was changed. The benefit of the former approach is that when running in check mode you can see if a change needs to happen while in this scenario you wouldn't know.
Use kwargs instead of positional args
If `read_scale` was a bool you could do `ev = "Enabled" if kwargs[key] else "Disabled"
You can avoid these list comprehensions by using the paginator's `.build_full_result()` method, which keeps things consistent with the other AWS modules and a little easier to read. `zones = paginator.paginate().build_full_result()`
All client calls should have exception handling. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
`delete` and `create` are not valid states
Technically this will never be `None` because of the defaults.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
You could probably do something like ```diff - self.dns4=' '.join(module.params['dns4']) + self.dns4=' '.join(module.params['dns4'] or []) ``` This works fine for me.
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
Not passing arguments to docker which don't affect the resulting service is no problem. It's only a problem (and shouldn't be backported) if it affects the visible behavior as seen from a user (like it updates a service which hasn't been updated with the old version).
Have you checked whether any of the value options where you removed the change overrides something defined in the image? If that's the case, this can't be a Bugfix PR (similar to changing the default of `user`).
Please remove `required=False`.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
I would move this to the module notes.
Spaces ! ```suggestion choices: [ absent, present, query ] ```
So I am interested to know the difference between PUT and POST. And highlight that here.
```suggestion - State the action to perform. Use C(present) to create cpu-class and ```
```suggestion - State the action to perform. Use C(update) to modify the igmp-snooping. ```
```suggestion - Web SSL (HTTPS) to enable or disable. ```
```suggestion - IP associated with the access list. ```
```suggestion - Simple Network Monitoring Protocol (SNMP) to enable or disable. ```
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
This is also not needed, idem for all other parameters.
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
can we use `ast.literal_eval()` here to convert string to valid dict (that has double-quoted strings )
nevermind- I see we added the isa check to deepcopy those for specific cases
can be removed, the call to 'supper' below already takes care of this
I'd argue that most content developers also don't need to be running devel, maybe something like this? ```suggestion 'you are actively modifying the Ansible engine, or trying out features under development. This is a rapidly changing source of code and can ' ```
I realized last night my suggestion to make this an error is inconsistent with how the other sanity tests handle missing requirements. To maintain consistency it should be a warning instead: ```python display.warning("Skipping sanity test '%s' due to missing libyaml support in PyYAML." % self.name) return SanitySkipped(self.name) ``` I still see value in making missing test requirements an error, at least under some circumstances. We'll need to think more about how that should behave, and make sure it's consistent for all the tests.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
This should be indented by 2 spaces. The same bellow.
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
This could move even more down. After listing apps.
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
This description seems redundant to me.
```suggestion - name: Gather self-heal facts about all gluster hosts in the cluster gluster_heal_facts: name: test_volume status_filter: self-heal register: self_heal_status - debug: var: self_heal_status ```
heal_type key is misleading. Can you change it to: `filter' (The filter can be of self-heal or rebalance)
s/status is/facts are/ Since we are returning the facts, which also includes status.
Where are we checking if the GlusterFS version is indeed > 3.2 Refer the peer module.
I am pretty sure the rest of the code will blow up, since it assumes that `systems_uri` is a string and not an array.
This is just bad. Things are really not that complicated to warrant such complicated block of code. Just split the work into semi-independent steps and chain them. For example: # Collect all ids self.systems_uris = [m["@odata.id"] for m in data.get("Members", [])] # Perform error checking if not self.systems: # No systems available return dict(ret=False, ...) ...
If the `system_id` is not present on the Redfish service, this line will explode, since `systems_service` will not be initialized.
Not catching non-200 responses.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
this is not a 1.0 callback, its using 2.0 API
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
Read operation: ditto
Read operation: ditto
Somehow this (+ the following line) doesn't work and prevent the module from working.I haven't digged deeper yet,
The original modules have this: ```yaml # (c) 2016, Peter Sagerson <psagers@ignorare.net> # (c) 2016, Jiri Tyr <jiri.tyr@gmail.com> ``` Peter is the original author, I'm the person who polished and published his module. You are another contributor, so you should be at the end of the list.
This file consists of texts from previously copyrighted file. You should respect the original copyright.
You should indent all the lists in this file by two more spaces to keep it the same like in all other files.
I would format this like this: ```python ANSIBLE_METADATA = { 'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community' } ```
Exactly. The new line should be right after the import and not after the global variable.
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Remove this line
Please check this.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Make these 2 seperate items in the description.
Make this two entries in your description. Especially because the first entry is the description of the option, the next entries are specifications or additional notes.
If a parameter is not required, no need to explicitly put this in. (If you would put in all possible values here, you'd be defining a handful of defaults)
Don't add a trailing dot to the `short_description` ! Keep the index clean.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
type should be a 'int'
Please add `type="str"`
Please add `type="str"`, and maybe list the possibilities as `choices=`.
It would IMHO make more sense to move that near the other command, so we can verify both command at the same time.
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
```suggestion if any([i in network for i in ['ip', 'domain', 'netmask']]) ```
Hmm, nevermind. It seems that if I remove the `resource_pool` argument altogether then everything works fine. Previously this value was set to `Resources` even though we don't have any explicit resource pools, but without the value an error was thrown previous to this commit.
I was actually thinking of moving it closer to the AnsibleModule part, so it would fail immediately (not after 3 minutes). But that means pieces logically belonging together are torn apart.
you can remove this condition as the previous condition already handle other cases
Upon further reflection, I think these three lines along with `check_mutually_exclusive` are erroneous for subspecs. We don't currently have a way to specify `required_if/one_of/together` or `mutually_exclusive` for subspecs, so in every case *but* the networking "aggregate" thing, this is severely broken (as you'd be making nonsensical checks in most cases)
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
having `main()` call `run_module()` feels a bit redundant, I see no reason to not put all of the main logic in `main` (and splitting actions into functions where it makes sense)
Types are missing above. token, msg and api are of type "str", port is of type "int". So something like: ```python token = dict(type='str', required=True) ... port = dict(type='int', default=80) ``` Please also add check-mode support. In whatever form you think is appropriate (either log messages adding check-mode run, or not sending messages but e.g. still attempt to connect).
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Please remove the `required: false`.
I would remove the `required: false` since it is implicit and therefore unneeded.
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
This line does not need quotes. (nitpick)
This line does not need quotes. (nitpick)
Below there are more like this, if you'd care :-)
This line does not need quotes. (nitpick)
This wil fail, as there are 2 actions in the same task.
I suspect this line is the problem with the yaml validation failure as \ indicates to yaml a line continuation, I think. To use a \ like this it would need to be inside single quotes. Likely the same issue on lines 72, 74 and 75
The problem is the fact that we are missing an `args:` key.
You know you have a real problem when CI fails and people are discussing why that might be :-P
Typo: exists -> exist (should be singular). I'm not really sure this is an improvement as you lose the explanation of what 'args' can be used for.
This avoids using floats/division and uses `"""` for docstrings (follows PEP 8 style). ```suggestion def deprecation_versions(): """Create a list of valid version for deprecation entries, current+4""" major, minor = [int(version) for version in __version__.split('.')[0:2]] return Any(*['{0}.{1}'.format(major, minor + increment) for increment in range(0, 5)]) ``` The use of floats/division can yield incorrect results: ``` '2.12' -> 2.12 -> ['2.12', '2.13', '2.14', '2.15', '2.16'] '2.13' -> ['2.13', '2.1399999999999997', '2.15', '2.1599999999999997', '2.17'] ```
I think that wildcard imports are generally discouraged, because it makes it difficult to refactor and determine the origin of a function or class. For example, at first the `boto3_conn` function used in the constructor seemed undefined.
Small typo here probably: `Retreived -> Retrieved`
It looks like this module is not idempotent. Running the same task twice with `state: present` or `state: absent` will show changed every time.
purge_tags doesn't need to remove all tags - you can use compare_aws_tags() (in module_utils/ec2) and then call untag_resource() with the list of tag_keys that are returned.
There should be a check before https://github.com/ansible/ansible/pull/24292/files#diff-aaef1b3abde00153e8695bfdf79c5e55R1882 that HAS_BOTO3 is True.
Please also use proper doc formatting like: "C(template) and C(storage_domain) parameters are provided"
Please add ` version_added: "2.4"`
But won't be moved if the storage domain is changed, no? The note should be added only if the parameter is NOT idempotent. The default is meant to be idempotent.
```suggestion - Only used for images that contain the Windows Server operating system. ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
If it's not required, you can leave out `required: false`.
Windows 8.1 / Windows 2012 (NT 6.2), no need to set the PS version as that will inevitably confuse people on older OS' who have upgraded to PS 4 or higher.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
Until the latter is merged I would avoid referencing it in the module docs.
Why have 2 parameters to set the name or ID, surely we would just want to set the name and not worry about the ID. Is there a benefit to using the ID over the name, if not then this should just be removed.
You still have SDK speak in here like `serviceLevelObject`
s/elasticPoolName/I(elastic_pool_name. Also change the word updated to set.
It seems like this is only the case for certain objects, might be best to explain this is more detail, also what is the default option.
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
```suggestion updates.extend(line for line in set_commands if line not in config) ```
Verifying here that IP address and prefix are in correct format would be good. Look for APIs: `socket.inet_pton(socket.AF_INET, address)` and `socket.inet_pton(socket.AF_INET6, address)`
Should this handle for space within interface name? Something similar to https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/eos/eos_vrf.py#L224 to avid idempotency related issues.
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
The default value for state should be `present`.
```suggestion version_added: "2.10" ```
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
Indeed :) I totally missed that...
https://github.com/mozilla/sops/blob/afd073a5be0fe2232d7cd345b9b30edc70ccb962/cmd/sops/encrypt.go#L32 ```suggestion class SopsFileAlreadyEncrypted(SopsError): ```
`required: false` can be removed, it's the default `default: null` can be removed, it's the default
`Allows notifications to be sent using SMS or MMS via the catapult bandwidth API.` No need to repeat the module name,
Generally we don't treat usernames as secrets, so no need to mask
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
(If you're interested in the funny things which can happen because of this, look at #50503...)
Yes. I think you can even use `1`/`0`, `y`/`n`, and maybe some more.
```suggestion choices: [yes, no] ```
Ah, sorry I missed that earlier: ```suggestion default: yes ```
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
```suggestion - The state of the fileset or nimclient to be. type: str ```
```suggestion choices: [ absent, allocate, commit, deallocate, installed, present, removed, reset ] ```
```suggestion - Name of the C(lpp_source) at the C(nimserver) to be used for installation. ```
```suggestion - Name of the Spot at the C(nimserver). ```
```suggestion default: yes ```
Honestly, I just failed to invent a better name
JFYI In the internal slack channel we came up with an idea: https://github.com/ansible/ansible/pull/39924 So it might get into devel before you merge this
Having it upstream would be nice, but I doubt we can change our minimum required Jinja2 version anytime soon.
I would rather add all other fields to the error message.
We should probably rename this. Revisiting this code... this is a pretty special-case function as well. I wonder if it should be a private function inside of parameters.py (basic.py can make it public as part of its API but the idea would be that we don't expect any new code to use it.)
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
I would call super here like this: ``` python super(Connection, self).exec_command(cmd, tmp_path, in_data=in_data, sudoable=sudoable) ``` It doesn't do anything useful for the docker connection but once again, it's nice to do it so that anyone looking at the docker connection plugin for a basis to create their own connection plugin will do the right thing (the base class's exec_command() fetch_file(), and put_file() use the @ensure_connect decorator to make sure that our connection is open before attempting these actions. For plugins that actually need to establish a connection, this is a necessary step).
I think the signature of exec_command has changed in v2. If you take a look at local.py or the ConnectionBase class you'll see: ``` python def exec_command(self, cmd, tmp_path, in_data=None, sudoable=True): ```
Yeah, a list is fine.
`current_grants[i] = v` is useless (as we don't use current_grants later), just add v to parsed_grants at the end of the loop : `parsed_grants.add(v)` Anyway, that's the solution I was going to purpose after hitting the same bug.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
You don't need this conditional, since Ansible enforces that these are the only choices.
`, no_log = True`
No longer need deepcopy
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
```suggestion type: path required: yes ```
```suggestion type: str default: https://intersight.com/api/v1 ```
also potentially end this block with `raise`
Please change this to `client = self.connect_to_aws(rds, region)`
C/P error, should be `AWS ElastiCache is down`? Same on L450
Fails since message contains An error occurred (InvalidParameterValue) when calling the ModifyCacheSubnetGroup operation: No modifications were requested.\n instead have if 'No modifications were requested' in str(e):
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
"One of your CIDR addresses has host bits set. To get rid of this warning, check the network mask and make sure that only network bits are set. [full boto3 error message]"
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
Please put all imports together at the top, and include only the stuff you are using, i.e. ```python from ansible.module_utils.basic import AnsibleModule ```
We are not doing anything with stdout and stderr, but on failures it may be the only clue to why it failed.
Missing example or detail of what the valid options are.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
I think what you've got it good, thanks
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
e is unsued, just `except Exception:` to avoid 'bare exceptions'
I think we should add an `allow_overwrite` or similar param.
Wouldn't it be better to let `openssl dhparam` write into a temp file, and on success move the temp file to the real file (with `module.atomic_move()`)? Then in case of interruptions or errors, existing destinations wouldn't be trashed (except of course if `atomic_move` itself goes terribly wrong).
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line.
this should be a list of `choices`, not suboptions (which describes sub-object schema)
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
enabled/disabled for this as we are talking about a service (email)
Should be specific about what's being forced in the arg name, something like: `force_removal_with_mapped_luns`. These tend to grow over time, and generic names like `force` are problematic for someone just reading the playbook to know what it does without consulting the docs.
should probably specify that this is only used for deletion
use the `missing_required_lib` function from `ansible.module_utils.basic`
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
use `missing_required_lib` from `ansible.module_utils.basic`
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
Cool. Thanks. Let me know once done.
Can be renamed to import_string based on my recommendation above.
These defaults work fine imo. I don't see why would someone want to manage zabbix hosts partially via XML/JSON imports and partially via web console until it is one-time import thingy.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
```suggestion - The application key to use. ```
```suggestion - Determines the type of record to use. ```
```suggestion - The application secret to use. ```
```suggestion or deleted. ```
```suggestion - The TTL of the record to manage. ```
Python 3 versions are packaged in `python3-libselinux` and `python3-policycoreutils`. But the module needs just `selinux` and `seobject` python modules and version depends on the current interpret version. I don't know how to make it understandable and correct. On lines 267 and 270 I'd probably use module names could be used instead of package names: ```` module.fail_json(msg=missing_required_lib("selinux"), exception=SELINUX_IMP_ERR) module.fail_json(msg=missing_required_lib("seobject"), exception=SELINUX_IMP_ERR) ````
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
`required=False` is not needed as it's the default
These 2 `if` statements could probably be combined. To `pop` when if it doesn't start with `_` or not equal to `msg`.
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Might be worth validating that zones is a list rather than a single zone provided as a string.
check_mode is True but I don't see any check done around this. Please correct me if I am wrong here.
You can use get_option() instead of accessing the dict directly.
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
Yes, 'msg' key and value should always present on *_exit() calls
Fixed in https://github.com/ansible/ansible/pull/34186
As a side effect on this, it should always result in `changed=True` similar to the `shell` and `command` modules.
```suggestion - Required for C(type=DS) when C(state=present). ```
Not sure what you've done in other modules, though allowing this to take `type=list` maybe nicer
Oh, ignore this
Return is not compulsory but will help end user to understand return value of module.
New person will be confused when you refer to `msg`, adding a brief description will help.
Use `env_fallback` ``` from ansible.module_utils.basic import env_fallback ... api_key=dict(fallback=(env_fallback, ['HEROKU_API_KEY', TF_VAR_HEROKU_API_KEY']), type='str', no_log=True), ```
`no_log=True` is argument spec will handle this.
not a blocker, but requried=false is the default and can be omitted.
There is no need to do `- >` here, just like a bit higher up, list items can be multiline.
Right, we tend to quote the complete string in such cases. But ok, not a big deal.
Or just don't use a `:`
Unneeded, the default is null, so you don't have to explicitly mention that.
Missing doc string for 'labels'
```suggestion version_added: '2.9' ```
Spaces ! ```suggestion choices: [ absent, present, query ] ```
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
So I am interested to know the difference between PUT and POST. And highlight that here.
This is not a blocker, just a thought on the interface.
Yeah, this should probably be an error if the config has explicitly removed the paths...
The only odd behavior I can create is if I set 'collections_paths = :' (an empty list) ``` ini [defaults] collections_paths = : ``` In that case, the collection ends up getting installed into $PWD/ansible_collections/. But I suspect that is a general issue with config types of 'pathspec' and not specific to collection_path.
@s-hertel that would be really nice for vanilla pulp ansible installations, which don't currently have token auth.
add a method for a file, then /dev/stdin will be a subset of that
Just use ` and ...` instead of nesting. Less indentation == better readable.
Add this snippet at the top of the module: ```python from __future__ import absolute_import, division, print_function __metaclass__ = type ``` Then, you won't have to inherit from `object`.
Initialized must go first.
This should probably guarded with `if __name__ == '__main__':`
just call scaleway.ini we are in ansible conflict should not occur
Need to bump this to `2.6`
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
missing default value
This task fails with `{"changed": false, "msg": "missing required arguments: valid_from, valid_to"}`
This variable is never assigned ```suggestion api.get_collection_versions('namespace', 'collection') ```
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
nit: ```suggestion cached_server = final_cache['galaxy.server.com:'] cached_collection = cached_server['/api/v2/collections/namespace/collection/versions/'] cached_versions = [r['version'] for r in cached_collection['results']] ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
py3.x-only code; can safely ditch the args to `super()`
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
how about ```suggestion installed_packages = defaultdict(list) ```
Tell people where we are looking `CONFIG_FILES`
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
One thing to note, merge_type might not work with apply, we might hard code the apply merge strategy to merge (since strategic merge patch would need to know the merge key to intelligently generate the patch)
Actually it needs to be `AttributeError` to keep everything happy (which the import machinery will turn into an `ImportError` if it was sourced by an import)
This probably needs to be bytes.
Tell people where we are looking `CONFIG_FILES`
tempted to add a warning 'path not found'
Now that #39924 has been merged into devel you can: ```python from functools import partial from ansible.module_utils.common.collections import is_sequence test_list = partial(is_sequence, include_strings=False) ```
Having it upstream would be nice, but I doubt we can change our minimum required Jinja2 version anytime soon.
Honestly, I just failed to invent a better name
JFYI In the internal slack channel we came up with an idea: https://github.com/ansible/ansible/pull/39924 So it might get into devel before you merge this
This code is already available in `ansible.module_utils.common.collections.is_sequence` for broader use. So please follow earlier suggestion to reuse it: https://github.com/ansible/ansible/pull/37517#discussion_r192379339
No, you still have to check `HAS_BOTO3` (imported [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L229) and checked [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L558) )
No wrap needed.
No wrap needed.
Unnecessary line break
No wrap needed.
this is not a good test, and could cause bugs in the future
again, please sort according to severity
```python current_config['received'] = (current_config.get('received') == 'yes') ```
```python if size_pct is not None ```
```python elif max_num is not None and () ```
Yes, please remove the return and update the caller.
no need to check for present as it is default state
@azaghal I would leave it as you have it, with the explicit check for 'present'
You are not returning ansible_facts here. This will break backward compatibility.
ditto as `required_if`
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
```suggestion - "The C(wait) option must be set to false when state is absent." ```
```suggestion choices: ['present', 'absent'] type: str ```
I would write: C(started) is alias for C(present). C(finished) is alias for C(absent). Same in the steps.
please use C() around possible values of the state
sure, that's fine
The version_added key has string values. ```yaml version_added: '2.4' ```
```suggestion - Remove tags not listed in I(tags) when tags is specified. ```
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
```suggestion - If set to C(present) and library exists, then library is updated. ```
```suggestion - Name of the datastore on which backing content library is created. ```
```suggestion - The content library description. ```
```suggestion - The name of content library to manage. ```
```suggestion - content library id for which details needs to be fetched. ```
Why not just not set a 'default' for the Option() if the goal is to ignore the default value? Or set the default to an empty container as unfrack_paths intends. Then the callback doesn't need to care about the default
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Sure, a separate PR sounds good.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
here we can just use "image" instead of GalleryImage
same here, snake case, and convert value to lowercase
snake_case, value to lower (linux/windows)
I think we can just change "GalleryImage" to "Azure SIG Image"
lets' decide myAsg or myApplicationSecurityGroup
last time i note it as it seems a pattern, don't remove capitalization
please create a list: e.g. ~~~ yaml author: - "Amel Ajdinovic (@aajdinov)" - "Ethan Devenport (@edevenport)" ~~~
Please update your example with a valid task. `Command` is not a valid argument to the module anymore.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
I feel like 300 seconds is a long time to wait. Most droplets are created within 120 second range.
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
Both are fine IMO, there's nothing wrong with doing presence-checks either. I'll let you decide.
I would change this whole block with something like: ```python units = list('b', 'kb', 'mb', 'gb', 'tb', 'pb', 'eb', 'zb', 'yb') try: multiplier = 1000**units.index(unit) except ValueError: units = list(None, 'kib', 'mib', 'gib', 'tib', 'pib', 'eib', 'zib', 'yib') try: multiplier = 1024**units.index(unit) except ValueError: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
Why shouldn't a try/except block not be used ? I'm intrigued.
If it is not required, you don't have to add `'required: False`.
Though if things are a literal copy of what's in ec2.py (as CloudRetry is) I'd rather use an import so we don't duplicate all the code.
Yup, the idea was to leave ec2.py, and to put new work (especially boto3 stuff) into aws.py when it scoped outside just EC2.
This should be GPL Can you also please update `enos.py`
the code in module_utils is BSD licensed, to allow for 3rd party module redistribution w/o having these to be GPL
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
While you are here, can you please add support for - https://github.com/ansible/ansible/issues/24644 - https://github.com/ansible/ansible/issues/41494
Most of these 'regular' are the reason I added the exclusion in the first place, specially nfs, fuse and cifs, but basically all cluster file systems that use networking to deliver mounts are susceptible.
my intention was to allow this but as a toggle, but not by default
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Need to `return bind_mounts` here
Plz also use `match` arg here
```suggestion (u'1', u'PB', 1125899906842624), (u'1E', 1152921504606846976), (u'1EX', 1152921504606846976), (u'1Z', 1180591620717411303424), (u'1ZB', 1180591620717411303424), (u'1Y', 1208925819614629174706176), (u'1YB', 1208925819614629174706176), ```
You copy-paste a lot. It'd be more resilient if you could just put repeatable parts of data sets into reusable vars.
There's subset of cases which are the same, you could put those into a variable and then merge that with extra cases on per-test basis
I feel like this could be a good place to use hypothesis...
You are not returning ansible_facts here. This will break backward compatibility.
I think for this case, this should work: ``` python required_if = [('state', 'present', ('value', 'value_type'))] ``` But haven't tested that...
ditto as `required_if`
If config_source is only used in combo with direct, whichs looks to be the case, it may make sense to collapse it into one arg (config_source). Then GConfTool2.__init__ could: ``` python if config_source: self.base_command += ["--direct", "--config-source", config_source] ``` That assumes there won't be a scenario where it makes sense to call 'gconftool-2 --direct' or 'gconftool-2 --config-souce some_config_source' independently.
@azaghal I would leave it as you have it, with the explicit check for 'present'
excellent handling of congestion control
```python if dcb_mode != current_dcb_mode or weight != current_weight: self._commands.append( 'interface {0} {1} traffic-class {2} dcb ets {3} {4}'.format(if_type, if_id, tc, dcb_mode, weight)) ```
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
This may apply to some of the other PRs in flight, as well as some of your existing modules.
You've named this check_params in other modules. Not a major issue.
```suggestion - "Name of VM group to use with rule." ```
Here and below: ~~private key~~ --> key pair
I would follow the guidelines here for boto3 exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2
This is unnecessary, AnsibleAWSModule handles it.
This whole connection block can be replaced with `conn = module.client('ssm')`
Instead of accepting the backoff decorator like `connection = module.client('ses', retry_decorator=AWSRetry.jittered_backoff)` I think you should take the generated decorator, like `connection = module.client('ses', retry_decorator=AWSRetry.jittered_backoff(retries=17))` so that users can change their retry settings per-client, and then on all subsequent calls take a boolean like `aws_retry=True` (defaulted to False) so users have to opt-in at the call site to using retries, but only have to do the configuration once. This seems like the good kind of magic to me ;)
This is kind of cool. I like it. @ryansb @willthames Do you have thoughts on this? It should be an new-style class `class _RetryingBotoClientWrapper(object):` The one possible pitfall of this (that I can think of) is that if people see it as a shortcut but need to not retry on a specific exception it would be easy to overlook and retry inefficiently but that would probably be an uncommon problem and just something to keep an eye out for when reviewing things that use this.
Ah, right, hadn't realised that. I'm not sure any modules using AnsibleAWSModule would have got as far as module.fail_json_aws if HAS_BOTO3 is not True though. Worth checking just in case I suppose!
you could line that up with msg
Yeah, sorry, you're right, that's fairly obvious now you point that out. Again, we can use standard set operators for this ``` if set(users) - set(current_group_members_list): ```
```suggestion description: If True, system firmware will use UEFI boot explicitly. ```
Since this accepts a list of ports, change the type to `list`. This requires it to be transformed a bit, but would be a better UI. A `list` type parameter will accept a comma separated string as well as single items, which field validation will return as a string.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
Should not be quoted. It might confuse people to think this is needed. It is not.
+1 to `psexec_command` just for clarity...
That's a perfectly good reason to have a different name. Standard naming would be good, although hard to enforce and could compromise readability (which is something I value highly in ansible). command_line makes sense to me but can live with either.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
Some stuff complains if the .py file is missing the final LF- can't remember if we hit that anymore or not, but not a bad idea to add it just in case.
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
I wouldn't exactly call a dictionary `list`.
Use `get_bin_path` instead of this function.
Add absent as well.
In `check_mode: yes` the returned query will always be `SELECT 1 FROM 'tablename'`. But this is not what I expected. Normally I like to see what query will be executed for that change. Please change this behavior to always return the query which will be executed even if it is not in `check_mode: yes`
Just an empty line, could be removed for cleaner code
I would expect a module to issue warnings only for something which the user needs to be warned about. If the user wants something to be absent and it already is absent, that's not something I would expect a warning about. You also don't issue a warning if the user has `state == 'present'` and the sequence is already there.
Yep, simply ignoring all other options when `state == 'absent'` is the easiest solution (that's what most other modules do, too).
Why not also do this when `module.check_mode` is `True`? Then the check mode behavior is closer to the real thing.
Please add `no_log=True`
Remove spaces before operator `=`
This can be simplified as `if resp.json()`
use `fetch_url` instead of `requests.get`
Remove spaces before operator `=`
chack -> check
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
Try except blocks souls he as small as possible
This should be supports_check_mode=False.
Try except blocks should be as small as possible. In this case, if is only needed around the calls to modify and delete. Perhaps put the try except around the if state conditional to limit the statements that it surrounds
So, I think on failure this output would be useful as well. So maybe it's better to create a new dictionary `debug_result` which you can then provide to fail_json calls related to fetch_url failing, and you can merge it with result before exit_json. ```python debug_result = dict( url=url, method=module.params['method'].upper(), headers=headers, payload=payload, ) ``` Then add the response and status: ```python debug_result['status'] = info['status'] debug_result['response'] = resp.read() ``` Then call fail_json using it: ```python module.fail_json(msg=str(e), **debug_result) ``` And exit_json: ```python if module.params['output_level'] == 'debug': result.update(debug_result) module.exit_json(**result) ```
I'd go for: ```python output_level=dict(type='str', default='normal', choices=['normal', 'debug']), ```
I prefer this: ```python host=dict(type='str', default='api.meraki.com'), ```
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
I think it's better to refrain from abbreviations in formal/written text. (At least that's what we learned at school) So make that: ```python module.fail_json(msg="DNA Center did not return JSON compatible data")` ``` So it doesn't look like nested quotes.
Since it's the only plugin which does that, I would remove it. Either all plugins should do that, or none.
catchall ignore ....
This has to be done only once, since the binary is always the same (`docker-machine`).
```suggestion # with the same name and value but with a dm_ name prefix. ```
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
```suggestion - This lookup does not understand 'globing', use the ``fileglob`` lookup instead. ```
Indeed :) I totally missed that...
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Add default value as note in description rather than `default:` value.
no need for specifying type here.
Full stop at end.
Add as ``` - Description of vault. ```
Description of vault.
You should also extend check mode handling for `separate_git_dir` arg.
Don't ever inject new arguments in the middle of signature, always add them in the end. This way you can often break APIs.
Remove this. The final module exit is 10 lines down from here.
Instead of lots of if/else, you could follow EAFP principle and do: ```python try: if git_version(git_path, module) < LooseVersion('1.7.5'): separate_git_dir_fallback = True else: cmd.append('--separate-git-dir=%s' % separate_git_dir) except TypeError: # will happen when comparing `None` module.fail_json(msg="Cannot find git executable at '%s'" % git_path) ```
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
also potentially end this block with `raise`
Please change this to `client = self.connect_to_aws(rds, region)`
Thanks for your work on this! It works as expected (although I wish describe_db_instances() could filter by tags as it would be simpler not to filter out the results while retrieving them).
C/P error, should be `AWS ElastiCache is down`? Same on L450
It seems like returning this string is the expected path through the function. So this should probably just be a return instead of raising an exception. Then the code that's calling it can decide to print it and reraise the exception that got us here if it chooses.
specifying `type='int'` removes the need for this, so you only need to check the range.
I'm not familiar with CE, though is this correct? ``` if mode == "mode-l3": ... mode = "mode-l2" cfg_xml = CE_NC_MERGE_NVE_MODE % (nve_name, mode) ... self.updates_cmd.append("undo mode l3") ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
`type='int'` You can then remove your code to check that this is an int.
`type='int'` You can then remove your code to check that this is an int.
I like this simplification but I believe that it should done somewhere in the core (suggestion for another PR) and not on per-module bases.
Break the line after the `(` to unify the style across the file.
rename variable name as it will shadow built-in 'type'.
I would name the method `passwd_check`.
I would name the method `passwd_set`.
I know. There's an alias for 'server'. Calling it `host` keeps it consistent with the modules and Python client. As a user, you can use `server` or `host`. The Python client calls it `host`, and uses `HOST` in the env variable.
I don't know what the opinion of the upstream reviewers will be, but considering this parameter controls a host's inventory hostname and not just `ansible_host`, it might be the case that this should be somehow contained within the standard inventory plugin `inventory_host` parameter.
this is already a requirement for the Ansible controller, you can omit it
is this per connection or global? some options seem like they are overtly indented
This variable is never used in the code.
We can reduce the level of indents: ```python elif option == 'test': elif option == 'retries': else: result[option] = self.healthcheck.get(option) ``` And I don't thinks someone will be bored enough to specify a `test: ""` to get into the `elif self.healthcheck.get(value): ` check
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Hmm, I think so. If the user specified zero, it probably has a good reason (or should fail if docker doesn't like it).
Ah, this is `golang`'s `omitempty`: https://github.com/moby/moby/blob/8e610b2b55bfd1bfa9436ab110d311f5e8a74dcb/api/types/container/config.go#L28
Yes. It could happen that someone templates something and gets the wrong value. If docker_container barfs with an exception, we get an Issue, if it returns a nice error, the user will hopefully solve the problem without filing an Issue ;)
I guess for consistency everything should be uppercase "Specific Virtual Machine Scale Set". Should "scaleset" be one word or two words? "scale set"
I should also note that this `retry` decorator isn't in use anywhere that I could tell.
This is an incorrect change. `retry_count` is not a global. Technically it is a nonlocal. `nonlocal` is not available in py2, so this closure just needs rewritten
s/Disk quota ID/Virtual Machine quota ID
```suggestion version_added: '2.11' ```
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
catchall exception handling is generally not a good idea as it neither gives a better user message nor aids in debugging. If you feel you must do it this way, be sure to return the stacktrace (retrieve that using raceback.format_exc() and put it into the exception parameter to fail_json).
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
they don't need a 'get' as the default will always be set, if that is not the case, there is a bug with `set_options`
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
you should not need to checked disabled, as the plugin itself wont be called at all if true
set this as the default, then you dont need to do checks yourself
check is redundant as you already flagged as 'required'
```suggestion booleans or other types by the YAML parser must be quoted (e.g. C("true")) ```
That's not what the code says (where default is `zip`)
I must be getting blind...
Definitely not. You're too diplomatic ;-)
typo: earch -> each> Also not sure if the / on the end of L198 is intended
This won't work if 'name' is an alias, rather than the parameter name.
This was very specific to ACI, I don't see a good reason to repeat this here.
I would do this in a more pythonic way like, `'/organizations/{0}/networks'`
No need for the 'else' here either. The 'if' is the exit statement.
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
This can be simplified as `if resp.json()`
use `fetch_url` instead of `requests.get`
Remove spaces before operator `=`
Remove spaces before operator `=`
Please add `no_log=True`
Probably should also check and fail for `self._connection.transport == 'local'` - no need to go nutty trying to figure out if they're rebooting the controller via a more circuitous route, but at least cover the easy one.
`delay_min_macos = delay_min | 1`
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
shouldn't this line and the one below just not be here, and the loop be `for arg, version in self.DEFAULT_DEPRECATED_ARGS` (though those aren't really a default either, so `DEFAULT` is a bit of a misnomer)
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
Could we maybe sort this out so it's easier to see? I mean having something in the lines of {'config': {'options': {'system': And so. It'd be just so much more readable.
iirc other platform use `enable` option to enable/disable lldp
`speed` should be `int`
what is TLV? it might be good to describe it at least once.
Applicable for other iosxr resource modules as well
```suggestion description: The error message returned by the Gitlab API ``` The same for the next one.
```suggestion description: JSON parsed response from the server ```
You are not returning this.
You don't return this one as well. Only specify things in `RETURN` which you actually return!
Use best practice to handler this error : ```python GITLAB_IMP_ERR = None try: import gitlab HAS_GITLAB_PACKAGE = True except Exception: GITLAB_IMP_ERR = traceback.format_exc() HAS_GITLAB_PACKAGE = False ```
No need of the new line here.
Not sure if we can license module code as Apache License.
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
```suggestion - Specify the desired state of the snapshot. ```
Requires a trailing dot.
Descriptions (except short_description) require a trailing dot.
Descriptions (except short_description) require a trailing dot.
Please do `C(name)` to make parameters stand out.
Descriptions (except short_description) require a trailing dot.
also replace the word "facts" with "info" in the docs
the description looks wrong to me
we could U() the link
Perhaps we could add an example to show how to list zones (without filtering).
Please replace your mail with your github handle (also in cloudscale_server module)
@dsoper2 I think I mentioned it once before, but this one big try-except block you are using in almost every module is considered a bad practice. We tend to prefer small try-except blocks and catching specific exceptions with specific error-messages guiding users. I understand that that's not always the easiest path, because you may not always know in advance in what ways something can break, but that's something you learn along the way. In this example, there are a lot if statements that can't go wrong (like assignments and conditionals). On the other hand, you're calling class-methods that might as well catch their own exceptions, so there's no need to catch them in the module. Maybe the only call you want to add in a try-except block is the call to CommDnsProvider, because it's external you may need the handle raised exceptions.
For ACI we opted to use `description` as default, and made an alias for `descr`. Since otherwise it looks a bit awkward (and core devs have questioned it too). But it's up to you.
We expect all imports to happen at the start of the module. If it is possible this will fail because e.g. ucsmsdk is missing, then you add it as part of a try/except block and set HAS_UCSMSDK=True/False, and provide a proper fail_json error if HAS_UCSMSDK is False.
Why not put the real meat directly here in main() ? I don't see a good reason to have 2 layers of abstraction (main -> setup -> setup_macpool) if it is unique to the module anyway.
The advantage is that you can simple call module.fail_json there where is fails, without the need to pass everything back. I think it improves readability.
Add alias of `username` (shown in argspec).
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
Could we maybe sort this out so it's easier to see? I mean having something in the lines of {'config': {'options': {'system': And so. It'd be just so much more readable.
iirc other platform use `enable` option to enable/disable lldp
what is TLV? it might be good to describe it at least once.
`speed` should be `int`
Applicable for other iosxr resource modules as well
Additionally when user sent ticket=true, this module will return also remote_vv_file parameter in vm dictionary, which contains remote-viewer compatible file to open virtual machine console. Please note that this file contains sensible information.
Can you use here: ```python host_id = get_id_by_name(hosts_service, host_name) ``` you won't have to check if host exists and it raises the exception for you. And you are insterested in host id only anyway.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
also please rename entity_id to job_id, no need to have it too generic here
here you need just a 'steps' not whole module as well.
This should be a more comprehensive example, I don't follow what the intent here is. I have an assumption that you're connecting to a ssh daemon that's running in the context of a chroot located at `/mnt` on the `server01` system but it should be more explicitly stated in an attempt to remove the ambiguity.
This should be configurable with a sane default (which I think `/usr/bin/chroot` is a sane default).
`Sets the connection time, in seconds, for the...`
I think this needs a `version_added: "2.5"`
duplicated `type: ` line. I wonder if this is what's causing the CI failure.
pyvmomi only support 2.7+, so you can safely bump to Python version to 2.7
```suggestion - Destination datacenter for the register/unregister operation. ```
```suggestion zabbix_user_info: ```
Remove this line.
unused import ```suggestion ```
No, I mean ``` except (vmodl.fault.SystemError, Exception) as e: ```
Also, add ```vmodl.fault.SystemError``` here,
Move import statements after Line 81 or after RETURN
No quote around list members.
Required is by-default set to False, no need to specify.
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
There is no state `get`.
I get error while trying this example ``` fatal: [localhost]: FAILED! => { "changed": false, "invocation": { "module_args": { "ipa_host": "master.ipa.test", "ipa_pass": "VALUE_SPECIFIED_IN_NO_LOG_PARAMETER", "ipa_port": 443, "ipa_prot": "https", "ipa_user": "admin", "ipavaulttype": "symmetric", "replace": false, "state": "present", "validate_certs": false } }, "msg": "missing required arguments: cn" } ```
`delete` and `create` are not valid states
``` for key in data: if ':' in key or '-' in key: newkey = key.replace(':', '_').replace('-', '_') data[newkey] = data.pop(key) ```
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
Make a common method in class to get url and return json loads response.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
It doesn't matter whether it's a method or a function. A private function is related to the module scope, a private method is related to the class. Still, both are private, it's just a different level of namespacing. If a module name starts with an underscore it'd be also private.
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
You are right, it's not consistent as-is. @Akasurde What is the direction we are taking this ? Also, we should also define a sub-spec for the hardware-parameter at some point.
Ok, I am confused, about it being a 3rd level dict (and why that even matters) and it being complicated (why ?). Even if it is under hardware it could be a separate spec, I don't see why that would matter. To me putting everything as a top-level parameter is problematic, that's why we introduced the hardware parameter in the first place. The problem here is that if people add it the way they prefer, things will become very inconsistent (and I guess this is why we are having that discussion now, again).
Please add capability from #45953 to this PR, allowing for an existing virtual disk to be specified.
Also describe if it deletes the files or not
`Care should be taken ...`
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
even hardcoding /tmp is not a good option, some systems create a per user /tmp mount .. aside from other more restricted permissions and file system types that might not work well with locks. if i had an easy answer to this, i would have already done it, but it is much harder than you would think at first approach.
Note: Our convention is to use a prefix (b_locak_path) rather than a suffix.
Set the default timeout here: ```suggestion def lock_file(self, path, lock_timeout=15): ```
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
I think this should be: ```suggestion # value: "{{ sample_com_challenge.challenge_data['sample.com']['dns-01'].resource_value | regex_replace('^(.*)$', '\"\\1\"') }}" ``` (I don't know why github thinks the original line has a leading space...)
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
This needs to be 'rb' so that it's bytes just like the BytesIO above.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
I don't see the point ;-)
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_PASSWORD']), ```
Please don't use such generic env vars. ```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_IDENTITY_ENDPOINT']), ```
he, sadly most people do use duplicate names across hosts/groups ~no, just do line #120 and remove 121-122 as they become redundant~ nvmd, its host facts .. its ok as is .. for some reason i was confusing it with 'vars cache'
the order is incorrect, it probably 'works' if you don't have duplicate vars in inventories as the set_variable is overriding any cached vars you would have yet you do the reverse override here.
this seems to do the reverse of what you want
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
Unless it's a specific value, leave the default out and put it in the description like you have done.
Probably expand on this a bit, maybe say if false then an existing container will not be changed and so on.
```suggestion - List of IP addresses. ```
This needs to be updated to reflect the actual return values.
Should set `no_log=True` for fields like this, this stops Ansible from logging secret information to plaintext sources.
I thought this initially too, looks like @sbj-ss is relying on the `if e.response['Error']['Code'] == 'NoSuchEntity'` for that use-case
module.run_command is catching subprocess.CalledProcessError and calling module.fail_json, so should never get this exception at this point. (looks like that was already in the existing code and not introduced in this pr, so just a note...)
If the source is not provided, there is an endpoint that lets you update all inventory sources for an inventory (future enhancement, I would not suggest doing that here, just pointing it out)
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
This is not wanted, a parameter is considered optional by default unless you add `required: yes`.
Add trailing dot.
This should become `executable`, which is the standard parameter name for this kind of functionality in Ansible.
This should be: `default: 'no'`
This should become: `type: bool`
Is this a requirement listed somewhere? Most of the tests for our modules are already implemented using unittest
Suggestion: add a blank line here to separate `import X` and `from X import` types of import
short_description shouldn't need a trailing dot, as the index does not have trailing dots.
No trailing dot in short_description. Keep the index clean and tidy ;-)
Short description should not contain a trailing dot
This could be moved inside the conditional that follows to avoid checking when there are no vendored modules.
Indent isn't really necessary here: ```suggestion if already_loaded_vendored_modules: print( 'doh, some vendored stuff was already loaded: {0}'. format(already_loaded_vendored_modules), file=sys.stderr, ) ```
```suggestion print('hijacking sys.path to use ansible-vendored files, bwahaha ð£ð£ð£') ```
```suggestion print('hijacked sys.path to use ansible-vendored files, bwahaha', file=sys.stderr) ``` (because this log entry is added after the fact)
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
We don't need tags in this function, I think.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
It might also be no IGWs found here.
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
a teeny typo: ipvr_addresses -> ipv4_addresses
Descriptions (except short_description) require a trailing dot.
two blank lines...
Indeed :) I totally missed that...
```yaml description: - The desired format for the returned key. choices: - PEM - SSH ```
```suggestion - Required when C(state=present). ```
Could you please add a changelog entry [here](https://github.com/ansible/ansible/tree/devel/changelogs/fragments) and porting guide note [here](https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/porting_guides/porting_guide_2.10.rst#id51)? This will help users.
Nitpicking: `Used only if C(vm_id_type) is C(inventory_path).`
the module itself doesnt use a swdepot binary (online i've only found refs to the other 3) so keeping swlist and pointing to swdepot module seems fine with me.
`auth_realm` should also be added to `fetch_url`.
I don't think that any callers currently need to modify bufsize, do they? If so, let's make it a module constant instead of a parameter. We can always add a new keyword argument in a backwards compatible way but we can't take it away.
One option would be to pass add an arg for the local fs path (or even an open file handler).
The code that gets replaced by this method (in crc32 for ex), the url is downloaded to a dir local to the module source. Here, a new temp dir is created. Afaict, those could have different permissions. If the mkdtemp() result is more open than the __file__/* path, a downloaded file may be readable with different permissions. Haven't tested to see if that is a problem so would like some clarification.
I talked to Jmainguy on IRC and he thinks that using mkdtemp() should be fine from a permissions standpoint. There are some other thoughts though: * Using the module tempdir, the temp dir should be cleaned up automatically by the controller. If we use a separate tempfile, it becomes the calling code's responsibility to clean up the temp file (and the temp file can be left if the module raises an exception before it cleans up). * the module doesn't always have a file (in pipelining mode). When that happens, we can't use __file__ to determine where to place a tempfile. bcoca proposed adding a mkdtemp/mktemp function that could handle this but that is probably worthy of a separate PR. * bcoca also noted that overall, it's better not to have modules do this. Having two separate tasks works just as well (however, we need to start shipping roles at some point so that composing multiple tasks into a single logical unit is as easy as creating a module). Perhaps a note in the docstring that modules shouldn't tack on downloading files as a secondary function would be satisfactory for now.
It's just an example. I just want it to be less scary.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Tell people where we are looking `CONFIG_FILES`
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
`payload_from_wished_lb` could be called once.
`creation_response.body` is empty I propose to use: ``` "%s: '%s' (%s)" % (creation_response.info['msg'], creation_response.json['message'], creation_response.json) ```
This method is unused and must be removed.
test of `wait` parameter could be moved inside the `wait_to_complete_state_transition` method.
All Scaleway products are not available in all regions/zones. I think it could be interesting to set the choices explicitly to avoid problems if we add a new region in `SCALEWAY_REGIONS` in which the `lb` product is not available. Here is a proposal inspired by [what we have implemented in the new Go SDK](https://github.com/scaleway/scaleway-sdk-go/blob/master/utils/locality.go): ```py # ansible/lib/ansible/module_utils/scaleway.py SCALEWAY_REGION_FR_PAR = "fr-par" SCALEWAY_REGION_NL_AMS = "nl-ams" SCALEWAY_ALL_REGIONS = [ SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS, ] SCALEWAY_ZONE_FR_PAR_1 = "fr-par-1" SCALEWAY_ZONE_FR_PAR_2 = "fr-par-2" SCALEWAY_ZONE_NL_AMS_1 = "nl-ams-1" SCALEWAY_ALL_ZONES = [ SCALEWAY_ZONE_FR_PAR_1, SCALEWAY_ZONE_FR_PAR_2, SCALEWAY_ZONE_NL_AMS_1, ] ``` ```py # lib/ansible/modules/cloud/scaleway/scaleway_lb_facts.py def main(): argument_spec = scaleway_argument_spec() argument_spec.update(dict( region=dict(required=True, choices=[SCALEWAY_REGION_FR_PAR, SCALEWAY_REGION_NL_AMS]), )) # ... ```
I would reverse order and have parse_kv go first, since it will also still be the most common usage, also the current detection will create many issues, we have used it before (still do for safe_eval). Use a try/fail approach on parse_kv to try yaml parsing afterwards and error out if all fail the module_require_args check should not be limted to kv, but also force skip yaml attempt
might be nice to fail if they are both provided.
I'd like to see us not pass the results of `load_options_vars` into `VariableManager`. Instead we should just use `load_options_vars` directly in `VariableManager`, and handle whatever complications there may be with using `CLI.version_info` from `VariableManger`.
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
In Python, we avoid adding unnecessary brackets.
You can just `return` without `else`.
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
Same change needs to be made to many other uses of filter.
Yes, the revisions you'v emade to this look good to me.
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
Ok, how does this look? 85164a272274514877a6369877e851461a5acf0b
This doesn't remove any orphan, it only checks whether there are any.
please use explicit import statements
please use explicit imports `from ansible.module_utils.basic import AnsibleModule`
please use explicit imports
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
I just had some time to look at this more closely and this is working correctly. As @s-hertel said, `recure: yes` is only valid for `state: directory` but isn't needed when removing directories.
I would give the example for removing a file some kind of extension, so it's clear that it's targeting a file rather than a directory. ```suggestion path: /etc/foo.txt ```
This is not a functional example and I don't think it does what you says it does: ```"msg": "missing required arguments: path"```
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
it absolutely is but "New in version 2.3." so I didn't make use of it yet.
Would be perfect with `delegate_to: localhost`.
`required: false` is the default, can be omited. Also, I would prefer to see the parameter types here.
The param `provider` is required when creating.
~~~ - name: Ensure a network is present cs_physical_network: ~~~
`id`, `name` and `zone` (which should be 'zonename': 'zone') are returned by default. Can be omitted in modules,
Define separate checks for json and boto3
Use the ec2 helper function `ansible_dict_to_boto3_tag_list`
There's a new AWS Retry generic handler that you can use here. Check out the ec2 shared code in module_utils
Handle boto3 exceptions as per the guidelines. E.g. ```module.fail_json(msg=e.message, **camel_dict_to_snake_dict(e.response))```
Not required - added by doc fragement
Can you add: ``` type: path ```
Can you add: ``` type: bool default: no ```
Can you add: ``` type: path ```
Can you add: ``` type: str ```
That's why I would also say `yes`. If someone thinks this is too much data, that person can simply turn it off with the option.
Won't this cause no task to ever be printed? You have nested the 'TASK' banner display under a check that ensures that the task name is 'include' and that the verbosity needs to be greater than 1.
task_uuid seems unused
we should also return if we both delegate executions and delegate_facts
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
Add that the user can specify the backend to use via the ```use``` parameter.
do not call "get" twice
avoid making double "get"
```yaml type: bool ```
state: type: str choices: ['present', 'absent']
use full names read-only, read-write
I think keeping both is probably best. Changing types of an existing return value, or removing one, will definitely break some people's playbooks. You could deprecate the old return value and announce that in the porting guide; then the old return value can be dropped in 2.13. This is not optimal because there is no mechanism which tells people that the result they are using is deprecated, but at least people who read the porting guide and/or changelog will have four versions to adapt their playbooks.
Ah, I just saw you already mentioned the return value docs :)
Remove this line and de-dent `if:` block. (And remove the `changed` variable in the `state == 'import'` block completely.)
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
`short_description: Manage VLANs on VyOS devices`
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
As `state` value is fetched at L112, this is not required.
Mutually exclusive with I(domain_name).
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
I am a bit surprised, since "state" is describing action. That sound a bit weird to me to mix 2 differents concepts in one single argument.
I guess this should be updated somehow.
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
oh I see, it makes sense then.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
this works fine but the if/elif is slightly complicated to follow, one branch touching password the other resource['password']... Consider something like this: ``` if self.module.params['update_password'] == 'on_create': password = None if password is not None: resource['password'] = password ```
no need to specify required=False or type=str as these are defaults
`{}` is not compatible across python versions that support format, use `{0}` or `%` instead
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
requiring this as a dict and not using suboptions nor no_log makes the connection password too exposed.
Not catching non-200 responses.
Not catching non-200 responses.
Not catching non-20x responses.
This method will retrieve only inventory of the last system that Redfish API returned in `_find_sytems_resource`.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
A message string would good to say that image is not preset or something similar.
I wouldn't call `module.params` as `packages` since it will hold also other parameters, not only the packages
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
```suggestion username = self.params.get('username') ```
```suggestion if not all([hostname, username, password]): ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
how about at least ```suggestion elif return_tuple[0] in sshpass_return_codes: ```
I think if these are combined and we are going to raise an exception on the first encounter of error codes 1-4, 6 anyway, then it's safe to combine this with the previous check for error code 5. The main goal is to fail on the first encounter to prevent password lockouts, and the rest of the failure scenarios don't make much sense to retry either. Removing the `remaining_retries` conditional also seems fine.
It's possible for this to traceback on Python2 if sshpass was used and we go through the code path here: https://github.com/ansible/ansible/pull/58121/files#diff-2cdbb4c74e2af35eda8ddf643f904b1aR336 Use a text string in that code path to avoid the chance of failure.
Actually scratch that... I'm wrong about that because msg is reset just above this. However, it looks like the stuff in the code path I mentioned above doesn't have any effect (because we're overwriting it in this conditonal block).
(nitpick) ```suggestion 6: 'Host public key is unknown. sshpass exits without confirming the new key.', ```
I think we are fine with having the property and can do w/o the 'special dict key' which would show in the user's dict definition
You probably don't need `{}` fallback anymore.
```python if dc is None: module.fail_json(msg="Failed to find the datacenter %s" % module.params['datacenter']) ```
I meant, `return` as `module.fail_json` will return anyways.
This is unreachable code.
That will come soonish, I hope. Whenever all more pressing things are done and I find time to work on my version_added PR again ;)
The schema check works correctly. (Which isn't necessarily the way you expect it to work :) ) The problem is the `author` function, which crashes for some inputs. It must not crash, and either return normally or raise a proper error like `Invalid`.
I think it's better to have `if not isinstance(line, string_types): continue`. That way all crashes are prevented, and not just the special case when `author` is `None` or a list containing `None`. The schema itself already checks whether `author` is either `None`, a string, or a list of strings, and will report everything that is none of these.
`None` is a valid value for `author` though, according to the schema. If the schema is correct, no error should be reported for the redshift module - or at least not for `author`. Once `version_added` is checked for collections, it would have complained about that one, since `"1.0.0 - \"Jens Carl (@j-carl), Hothead Games Inc.\" - \"Rafael Driutti (@rafaeldriutti)\""` is NOT a valid version number.
This PR adds `version_added` validation: #70869. It was already there for module options and return values, but not for the top-level `version_added` of a module in a collection.
I think you should either use `pid` or `PID` everywhere. Whether you prefer `PID` or `pid` is something you have to decide :)
```suggestion required: true type: str ```
This debug needs to be updated for a few things: 1. Use full YAML syntax, not `key=value` 1. `.pid` should be `.pids` 1. Instead of `','.join` please use the `|join` jinja filter.
You could drop "It return", i.e. change the description to "Process IDs of the given process"
the comma should be before `or`, i.e. `list of none, one, or more process IDs`
```suggestion - Valid path starts from '/'. Probe is sent to <Protocol>://<host>:<port><path>. ```
This isn't really needed - the task should already be returning changed==[true | false], so users interested in whether the resource was altered can just check that property instead.
Python 2.6 is minimum requirement for Ansible >=2.4 targets
Same here, seems a ValueError would be cleaner.
also the recent rule is to have choice values in snake_lower_case format
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
use ```from ansible.module_utils.vmware import find_obj```
`Name of the datastore cluster from which all child datastores need to be managed`
`Name of the cluster from which all child datastores need to be managed` I find this a bit weird, btw... clusters do not really have datastores directly as children, only datacenters have datastores directly: You can not create a datastore specific to a cluster, you create datastores on the datacenter, and connect hosts to them. I assume the `cluster.datastores` just lists all datastores that are connected to hosts in that cluster. Personally, it would make more sense to use datacenter as a grouping parameter instead of cluster (but that might also be a bit excessive, as that would put all datastores in maintenance mode in a DC, basically preventing any VM to run at all...)
remove un-used variable.
This needs to be the **repo** parameter, with possibly **name** as alias.
Leave out 'required: false' as it is the default anyhow.
CI failure due to missing newline at end of file: ``` 2017-02-02 22:37:29 ERROR: PEP 8: lib/ansible/modules/windows/win_git.py:72:2: W292 no newline at end of file (current) ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
Don't add `required: false`. It is implicit.
What's the reason for using the shell here? There's no redirection, pipes, or other needs for the shell that I can see.
For this case (no id specified; use the first one), it looks like there is some code missing to read the data from the first URI and then set `target_serial_interface_current_setting` to the data.
Why the loop here? `if match` should be sufficient
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
You can use iteritems as below ``` from ansible.module_utils.six import iteritems iteritems(parsed) ```
use isinstance built-in method
Do not use print statement. All module output is supposed to be returned as JSON.
use `isinstance(obj, type)`
Use [find_obj](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L57) instead.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
There is a parameter called `validate_certs` which used other modules. It would be great if you could that here so it will match every other module. [Example](https://github.com/ansible/ansible/blob/013c42b14fa06ff6355d8a9d52430f4cb1262047/lib/ansible/utils/module_docs_fragments/vmware.py#L30)
This should really be: ``` - Set custom DNS search domains. (Use I(dns_search) with C('') if you don't wish to set the search domain.) ```
I would remove all aliases if possible.
You can also use `I(...)` here.
Please, at most one alias, even better none. Having a long list of aliases is really bad UX IMO.
I don't think we need a default for this since I can't image it being generally applicable.
I think we can omit all the entries that reference `DEFAULT_BOOT_TIME_COMMAND` just point to that in the `get()` calls.
Change the default to `self.DEFAULT_BOOT_TIME_COMMAND` instead of `self.BOOT_TIME_COMMANDS['linux']`.
this should look like this instead: ``` result = super(ActionModule, self).run(tmp, task_vars) if result.get('skipped', False) or result.get('failed', False): return result ```
`delay_min_macos = delay_min | 1`
I don't understand why we would `return False` here. This function is about giving back an instance based on the public IP address or failing gracefully with an error message for the user. If this `return False` is happening, we need to write code to handle that in all places it is called within the module. This can lead to extra `if/else` which we should avoid for maintainability purposes.
I think we should guard against an `IndexError`. Even if Linode guarantee us some value, given programming error and such, I'd like to guarantee users of this module error messages that lead them in the right direction.
Ah, right, got it :+1:
Following PEP 257, this should be: ```suggestion """Return the possibly of a file being consumable by this plugin.""" ``` ref: https://www.python.org/dev/peps/pep-0257/
If state: absent and the ip is not there, this raises botocore exception `InvalidAddress.NotFound`.
I get that long format task ARNS might be a prerequisite for tags but might be better say e.g. > "Cannot set task tags: long format task arns are required to set tags"
AnsibleAWSModule has a function to check boto3/botocore versions you can use here. ```suggestion return len(load_balancers) > 0 and self.module.botocore_at_least('1.9.0') ```
Same thing here as above. Testing with botocore 1.8.19 fails when trying to use healthcheck grace period and succeeds on 1.8.20 Otherwise, looks good.
There is a 'createdAt' as a key in service as well.
ec2_argument_spec isn't needed anymore (built in to AnsibleAWSModule).
```suggestion - If set to C(False), will add, reconfigure or remove network adapters according to the parameters in C(networks). ```
Just an idea, Could we move this functionality to new module rather than putting in same module ? Same like `vmware_guest_disk_info` and `vmware_guest_disks` Nothing blocker as such.
Sounds a strange behavior to me to apply the change only on the first matched NICÂ when the definition does not indicate a single object. Either apply change on all matched NICs or fails sounds more logical to me.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Cool. Thanks. Let me know once done.
`results[mount]['info']['note']`must be changed here, because `res.get()` contains no information about the timeout happened here, e.g. `'Timed out while attempting to get extra information: %s.' % (to_text(res.get()))` Also a `self.module.warn('Timed out while attempting to get extra information for mount %s: %s.' % (mount, to_text(res.get())))` should be added here, otherwise the information that a timeout happened is only in the facts note, and so mostly hidden from the user.
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Another regex that can be precompiled.
This is useless unless you also return it as a value.
Please put this on a single line. Lines can be 159 characters wide.
no need. dependency check done by AnsibleAWSModule
If state: absent and the ip is not there, this raises botocore exception `InvalidAddress.NotFound`.
Technically this will never be `None` because of the defaults.
It would be nice if the current tags were added to the response.
This should go in a facts module instead.
Remove as not needed (default)
Remove as not needed (default)
If you have a `default` option then this is not true. I would just remove this line as `required: no` is the default.
This isn't really the case, the module seems to be installing the feature so I would mention that. Also mention that if a reboot is required then it will fail.
I think `state` is more ansibley
same, probably stick with the CamelCase form already in use through the rest of the module
This should probably be in the same if statement as `if self.state == 'present'`, this way you know the disk exists and so the initial present check is not required and you never really want to run this additional operation if `state: absent`.
CamelCase for consistency? This one could go either way since it's a new arg, but would depend on if there's a bigger plan to move everything else in this module toward snake_case
A few things when writing descriptions * Put each new sentence on a new line * When referencing another module option, enclose it in `I()` * When referencing a value for an option, enclose it in `C()` * You don't need it here but you can reference another module by enclosing it in `M()` * You don't need it here but you can add in a URL by enclosing it in `U()` So in the end this would look like ``` description: - Size in GB of the managed disk to be created. - If I(create_option) is C(copy), then the value must be greater than or equal to the source's size. ```
since `self.network_security_group_resource_group` is not required, I suggest add a logic to make `self.network_security_group_resource_group = self.network_security_group_resource_group or self.resource_group`, then change the `get_network_security_group(self, name)` to `get_network_security_group(self, resource_group, name)`
For EOS, following line is also required after this line: ``` commands.append( 'no switchport mode trunk') ```
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
`rolling_order` should not be removed, it is still a valid setting in vSphere 6.7 API: https://code.vmware.com/apis/358#/doc/vim.host.NetworkPolicy.NicTeamingPolicy.html#rollingOrder
Ok, sounds good, i get that :).
There's some mixed spaces and tabs here, please remove the tabs and use spaces only.
add a `mutually_exclusive` section
update_ntp_settings â update_ntp_servers (or re-change the update_ntp_servers method name)
`continue` isn't necessary
add an alias to `domain` as `domainname`
@ckotte I guess it would be more clear if the PR summary would be updated with the different changes you are making.
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
I would prefer to say name. But Iâm ok if you want to stick with this here. Or maybe client_config_name.
Should be specific about what's being forced in the arg name, something like: `force_removal_with_mapped_luns`. These tend to grow over time, and generic names like `force` are problematic for someone just reading the playbook to know what it does without consulting the docs.
Please add `, no_log=True`
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
`def get_recommended_datastore(self, datastore_cluster_obj=None):` â `def get_recommended_datastore(self, datastore_cluster_obj):`
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
I see did some changes of single quotes to double quotes but you left all double quotes are the were. You should change all other cases than named above to single quotes (e.g. keys in the dict vars - `my_dict['my_key']`).
That all sounds correct.
Capital letter at the beginning and period at the end of the sentence.
This should be: ```python msg = ( "Physical volume %s is already used by volume group %s." % (pv, lspv_list[pv])) ```
This should be: ```python module.fail_json( msg=( "Physical volume %s is in use by another volume group " "%s." % (pv, lspv_list[pv]))) ```
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
change 'type(job).__name__.lower()' to just 'job' no need to do it generic here
I would add here fetch_nested=True, because we always want to return steps.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
1) Can you please raise a bug (or PR if you know the fix) for the `basic.py` issue 2) suboptions don't (currently) inherit `no_log`, or `type` So you will need to set that explicitly on the sub options as needed
Right -- but is it the same format as os-release? If it's not the same format you'll need to add different parsing rules for that file below.
Ugh -- so this is where I look at the code and think, this needds to be refactored to make this new case sane :-). If you don't want to refactor, here's some pseudo-code for how to do it hackily: ``` python # Try to handle the exceptions now ... if self.facts['distribution_name'] == 'Debian': try: self.get_lsb_facts() self.facts['distribution_release'] = self.facts['lsb']['codename'] except: pass for (path, name) in Facts.OSDIST_LIST: [...] if self.facts['distribution'] in ('Fedora', ) or (self.facts['distribution'] == 'Debian' and self.facts['distribution_release'] != 'NA': ``` Like I say pretty hacky. But the code needs a refactor anyway. And we aren't putting false values into the data if we do it this way so future programmers won't try to figure out what debian-version is doing in OSDIST_LIST.
Please keep the mock data files and add `/etc/products.d/baseproduct` file content in `input` section. Something like ... ``` "input": { "/etc/SuSE-release": "SUSE Linux Enterprise Server 12 (x86_64)\nVERSION = 12\nPATCHLEVEL = 2\n# This file is deprecated and will be removed in a future service pack or release.\n# Please check /etc/os-release for details about this release.", "/etc/os-release": "NAME=\"SLES_SAP\"\nVERSION=\"12-SP2\"\nVERSION_ID=\"12.2\"\nPRETTY_NAME=\"SUSE Linux Enterprise Server for SAP Applications 12 SP2\"\nID=\"sles_sap\"\nANSI_COLOR=\"0;32\"\nCPE_NAME=\"cpe:/o:suse:sles_sap:12:sp2\"" "/etc/products.d/baseproduct": ... }, ```
Since this is duplicated code, I wonder if it could be consolidated with the `Kali` branch.
This could use `get_file_lines()`. ```suggestion distdata = get_file_lines(debian_version_path) for line in distdata: m = re.search(r'(\d+)\.(\d+)', line.strip()) if m: debian_facts['distribution_minor_version'] = m.groups()[1] ```
_tmp_args should be a local variable rather than an instance attribute. But if we do that the unittests will need changing in a more intrusive way. I think that's the right choice but I haven't looked at how to achieve that yet.
if that is an issue for the test, the test might not be correct, if this is an issue in general, it should be fixed in the code.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
Don't add this, if the parameter is not required.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
Please check this.
Please remove deprecated parameters as this is new module.
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
Please do not quote `%r` as it will automatically add quotes in creating a string representation of a string.
Since we are updating this now, let's switch `'%s'` to `%r` for the default values.
This will fail on new modules since `existing_doc` will be `None`.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
The docs say this should be `servers`, I'm ok with either but it should be consistent.
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
Maybe should be AzureRMCdnEndpointFacts, but that's minor
you can create entire dictionary at once
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
How about ```suggestion kv_pairs = [kv_pair.strip() for kv_pair in tags.split(',') if kv_pair.strip()] for kv_pair in kv_pairs: ``` That avoids empty strings showing up in the result, and also allows users to separate with `, ` instead of `,`.
If `tags` is the empty string, you will get one `kv_pair` which equals the empty string. That's probably not what you want.
Please use `C(...)` instead of backticks.
```suggestion - Number of containers instantiated in the service. Valid only if I(mode) is C(replicated). ```
The numbers should be in C(...), I think.
Also describe if it deletes the files or not
you dont need to include most of the defaults here (nor in docs), `default=None`, `type=str` and `required=false` are all redundant
Actually, the `dimensiondata_network` module already has metadata: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/dimensiondata/dimensiondata_network.py#L25
You'll need to rebase your branch to pull in the metadata and resolve the merge conflict.
No full stop needed on `short_description`. All other `description:` fields should be full sentences.
This formulation of importing configparser is not compatible with python3. You can use ``` python from ansible.module_utis.six.moves import configparser ```
cannot assume non 'core' modules are in the system, this should attempt to import and then allow for the AnsibleModule class to report about the missing module in a 'friendly' way, see ec2.py for examples.
understood, but namespacing is also a usability and convenience issue, it makes it easy for the user to define variables 'safe from conflicts'.
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
Try this: ```python attrs[name] = list(map(to_bytes, value)) ```
You can add it into this PR.
The same should be applied in the [`ldap_attr`](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/net_tools/ldap/ldap_attr.py#L176) module.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
This should be a string. ```yaml version_added: "2.3"
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
All `description:` MUST be full sentences (capital letter and full stop)
It would be good to combine these before the module gets released to avoid changing the module interface after release.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Sorry, was out all of last week. I'm looking for my reproducer right now.
Here is my reproducer, consistently fails: ``` --- - hosts: localhost connection: local vars: elb_app_lb_name: "{{ elb_app_lb_name }}" tg_name: "{{ tg_name }}" tasks: - name: create an application lb elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 listeners: - Protocol: HTTP Port: 80 DefaultActions: - 'Type': 'forward' 'TargetGroupName': '{{ tg_name }}' - name: update subnets elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-cbdf56ae - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 ``` Traceback: ``` TASK [update subnets] ************************************************************************************************** task path: /Users/shertel/Workspace/ansible/my_playbooks/elb_application_lb/iterate_over_NoneType.yml:22 Using module file /Users/shertel/Workspace/ansible/lib/ansible/modules/cloud/amazon/elb_application_lb.py <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: shertel <127.0.0.1> EXEC /bin/sh -c 'echo ~ && sleep 0' <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" && echo ansible-tmp-1499709521.38-260285283136193="` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" ) && sleep 0' <127.0.0.1> PUT /var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/tmpiiu8JI TO /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/ /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py && sleep 0' <127.0.0.1> EXEC /bin/sh -c '/Users/shertel/Workspace/ansible/venv/python2.7/bin/python /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py; rm -rf "/Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/" > /dev/null 2>&1 && sleep 0' The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1005, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1000, in main create_or_update_elb(connection, connection_ec2, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 895, in create_or_update_elb listener_changed = create_or_update_elb_listeners(connection, module, elb) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 704, in create_or_update_elb_listeners listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 487, in ensure_listeners_default_action_has_arn for listener in listeners: TypeError: 'NoneType' object is not iterable fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1005, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1000, in main\n create_or_update_elb(connection, connection_ec2, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 895, in create_or_update_elb\n listener_changed = create_or_update_elb_listeners(connection, module, elb)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 704, in create_or_update_elb_listeners\n listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get(\"listeners\"))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 487, in ensure_listeners_default_action_has_arn\n for listener in listeners:\nTypeError: 'NoneType' object is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ************************************************************************************************************* localhost : ok=1 changed=1 unreachable=0 failed=1 ```
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
```suggestion if host_network_info.atBootIpV6Enabled: if host_network_info.ipV6Enabled: ... elif host_network_info.ipV6Enabled is False: ... else ```
It would be good to call out a reboot is required to make it active
Same as with the other module: I suggest setting the current/desired state to what it would actually become, including the correct message. Check mode should represent what will be the outcome of the change as if it were for real, except not actually make the change.
Call out that a reboot is needed to actually deactivate it.
previous state in this case would be `enabled`, additionally on the message: Same as with the other module: I suggest setting the current/desired state to what it would actually become, including the correct message. Check mode should represent what will be the outcome of the change as if it were for real, except not actually make the change.
It doesn't solve the spacing/padding problem, now we have this (one space at 9 columns before the end, i.e after the right-padding of the name and before the left-padding of the time): ``` before ------------------------------------------------------------------ 0.00s after----------------------------------------------------------------- --- 0.00s ```
Since we're making msg unicode above we need to do the same here: ``` python msg += u"\n{0:-<79}".format('{0} '.format(result['path'])) ```
And then we can get rid of the to_unicode here because we've already changed it into unicode above.
this is not a 1.0 callback, its using 2.0 API
If the source is not provided, there is an endpoint that lets you update all inventory sources for an inventory (future enhancement, I would not suggest doing that here, just pointing it out)
How is this required if it can also be specified by the environment variable? Compare to openshift plugin via `ansible-doc -t inventory tower` ``` api_key: description: - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable. ```
I just realized we are missing this in all plugins (i just updated foreman #42355 ): ``` plugin: description: the name of this plugin, it should always be set to 'tower' for this plugin to recognize it as it's own. required: True choices: ['tower'] ```
i actually don't think you should force having the `tower_config_file` entry, but it could be posed as an option and default to the 'normal location'
It also might be good to compare these options to the options in https://github.com/ansible/ansible/blob/cdd21e2170b9a47d84624c8c2f792a66f2b0fe57/lib/ansible/utils/module_docs_fragments/tower.py#L23-L42
its fine to have a 'separate pre-existing file', I would just use it as a fallback if other methods are not populated and i would not create one if it were not already standard.
Suggest to add the alias for `load_balancing_policy` for backward compatibility, including in doc
This should really be `switch=dict(type='str', required=True, aliases=['switch_name']),`, so that is in line with the doc. Otherwise switch it in the doc... (but as you changed the `portgroup_name` to `portgroup` here, it needs to be consistent)
if you change `check_trunk_vlan_config` to return in the same order as the others, the variables here need to be reversed (and any `result[1]` in the code, needs to change to `result[0]`)
`""Delete a DVS Portgroup""`
Shouldn't this be in the reverse order, so it is in line with the other check methods? (consistency in code is good). That way you always use `result[0]` (will need to update that at other spots as well)
```suggestion description: Whether the domain is eligible for submission of "EV" certificates. Will never be C(true) if I(ov_eligible) is C(false) ```
```suggestion sample: true ```
```suggestion returned: success and I(ev_eligible) is C(true) and I(domain_status) is C(APPROVED), C(RE_VERIFICATION) or C(EXPIRING). ```
```suggestion description: Can be used to request certificates from ECS, with C(provider=entrust). ```
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
Just because a software is installed it does not make it the service manager, i have runnit and daemontools and encore-6 installed, none of them are 'THE' service manager. This is why checking proc 1 is important, also that only resolves the 'general service manager' which is what this fact tries to provide. If the `/proc/1/comm` path is unreadable we either need to find alternate way of figuring out the command (ps?) or return N/A or None as we failed to determine the 'real' manager.
To allow for future growth and other fallbacks ``` elif os.path.islink('/sbin/init'): service_mg_name = os.path.basename(os.readlink('/sbin/init')) if service_mg_name == 'runit-init': ```
yep, sorry it took me so long to realize it could be like this, had not looked at full file, when i did it became a much less invasive change.
was just rethinking this a bit, might be a simpler change in line 100, trap the failure of getting file contents above and do the symlink/basename there and assign to proc_1. But i fear both are invasive, also the proc_1_map should be used instead of the if I suggested previously.
```suggestion service_mgr_name = 'sysvinit' ```
If we don't add type information the docs don't look as good: https://docs.ansible.com/ansible/devel/modules/zypper_repository_module.html
```suggestion description: Destination file/path, equal to the value passed to I(path) ```
equal to dest, i always expect it to be equal to itself
That should already be the case except where 'python stringification' takes place, ... which affects fields like Default but not most others. Removing the python stringification would make it match.
i prefer if you call it memory_dump it's more understandable
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
The `root_uri` may include a port number (e.g. 192.168.1:8000). Should probably split that off also.
For this case (no id specified; use the first one), it looks like there is some code missing to read the data from the first URI and then set `target_serial_interface_current_setting` to the data.
Same things that holds for IPv4 addresses also holds for their v6 counterparts.
Redfish standard mandates that `IPv4Addresses` key is in response, but I know from experience that some systems omit it when there is no addresses to return instead of returning en empty list. It might be safer to do `for d in data.get("IPv4Addreses", []):` here.
Since all of the properties above are optional, directly accessing them might not be the best idea. One way of handling this is to use `dict.get()` method that will return `None` if the key is not present. The other option would be to only access the value if the key is present.
It's addressed here https://github.com/ansible/ansible/pull/47803/files#diff-4e0a09d18f6dfe19eb9d0b30c0a53bafR16
you are also missing doc fragments for classes using constructable and cacheable
@machacekondra still, it requires the docs also that module would not have passed review, it got merged w/o it so it is not a good example to follow
This variable is never used in the code.
is this per connection or global? some options seem like they are overtly indented
(Finally: let's leave the `mode` / optional `name` parameter away and get this merged first; you can then add it in #50428 or a follow-up PR, so that you can use the new `module_utils` Python module.)
```suggestion - When identifying an existing node name may either the hostname of the node (as registered in Swarm) or node ID. ```
In fact, this has been supported since docker-py 1.10.0. There's no need to require docker-py 2.6.0. (https://github.com/docker/docker-py/commit/a75553b3)
```suggestion - Must be executed on a host running as Swarm Manager. ```
One last thing: ```suggestion - Must be executed on a host running as Swarm Manager, otherwise the module will fail. ``` Whether the playbook task fails can be [configured](https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#controlling-what-defines-failure).
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
also extends `azure_tags`
lets' decide myAsg or myApplicationSecurityGroup
We may need at least the following features here: - [ ] `list_keys()`: Show the SAS policies of the Event Hub, so that we can have connection string - [ ] `list_consumer_group()` We usually add these with a flag to avoid network overhead. refer: https://github.com/ansible/ansible/blob/1dc8436ed91ef25748dd270c289c05f893cca6e3/lib/ansible/modules/cloud/azure/azure_rm_servicebus_facts.py#L55-L60
I think this logic should be handled by service instead of ansible client side
What if the rest service_principal missing client/secret field
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
How about the rest items of `spnprofile`
No need to set this, or check it.
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
change this to return `customer_gateways`
not needed with AnsibleAWSModule
The problem here is that it has to be maintained outside of Ansible. Might be better to leave it as free-form (and make the module fail message give details).
use /latest/ instead of version specific, since we will eventually archive docs for older versions
Instead of listing here, point at `ansible-doc -t conneciton -l` and maybe link to the connection plugins page, since this can change by installation.
If it is not required, you don't have to state this explicitly. (Makes it easier to see which parameters are required when skimming the list)
All descriptions (except the short_description) end with a trailing dot.
understood, but namespacing is also a usability and convenience issue, it makes it easy for the user to define variables 'safe from conflicts'.
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
I think changed needs to be set to True here.
Same here. Looks like some strange linewrapping is going on.
This isn't used in the examples. Is it possible to do this by name instead of URL? It seems a little complex to have to provide a full URL to use non-default networks.
Since this isn't being used in any tests I was wondering if it is right that this is a str, or should it be type='float'? I wondered about this for max_utilization too.
This isn't really needed - the task should already be returning changed==[true | false], so users interested in whether the resource was altered can just check that property instead.
Some modules define this as: ```yaml choices: - 'True' - 'False' - 'yes' - 'no' ``` to indicate that you can also specify it differently. If there is no standard, that's up to you.
I understand, we are trying to make things more concise over time. But at this time a lot of the modules are not consistent at various levels.
Should be a parameter of the task itself and not the module
This could be `elif`.
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
`api_token` parameter is missing.
The module has required options, but you don't provide any in this example.
```suggestion - name: Gather self-heal facts about all gluster hosts in the cluster gluster_heal_facts: name: test_volume status_filter: self-heal register: self_heal_status - debug: var: self_heal_status ```
This description seems redundant to me.
I'm just trying to think of a simple use case for these facts.
Missing full stop > Descriptions should always start with a capital letter and end with a full stop. Consistency always helps.
Only needed if true, otherwise it is assumed to be false.
> Descriptions should always start with a capital letter and end with a full stop. Consistency always helps.
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
The `basedir` path will need to be bytes to avoid unicode errors. Something like this: ```suggestion b_basedir = to_bytes(context.CLIARGS['basedir']) collections_search_paths.update([b_basedir]) default_collections_path = [b_basedir] + default_collections_path ``` I did not test this. I'm just guessing from looking at the test failure.
you want to put basedir first to match normal precedence
note that collections_search_paths is a 'set' which does NOT preserve order, but default_collections_path should
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
Missing `=dict` on this and the next few lines
Write a method to generate final diff so it can be used anywhere in the code when required.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
`ManageIQ username. C(MIQ_USERNAME) env var if set. otherwise, it is required to pass it.` and delete the `default:` line. This applies to the remainder of this file
To make this a clickable link please do `'manageiq-client U(https://github.com/ManageIQ/manageiq-api-client-python/)'`
Full sentences + full stops Capitals for acronyms `The ManageIQ environment URL.`
we try to use 'state' instead of action, as ti keeps with the declarative voice of Ansible vs an imperative approach from programming languages.
I think this should be a separate command option - `delete` or `create`. `state` seems like something different. At a minimum, I think it should be more explicit - like `action: create | delete`
On IRC, @bcoca mentioned that this should be doable with `construct`. It is currently not possible, though, but it is better if this can be solved in a plugin-independent way in the future, than now having plugins do it differently. @ximon18 do you mind removing this? Or is this a feature you absolutely need? With `construct`, you can do essentially the same, but not for arbitrary key-value pairs, but only for keys you know about in the inventory config. If that's ok, removing this probably speeds up getting this merged :)
Ah, sorry. I mean `split_tags` and `split_separator`.
``` from ansible.module_utils.common.process import get_bin_path ```
i would use the find bin function and not assume it is in path
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
I'm a fan of this approach @WojciechowskiPiotr for this situation.
`node-hostnames` (for me) would be the list of hostnames, while `nodes` would be the list with more infos. Why not return the list of inspect results, though? How about three modes: - `nodes`: list of inspect results - `node-hostnames`: list of hostnames - `node-summaries`: list of summaries (ID, hostname, status, ...)
Fine for me. 2.8 is still some some time out, fortunately :)
The main reason is that usually, `xxx_facts` modules also return information on whether `xxx` is available at all. It would be fine for me to simply return more detailed error messages on failure, after all we can pass arbitrary information along when calling `module.fail_json()`. If we return this information (docker in swarm mode / node is manager) also on failure situations, users can add `ignore_errors: yes` and use that information if they like.
Are you still working on this? I can't find anything like that in the current version.
I'd recommend adding a main() and a 'if __name__ == __main__: main()' here, but thats optional.
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
I'd rephrase: 'Obtain data of `vm_name` if specified, ...'
Should this be `type='bool'`, or is it more complex? If it's more complex then it might be worth expanding the description for this option.
As far as I can tell, the 'in_use' is never used.
this got named use_backend
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
we should also return if we both delegate executions and delegate_facts
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
Name needs to be updated here.
You can definitely add yourself here as well.
First letter should be capital and the sentence should end with a period.
All `description:` (apart from `short_description:`) must be full sentences, ie start with a capital letter and end with a full stop.
version added is 2.4
Do note that this only looks at the primary credential cache. This means that if you use a collection credential cache such as DIR, KEYRING or KCM (default in most distributions these days), you might not see a ticket that exists in a non-primary credential cache. Maybe consider using `klist -A`, or try a `kswitch -p <principal>`? The latter is easier to parse, but might break stuff if people are still using the old krb5 APIs (rather than GSSAPI) and were using the primary credential that you just made secondary.
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
s/run the/run in the/
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
s/does not do anything/has no effect/
afaik, winrm is only one using v X 6 and no one is doing the `display.verbose( ..., caplevel=23)`, I was pointing it out JIC you wanted a more precise wording.
since force-push ate my previous commit to fix this: s/coloon separated path(s)/path(s) (colon-separated)/
i would prefer to not add more connection specific arguments
Typo in the help message
Just to make an attempt at word-smithing > When doing an --list, represent shared variables inside groups or the inventory, > which has a smaller memory footprint but is not Ansible's internal representation
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
Typo here, should be L2 interfaces
Would it be possible to go into some detail, rather than just repeating the configuration options
`short_description: Manage VLANs on VyOS devices`
Indentation here doesn't look right
Please add `alias: ['trunk_vlans']` Bit confusing that the primary name is `trunk_allowed_vlans` though you use the aliased `trunk_vlans` in the examples.
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
Omit these lines please.
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
oh I see, it makes sense then.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
Nowadays we list all the functionality we use from a specific library explicitly. So: ```python from ansible.module_utils.basic import AnsibleModule ```
also would be super cool if we would move this to the top of the file. ``` 178 Python Imports 179 ============== 180 181 To make it clear what a module is importing, imports should not be sprinkled throughout the code. ```
add a `mutually_exclusive` section
`Current host '%s' can not be %s...`
`Current host '%s' can not be rebooted...`
`Current host '%s' can not be shut down...`
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
This seems like a good candidate for module_utils, since it will be needed for other conversions as well.
I think having a parent class in module_utils for each of namespaced and non-namespaced services would make sense, which namespace handling happening at that level.
I've been thinking that it would be a good idea to prefix parameters with the subcomponent they belong to (with the exception of metadata fields). So anything under spec, could be spec_<field name>
It would probably be good to expose api version, even if it is just locked to a single version for the time being.
Can you name this a little more verbosely? I can't unsee "get best"
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
Why don't you just encode suffix like `u'-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8'.encode('utf-8')` and for the no_temp_unicode override just do `suffix = b'-ansible'`? No need for this check which is arguably more confusing.
Tell people where we are looking `CONFIG_FILES`
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
I feel like this should be moved to `else:`
~~~ - name: Ensure a network is present cs_physical_network: ~~~
For consistency, please use the `delegate_to: localhost` syntax.
`required: false` is the default, can be omited. Also, I would prefer to see the parameter types here.
Ok, I see.
I think it's time to move this method to Cloudstack module utils.
I think changed needs to be set to True here.
Same here. Looks like some strange linewrapping is going on.
I'm not big on returning `Exception` here I'd rather be specific to JSON-ish exceptions, like: ``` try: pass # blah blah code # on Python 3+, json.decoder.JSONDecodeError is raised for bad # JSON. On 2.x it's a ValueError except getattr(json.decoder, 'JSONDecodeError', ValueError) as e: module.fail_json(...) ```
And then for requests-status issues, have a separate clause.
This will raise a TypeError: `exceptions must derive from BaseException`
```suggestion - Set the user's plugin used to authenticate C(CREATE USER user IDENTIFIED WITH plugin). ```
```suggestion - Set the user's plugin hash string C(CREATE USER user IDENTIFIED WITH plugin AS plugin_hash_string). ```
```suggestion version_added: "2.8" ```
```suggestion version_added: '2.10' ```
```suggestion - Set the user's plugin auth_string C(CREATE USER user IDENTIFIED WITH plugin BY plugin_auth_string). ```
Please add the module as a function parameter and maybe replace `dest `trough the `filepath` in the error message error: global name 'module' is not defined
maybe you add the type `type='path'`
Do you need that step? `clients = client_list` should be enough
Only needed if true, otherwise it is assumed to be false.
Only needed if true, otherwise it is assumed to be false.
this is checking the directory on the controller, not on the remote
I wonder if the output can be simplified to avoid repeating `unset` and `export`.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
su requires a tty, that is why most 'subprocess' plugins don't support it.
That all sounds correct.
I see did some changes of single quotes to double quotes but you left all double quotes are the were. You should change all other cases than named above to single quotes (e.g. keys in the dict vars - `my_dict['my_key']`).
Capital letter at the beginning and period at the end of the sentence.
This should be: ```python msg = ( "Physical volume %s is already used by volume group %s." % (pv, lspv_list[pv])) ```
This should be: ```python module.fail_json( msg=( "Physical volume %s is in use by another volume group " "%s." % (pv, lspv_list[pv]))) ```
```suggestion - This module can be used to create and delete an access list. ```
```suggestion - Access List Name. ```
```suggestion - "This module can be used to create or delete an event in oVirt/RHV." ```
```suggestion - "The C(wait) option must be set to false when state is absent." ```
```suggestion choices: ['present', 'absent'] type: str ```
An example of using values would be good to have.
A message string would good to say that image is not preset or something similar.
Can we rephrase it as "Host should support C(atomic) command"
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
The mixup to me is that people using incorrect units will silently be using bytes, whereas it should report this as an error.
Not a must fix. We could remove 2 lines of code and logical branch for ```if not ignore_errors:``` The Core reviewers might like it more direct and declarative.
CI failure due to: ``` 2017-01-31 18:50:23 ERROR: PEP 8: lib/ansible/module_utils/netapp.py:150:31: W292 no newline at end of file (current) ```
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
Future improvement: Along the same line of thought as above, should we rename request to something like santricity_request? Just trying to improve the readability.
I think it's likely the proxy code won't work as I haven't been able to test it well under Meraki
Okay, let's do this.
Just a note... We probably won't run into problems here as don't currently have symlinks with non-ascii filenames but this would be an issue if we did. I can't remember all the permutations between py2.6 and py3 but I think we'd either have to play around with the ensure_ascii and encoding arguments of json.load or do our own encoding and decoding and probably go back to f.write() and f.read() instead of using json.dump() and json.load(). I'm mentioning it since there's definitely places in the ansible code itself, where that is an issue so it's not a safe refactor in general.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
Now that there are two lines, "it" is a bit unclear. I'd change this to "Setting C(default) to C(yes) causes an error if the path is a file."
Never raise an exception, fail the module instead
line is too long
I would write this as ``` if current_values.get(key, "").lower() != val.lower(): ```
I would also do this: ```python if not vm: # fail # continue with the module ``` This makes it easier to read, as you don't have to find what `else` is part of what condition.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
Actually someone can sent for example '123213321321321', which isn't valid name nor ID, so it will fail with HTTP 404.
Check this: https://github.com/ansible/ansible/pull/29175/files If you will do it the same we can close that PR.
`network = on_service.networks_service().network_service(search_entity().id)`
%s is not UP"
You can use here something like: ```python sd = storage_domain_service.get() dc_name = connection.follow_link(sd.data_centers)[0].name ```
```suggestion # checksum filename ```
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
`del` is a builtin, not a function. These parens don't have to be here
Since you return above, unnest the `raise` here.
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
Same suggestion as above. .get() doesn't have to return a Nonetype so you can use it for "port" too.
Rather than a try/except you could do: `old_port = self.data.get("endpoint", {}).get("port")`
this is not needed as each section checks for it's own parameter
yes, this is equivalent to the 3 ifs that follow, there is no need for this duplication
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Use `required_if(['state', 'present', ['recipients', 'actions']])` in the `AnsibleModule` arguments
I am a bit surprised, since "state" is describing action. That sound a bit weird to me to mix 2 differents concepts in one single argument.
I guess this should be updated somehow.
Full stop, rather than comma at the end.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
oh I see, it makes sense then.
```suggestion result = dict( ``` More in line with a lot of modules.
```suggestion - name: Change login times for user ```
```suggestion mode: '0644' ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
i'm not sure that makes sense, if handler was not included, it would not be available for notification already. Since it should already add the conditionals inherited (only on import or include + apply) you should not need to check any other conditions.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
An equivalent to this would be `extra['Metadata'].update(metadata)`
I think you need `to_native` here.
I assume this should also be added to put_bucket_acl. The only thing I'm wondering about is if we should handle this for other S3 drop-ins as well. I assume most of them will fail for these two calls and all have their own special exception that they raise. Minio, for instance, raising a `NotImplemented` error.
Actually, since XNotImplemented is not an exception botocore will recognize most of the time so looking at the botocore code, it will catch all ClientErrors https://github.com/boto/botocore/blob/cac78632cabddbc7b64f63d99d419fe16917e09b/botocore/errorfactory.py#L40-L42 and will end up mask exceptions from lacking put ACL permissions. I'm going to revert my commit to handle these the old way with ['Error']['Code'].
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
Right but this seems arbitrary, cut off at 40 characters ? For readability I think it's better to not split lines if it is not required. But you are right, it's not mandatory. So you can ignore this :-)
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
```suggestion - This module was called C(docker_service) before Ansible 2.8. The usage did not change. ``` This can stay `C(...)`. It's not an option name, and the same formatting (of the same sentence) is used in many other modules :)
I think it should look like this: ``` python from ansible.module_utils._text import to_native [...] def enable_ds(module, array): """Enable Directory Service""" try: array.enable_directory_service() changed = True except Exception as e: module.fail_json(msg='Enable Directory Service failed: Check configuration: %s' % to_native(e)) module.exit_json(changed=changed) ``` One thing I'm not sure about is how we tell if array.enable_directory_service() made a change or not. Our users generally define Ansible's idempotence as: * they describe the state they want in a playbook task * the module makes the state match what is in the playbook * the module returns changed=True if something had to be changed to achieve the desired state or changed=False if the state was already as desired. This code probably does the first two but it's not doing the last one. I'm not sure how to fix it because I don't know what array.enable_directory_service() does. If it returns a specifc exception if the directory_service was already enabled, then we catch that specific exception and set changed=True for that. If it returns a status code telling whether it had to make a change or not, then we can use that to set changed. If neither of those, we would have to query the current state of the toggle first. If the toggle is already enabled, then set changed=False and call module.exit_json(). If the toggle is not yet enabled, call array.enable_directory_service(), set changed=True, and then call module.exit_json(). (Also note, these notes on changes also apply to the other verbs you have in this module: disable_ds, delete_ds, and create_ds)
This isn't needed if you have set a default.
No needed if you have a default.
Not needed if you have a default.
This isn't needed if you have set a default
Please use lower-case for these options. YAML is case-sensitive, so it will appear in the docs as Title-case.
Please note that I also fixed this in #52402, which just got merged; the conflict you currently have is probably related to this line. I think git should have no problem rebasing to current `devel` (since it will notice that this PR does the same as is already done on `devel`), so resolving it (via rebase) should be no problem.
This needs to be added to the `update_failure_action ` choices in `argument_spec` as well. Usage of the `rollback` choice also needs to be checked in `option_minimal_versions`. See how `publish_mode` is implemented.
CI is failing here, you need `version_added: "2.8"`
You beat me by 30 seconds ;-)
please quote version_added as well to not be a float.
Allow filters ``` argument_spec = openstack_full_argument_spec(filters=dict(required=False, type='dict', default=None)) ```
Allow filters ``` security_groups = cleanProtocol(cloud.list_security_groups(module.params['filters'])) ```
I'd prefer having the type specified for all parameters, like this: ```python argument_spec = openstack_full_argument_spec( service=dict(type='str', required=True), interface=dict(type='str', required=True, choices=['admin', 'internal', 'public']), url=dict(type='str', required=True), region=dict(type='str'), enabled=dict(type='bool', default=True), state=dict(type='str', default='present', choices=['absent', 'present']), ) ```
Would it be possible to have this field accept a dict instead of `k=v` string? ```yaml - os_server_metadata: server: vm1 state: absent meta: hostname: '' group: '' ```
So the main reason for this is that it increases readability. If only the items that are required are listed like this, you can see with a glance which parameters are required. Same for default values. It's useful to easily identify the custom default values. (Just like PEP8, this is purely from a readability point-of-view) For the same reason we prefer lists to be alphabetically sorted, unless the order has a purpose.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
Let's keep the naming aligned with docutils' own RST terminology/definitions, at least: ```suggestion _RST_ROLE = re.compile(r":\w+?:`") _RST_DIRECTIVE = re.compile(r".. \w+?::") ```
Looking at how this is handled, I wonder if this could be turned into a sequence of transformations. ```python _RST_TRANSFORMATIONS = ( (re.compile(r".. seealso::"), "See website for:"), # seealso directive (re.compile(r".. note::"), "Note:"), # note admonition (re.compile(r":\w+?:`"), "website for `"), # any role (re.compile(r".. \w+?::"), ""), # any directive ) ``` And then just ```python for regex, replacement in cls._RST_TRANSFORMATIONS: t = regex.sub(replacement, t) ``` (below)
i would make these 3 into one (since they are basically same behavior)
I thought we decided on titlecase, no? ```suggestion t = cls._RST_NOTE.sub(r"Note:", t) # .. note:: to note: ```
I wonder if it'd be hard to title-case the matched admonition. They are case insensitive. One can do any of ```rst .. Note:: .. notE:: .. NOTE:: .. NOTe:: ```
there are other locations in the file as well where such a fix is required
urlencode take a dict as parameter. you should replace this with `urlencode({"name": name})`
I've tried your branch on my local grafana with the `json.loads` fix. If I import an existing dashboard (previously in general folder) it will be moved to the specified folder. but the module is not idempotent anymore. If I re-run the playbook the task will return a `changed` status even if the dashboard json file has no changes.
Only those two lines are required, and it works for me with it
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Hmm, that's pretty inconsistent. So now we got three different choices... :) I guess it's fine to leave it with 1.25.
You're right. I also checked the source at tag `2.1.0`, and it contains that parameter. I guess they did some refactoring between 2.2.x and 2.3.0 which resulted in that commit...
That's not really necessary since the global minimum is 1.8.0. Shouldn't hurt, though, we just have to remember this when we bump the global version... :)
While we're at it: please add a trailing comma, that makes it easier to add another option (if we ever need to) :)
Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
```suggestion - Netvisor API to enable or disable APIs. ```
```suggestion - Web (HTTP) port to enable or disable. ```
```suggestion - Simple Network Monitoring Protocol (SNMP) to enable or disable. ```
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion - Web SSL (HTTPS) to enable or disable. ```
did you mean `cmd[u'prompts']`? missing a closing quote
+1, @amuraleedhar pls check your command spec for whether `prompt` or `prompts` is the correct key.
string literals are quicker than calling to_text() so that's why I mention it.
Prexisting but note that you're still operating on a string literal here so you can write it like this: ``` python cmd[u'promt'] = ur"[\r\n]?password:$" ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
please add ``` from __future__ import absolute_import, division, print_function __metaclass__ = type ```
I think we want to make this a one-liner now, as mentioned [here](https://github.com/ansible/community/wiki/Testing:-boilerplate,-wildcard-imports,-and-get_exception#boilerplate).
Please change this to 1.1
Please replace with the one-line license declaration.
This is the old ANSIBLE_METADATA stub. CI will fail.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
Formatting nitpick. You can add this to the line above.
Tend to favour YAML data structures rather than JSON style ``` sample: - name: my_bucket creation_date: "2017-07-06T15:05:12+00:00" ```
`changed=True` would be better.
`force` parameter: use boolean type
You need to check the requirements (PyYAML and GlusterFS > 3.2) there.
Am not talking about `check_mode`, but about `change=True` / `changed=False`.
http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#new-module-development There is written: ``` # during the execution of the module, if there is an exception or a # conditional state that effectively causes a failure, run # AnsibleModule.fail_json() to pass in the message and the result if module.params['name'] == 'fail me': module.fail_json(msg='You requested this to fail', **result) ``` AFAIK module should return with `module.exit_json` or `module.fail_json`, not `raise ValueError` for example.
The pep8 line length enforced is 160 - can keep this on one line.
Can be `except ImportError:`
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
No need to wrap.
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
Missing `=dict` on this and the next few lines
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
`read-onYly` should probably be `read-only`
Please remove this line.
Please add `type: bool`.
Same here, I suggest just adding `port_security_enabled=port_security_enabled` or something like that. In this case, `project_id` is pointing to `port_security_enabled` value.
could be just `if module.params['dns_domain'] is not None:`
please use here: ```python self.changed = True if not self._module.check_mode: auth_keys_service.key_service(key).remove() ```
For add and update as well: ```python self.changed = True if not self._module.check_mode: auth_keys_service.add(auth_key) ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Isn't paging for boto rather than boto3. This should just use standard boto3 pagination methods including build_full_result() I wrote this long before I understood boto3 pagination!
I think this needs to be a dict since it's used as-is in the call to ansible_dict_to_boto3_filter_list().
import HAS_BOTO3 too and add a check for it in main()
Can get rid of unnecessary line breaks.
This doesn't support aurora snapshots. Besides that, this looks great.
well, maybe. I haven't checked what `.absolute()` does.
I'd probably still want to see `.absolute()` in the end
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
I think it's not pylint itself, but our own checks...
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
```suggestion if os.path.isabs(link): ```
Shouldn't this be: ```suggestion if os.path.isabs(target): ```
I guess this should also be `os.path.isabs(link)`, but the next line also needs to be adjusted.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
Beware that in your examples, you are actually using `application_profile_name` not `app_profile_name`
Add a trailing dot.
I would simple make this `tenant`. If you still prefer backward-compatibility, you can add `tenant_name` as an alias.
The `notes` is a list of items, and each note must end with a trailing dot. Please also make this an full English sentence: ```yaml notes: - The tenant used must exist before using this module in your playbook. The M(aci_tenant) module can be used for this. ```
Has this actually been tested ? (Also move that list item to the start of the line)
Not catching non-200 responses.
Again, name of the method is misleading, since chassis path is stored for each of the chassis that Redfish returned, or method body is broken.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
This will fail if `self._find_managers_resource` has not been called yet. Method should probably check for the `self.manager_uri` presence and populate it instead of failing with attribute error.
This will fail if Redfish returns empty list of managers.
```suggestion node=dict(type='str'), ```
Not passing arguments to docker which don't affect the resulting service is no problem. It's only a problem (and shouldn't be backported) if it affects the visible behavior as seen from a user (like it updates a service which hasn't been updated with the old version).
Have you checked whether any of the value options where you removed the change overrides something defined in the image? If that's the case, this can't be a Bugfix PR (similar to changing the default of `user`).
I think we also want to require `encryption` be specified anytime `encryption_key_id` is passed. That way users won't accidentally pass the key_id and assume that it's being used when it may not be.
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
```suggestion array = module.params['force_array'] or (values is not None and len(values) > 1) ``` to avoid ambiguities when reading
Only import required.
This statement seems useless.
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
you just described check mode in general
docs say name is required, spec does not
a better message might start 'Failed to update the organization: `<execinfo>`' ... also It would be nice to make the distinction between retrieval and update, as they could pose separate permission issues. i.e. I can read but not update the organization.
This should be indented only by 2 spaces.
Actually this shouldn't be indented at all. Lists can start from the same indentation as their parent. And the general rule is, don't add things that aren't needed (so don't quote strings if they're not needed, or don't indent if it's not needed).
This doesn't need to be quoted.
You can drop the backticks around the `http(s)`.
I believe that this section should start on the same line as the dash instead of the line beneath from looking at other modules.
a better message might start 'Failed to update the organization: `<execinfo>`' ... also It would be nice to make the distinction between retrieval and update, as they could pose separate permission issues. i.e. I can read but not update the organization.
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
you just described check mode in general
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
docs say name is required, spec does not
@nitzmahone could you keep this `FIXME` note? This should probably be discussed separately.
I'm fine with the change in message, just noting that this test needs to be fixed up to check the new assertion https://github.com/ansible/ansible/blob/cf39d9de258cb9c47de9043e1a85e327e177dba7/test/integration/targets/ansible-galaxy-collection/tasks/install.yml#L43.
Are you only doing this to support Python 2.6? Those keys are already unique.
I think this may read better: ```suggestion if missing_keys: ```
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
I'd like to not pull SEQUENCETYPE into this file but this one is a little tricky. A Mapping is an iterable and we have a separate conditional block to work with those. If we just check for collections.abc.Sequence then we wouldn't catch things like sets and keyview.... I think what we can do is put the Mapping conditional before this one and then change this one to ```if is_iterable(obj)```.
We should probably rename this. Revisiting this code... this is a pretty special-case function as well. I wonder if it should be a private function inside of parameters.py (basic.py can make it public as part of its API but the idea would be that we don't expect any new code to use it.)
It seems like no_log and deprecation are separate things and should be handled in separate functions.
It looks like you will need to sort the legal inputs before comparing. Something like: ``` diff --git a/test/units/module_utils/common/parameters/test_handle_aliases.py b/test/units/module_utils/common/parameters/test_handle_aliases.py index 0db4c2ee7a..2b1e13cd95 100644 --- a/test/units/module_utils/common/parameters/test_handle_aliases.py +++ b/test/units/module_utils/common/parameters/test_handle_aliases.py @@ -59,12 +59,15 @@ def test_handle_aliases_basic(): 'nick': 'foo', } - result = ( + expected = ( {'surname': 'name', 'nick': 'name'}, DEFAULT_LEGAL_INPUTS + ['name', 'surname', 'nick'], ) - assert result == handle_aliases(argument_spec, params) + expected[1].sort() + result = handle_aliases(argument_spec, params) + result[1].sort() + assert expected == result def test_handle_aliases_value_error(): ``` That diff is for the next testa actually.
you can use from `ansible.module_utils.urls import fetch_url` instead of import additional library
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
```suggestion default: "org.graylog2.indexer.retention.strategies.DeletionRetentionStrategy" type: str ```
Match type for other parameters too.
```suggestion default: 1 type: int ```
```suggestion default: 4 type: int ```
```suggestion default: {'type': 'org.graylog2.indexer.retention.strategies.DeletionRetentionStrategyConfig', 'max_number_of_indices': 14} type: dict ```
Well, the final code is easier to read on a single line, so rather than extending it the result is IMO more readable so worth the effort.
Did you change anything in these lines? It's kinda hard to easily visually identify whether something is changed...
No changes were made.
I'd argue that it's less readable because line is too long now
Talking about unsafe. Not the stuff needed for representing octal values.
Rather than making these globals, store them as locals and pass them into the functions, or just run `mode.get_bin_bath` within the function. Globals are not worth the future troubleshooting complexity in this case, especially since `RPM_PATH` is the only variable used in two different functions.
What is the reason for reordering all these parameters? This breaks `blame` attribution for these lines & doesn't improve the code.
This is unnecessary change.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
I'm not sure what you check with `if want['vlan']` but it seems wrong without any explanation...
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
Should this handle for space within interface name? Something similar to https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/eos/eos_vrf.py#L224 to avid idempotency related issues.
If the VLAN exists, you should check the name and state to make sure they are same as requested.
I think it is better to pass module as argument to build_xml() and handle lxml install check-in module_utils instead of having it in each module
i would mention this plugin is Windows specific
```suggestion short_description: Execute tasks inside a VM via VMware Tools ```
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion - pyvmomi (python library) - requests ```
Should we just hardcode this instead of using `__name__`? Using `__name__` could make this dynamic, as it could be `__main__` or `ansible.utils.display`. We might benefit from just making it `ansible`
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
When hitting an error you must exit with module.fail_json
When hitting an error you must exit with module.fail_json
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
What exceptions are you planning to catch here ? Because we prefer to catch only the exceptions we know can be raised. Blank statements like this one may hide real logic errors under the premise that it was a known issue all along.
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
Why not do this in a single statement ? ```suggestion result = dict( changed=False, ansible_facts=dict( tcp_listen_violations=list(), udp_listen_violations=list(), tcp_listen=list(), udp_listen=list(), ), ) ```
Add trailing comma for multi-line dicts. ```suggestion supports_check_mode=True, ```
Add trailing comma for multi-line lists and dicts. ```suggestion whitelist_udp=dict(type='list', default=list()), ```
Instead of doing this, can we simply re-raise the existing exception? That way the traceback information stays intact: ``` python except AnsibleUndefinedVariable as e: raise except Exception as e: [....] ```
That was the thing I was saying earlier- checking for/failing on undefined inputs upfront would probably be what most people would expect, but that'd be a breaking change. Even if we chose that breaking change, we'd probably need a way for filters that *want* to allow undefined inputs to do so (transparently to the caller of the filter). And yeah, we probably need an analogue for tests, since the same problems exist.
Another option might be to build it the way we wish it were, then start a deprecation warning cycle on this bridging behavior (eg, do something like this and/or input inspection with an explicit optin/optout in plugin metadata, decorator, or whatever, then issue a dep warning on the exception catch or undefined inputs for plugins that haven't explicitly opted into receiving them). :shrug:
Shouldn't need the second and third parameters now `boto3_tag_list_to_ansible_dict` has been fixed. Not a blocker though.
State what you're trying to do when failing ``` module.fail_json(msg="Couldn't set assign-ipv6-on-creation: " + e.message, ...) ```
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
we want want -> we want
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_PASSWORD']), ```
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
```suggestion - Can be the name or resource ID of the route table. ```
Since this is the description of `route_table`, let's not make it `I(. . .)`. ```suggestion - Can be a dict containing the I(name) and I(resource_group) of the route table. ```
aha, it is in the virtual network module but in raw format
Can you differentiate between the named route not being present in the rout table and other exceptions to avoid log spew in the normal situation in which the route does not exists for that route table.
This `.close()` isn't needed, the context manager closes the file automatically.
It's recommended to use string interpolation over concatenation. ```suggestion cmd += ['--dns=%s' % ','.join(params['dns'])] ```
All of these uses of `str` should be switched to `to_bytes(var, errors='surrogate_or_strict')`. `to_bytes` comes from `ansible.module_utils._text`.
Oh, and in places with variables where you concatenate that with literals, also apply this function to avoid certain edge-cases which appear sometimes when you try to merge different data types.
I recommend you reversing this into a "guard expression" style: ```suggestion if rc == 0: return json.loads(out)[0] ``` And then you can reduce the nesting of the whole block of code which improves readability.
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
```suggestion with pytest.raises(FailJson, match='Unable to find required'): z = TgzArchive( src="", b_dest="", file_args="", module=fake_ansible_module, ) ```
Should the `continue` be here? The following 3 lines will never get evaluated.
It's all about your internal logic. The value is `None` instead of one of the choice values. On the other hand, if the `mode` parameter is not always required, it should not have `default` value.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
I'm cool with DryRun for this use case - the logic here is pretty simple so catching the exception is plenty sufficient.
That's definitely better, but it might just be simpler to do ``` def create_placement_group(connection, module): name = module.params.get("name") if module.check_mode: module.exit_json(changed=True, placement_group={"name": name, "strategy": 'cluster'}) try: connection.create_placement_group(GroupName=name, Strategy='cluster') except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Couldn't create placement group [%s]" % name) etc... ```
That's fair - permissions are definitely worth managing right!
Don't use DryRun - you're not handling the exception that will be returned. With check_mode, we usually just don't make the API call at all and return something suitable in the results.
HAS_BOTO3 import not required due to use of AnsibleAWSModule
You should probably note that these patterns are expected to be regex (vs. globs). The examples show this, but it doesn't hurt to be explicit. It also wouldn't hurt to mention that the patterns are not implicitly anchored.
```suggestion - name: Show variables with 'hosts' in their names ```
```suggestion - name: Find several related variables that end specific way ```
Typos: they -> the, too -> to.
```suggestion - List of the variable names requested. type: list ```
I would omit the 3, it seems like in the internal API you can set as many recovery actions as you want. It's just the GUI that limts to 3.
I would simplify this by saying the list order is the order of actions to take, i.e. first entry is the first action and so on.
In the code, you enforce setting all 3
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
If you enclose this in `EXAMPLES = r'''` you don't need to escape the `\`. Standard practice for all module doc blocks is to use `r''' '''`
i think we require this
some people are using `.yml.vault` or similar, so the same extensions might not always apply, that said, this is probably an improvement for most people.
Could be more compactly written as: ``` python try: r = call(['shred', tmp_path]) except OSError as e: r = 1 if r ! = 0: # We could not successfully execute unix shred; therefore, do custom shred. self._shred_file_custom(tmp_path) ```
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Hm, good point. I'm not sure. Maybe making exceptions more specific will be a pr for the future since it's used elsewhere in the module anyway.
@alexlo03 only inadvertently, I somehow switched from thinking about boto to boto3 exceptions. The same guidelines have boto exception handling - not sure if `boto.exceptions.BotoServerError` will suffice for timeouts or not. http://boto.cloudhackers.com/en/latest/ref/boto.html#module-boto.exception Given that we use `ClientError` with boto3, chances are `BotoClientError` will work with boto
Instead of Exception you could use boto.exception.EC2ResponseError
The parenthesis around `group, groups` aren't needed.
Once we have a client, I don't think we need to handle this exception again.
I always sort alphabetically if the order has no meaning.
No quotes needed here;
Can be covered in the `AnsibleModule` instantiation by using `required_if`
there's away to have this checked in the declaration of the module: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/nuage/nuage_vspk.py#L1019-L1020 (same for esxi_hostnames)
`vmware_host_config_facts` â `vmware_host_config_manager`.
In that case, we'd also better drop it, otherwise we'll get idempotency problems...
Wrap calls to self.client.X in try/except block. On APIError call self.client.fail() with an error message and exception details.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
From the way the docker modules currently operate, it probably makes sense to add a `AnsibleDockerSwarmClient` to `module_utils/docker_swarm.py`, which extends `AnsibleDockerClient`. Then `docker_swarm`, `docker_swarm_facts`, `docker_node` and `docker_node_facts` could use `AnsibleDockerSwarmClient` instead of using `AnsibleDockerClient` directly.
Could you please correct docstring? There is no boolean value in return value.
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
still: https://github.com/ansible/ansible/pull/44070#discussion_r212981844 https://github.com/ansible/ansible/pull/44070#discussion_r213508181
I mean: the current error isn't reported back (`e` is unused). I just pointed out that `display` is available and could be used to report the error.
Best to not link to a versioned doc but the stable/latest branch https://pika.readthedocs.io/en/stable/.
I mean: ``` try: [use connection] finally: connection.close() ```
you should note that the return changed and those fields are new in 2.4 .. also keep dest and note that it is only valid in previous versions
return docs should reflect which version a key was added in, also that the dest key existed but was removed. 'result' clashes with internal/common used return fields, I suggest changing to a different name
not a blocker, but there would be a little helper code for this in basic.py https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L2301
This is now auto-handled by AnsibleAWSModule
not a blocker, this open_url/except has been used many times and it would be probably worth to create a function in a shared code module_util under module_utils/opennebula.py. Note that any code under module_utils has to be bsd licensed.
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
It would be a nice idea to have return dict. not blocker though.
This should be: ```yaml type: bool ```
This should be: ```yaml type: bool ```
Since we have a line for `version_added`, I'd remove the "(added in Ansible 2.0)".
which was incorrect solution as the 'non templating' of pause shows
no, jimi-c has alternate solution and we'll probably go with that
Squashing is fine in this case, I think, if a list of lists is effectively just another way of writing a list e.g. sometimes you might want to do: ``` yum: name: "{{item}}" state: present with_items: - "{{list_of_default_rpms}}" - "{{list_of_custom_rpms}}" ``` You can use union to join the lists of course, but I'm not sure what other use case drives this test that isn't amenable to squashing
These 2 lines can probably just be collapsed into an `elif`
This is easier to read: ```python if self._task.notify is not None: if notify_per_loop_item: if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ``` Or using the existing string option: ```python if self._task.notify is not None: if notify_scope not in ['task', 'per_loop_item']: raise AnsibleError("Invalid option '{0}' given for notify_scope. Valid options are " "'task' or 'per_loop_item'".format(to_text(notify_scope))) elif notify_scope == 'per_loop_item': if result['changed']: result['_ansible_notify'] = self._task.notify else: result['_ansible_notify'] = self._task.notify ```
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
You don't need to state default=None as this is the default value.
You can remove `required=False` as that's the default.
You don't need to state `default=None` as this is the default value.
I think, using `pass` instead of returning `None` in AttributeError as `return None` fails to retrieve snapshots. Snapshot data works perfect with `pass`.
Something like this instead: ``` python def _get_vm_prop(vm, attributes): result = vm for attribute in attributes: try: result = getattr(result, attribute) except AttributeError: return None return result _get_vm_props(vm, ('guest', 'toolsRunningStatus')) ```
Note: this could be written as: ``` python except (AttirbuteError, IndexError): return None ```
Could try ``` python def _get_vm_prop(vm, *attributes): result = vm for attribute in attributes: < etc > ``` That version is a tiny bit magic, but it would allow: ``` python _get_vm_prop(vm, 'some_attr') # as well as _get_vm_prop(vm, 'some_attr', 'another_attr', 'etc_attr') ```
throw seems unused
I think changed needs to be set to True here.
Same here. Looks like some strange linewrapping is going on.
And then for requests-status issues, have a separate clause.
I'm not big on returning `Exception` here I'd rather be specific to JSON-ish exceptions, like: ``` try: pass # blah blah code # on Python 3+, json.decoder.JSONDecodeError is raised for bad # JSON. On 2.x it's a ValueError except getattr(json.decoder, 'JSONDecodeError', ValueError) as e: module.fail_json(...) ```
This will raise a TypeError: `exceptions must derive from BaseException`
I think this was supposed to be ```suggestion assert not (self.hostA == other) assert not (other == self.hostA) ```
This one is not legal. In python, a dictionary key must be hashable. dictionaries themselves are not hashable. Anything containing a dictionary would also not be hashable. So the key isn't valid.
(Similarly, mark any string that you are going to call decode on with as a b"string".)
Mark any string that you are going to call encode on as a ```u"string"```. Otherwise you can run into problems on Python2.
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
`default=True` (as it's a bool, not a string)
`default=True` (as it's a bool, not a string)
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
you just described check mode in general
I am pretty sure this will fail to run, since concatenating strings and arrays is not something python supports. You will need to add a loop over the `self.systems_uris` and then incorporate all of the responses into final result.
I would leave `get_storage_controller_inventory` function largely intact in this case, since it already sort-of works for single system. The only thing that I would change is to replace `self.systems_uri` with an explicit function argument to decouple it from the global state. Then I would introduce another function like `get_multi_storage_controller_inventory` that just loop over the `self.systems_uris`, calls `get_storage_controller_inventory` and merges results. How to merge results is something that maintainers should guide you through since this will also affect the final result format and maintainers are the ones who should define that.
```suggestion disk_result[property] = device[property] ```
Not catching non-200 responses.
Not catching non-200 responses.
As you already have the same 'or' clause in `_init_server_container` you can just rely on `self._info.get('uuid')` here.
I would probably make this a module level constant like `ALLOWED_STATES`. I also noticed that you don't transform the output for the diff. I don't think it matters much but for consistency this should ideally also be transformed. Maybe the best way to handle this would be to transform the values already in `def _get_server_info`. This way the module internal name would always be "state" and there would be no confusion between "state" and "status". That's also how this was handled before your change.
AFAIK this test is wrong. The previous version had `until: server.ssh_fingerprints`. The API always returns the ssh_fingerprints key, but until the fingerprints are available the value is `null`. So the new condition is always true even if the fingerprints are not yet available. If you are concerned that the key might not be available (this should never happen) you might want to write it as `until: server.ssh_fingerprints is defined and server.ssh_fingerprints`.
I don't think the `or []` is needed here. If there are no server groups defined, the API already returns an empty list.
The API currently allows multiple groups with the same name. Do we need some logic similar to the logic in `cloudscale_server` to detect this? Otherwise this could lead to surprising results... And tests for this case would be nice too.
Probably best to add an entry saying the location is derived from `C(resource_group)` if not specified
We should probably also include a sample and/or doc note that shows that the route table is associated via `azure_rm_subnet` - was definitely the simpler choice to implement that way, but we need to tell people where that happens.
name of the `route`, not virtual network
When quoting an option choice/value, enclose it with `C()` instead of a single quote, e.g. `'present'` becomes `C(present)`.
`required: false` is the default value, we can omit it here
Why change the requirement? Also, you should add an explanation in the description that this was changed for version 2.3 and that in previous versions it was not requried.
`required: false` already denotes `optional`, but I'm not against this update
The original phrasing is more complete
This would be handled by the `AnsibleAWSModule` ```python try: import botocore except ImportError: pass # handled by AnsibleAWSModule ```
we normally add more than the 'library' error as they tend not to be as helpful as giving a user context on what you were attempting to do exactly when the error occurred.
might as well get rid of any `required: false` and `default: null`s
it would require to have the content into a var e.g like with the slurp module.
Please make this oauth_token instead of api_token. This will provide some value to the end user in which type of api token and stay inline with the other modules. You will need to include the oauth_token below as an alias.
list_all is not really a state
DigitalOcean no longer has the v1 api online, actually this hasn't been online in almost a year. There is no reason to reference it in the notes.
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
`if unit in disk_units:` is case sensitive already, the `unit = unit.lower()` should be done before the if statement. ```python In [24]: unit = 'Gb' â â In [25]: disk_units = dict(tb=3, gb=2, mb=1, kb=0) â â In [26]: if unit in disk_units: â ...: print 'Found' â ...: else: â ...: print 'Not Found' â ...: â Not Found ``` (done in `ipython`)
@lpmi-13 thanks for the PR. This looks correct to me - `fail_json` will exit the code.
`check_rc` is false by default, no need to pass.
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
I'd move this block into it's own method since fetch_file will likely need it as well.
also need to return AnsibleOptionsError if the value of the config is incorrect
i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
actually, after looking at code 'currently', include_vars always ovewrites as it does not use combine_vars at any point .. this might be a 'bug' in VarsManager on `set_host_facts` and `set_nonpersistent_facts` methods .. unsure if we need to fix considering upcoming deprecation.
I would add note (this falls back to the global hash_behaviour configuration).
Do we still need kind? For service I think it should always be v1
...The remote host **MUST** support...
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
```suggestion # just get value from attribute itself as normal ```
you need to skip value from parent if include_tasks/include_role, but still inherit
You can use `module.deprecate` to throw a deprecation warning.
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
`changed=False` (this module doesn't do any change).
```suggestion When some attribute is not listed in the new list of attributes, the existing ```
```suggestion - Set syspurpose attributes in file C(/etc/rhsm/syspurpose/syspurpose.json) ```
```suggestion type: bool default: False ```
You probably want this here: ```yaml type: bool default: 'no' ```
I would separate individual examples by an empty line.
i would mention this plugin is Windows specific
```suggestion short_description: Execute tasks inside a VM via VMware Tools ```
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion - pyvmomi (python library) - requests ```
Fair enough. It is not a hard requirement.
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
`descriptions:` should end with a full stop
You can remove this line
missing full stop
Don't default state. Make it an explicit option.
You could just import `defaultdict` from collections
You don't need to import everything from ec2. Looks like you're using: ec2_argument_spec, HAS_BOTO3, get_aws_connection_info, boto3_conn
You can change this to `from botocore.exceptions import BotoCoreError, ClientError` since those are the two that need handling.
e is added to the exception in fail_json_aws so doing it again here will result in a redundant error message. Same for the other exception handling. You could use `.format(module.params['domain'])` instead to let the user know which domain failed.
This argument is marked as being removed in the same version it is introduced. This makes no sense.
Not tested, though this may lead to a similar issue as https://github.com/ansible/ansible/issues/20391 due to `timeout` having a default value
This function is not required as it is not doing extra arg validation. For other network platforms, this function is present due to legacy reason and will be removed in subsequent refactor.
From 2.5 onwards network platforms using persistent connection will be using cliconf and netconf plugins. To use cliconf plugin you need to add platform-specific plugin in `lib/ansible/plugins/cliconf/<platform-file>` You can refer `asa` modules as it is implemented using cliconf api's https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/asa.py https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/cliconf/asa.py
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
@FedericoOlivieri I just raised a PR which should mitigate this problem. This is the one https://github.com/ansible/ansible/pull/54783. Once this is merged, please fetch, rebase and try again.
This basically adds the provider dict to the module argspec, please remove this.
The default value for state should be `present`.
Please move this below the future import statement, to keep the module consistent.
asa_argument_spec import is no longer needed
Good point for handling the `_` char, but have you tested the `-` char ? I know some devs use it ð in the db name, as long as they quote the db name.
No sure there: why should databases with `_` in their names should be escaped ? I'd understand for `-` but not for `_`
You should change this one to ```suggestion return res > 0 ``` to avoid the problem. The function `db_create` is called only in two places; in one place, the return value is ignored (import), and in the other (present), you need to know whether *at least one* DB was created, and not whether *all* DBs have been created. So if you return `res > 0` here, `changed` is determined correctly for `present`.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
I'd change this to keypair if it can be a name too.
image image -> stack
stack will not be created
this doesn't jive with the impl- looks like impl will swallow "object not found" (as it should) and return no change, so this statement should probably be removed.
this should be a list of `choices`, not suboptions (which describes sub-object schema)
I blame my `black` setting.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
This does not need to be wrapped.
```suggestion - name: Change login times for user ```
```suggestion mode: '0644' ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
```suggestion result = dict( ``` More in line with a lot of modules.
I understand, we are trying to make things more concise over time. But at this time a lot of the modules are not consistent at various levels.
Some modules define this as: ```yaml choices: - 'True' - 'False' - 'yes' - 'no' ``` to indicate that you can also specify it differently. If there is no standard, that's up to you.
After every `.`, put it on a newline and start with `-`, e.g. ``` description: - If C(auto) is selected, ... - If C(delayed) ... - If C(manual)... ``` I would also put in a new entry saying `delayed` was added in 2.5.
Should be a parameter of the task itself and not the module
please quote version_added as well to not be a float.
Indentation doesn't look right here.
indentation doesn't look right here
Please use: ``` type: bool default: 'no' ```
Please use: ``` type: bool default: 'no' ```
Please use: ``` type: bool default: 'yes' ```
Here is my reproducer, consistently fails: ``` --- - hosts: localhost connection: local vars: elb_app_lb_name: "{{ elb_app_lb_name }}" tg_name: "{{ tg_name }}" tasks: - name: create an application lb elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 listeners: - Protocol: HTTP Port: 80 DefaultActions: - 'Type': 'forward' 'TargetGroupName': '{{ tg_name }}' - name: update subnets elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-cbdf56ae - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 ``` Traceback: ``` TASK [update subnets] ************************************************************************************************** task path: /Users/shertel/Workspace/ansible/my_playbooks/elb_application_lb/iterate_over_NoneType.yml:22 Using module file /Users/shertel/Workspace/ansible/lib/ansible/modules/cloud/amazon/elb_application_lb.py <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: shertel <127.0.0.1> EXEC /bin/sh -c 'echo ~ && sleep 0' <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" && echo ansible-tmp-1499709521.38-260285283136193="` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" ) && sleep 0' <127.0.0.1> PUT /var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/tmpiiu8JI TO /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/ /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py && sleep 0' <127.0.0.1> EXEC /bin/sh -c '/Users/shertel/Workspace/ansible/venv/python2.7/bin/python /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py; rm -rf "/Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/" > /dev/null 2>&1 && sleep 0' The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1005, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1000, in main create_or_update_elb(connection, connection_ec2, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 895, in create_or_update_elb listener_changed = create_or_update_elb_listeners(connection, module, elb) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 704, in create_or_update_elb_listeners listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 487, in ensure_listeners_default_action_has_arn for listener in listeners: TypeError: 'NoneType' object is not iterable fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1005, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1000, in main\n create_or_update_elb(connection, connection_ec2, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 895, in create_or_update_elb\n listener_changed = create_or_update_elb_listeners(connection, module, elb)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 704, in create_or_update_elb_listeners\n listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get(\"listeners\"))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 487, in ensure_listeners_default_action_has_arn\n for listener in listeners:\nTypeError: 'NoneType' object is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ************************************************************************************************************* localhost : ok=1 changed=1 unreachable=0 failed=1 ```
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
Sorry, was out all of last week. I'm looking for my reproducer right now.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
```suggestion - The repository name. ```
```suggestion - The public key. ```
The reason I brought it up: https://github.com/ansible/ansible/issues/51757 Though in this case it may not be a connection variable.
```suggestion - The repository owner. ```
```suggestion - The public key. ```
You can replace this line through line 363 with simply: `client = module.client('es')`
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
`'required': False` is the default so you can omit that. Same for any of the following.
^ that seems to be an expression not really a data type issue (sorting keys, this is another known json issue), in any case, there is also an existing `jsonify` in module_utils.
a simpler fix i was already working on: `+ display.display(json.dumps(text, cls=AnsibleJSONEncoder, sort_keys=True, indent=4))`
Oh, I missed that the check is slightly different. but still such function could accept key + check type class and could be reused 3 times if you want to go for it :)
Please change this to a guard expression, just like the one above: ```python if group_data is None: return for key, data in group_data.items(): # it's one tab less now ^_^ ``` It helps to keep nesting low and style would be more consistent.
If you use `to_text(xxx, errors='surrogate_or_strict')` it won't throw exceptions.
required=False, default=None is default for an argument
get rid of this if it's empty
This can also be an ARN, right? In which case the length can be up to 140 characters.
Another general exception handling that can be removed.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
This is still something we shouldn't really want to explicitly support.
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
Please add an example below that shows you how get the newer NuGet provider version.
This supports more than just URLs, I would add more points talking about what it actually supports.
This is a personal preference, but I'd rather not have a class name in all caps.
Could be shortened to `return rc == 0` if you're not doing any further processing other than returning.
Isn't this a bit too much context to report merely the MAC access is invalid? I'd include the `name`, `mac` and `etherstub` and leave out the others.
missing `if not self.module.check_mode`
from ansible.module_utils.vmware import get_parent_datacenter
doc string doesn't match actual return data
does not match actual return dict
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
not needed when `required=True` is specified
not needed when `required=True` is specified
Please include an aggregate example
Perhaps change to `ONLY` to make that statement stand out a bit more
Please add `alias: ['trunk_vlans']` Bit confusing that the primary name is `trunk_allowed_vlans` though you use the aliased `trunk_vlans` in the examples.
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
It's not dicitinonary. It's list of permit names.
You miss description parameter of the role.
An example of removing role would be nice.
please use C() around possible values of the state
I would write: C(started) is alias for C(present). C(finished) is alias for C(absent). Same in the steps.
```suggestion url = "/".join([base_url, index_set_id]) ```
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion content = to_text(response.read(), errors='surrogate_or_strict') ```
```suggestion payload = { 'username': username, 'password': password, 'host': endpoint } ```
Not catching non-200 responses.
Not catching non-200 responses.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
Not catching non-200 responses.
Useless loop, since it can be merged with the next one.
Please ignore, the param will be set to False when not specified
There are other parameter to find an existing VM using `get_vm` API such as `moid`, `uuid` and a helper parameter `use_instance_uuid`, it would be great if we can implement these parameters as well. This will make all guest module parameters equal and this module future proof.
```suggestion destination_vcenter_password=dict(type='str', required=True, no_log=True), ```
Password is sensitive information. Use `no_log=True` so that it will hide the information from logger and callback plugins.
Mark params as required=True which for the required params
You can replace this line through line 363 with simply: `client = module.client('es')`
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
`'required': False` is the default so you can omit that. Same for any of the following.
if `scope=user` or `scope=global`, and `daemon_reload=true` or `daemon_rexec=true` â ansible will try to daemon-reload or daemon-rexec the system daemon (instead of the user one).
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
When this message is printed, it will contain a newline followed by a lot of spaces. You should compose it as follows: ``` .py module.fail_json(msg=('For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. ' 'Attempting to use bit lengths under 1024 will cause the module to fail.')) ```
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
You should use `module.get_bin_path('ssh-keygen', True)`.
What kind of permissions is this file created with? I find it slightly scary that we're creating some tempfile containing the password that's not entirely guaranteed to be removed (e.g. if system goes offline before ansible can delete it).
Passwords should not be written to disk. Is there a reason you can't use `pexpect` to provide the password? I did a quick proof of concept using that method: ```python #!/usr/bin/env python import pexpect def main(): password = 'testing' child = pexpect.spawn('ssh-keygen', ['-q', '-b', '2048', '-t', 'rsa', '-C', 'demo', '-f', '/tmp/keyfile']) child.expect('Enter .*:') child.sendline(password) child.expect('Enter .*:') child.sendline(password) child.expect(pexpect.EOF) if __name__ == '__main__': main() ```
add ``` datastore = None ```
Also, if the disk already exist, 'autoselect_datastore' shouldn't modify the disk.
`if expect_disk_spec.get('autoselect_datastore', False):`
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
`if unit in disk_units:` is case sensitive already, the `unit = unit.lower()` should be done before the if statement. ```python In [24]: unit = 'Gb' â â In [25]: disk_units = dict(tb=3, gb=2, mb=1, kb=0) â â In [26]: if unit in disk_units: â ...: print 'Found' â ...: else: â ...: print 'Not Found' â ...: â Not Found ``` (done in `ipython`)
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
s/write target file {0}/fetch file to {0}/
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
Yeah, a list is fine.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
boto3_conn now handles region problems, no need to do it in the module
```suggestion - Variables which are present in the playbook, but are not present in the Gitlab project, ```
```suggestion - Variables which are untouched in the playbook, but are not untouched in the GitLab project, ``` Please do a search and replace (with 'match case' enabled) to fix this in all cases.
What is `purged_vars`, BTW? I now saw that this is not an option for this module.
indentation here seems different. I think there are extra spaces then rest indentation above
```suggestion - Create or delete project variable. ```
This results in following error: > RuntimeError: dictionary changed size during iteration I solved it by doing it in two steps: ``` params_to_delete = set() for param in params.keys(): if param not in emr_argument_spec(): params_to_delete.add(param) for param in params_to_delete: del params[param] ```
`state` shouldn't be an action. This should just have the choices `present` and `absent`.
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
This needs BotoCoreError and ClientError exception handling: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to terminate job flows for cluster {0}".format(cluster_id)) ```
Needs exception handling here too.
Please rephrase this like: ```yaml source_username: description: - Username used to authenticate against C(source). - This only affects the C(source) parameter. ```
I would add here a statement to indicate this is actually a method for using *stateless* sources (so without modifying the running configuration). I think we need to make this absolutely clear, because this is a very different use-case then what we (in configmgmt) would recommend. Personally I think this way of working is more a convenience, rather than a proper way of working. We would need a `win_chocolatey_source` module for the proper implementation.
Take the default key out as nothing is actually set, `no` means `False` which in this case is incorrect.
ditto about this not being needed.
The example also needs an update.
Method name is deceiving, since the body of the method will only set a single attribute.
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
Bad name again, since body of the method only sets one attribute.
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
Jobs seems to be Dell specific, since standard does not talk about jobs at all. What standard does talk about is that some actions may be asynchronous and that in such case `Location` header value points to the `TaskMonitor` for this action. And again, constructing OData ids using concatenation is just bad.
Shouldn't we just use a naming alias here so that one can use either role_name or local_role_name? Both of the options have the same fields. ``` aliases: local_role_name ```
I thought 0 is allowed as well? (0 is not a positive number.)
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
Should be type `int`
For public APIs we should be accepting text strings and internally convert to bytes where needed. If we really must accept bytes (which in this case I don't see a reason to) we should prefix the arg with `b_` to indicate that. The `b_` prefix may go away as we start to add type annotations but so far the behaviour is the standard we usually follow in ansible.
I'd do ```suggestion if not ignore_errors: raise ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
Should be AnsibleAWSModule now you're using fail_json_aws
Not required with AnsibleAWSModule
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
All the boto3 client methods in this module should handle BotoCoreError. There are a number of places that need this added.
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
it seems i misunderstood the feature, i thought this controlled what OS property populated the inventory_hostname
i want to standarize on 'inventory_hostname' and allow either free jinja2 form or 'choices' depending on plugin, not showstopper, but something to think about to standarize across plugins.
Please fix: '... if it doesn't exist:'
'exists' -> 'exist'
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
this is one of the pep8 rules we don't need to follow
pep8 stuff ``` if 'names' not in vmap: ```
Please don't use `\`, there are better ways Also use proper indent
I think we should just raise. setup.py is for installing the software. That comes with different assumptions about what you'd want to see than for running the software.
Yeah, I'd drop the try: except altogether.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
The method does nothing, should not this method be removed ? * [X] Done
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Use whatever fixture names make sense. Personally I'd probably name the fixture `XenAPI` since that's the import it is replacing. Then there's no need to assign `XenAPI = fake_xenapi`. Setting `autouse=True` only loads the fixture for the test automatically. If you want access to that fixture as a local, it still needs to be a function parameter. The benefit to autouse is that it guarantees the import will be mocked, even if the test doesn't require a reference to the fixture. However, there's nothing wrong with specifying an autouse fixture as a function parameter. Doing so simply makes the auto-instantiated fixture available as a local within the test function. To guarantee correct fixture order, declare that the `fake_xenapi` fixture is used by the fixture providing `ansible.module_utils.xenserver`. Modifying `sys.modules`, or making other changes to global state, outside of a test fixture or function will apply those change to all unit tests (everything under `test/units/`) when pytest collects the tests before they are executed. Since we run unit tests with the pytest `--boxed` option, each test is run in a separate Python process after the initial collection is performed. This means that any global state changes made in-process by a test function are discarded at the end of that test function, but all changes made during collection are shared. Imports handled during collection will result in changes to `sys.modules` that will be shared across all tests. This is fine for regular imports. However, the mocked import for `XenAPI` is specific to the tests in `test/units/module_utils/xenserver/`, so it should be restricted to those tests. If another test, such as one for a xenserver module were to also mock `XenAPI` they would conflict.
This needs to be in a fixture so it doesn't affect all unit tests. To avoid the need to reference the fixture on each test you may want to use `@pytest.fixture(autouse=True)` on the fixture. Perhaps something like this: ```suggestion @pytest.fixture(autouse=True) def fake_xenapi(): xen_api = importlib.import_module('units.module_utils.xenserver.FakeXenAPI') sys.modules['XenAPI'] = xen_api return xen_api ```
You shouldn't need to assign `XenAPI = fake_xenapi`. What mocker.patch calls are you trying to make that require that? To have access to `ansible.module_utils.xenserver` in tests without importing it in each test function, you could wrap it in a fixture.
You could even rename the fixture to something other than `fake_xenapi` if desired.
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
`self.module.warning` could be used
a generator should be used here.
`urljoin` is unused
`api_token` parameter is missing.
Yes because this module use this specific API
`'required': False` is the default so you can omit that. Same for any of the following.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can remove this check for region as it is now handled in boto3_conn.
You can update this to `boto3_conn(module, conn_type='client', resource='es', region=region, endpoint=ec2_url, **aws_connect_params)` so it allows for access keys as well as boto profiles.
it's probably this? ```suggestion :type mutually_exclusive: list[str] or list[list[str]] ```
Or maybe ```suggestion :type required_together: list or None ``` per https://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html#python-signatures
is this ```suggestion :type required_one_of: list[list[str]] ```
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
Well, then they will never really know and think they always have to quote. I don't think it's better to teach them to always quote, and certainly not using double quotes. Besides, you're not being consistent, you're not quoting the task name value and delegate_to.
The short_description never has a trailing dot. Help keep the index clean !
Required is default to false, so this line is not required.
This should get imported from ansible.module_utils.six
If module-level version_added is 2.5 this can be deleted
Catch botocore.exceptions.ClientError instead of Exception here too.
This should be botocore.exceptions.NoCredentialsError.
If this is set to type='int' this should avoid the later type conversion
I think it might be good to have a `purge_roles` option to be able to only enable role_to_remove if desired. I think it's a little confusing that both state: absent and state: present can be used to remove roles. I like the logic in this section (particularly if there was a purge_roles option that works like purge_tags does for other AWS Ansible modules) better than for state absent.
This line doesn't need to be in the try/except.
Just noting that this RETURN is incomplete
I've been thinking that it would be a good idea to prefix parameters with the subcomponent they belong to (with the exception of metadata fields). So anything under spec, could be spec_<field name>
required is by-default false so no need to add it for every instance.
I completely missed that, apologies
Do we still need kind? For service I think it should always be v1
Let boto3_conn handle region failures - region can be picked up in a number of ways that mean that the `region` variable doesn't get set but the connection is fine.
create_vault returns a dict with `location` and `ResponseMetadata`. You'll probably need to call describe_vault to return the expected parameters (and please use camel_dict_to_snake_dict, and don't forget to also call list_tags_for_vault, convert the tags using boto3_tag_list_to_ansible_dict and then add those to the results too) Edit: no need to call boto3_tag_list_to_ansible_dict as tags are actually in the right format for once. This service must be unique!
Sure, but I don't believe it ever happens (and if it does ever happen, use `.get` to return an empty list)
You haven't answered my question :). It just seems unlikely that you'd get a response object with a list of vault objects that don't happen to havethe `VaultName` key, without some other exception being thrown.
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
Delete this line, it's not used either
Delete this line, this import is also not used.
Delete this line, it's not used either.
This is not used and shouldn't be imported
AnsibleFailJson is not used and shouldn't be imported
I could add a commit if you like. Or I'll just make a follow up PR, doesn't matter.
Looking quickly at other modules, it looks like this is the only thing that looks at the `args` attribute. I'd do something like this instead: ```python module.fail_json(msg=to_native(e)) ``` It looks like there's a mix of stringifying `e` and returning `e.message`.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
We don't need tags in this function, I think.
For things with this many arguments, I'd really like to see keywords used to avoid any order mixups in the future.
add_group creates and returns a 'sanitized' group name, to avoid warnings you might want to use `self._sanitize_group_name(name)`
@gaudenz for those that really want it, there will be global toggle available, you CAN add toggle at plugin level to do same
+ type: int
+ type: str
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
@Qalthos exactly, it does nothing under py2, but adds explicit cause under py3. But now that I think about it, it's probably a default behavior anyway.
You might want to use `six.raise_from`
You're missing `%s` in the string. `to_text(exc)` is rendered to `/dev/null` now :)
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
This can be converted to return True. No need of new variable retry_request
Tying back in with what I wrote in the ```__init__``` about self.changed, setting self.changed = False here is dangerous. A module might have already run a different method that made a change in state and set self.changed = True. Then the code path in the main module might have accidentally run remove() twice. The second time, self.changed will be set to False, leading to a False report that nothing was changed. Setting self.changed = True on successful removal is a better way to do this. Note, however, that modules will have to be careful. For instance, they may both create and remove() a resource in one module run. In that case, the module probably does not want to return changed due to the resource being removed().
The Base64 decoding can be hoisted out of the loop
Don't use `C(...)` here, as this will be shown unformatted to the end-user.
- You are producing a hex-encoded digest, decoding it back into binary, then encoding it as hex again. - `encode('hex')` (or rather the `hex` codec) is pretty nasty to use, as codecs as supposed to work with Unicode strings. (I suspect that's why you end up doing the encode/decode/encode dance) What about this: fingerprint[algo] = ':'.join(pubkey_digest[i:i+2] for i in range(0, len(pubkey_digest), 2))
`pexpect` could be used to provide the password to the subprocess on stdin.
If one sentence is written in two lines, the quotes are required. ð
Probably don't want to add this multi-case, multi-form support for all these options... Just use the CamelCase form that's currently used through the rest of the module- if someone wants to address the camel/snake thing in a bigger way throughout the module later and deprecate the CamelCase form, that should probably be its own PR.
Use connect_to_api from vmware.py
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
I would switch the statements, test for dict, test for list, else raise error.
`if credential and ...` could be used here. With Python 3.5, the call to `endswith` raises an exception: `TypeError: endswith first arg must be bytes or a tuple of bytes, not str`.
Unnecessary blank lines here, removing these blank lines is preferable.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
we want want -> we want
use this instead ``` module.get_bin_path('yum', required=True) ```
Can we have a list of packages which can be locked/unlocked? just like yum module does.
Use `get_bin_path` instead of this function.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Add absent as well.
its service_facts, not systemd_facts, I don't really want to pollute with states that are nonsensical to other systems
```suggestion - 'This commonly includes (but is not limited to) the following: C(running), C(failed), C(dead), C(exited), C(stopped) or C(unknown).' ``` running appears twice
the state and status fields are supposed to be generic across init systems, I'm fine with adding optional fields returned when systemd is run, but we should not customize the generic values to systemd specifics.
The colon here turns it from a string to a dict, you need to quote the entire line to avoid this ```suggestion - 'This commonly includes (but is not limited to) the following: C(failed), C(running), C(stopped) or C(unknown).' ```
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
This should be removed an replaced with: ```yaml default: high performance ```
Not needed. The module is new in version 2.4.
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
I would propose to give the json paylod in the error message, as it would help for debugging
Duplicate entry in the list, I guess one need to be removed.
`str` isn't needed here.
`filter(lambda x: x, map(self.validate_query_parameters, self.query_filters))` could be used here (in order to avoid calling twice `validate_query_parameters`).
Indeed, `extract_name` needs to be called only once per host. In order to do that add a parameter to `add_host_to_groups` method: ``` self.add_host_to_groups(host, name) ``` ``` def add_host_to_groups(self, host, name): ... ```
Please ensure all `descriptions` are full sentences. Capital letters & full stops.
No need to repeat the choices.
`If set, I(grafana_user) and I(grafana_password) will be ignored.`
typo of dashboard
Please remove this and replace with `choices: [present, absent, export]`
"Only updates an existing macro if set to C(yes)." would be good. Less negation is better :-)
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
this docstring now wrong
It would be helpful to display valid values here.
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Change `should` to `would`.
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
Suggest rewording this sentence as "If setting a dict, the keys should be the protocol and the values should be the hostname and/or port for the protocol given in the key."
Again, suggest rewording this as suggested for win_http_proxy.
s/run the/run in the/
Suggest adding a combined example that also uses win_credential.
For integers please: use `type='int` remove the `isdigit` check from `check_params`
For integers please: use `type='int` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
Format replacement strings with nothing inside of them, {}, are only available in python-2.7 or better. So you'll need to make sure that all your formats have numbers inside of them. For example, this line would then be: `record_ids = client.get('/domain/zone/{0}/record'.format(domain))`
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
The module is misspelled. It should be online_domain_record
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Remove this as it is already declared above.
```suggestion module.fail_json(msg=to_native(e), errno=e[0], reason=to_native(e), **result) ```
It would be a nice idea to have return dict. not blocker though.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
This assumes that we always make changes, even if the directory already exists (or is already missing), or if the file already exists and is not overwritten.
I don't see the point ;-)
No problem. It was pure chance I was here at this time in any case. Have a good evening!
if you put a "is" between force and set it would be better.
This should be `else`, looks like the logic got inverted accidentally.
I would remove this blank line.
You have to remove the None values from the list somehow: ```python3 if tags: # remove None values for api for tag in tags: if 'value' in tag and tag['value'] == None: tag.pop('value', True) ```
(In order to optionally not make frequent, redundant, probably unnecessary requests to the COPR API)
```suggestion # the variable if it hasn't been set by the user already. ```
Just for sanity sake maybe pull out ```python "copr:{0}:{1}:{2}".format(copr_server, copr_user, copr_project) ``` into its own var, since it's duplicated 5 times.
> Would this be better as `if key not in module.params` so we don't capture the case where the user explicitly sets things to `null`? The ansible way for the user to skip an upon is `{{ omit }}`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
required=False is the default
I'd like to remove `lambda_function_arn` in case anyone ever wants to implement other notification types
Can we just call this argument `lambda_alias` without the alias (just thinking about future proofing for other notification targets)
Yes. Either to_native or to_text would be fine in this case.
You can remove this. If there isn't a specified return, None is returned.
```python makedirs_called = 0 def mock_makedirs(path, mode): makedirs_called += 1 expected = os.path.expanduser(os.path.expandvars(am._remote_tmp)) assert path == expected assert mode = 0o700 return ```
this is basically noop, unless you are under pipelining, in which you get None, tmpdir will still be populated though
I know, was just wondering if it's intended that it works that way.
For the cases where I've wanted to use a nose test generator, I've ended up just making the test class inherit from object. You lose the TestCase methods (various self.assert*) but usually test generators methods have pretty simple assertions so not too much of a issue. To me it is simpler than injecting the support into a TestCase subclass. (an example is https://github.com/alikins/ansible/blob/6e8a3d0c25fdeaa349351c6636b062376c30b0a6/test/units/plugins/lookup/test_ini.py)
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
brackets in the URL
This isn't needed if you have set a default.
This isn't needed if you have set a default
the brackets in the URL itself cause issues when rendering this, just remove the `(v=vs.110)` and it will still work
No needed if you have a default.
```suggestion host = find_obj(self.content, [vim.HostSystem], name=esxi_host_name) if host is None: self.module.fail_json(msg="Unable to find host system %s in the given configuration." % esxi_host_name) ```
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
It is not mandatory to have return but I would recommend to add one, from UI/UX point. :)
Add a blank after this to notify that these are two separate tasks.
``` def __init__(self, module): super(VmwareConfigFactsManager, self).__init__(module) cluster_name = self.params.get('cluster_name', None) esxi_hostname = self.params.get('esxi_hostname', None) if cluster_name: cluster_obj = self.find_cluster_by_name(cluster_name=cluster_name) if cluster_obj: self.hosts = [host for host in cluster_obj.host] else: module.fail_json(changed=False, msg="Cluster '%s' not found"%cluster_name) elif esxi_hostname: esxi_host_obj = self.find_hostsystem_by_name(host_name=esxi_hostname) if esxi_host_obj: self.hosts = [ esxi_host_obj ] else: module.fail_json(changed=False, msg="ESXi '%s' not found"%esxi_hostname) ``` @Akasurde What do you think ? No variable except `hosts` has to be attributes. The module should fail if the cluster or ESXi isn't found.
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
Don't assign a lambda function, use def
Don't assign a lambda function, use def
Do not assign lambda, use def instead
this line isn't needed
avoid putting quotes around values unless they are really needed
Unless it is an actual value omit the `default`, I see the description already contains what it defaults to in this case.
We are trying to move away from having the `state` key containing the raw Python SDK return values to just what is not known by the client. In this case I would just return the `id` of the object under the root level, e.g. ``` RETURN = ''' id: description: returned: success and keyvault exists type: str example: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX/resourceGroups/presentation_rg/providers/Microsoft.KeyVault/vaults/ozidatamanagement ''' ``` If the user wants to get more information about a resource that is what the facts module is for.
This shouldn't be set.
this part feels to me like this should have been a separate PR with separate ISSUE. not a blocker just feels it would be more sterile.
This should have the two arguments in separate strings in case the implementation that invokes the commands changes to exec commands in the future.
I don't think it's safe to change when we use the yum api, however I don't remember the specifics. I would not change this behaviour just to change this as I think it exists for some cornercases.
Is skip-broken allowed for all of the commands that we run? (I've used it with yum update but never with yum remove or yum install).
Ha, there seemed to be a bug in the previous code, we might want to do ``` for spec in items if spec.startswith('@'): ... ```
As this is a new module, we only need the top level `version_added`, no need for it per option. ```suggestion ```
You can safely remove this line.
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
You can delete this line.
`type='str'` and `required=False` are both defaults, and neither is required in the argument spec (this applies anywhere either might occur)
Also describe if it deletes the files or not
`Care should be taken ...`
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
ansiblemodule already has a .log method, this is redundant.
I would remove the debugging from the module as user cannot enable it anyway.
AnsibleModule already has a `.debug ` property which can be enabled via configuration on the controller
Please change the indentation to 2 characters to have the same formatting like above.
Should the `continue` be here? The following 3 lines will never get evaluated.
This change will mean that new targets will not get registered if `purge_targets` is False, which is not what would be expected. We could really use a test suite to catch this kind of thing.
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
yeah, there's a missing chunk of code.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
does this make sense with a stop? in most cases 'reload' is just sending a signal to the daemon ... not sure it applies to that action either.
I would imagine the same issue is possible for other states also, i would solve this in a generic way instead of only for one of them.
because the version i tested with initially had the message in stdout
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
Module are not permitted to uses the requests module, due to unnecessarily adding dependencies to modules. You should utilize the functionality in `ansible.module_utils.urls` instead of requests.
Is the dependency on a socks proxy part of your specific environment, or something that every person using this module will need? I have more reviewing to do, but I would be fundamentally against the module having specific settings for socks if it isnât a requirement of fortios. Just as with using other proxies it should be a fundamental part of how Ansible can be used and should not be a determining factor of how a module is implemented due to one persons environmental restrictions.
That should also be a docstring IMO.
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
Use `self.get_option` instead of `os.getenv` directly.
Tripple double quotes (`"""`). No spaces around the sentence. Period in the end of the sentense.
Find better var name
please follow PEP257
To not mutate original dict by reference
That's true... although in this case we're just throwing away the original so it's kinda wasteful.... it feels like we're trying to follow the wrong pattern here.....
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
```suggestion - Whether gateway links can be used in remote Virtual Networking to link to this Virtual Network. ```
```suggestion - Whether the VMs in the linked Virtual Network space can access all the VMs in local Virtual Network space. ```
Here too, should either be "Success" or "Succeeded".
```suggestion - Provisioning state of the subnet. ```
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
For the author information we normally only keep name and GitHub handle.
I'd use the minimum indentation here, like you do elsewhere. So it is consistently indented.
Here add: ```yaml type: list ```
This parameter is required if C(cluster_name) is not specified.
Ah, I see it now. yeah, so just change self to be cls to match convention when using `@classmethod` and it should be fine.
Missing `raise`. I would probably change to `AnsibleAssertionError`.
I think this should be 'exit' instead of 'abort'
```suggestion b_password_string = b"|".join((br'(\w+\'s )?' + to_bytes(p.format(**self._fields))) for p in prompts) ``` `.format` requires splatting the dict, instead of just the dict itself
print statement can be removed
Parameters that are not required don't need `required: false`.
If there's no default, `None' is implicit. (It means parameter undefined) So this is not needed.
No need to have the `required: false` lines, it's implicit.
Make this a separate item in the list.
Make this a separate item in the list.
Would it be possible to go into some detail, rather than just repeating the configuration options
Indentation here doesn't look right
We have `mode: trunk` here, so this appears to be the same as the above, and actually an ONLY example
Shorten to `mac` or use hyphens consistently (`mac-address`).
The name of that parameter is bad, it's simply âDNS search domainsâ. Perhaps `search-domains`, or `resolvconf-domains` (but then rename `nameserver-addresses` to `resolvconf-addresses`)
s/write target file {0}/fetch file to {0}/
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
Yeah, a list is fine.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
lacking parameter validation, user should be notified if the minimal requirements for lookup to work are not met
Adding the exception string to the error would help the user narrow down what the issue is.
It likely makes sense to add the remaining psycopg2 parameters including host and port.
I think `if props is not None` is more conventional :smile:
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
Also, it seems that you don't strip spaces, so if there will be leading spaces it would not match, for example.
use list literal
This is tricky. It should probably return false because there's no way of knowing whether it's the same version, so we'll need to invoke pip to reinstall it as it does when you run it manually
Why don't you do this right in the `return` line? If you think it's going to be too long, be aware that you can break the line by wrapping it with braces: ```python def _is_valid_distribution_name(name): return ( not name. lstrip(). startswith(('>=', '<=', '!=', '==', '>', '<')) ) ``` (you can put `not` outside of brackets if you like it more this way)
I'd probably add `distribution_parts = []` after yield inside of `if` block and then you'd only need `distribution_parts.append(name)` outside of if-block without a need to have diverse code or `else`-block.
This should have exception handling around it. Once you update to AnsibleAWSModule you can do: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to list clusters") ``` and it will use e.response and add the traceback for you.
required=False is the default, so you can omit that, same for any of the following. `name_regex=dict()`.
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
State should have the choices 'present' or 'absent' to be like other Ansible modules.
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
```suggestion if type is not None: ```
`type` is a reserved identifier in Python. You can use it, but it is not good style. Better use `luks_type` or something for the variable name. (Using `type` for the option name is totally fine.)
Anyway, it's probably best to wait until #61603 is merged and then change this.
This will collide with #61522. Also, you should use a similar approach as in there, i.e. don't do an `if` with two copies of `self._run_command()`, but collect the options in a list and then finally call `self._run_command()`.
There's another `try/except` missing here.
This can be removed
There's no need to wrap this in a `try`/`except`.
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
Funny thing, the only module which was there already in Ansible 2.7 is `docker_image_facts`, and its return value is called `images` :-) Let's change it in all `_facts` modules, then. I'll create a PR for that.
Also, let's continue the discussion in #51939.
Isn't it missing a whitespace ? Are you sure environ is defined here ? I don't see it. Perhaps this would work too, if you do want OVIRT_URL= to override kwargs['url']: kwargs['url'] = environ.get('OVIRT_URL', kwargs['url']) Example: $ A= python -c 'import os; print os.environ.get("A", "X")' (we get an empty string) If you do not want OVIRT_URL= to override kwargs['url'], then you can use or: kwargs['url'] = os.environ.get('OVIRT_URL') or kwargs['url'] Example: $ A= python -c 'import os; print os.environ.get("A") or "X"' X (we get the value that's at the right of or) Hope this helps
Why not leverage .setdefault here ? ``` kwargs.setdefault('url', os.environ.get('OVIRT_URL')) kwargs.setdefault('username', os.environ.get('OVIRT_USERNAME')) kwargs.setdefault('password', os.environ.get('OVIRT_PASSWORD')) ``` ï¿¼
Since this might be nested-vars, or the user may supply a relative path. To make sure you handle this var well, also use `expanduser` and `expandvars`.
instead of manually assembling all the options, use set_options/get_option and all this will be resolved 'per option' in normal precedence order
Please fix: '... if it doesn't exist:'
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
This should also check for `provider['timeout']` value. Something like `persistent_command_timeout = C.PERSISTENT_COMMAND_TIMEOUT or self._module.get(âproviderâ, {}).get(âtimeoutâ)`.
Why is this additional check required here? Since error response from remote host is added as part of data this change is not required imo
There's no need to wrap the strings like this. Our project lint settings accept up to 160 characters wide. ```suggestion result['warnings'].append('Some configuration commands were unmanaged, review unmanaged list') if result.get('invalid'): result['warnings'].append('Some configuration commands were invalid, review invalid list') ```
Only import what you need, rather than `*`
double space between `and` and `self.options.subset`
```suggestion raise AnsibleError("The password script %s returned an error (rc=%s): %s" % (pwd_file, p.returncode, stderr)) ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
This limits you to 1000 hosts where previously it iterated all the pages.
I can get this to work with 2.3 if I do `if getattr(self, '_play_prereqs', None):` instead.
You can just `return` without `else`.
you shouldn't need to create an intermediate in-memory list here. Also, `str.startswith()` supports checking multiple values: ```suggestion out = "\n".join( line for line in out.split('\n') if not line.startswith(('You are using', 'You should consider')) ) ```
In Python, we avoid adding unnecessary brackets.
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
```suggestion - Use with I(state) C(present) and I(purge) C(true) to specify content paths to be purged. ```
```suggestion - Use with I(state) C(present) to start the endpoint. Set to C(false) to stop the endpoint. Set to C(true) to start the endpoint. ```
No need to explain the true or false
```suggestion - Controls if the machine is allocated/deallocated, only useful with I(state=present). ```
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
Understood. (I was only looking at the patch, so...)
Can you add: ``` type: path ```
missing default value
you don't need to use 'original_safe' as that was an import in the base class to maintain backwards compatibility, also you should get this from the base class: `self._sanitize_group_name()`
Can you add: ``` type: str ```
This is a private function (starts with an underscore) so I'd hope we could move this without having to leave a stub for backwards compatibility. If you want to remove the stub in a separate commit/PR just in case, though, I can live with that.
It seems like no_log and deprecation are separate things and should be handled in separate functions.
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
i would consider moving this to a module_utils/tower as I expect other modules will need to use the same auth
> set the default to be True (that way user have to force into an insecure setup, that's how other modules work) By default tower-cli will assume True by the same reasoning. The net effect after making that change should be the same.
you just described check mode in general
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
I considered that, but I don't think pytz is a dependency you can count on and in Python 2 you don't have `datetime.timezone.utc`. The following could work, but is rather verbose: ```python try: from datetime import timezone except ImportError: # Python 2 return datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ') else: return datetime.utcnow().replace(tzinfo=timezone.utc).isoformat() ```
smth like `datetime.utcnow().replace(tzinfo=tz).isoformat()` maybe
Same here: move url outside of the loop: ```suggestion ```
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
Well this would be for 2.4 so maybe that is the better path
it absolutely is but "New in version 2.3." so I didn't make use of it yet.
local_action has same issue as it is an alias to `delegate_to: localhost`
this is actually incorrect, ansibile_ssh_host will reflect 'localhost' not the var associated with 'inventory_hostname' .. which is why this should use `connection: local`
You could fix #19781 real quick right here :D
It's probably better to loop over the items and check the value before changing, so you can report back if there was a change or not.
Unless I am mistaken, this doesnt actually do anything. I do not believe it's possible to have an 'absent' flag to remove an entire stanza. `chsec` can only remove given attrs/options from a given stanza, it cannot remove the entire stanza. This code block is just 'unsetting' all of the given attrs/options and ignoring the value assigned to them. These two YAML examples behave exactly the same way even though one has state=present and the other state=absent: ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=LDAP,registry=LDAP state: absent ``` ```yaml - name: Remove LDAP user stanzas aix_chsec: path: /etc/security/user stanza: ldapuser options: SYSTEM=,registry= state: present ``` HOWEVER, if there are other attrs set on that user stanza, the *stanza will still exist*. You need to specify every single user attr/option on that stanza to remove the stanza. Adding a 'true' state=absent will mean going through the given `file`, finding the stanza, getting all of the key:value pairs in that stanza, and then running chsec key=null to every one of those. That's a loooot more work.
To me it seems more logical if the format is not a list, but a dictionary. ```yaml options: SYSTEM: LDAP registry: LDAP logintimes: :0800-1700 ``` The only reasons for using a list here, would be to ensure a specific order for processing, or to ensure that a specific key can be duplicate (so provided keys are not unique). But I don't think these are no applicable here.
```suggestion mode: '0644' ```
```suggestion result = dict( ``` More in line with a lot of modules.
(and there's no need to have this var outside or this loop or increment it manually, then)
```python for line_number, line in enumerate(lines, 1): ```
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
`fd` in name implies "file descriptor", but file-object is more than that. I'd do `module` or `module_file`
`import ansible.module_utils.parsing.convert_bool import BOOLEANS` and use that constant
this should probably use the BOOLEAN tests from module_utils
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
`self._options_context` stores the context of parent options in case of nested suboptions. As the `elif` block does not have a recursive call to `_handle_options` context handling is not required here. However, context information can be added as part of error message in case this argument is part of nested sub-options (similar to other error messages in sub-option handling).
we want want -> we want
Needs to be unindented so these are always returned
Not excited by all the nested for loops but working as expected.
should be `current_option =`
Sometimes response is None so this doesn't work
You inadvertently added a third blank line. Probably worth running flake8 and removing what issues you can
exception classes should be defined after impotrs and constants and before helper functions.
The Base64 decoding can be hoisted out of the loop
I'm not certain that we want to name this *Module. Just from reading this PR it appears that it will be used more for managing keys and certs rather than managing a program (the ansible module).
Are check, dump, and generate always needed? If so, consider making this an abstractbaseclass: https://docs.python.org/2/library/abc.html
The usual idiom I see with these *Module type of classes is that they hold onto module in an attribute. I happen to think that's the wrong thing to do (as it leads to calling self.module.fail_json() instead of raising exceptions that are then handled at a higher level). But if you aren't going to hold onto module, you shouldn't pass it into the constructor. Instead pass in the specific parameters that you care about: ``` python def __init__(self, path, state, force, check_mode): ```
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
Does the result provide any insight into if anything's changed? Looks like put and delete are currently both hard coded to return ``changed=True``
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
Capital letters & full stops please
`required: false` lines can be removed
return value does not match RETURN doc string
This can be removed. If a parameter is required, there is no default.
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
Again, the name for that task was a copy-and-paste from the integration tests. It would probably better to use, eg. ```yaml - name: Enable 'telnet-client' windows feature ```
Ah, I think it's a copy-and-paste error from the integration tests. Good catch :-)
If a parameter is not required, we don't have to state that explicitly. It is implicit. Only when parameters are required, you need to add `required: yes`.
This should fix the last error that you are getting: ```suggestion type: list elements: str ```
You need `choices` here, too.
Can be covered in the `AnsibleModule` instantiation by using `required_if`
Can be covered in the `AnsibleModule` instantiation by using `required_if`
`Host group` (copy/paste, i guess)
`self.module.warning` could be used
a generator should be used here.
`urljoin` is unused
`api_token` parameter is missing.
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
All `descriptions:` should be full sentences, e.g. start with a capital letter, and end with a full stop.
`, no_log=True` to hide secret things.
Please remove the "required: false", you only have to add `required: true` if it is required.
Ansible already states that it does not support 3.4, python 3 support targets >=3.5
Might want to do a Python version detection here as Python 3.4 does not implement PEP 475, should use selectors2 for 3.4. PEP 475 is only implemented by Python 3.5+
`kubectl` is a valid connection plugin, without looking into the code further I assume that's being used as the transport backend in that inventory plugin. https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/kubectl.py
Nope, I'm just wrong, my bad
`service.metadata.labels` and `service.metadata.annotations` should have a `.to_dict()` method defined, I think that will have a better guarantee of correct behavior
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
```suggestion - A list of tags to be remove from the resources. ```
I(....) adds the highlighting that this is an argument name.
```suggestion - Either I(tag_keys) or I(tags) is required when the state is absent. ```
```suggestion type: list elements: str ``` It's helpful to define that the list is a list of strings (or what ever).
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
Could be more compactly written as: ``` python try: r = call(['shred', tmp_path]) except OSError as e: r = 1 if r ! = 0: # We could not successfully execute unix shred; therefore, do custom shred. self._shred_file_custom(tmp_path) ```
This introduces a different race condition, file can now be looked at in 'intermediate' state.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
su requires a tty, that is why most 'subprocess' plugins don't support it.
Okay, so @cyberark-bizdev take out my first example. The last two are what we're shooting for. (The middle one is the same as bcoca's example, just in compact yaml instead of "readable" yaml ;-)
@pilou-, cyberark-bizdev I had a chance to talk to bcoca today and he said the best way to do this is to pass a list of dicts to the lookup. Then either of these playbook constructs can be valid: ``` with_cyberaskpassword: - {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'} - {'appid': 'Application2', 'query': 'safe=Safe2;Folder=root;Object=User2', 'output': 'password,passprops.username,passprops.address'} with_cyberarkpassword: {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'} - debug: msg='{{ lookup('cyberark_password', {'appid': 'Application1', 'query': 'safe=Safe1;Folder=root;Object=User1', 'output': 'password,passprops.username,passprops.address'}) }}' ``` Implementing that will take a little restructuring. I'll go into that in the run method below.
check_output is not python2.6 compatible
Okay, so to implement the examples like this: ``` with_cyberark_password: appid: 'Application1' query: 'safe=...;' output: 'password ....' ``` We'll want to take the dict from terms instead of from kwargs. terms will hold the dict that the user passed in so you should be able to drop in replace it in your constructor like so: ```CyberarkPassword(**terms)```
Unnecessary blank lines here, removing these blank lines is preferable.
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
I would probably go for "Exit" here, but that's more cosmetic than functional.
su requires a tty, that is why most 'subprocess' plugins don't support it.
if not handling become methods update the class variable to indicate this
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
e.message doesn't exist on Python 3 so this may raise an AttributeError
You don't need to hardcode the port.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Add `exception=traceback.format_exc()` here as well please.
Add traceback here as well (for line numbers).
The `bool` is redundant, is it not? IIRC `any` always returns a `bool`
Note, this will work as well: ``` python if not any(ex in module.params['virtualenv_command'] for ex in ('pyvenv', '-m venv')): ``` The difference is really minor (no need for the second parens for the generator expression and use a tuple instead of a list) but might as well since you have to make other changes.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Are you still working on this? I can't find anything like that in the current version.
Ok, but that's only the message, which shouldn't be parsed / understood by the calling code. Something useable would be a boolean variable `docker_in_swarm_mode` or `swarm_node_is_manager` which is returned in any case (except maybe when the docker daemon doesn't seem to be there in the first place). It might be a good idea to introduce a general `fail_results` variable in `AnsibleDockerClient`, which is empty by default and passed on to `module.fail_json` in `fail()`. If everyone (i.e. also the code in module_utils/docker/swarm.py) calls `client.fail()` instead of `module.fail_json()`, it will always be returned. Then the facts module can put the booleans into `client.fail_results` with value `False`, and update them to `True` once the corresponding calls succeed. If you want I can prepare such a system in another PR.
The main reason is that usually, `xxx_facts` modules also return information on whether `xxx` is available at all. It would be fine for me to simply return more detailed error messages on failure, after all we can pass arbitrary information along when calling `module.fail_json()`. If we return this information (docker in swarm mode / node is manager) also on failure situations, users can add `ignore_errors: yes` and use that information if they like.
Fine for me. 2.8 is still some some time out, fortunately :)
I'm a fan of this approach @WojciechowskiPiotr for this situation.
Add a few more examples of just listing the ports: ```suggestion when: tcp_listen_violations - name: List TCP ports debug: var: ansible_facts.tcp_listen | map(attribute='port') | sort | list - name: List UDP ports debug: var: ansible_facts.udp_listen | map(attribute='port') | sort | list - name: List all ports debug: var: (ansible_facts.tcp_listen + ansible_facts.udp_listen) | map(attribute='port') | unique | sort | list ```
Don't quote strings when that's not necessary, and add spaces in Jinja variables for readability. ```suggestion msg: TCP port {{ item.port }} by pid {{ item.pid }} violates the whitelist ```
```suggestion RETURN = r''' ```
Please remove the "required: false", you only have to add `required: true` if it is required.
If it is not requires, don't add it. ```suggestion whitelist_tcp=dict(type='list', default=list()), ```
not sure if this is useful
throw seems unused
So, is there a plan later to use include_private ? (as the current patch don't use it)
Great, thanks for putting this check in here.
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
```suggestion - The administrator password for the BIG-IP device. ```
FYI you can replace this with `type: bool`
It's a minor issue. Wonder if it can go in the docs fragment
```suggestion description: Sets the conflict resolution policy for objects that are specific to a particular to a BIG-IP device. ```
remove `default: None` as default is set to None by-default.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#indentation): Indentation should be 4 spaces instead of 8.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a class.
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
```suggestion - Can be the resource ID of the security group. ```
```suggestion - Can be a dict containing the I(name) and I(resource_group) of the security group. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
```suggestion - To remove all resources related to the VM being removed, including auto-created resources, set to C(all). ```
```suggestion - To remove only resources that were automatically created while provisioning the VM being removed, set to C(all_autocreated). ```
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
`load_fixture()` takes the module name as the first parameter now, so you can lose the `os.path.join()` above and just have `load_fixture('nxos_switchport', filename)`
Right, but `'show_vlan'.replace('2/1', '')` is still `'show_vlan'`. Unless I am missing something painfully obvious, the condition is not needed. (I will admit that I am picking nigh infinitesimal nits here... the rest of this is just fine and you could just merge it if you want)
no, if the variable is set but empty, you should empty out the options
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
instead of forcing templating here, when you don't have task_vars yet, just set run_once based on 'bypass' and then template below in 890 with full task_vars. That way you avoid a 2nd very expensive call for vars and actually get the complete ones (with host).
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
there is no need to set a temp variable for `images`
just don't know exactly what's in the properties :-)
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
Maybe should be AzureRMCdnEndpointFacts, but that's minor
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
there is a helper in `AnsibleModule` for mutually exclusive params: ~~~diff module = AnsibleModule( argument_spec=argument_spec, + mutually_exclusive=(('positional_args', 'named_args'),), supports_check_mode=True, ) ~~~
Would it maybe be better to only check the beginning of the query? Assume that the query is `SELECT * FROM USER_UPDATES`; in that case, because `INSERT` appears in `q.upper()` and `cursor.rowcount > 0` (assuming the table isn't empty), the module will say something was changed.
How about ```suggestion q = q.lstrip()[0:max_keyword_len].upper() ``` and removing the `.upper()` calls below? Will be more efficient :)
`current_version` could be mentioned in the error message.
SHould have `type: bool` and the default option
Change to type bool instead of enabled and disabled
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
No need for the try/except, `get_resource_group` already handles this.
This isn't really how we usually go update operations in Ansible. Is there way of checking if a change needs to occur and then making or rather than making a request and seeing if it was changed. The benefit of the former approach is that when running in check mode you can see if a change needs to happen while in this scenario you wouldn't know.
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
probably want a to_text and u prefix.
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
`Could not recursively set attri...`
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
This check is OK.
I see. However, if I don't specify `resource_pool` in my playbook I end up with a `null` value for `resource_pool` and the message: ` "msg": "A specified parameter was not correct: spec.location.pool"`.
you can remove this condition as the previous condition already handle other cases
`Host group` (copy/paste, i guess)
Hmm, nevermind. It seems that if I remove the `resource_pool` argument altogether then everything works fine. Previously this value was set to `Resources` even though we don't have any explicit resource pools, but without the value an error was thrown previous to this commit.
`You must set C(PUREFA_URL) and C(PUREFA_API) environment variables`
`If an empty list C([]) is specified`
`If an empty list C([]) is specified`
To make this a clickable link please do `'manageiq-client U(https://github.com/ManageIQ/manageiq-api-client-python/)'`
As per other PRs, you don't need to repeat the option name.
Double quote around Author name.
We get good messages for free if we use unittest.assertIsinstance(), assertEq(), etc. Need to inherit from unittest.TestCase to have access to those.
Need to import reduce from ansible.module_utils.six.moves.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
please fill this in
Absolute paths still can contain `..` in the middle of the path and that would be processed when accessing paths.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
If we ever start generating the docs from docstrings, this will be problematic â RST uses double backticks for inline code, unlike Markdown.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Yeah, a list is fine.
No longer using a temporary file. This issue is resolved
kushal found that check_call is 2.5 ; check_output is what is 2.7.
s/write target file {0}/fetch file to {0}/
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Using type `path` is causing the `~/` to be evaluated too early. It ends up resolving to `/root/.ansible/tmp` (the user running ansible-playbook) instead of `/home/ansibletest1/.ansible/tmp` (the become user for the task).
This line is responsible for the test failure.
There is no need to add quotes here. Please remove them from all modules.
Please remove the `r` here as there is no reason to use byte string for any of the string blocks. The same in all other files.
correction: It's not a byte string, it's a raw-string literal
This should probably check if tags is not None first. If the user doesn't specify tags in their play: ``` The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py", line 699, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py", line 692, in main update_image(module, connection, module.params.get('image_id')) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py", line 578, in update_image tags_to_add, tags_to_remove = compare_aws_tags(current_tags, desired_tags, purge_tags=module.params.get('purge_tags')) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_modlib.zip/ansible/module_utils/ec2.py", line 757, in compare_aws_tags TypeError: argument of type 'NoneType' is not iterable fatal: [localhost]: FAILED! => { "changed": false, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py\", line 699, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py\", line 692, in main\n update_image(module, connection, module.params.get('image_id'))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_module_ec2_ami.py\", line 578, in update_image\n tags_to_add, tags_to_remove = compare_aws_tags(current_tags, desired_tags, purge_tags=module.params.get('purge_tags'))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_1M9gC7/ansible_modlib.zip/ansible/module_utils/ec2.py\", line 757, in compare_aws_tags\nTypeError: argument of type 'NoneType' is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } ```
Not really sure what the desired behavior for this bit is. If I run a task with ``` launch_permissions: group_names: ['all'] user_ids: ['123456789012'] ``` and a subsequent task removes the group_name 'all': ``` launch_permissions: group_names: [] ``` should that also remove the user_ids? That is what happens now.
These comprehensions don't need `[]` around them - `set(str(user_id) for user_id in launch_permissions.get('user_ids', []))` because 2.6+ handles comprehensions in function calls without them.
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
before continuing here, check that fields is actually populated as a list, or try/except the following code
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
make this a set to be a bit more efficient. (We're only using it for containment checks.)
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
This line is responsible for the python 3.5 syntax error. Change it to the following to fix: ```python print(json.dumps(data)) ```
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
Since this might be nested-vars, or the user may supply a relative path. To make sure you handle this var well, also use `expanduser` and `expandvars`.
Isn't it missing a whitespace ? Are you sure environ is defined here ? I don't see it. Perhaps this would work too, if you do want OVIRT_URL= to override kwargs['url']: kwargs['url'] = environ.get('OVIRT_URL', kwargs['url']) Example: $ A= python -c 'import os; print os.environ.get("A", "X")' (we get an empty string) If you do not want OVIRT_URL= to override kwargs['url'], then you can use or: kwargs['url'] = os.environ.get('OVIRT_URL') or kwargs['url'] Example: $ A= python -c 'import os; print os.environ.get("A") or "X"' X (we get the value that's at the right of or) Hope this helps
Why not leverage .setdefault here ? ``` kwargs.setdefault('url', os.environ.get('OVIRT_URL')) kwargs.setdefault('username', os.environ.get('OVIRT_USERNAME')) kwargs.setdefault('password', os.environ.get('OVIRT_PASSWORD')) ``` ï¿¼
note, this is not a blocker but you can use a generator expression here instead of a list comprehension. it could save on some system calls (calling os.path.exists) but I doubt that will be a noticable optimization so it's really just style.
We generally don't mask the usernames, just passwords.
> For example, user_folder is '/DC0/vm' and actual_vm_folder_path for two VMs with same name is '/DC0/vm/finance' and '/DC0/vm/marketing' and user wants VM with '/DC0/vm/finance' path. So there are chances that user might end up in getting wrong VM if we just use user_folder. I think computation of user_desired_path might decrease this chance. How can you only get the VM in '/DC0/vm/finance' if `user_folder` is '/DC0/vm' ? If `user_folder` is `/DC0/vm` we fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So you get both VM from '/DC0/vm/finance' and '/DC0/vm/marketing'. ################ If you mean to write `/DC0/vm/finance`: If `user_folder` is `/DC0/vm/finance`, we still fall into the `user_folder.startswith("%s%s/vm" % (dcpath, user_defined_dc))` condition and [user_desired_path = user_folder](https://github.com/ansible/ansible/pull/33525/files#diff-d5ca044435f1fc628995b038d2e238f7R949). So using `user_desired_path` or `user_folder` is exactly the sameâ¦ I don't get your example.
Then: ``` user_folder = self.params['folder'] slashed_user_folder = user_folder if not slashed_user_folder.startswith('/'): slashed_user_folder = '/' + slashed_user_folder if not slashed_user_folder.endswith('/'): slashed_user_folder += '/' â¦ for vm in vms: â¦ if slashed_user_folder in actual_vm_folder_path: vm_obj = vm break ``` My point/remark/question wasn't about altering `user_folder` but about the `user_desired_path` computation and usage. The important part is that I suggest to replace: ``` if user_desired_path in actual_vm_folder_path: ``` by: ``` if slashed_user_folder in actual_vm_folder_path: ``` Again if you are sure about the user_desired_path computation, that's OK for me.
`continue` not `break` (with `break` we can miss some VM). Or `fail_json(â¦`, because a VM object without name shouldn't exist.
@Akasurde Is it possible to have `len(temp_vm_object.propSet) != 1` ? Has I understand it temp_vm_object.propSet will only contain the name of the temp_vm_object.
Everything from `for vm in vms:` to line 957 can be moved outside of the loop. Also, instead of computing user_desired_path (which is a bit complex and error-prone IMHO) what do you think of: ``` if not actual_vm_folder_path.startswith("%s%s" % (dcpath, user_defined_dc): continue if user_folder in actual_vm_folder_path: vm_obj = vm break ```
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
This needs BotoCoreError and ClientError exception handling: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to terminate job flows for cluster {0}".format(cluster_id)) ```
Needs exception handling here too.
This needs exception handling.
This should be called tags for consistency with the other AWS modules. It also appears tags are only changed/added by this module when first creating the job flow but it should be modifiable since the API supports this with add_tags() and remove_tags(). Here are some general guidelines for dealing with tags. https://github.com/ansible/ansible/blob/bf304832ffb8fc723c4d2f755e2e45ba17809f73/lib/ansible/modules/cloud/amazon/GUIDELINES.md#dealing-with-tags Here are a couple module examples, though there are many: https://github.com/ansible/ansible/blob/ab96a841542478189a6195a05ff748565613056f/lib/ansible/modules/cloud/amazon/ec2_ami.py#L568-L585 https://github.com/ansible/ansible/blob/1905a6e8fb38a6d85eed5632c45250aa676715d9/lib/ansible/modules/cloud/amazon/ec2_vpc_route_table.py#L337-L360
Why remove this test? Is `""` a valid screen name? If yes, there should be a changelog fragment (bugfix since a valid screen name was not allowed by the module).
Yes, definitely! I guess it got removed accidentally...
This is the only part of the code where `screen.get_host_group_id()` and `screen.get_host_ids_by_group_id()` methods are being called. With removal of these lines it no longer makes sense to keep those methods in the code anymore, but I would argue that it is better to update these two methods rather then add new ones (`get_host_group_ids()`, `get_host_ids_by_group_ids()`) This change introduces a new bug as well tho, module parameter `sort` will stop working.
Missing `raise`. I would probably change to `AnsibleAssertionError`.
There is no benefit to such handling of "hidden" module parameter. `AnsibleModule` should be fairly capable of doing this for us. What I mean is this: ```python module = AnsibleModule( argument_spec=dict( host_group=dict(type='list', aliases=['host_groups']), ), ) module.exit_json(ok=True, host_group=module.params['host_group']) ``` Will accept parameters in both formats and convert them to list: ```yaml - testmod: host_group: abc - testmod: host_group: - abc - def ```
```suggestion b_path = os.path.expanduser(to_bytes(path, errors='surrogate_or_strict')) ```
string literals are quicker than calling to_text() so that's why I mention it.
Prexisting but note that you're still operating on a string literal here so you can write it like this: ``` python cmd[u'promt'] = ur"[\r\n]?password:$" ```
I think this should probably be `'auto'` instead of `None` ... unless I missed something (which I'm always open to the possibility that I have): ```python use_backend = self._task.args.get('use', self._task.args.get('use_backend', 'auto')) ```
In order to simplify the code, `main` could call `execute_module` directly (and then `run_tasks` method should be removed), apart from that module behavior seems fine.
also you might want to make this into an option, see ssh connection plugin's `reconnection_retries`
This is an unrelated change but I think this line should be ```suggestion module.fail_json(msg=missing_required_lib('ipaddress'), exception=IPADDRESS_IMP_ERR) ```
These should not be using the exception key like this. exception is only for the traceback. So this line should really look like this: ``` python import traceback from ansible.module_utils._text import to_native [...] self.module.fail_json(msg='Error getting user %s: %s' % (self.name, to_native(e)), exception=traceback.format_exc(e)) ```
This approach adds a lot of complexity, since we're jumping into every place a write happens and adding a conditional. I'd prefer an approach that split out the "checking for differences" work from the "actually writing changes" work. That way, we'd have fewer new conditionals to manage.
`This module can be used to manage maintenance mode of a datastore` (small change: remove 'for', add 'a')
no, it's probably not fixable anyway
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
I'm not a fan of this, because credential type is not unique based on name, and because tower-cli already does a name-based lookup (again, which is wrong) of the related field in the call to the modify method. But this looks like it's mostly the same as how organization is handled, so I'm trending toward saying this is right for now.
credential is particularly problematic because it may be owned by a single user, in which case the organization will be null. This is a common case, and wouldn't be possible by assuming the organization is shared as you are doing here.
This is a pain point shared among all Tower / AWX clients, and I wouldn't say that any of them have ever gotten it right. I don't like 2 separate parameters. In my perfect world, I think it would optionally take a string or a dict (and there would be a type option to allow this), and using the dict you could specify both the project name & organization. This is unlikely to happen. The _primary_ fix you're getting in here, adding `organization` parameter to tower_inventory_source, and applying it to the inventory filter - that's really good. We need that. I would like to mostly focus from that and not worry too much about the other details which are still far from perfection.
Change description to match `enable` and `disable` dvSwitch.
period at the end of statement.
We are not dealing with Standard switch, right ? Also, we are not creating or removing switch.
``` super(VMwareDVSwitchNIOC, self).__init__(module) ``` is missing.
This is not required if using `super`
End with a period.
Should start with a capital and end with a period.
These 4 lines nowadays should be written as: ```yaml type: bool default: 'no' ```
The version_added key has string values. ```yaml version_added: '2.4' ```
For examples we are standardizing on `key: value` Rather than key=value
`''.join(self.topic)` could be replaced with `self.topic[0]` (here size of `topic` is always 1). DONE
The `try`/`except` statements seems useless (nothing can raise `KafkaError`) DONE
`try` and `except` statement seems useless: nothing will raise `KafkaError`.
[run_command](https://github.com/gdelpierre/ansible/blob/a6742ea78fba6b8206eaef61c6410e985a9a61f7/lib/ansible/module_utils/basic.py#L2558) won't raise an error and `rc` will not be zero.
A suggestion: '--config' repetition could be avoided using: ``` if self.config: config_param = ''.join(' --config %s=%r' % (key, value) for (key, value) in self.config.items()) else: config_param = '' ``` _DONE_
I would write it as - ``` self.module.params.get('uuid') or self.module.params.get('name') ```
You can replace line 1284-1293 by: ```python vms_service = self._connection.system_service().vms_service() vm_id = get_id_by_name(vms_service, self.param('srcvm')) vm_service = vms_service.vm_service(vm_id) ```
you can remove this condition as the previous condition already handle other cases
We need to wait until snaphsot is removed and vm ready to remove another snapshot, not any random wait time.
Can you please create method `__get_cluster()` and add there the logic on line 1307 - 1310
I would let the `scaleway_compute` handles IP assignation to server.
``` if module.params["state"] == absent: absent_strategy(pi=api, wished_ip=wished_ip) else: present_strategy(pi=api, wished_ip=wished_ip) ``` could be more readable.
`creation_response.body` is empty I propose to use: ``` "%s: '%s' (%s)" % (creation_response.info['msg'], creation_response.json['message'], creation_response.json) ```
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
`payload_from_wished_lb` could be called once.
``` tenant = module.params['tenant']` ```
All of them should be is None IMHO.
0 is technically valid, so this should be `self.prefix_length is not None`
facts modules can trivially support check mode (#23107)
`aci_argument_spec` is now a function and needs to be called like: `argument_spec = aci_argument_spec()`
It would be more pythonic to write this as `self.chassis_uri_list = [ch["@odata.id"] for ch in response["data"]]`.
Per function name, this should be stored in `manager_uri` instance member.
If the function name is correct, this is what should be stored.
This will fail if Redfish returns empty list of managers.
Last four lines could be simplified to `self.manager_uri = response["data"][-1]["@odata.id"]`.
updatedâuptodate (or up_to_date)
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
Again, this doesn't look like an availability check.
you can use `state` to avoid the 'or' to the user
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
This should be 'supported_by': 'community'
This should be 'supported_by': 'community'
This should be `'supported_by': 'community'`
This should be ``` 'supported_by': 'community' ```
Please update to: `short_description: Run commands on remote devices running Mellanox MLNX-OS` We use company & product name so it's easier for people to find modules.
```suggestion the machine will be updated. - Use with I(started), I(allocated) or I(restarted) options to change the machine's power state. ```
```suggestion - Set to C(absent) to remove the virtual machine. ```
```suggestion - Controls if the machine is allocated/deallocated, only useful with I(state=present). ```
```suggestion - Set to C(true) with I(state=present) to generalize the machine. ```
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
This can become a function since it no longer makes use of self.
Don't modify things inside of a function unless there's a huge performance hit. Just return the values. Also, don't pass in a meta object like mount_info... Instead be explicit that you need the mount and the device by passing just those two arguments in. Looking at this further, though, it probably makes more sense to call each of those separately as they're disjoint information and could timeout separately.
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
should probably have an upper bound of < 10 just for sanity
From our triage meeting, we all found we were confused by this line. Making it more verbose will likely make it easier to understand.
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
yes, we've been wanting to change that for a while but were waiting until we made the architecture more pluggable to allow for old/new formats to be used transparently.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Note for the next time you need to do some work in here: rather than use a dummy variable, it's more idiomatic to just not assign the exception to a variable: ``` suggestion except Exception: ```
Yep. In default configurations, pylint will complain that Exception is caught (exception too broad). It does not complain that the exception is not assigned to a variable. (Our configuration of pylint allows catching Exception. Mostly because it would be extremely time consuming for us to clean that up... Having to evaluate every usage of Exception to see if it is valid or should be replaced with something more targeted)
```suggestion playbooks to use M(dellemc_pmax_addvolume) module." ```
```suggestion underscore." ```
```suggestion required: true type: str ```
```suggestion to verify the scripts run with valid input. These modules are a tech preview." ```
```suggestion match your environment." ```
I'm cool with DryRun for this use case - the logic here is pretty simple so catching the exception is plenty sufficient.
That's fair - permissions are definitely worth managing right!
Don't use DryRun - you're not handling the exception that will be returned. With check_mode, we usually just don't make the API call at all and return something suitable in the results.
That's definitely better, but it might just be simpler to do ``` def create_placement_group(connection, module): name = module.params.get("name") if module.check_mode: module.exit_json(changed=True, placement_group={"name": name, "strategy": 'cluster'}) try: connection.create_placement_group(GroupName=name, Strategy='cluster') except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Couldn't create placement group [%s]" % name) etc... ```
HAS_BOTO3 import not required due to use of AnsibleAWSModule
Instead of building regexes to match the link parameters and extract them, it would be easier to use `parse_qs` which pulls values from valid query strings. For example: ``` >>> from ansible.module_utils.six.moves.urllib import parse >>> query = parse.parse_qs('/foo/bar?page=6&per_page=20') >>> print(query) {'per_page': ['20'], '/foo/bar?page': ['6']} >>> int(query['per_page'][0]) 20 ``` Or for more advanced parsing, you could use `urlparse` to remove the query string and path to use. ``` >>> parse.urlparse('/foo/bar?page=6&per_page=20') ParseResult(scheme='', netloc='', path='/foo/bar', params='', query='page=6&per_page=20', fragment='') ```
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
@pierremahot we'll need a test for this
This needs to be C(validate_certs) which is the standardized parameter name.
Please don't add any aliases except for backward compatibility. We don't want to offer more choice than necessary.
Use URL instead of Url. ```suggestion - The URL of the Gitlab server, with protocol (i.e. http or https). ```
There is no need to add quotes here. Please remove them from all modules.
If `purge` is `true`, it will be empty according to the code you pasted below.
Omit these lines please.
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
Rename DO to DigitalOcean to avoid acronyms
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
There is no need to make an api call just for checking that the zone exists. The ovh python package raise a ResourceNotFoundError that can be caught in the next api call to check if the zone exists.
`class_name_to_type()` has fallthrough return None if it doesn't find (unless I'm reading it wrong)
It is also OK as-is if you like it; I just wanted to make it clear you don't *have* to obey the consistency if you see a better way. [I think I was in a bike-shedding mood when I did this review... Feel free to push back :-)]
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
Remove the two extra double-quotes here.
not a blocker to this PR, but this should be moved to config (really should not be a thing in core at all, but setlingling for moving into config).
this will repro the "what if one of the collections is missing?" case ```suggestion 'testgroup': ['testns.testcoll', 'testns.othercoll', 'testns.boguscoll'] ```
community.general also contains some of the modules of the `k8s` module defaults group (the `kubevirt` modules), and some modules of the `ovirt` module defaults group (the deprecated `_facts` modules).
personal preference, but since we only want to do the work once based on the result of a looped query, I usually write those things as an explicit query predicate, eg: ``` if any(name for name in redirected_names if name in action_group): tmp_args.update(...) ``` this form also stops the iteration once we know there's work to be done. You could accomplish the same in the existing form by adding a `break` after the update, but IMO the existing form is less clear that you're not really looping over the side effect.
```suggestion serial_port=dict(type='int', required=True), ```
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please do not add `required=False`, it is implicit.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Same as for the updated, I'd rather say `has been deleted`
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use 'msg' for returned messages, this is a standardized return value.
I would also add to `identity`, `filter`, and `ldap_filter` some form of text saying one of the 3 must be set
This should use the proper LDAP attribute name for DN ```suggestion - This value is either the C(distinguishedName) or C(objectGUID) or the AD object to lookup. ```
```suggestion short_description: retrieve info regarding domain objects of all kinds ```
Should add a point here saying not allowed with `I(identity)`
Should add a point here saying not allowed with `I(identity)`. Should also say the value is the `C(distinguishedName) of the path to search from.`
there is no need to version params for new modules
`default: null/None` is the default, it can be omitted
`required: false` is the default, can be omitted
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
there is no need to version params for new modules
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
specifying `type='int'` removes the need for this, so you only need to check the range.
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
SHould inherit from object because of python2
No, it doesn't become the default until Python3.0
I would recommend updating to inherit from object. Just because others did it or are doing it, doesn't necessarily make it a thing we wish to have. We are trying to improve and standardize on implementations, and the preference here is that we standardize on inheriting from object. A future task can be to improve modules where this was not followed.
Parentheses around `e.message` are useless.
So the suggestion I added above (copied below) works around this, if we add the following change we don't need to add the `ensure_required_libs` function or make any changes to `ensure_libs`. ```suggestion try: ensure_libs(sslrootcert=module.params.get('ca_cert')) except LibraryError as e: module.fail_json(msg=str(e)) ```
Would it be better to reuse the existing `ensure_libs` function here? ```suggestion try: ensure_libs(sslrootcert=module.params.get('ca_cert')) except LibraryError as e: module.fail_json(msg=str(e)) ```
I have had a look at the description and the [failed tests in shippable](https://app.shippable.com/github/ansible/ansible/runs/120738/5/console), my understanding for checking that is that this is because the `ensure_libs` function was changed but the tests were not updated. What I am suggesting above is not to change the `ensure_libs` function but to simply use it. This will mean that we won't have two functions `ensure_libs` and `ensure_required_libs` that contain the same logic.
ð, this is a nice little refactor.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
Please rewrite the description what the task is doing in detail. E.g. **Disable the domain firewall profile.**
Same here, trailing do required.
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
The description needs to have a trailing dot. (The short_description does not)
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
add ``` datastore = None ```
`if expect_disk_spec.get('autoselect_datastore', False):`
Also, if the disk already exist, 'autoselect_datastore' shouldn't modify the disk.
add and else branch here and tell the user they specified too many disks
also, have a look at https://github.com/ansible/ansible/pull/36617#discussion_r170312630
Instead, please set `self.index = json.load(f)`. The JSON library uses the `.load` function to stream straight from files without needing to `.read()` first. This also avoids pesky encoding issues with Python2/3.
I usually feel that something of this level of granularity is overly subdividing the code but this is setup.py, so I'm not as worried about it here as in the main code.
You're correct. I misread that this `if` statement is indented. Looks good!
I would also add the deprecation warning here in addition to the failure.
i would add `: %s` and to_text(e)` to the end of msg
use to_native (module_utils._text) instead of str, it deals with py2/py3 compatiblity
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
the shell itself would have done it before. but might have done it slightly differently.
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
bad place for a typo: s/connecton_timeout/connection_timeout/
Again self_host is not defined for winrm.
IIRC should be just `raise` to re-raise the existing error
I would probably go for "Exit" here, but that's more cosmetic than functional.
Fails because self_host is not defined for accelerate transport.
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
I'd do ```suggestion if not ignore_errors: raise ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
Keep a blank line between examples for readability.
This is wrong, already explained.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
Should be a parameter of the task itself and not the module
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
```suggestion - When a value is masked, it must be in Base64 and have a length of at least 8 characters. ```
```suggestion - Support for protected values requires GitLab >= 9.3. ```
```suggestion - When you masked a value, the value must be base64 compliant and has at least a length of 8 characters. ```
You could simply only pass variables that are `True`, then you're on the safe side :) I.e. something like ```.py params = {"key": key, "value": value} if masked: params["masked"] = True if protected: params["protected"] = True return self.project.variables.create(params) ```
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
all the 200s should be 'OK'
jic someone adds any other '200ish' code as valid in API response ``` if info['status'] >= 200 and info['status'] < 300:```
please add the `version_added: '2.10'` here as well
Ah, well that'd be even better :+1:
`marker` must be capitalized here per http://boto3.readthedocs.io/en/latest/reference/services/iam.html#IAM.Client.list_policies, so line 140 has to call `get_policy_by_name(module, iam, name, Marker=response['Marker'])`
This is an invalid yaml. We usually write the description as a list. BTW, there is no need to add the example. if there is ":" in the sentence, the whole line should be quoted. ```yml description: - "XXXXX" ```
aws_ip_ranges -> aws_service_ip_ranges
These should be in ansible standard form (use boto3_tag_list_to_ansible_dict)
You don't need connect_to_aws, boto3_conn or get_aws_connection_info if using AnsibleAWSModule
This import isn't used.
After looking at the PR description, it sounds like it'd be saner to use a different variable name. Also, it looks like this could be moved closer to the loop that iterates over these dirs.
I believe it is due to mutating the `dirs` created by `os.walk`, which impacts future iterations that include that same `dirs` reference. I'm sure we could refactor the code, to not require it, but this is a known good change that works.
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
Where's it? I cannot see it.
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
``` python except KeyError as key_name: ```
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
Tell people where we are looking `CONFIG_FILES`
Please fix: '... if it doesn't exist:'
Ah. lambda is prettier though :). maybe we can run pep8 with ignore lambda error.
Missing `=dict` on this and the next few lines
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
```suggestion text = to_text(text).strip() ``` `to_text` can be imported from `ansible.module_utils._text`
Please add `mutually_exclusive = [['name', 'interface_type']]` in aggregate spec dict. This ensure the mutual exclusion is applied for each item in aggreaget list
IMHO this condition is on the wrong place, because the in check mode it seems not to return `changed=True` handled later in the code. As a result, a user may get a changed=False in check mode but a changed=True in live mode. This condition should be right before the actual action(s) happens.
Here's how I'd fix this (since pylint complains about the change that autopep8 makes): ``` diff diff --git a/lib/ansible/modules/storage/netapp/netapp_e_storagepool.py b/lib/ansible/modules/storage/netapp/netapp_e_storagepool.py index cafcbdbbc5..c55e8132a4 100644 --- a/lib/ansible/modules/storage/netapp/netapp_e_storagepool.py +++ b/lib/ansible/modules/storage/netapp/netapp_e_storagepool.py @@ -120,14 +120,13 @@ def select(predicate, iterable): if predicate(x): yield x +def _identity(obj): + return obj class GroupBy(object): # python 2, 3 generic grouping. def __init__(self, iterable, key=None): - if key is None: - def key(x): - return x - self.keyfunc = key + self.keyfunc = key if key else _identity self.it = iter(iterable) self.tgtkey = self.currkey = self.currvalue = object() ```
Rather than silently returning `None` when incorrect argument types are used, explicitly raise a `TypeError` to communicate the problem to the caller. ```suggestion raise TypeError(f"Unable to diff 'dict1' {type(dict1)} and 'dict2' {type(dict2)}. Both must be a dictionary.") ```
Use Jinja variable instead of IPs.
This feels wrong because if it matters that we get inventory_hostname when using delegate_to then we wouldn't want to also use inventory_hostname in the non-delegate_to case... that probably means that this happens to make some test cases work but hte real bug is elsewhere (or we shouldn't have inventory_hostname in the else?) Would need to explore this more to understand what's actually happening here.
Your PR #52278 needs more `shipit` commands to be merged
```suggestion res = re.match("""GRANT (.+) ON (.+) TO (['`"]).*\\3@(['`"]).*\\4( IDENTIFIED BY PASSWORD (['`"]).+\\6)? ?(.*)""", grant[0]) ```
Could you please replace this `with `
Keep using `self.module.fail_json()`, of course fine. ð Changing all `.format()` into `%`, great! ð I've never noticed that the module has so many `.format()`...my reviews must be too rough at that time ð
Use `%` instead of `.format()` to support older version of Python. ```python self.abort('%s is not a supported option on target platform' % key) ``` (L557 too)
Why do we need to force to change powerstate? Seems over protective.
The expected_state variable only strips the underscore (_) character from the state variable, but the providable power states for vmware_guest_powerstate use hyphens (-), so the expected state will never match the current_state or any of the other conditionals. Using underscores for the state names (ex. powered_off) strikes me as being more consistent with the existing conventions than adding hyphens.
Please split this message up in 2 parts.
Seems to me that poweredoff state is consistent with shutdown-guest state, and the result should be success and changed=false
missing import of get_exception()
You can remove `, required=False`
@jmighion would be great if you can update ios_config as well. Thanks!
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
As this is added in top-level arguments please add `removed_in_version=2.9`
This argument is marked as being removed in the same version it is introduced. This makes no sense.
I'd rephrase: "Kernel command line parameters (formatted as string) to be used with the kernel specified by `kernel_path` option."
I'd rephrase to: "Path to a kernel image used to boot the virtual machine"
```suggestion - Only used for images that contain the Windows Server operating system. ```
please add `no_log=True` to avoid leaking the password in the logs.
Create vm pool and override the pool values.
I'm not sure what you check with `if want['vlan']` but it seems wrong without any explanation...
Should this handle for space within interface name? Something similar to https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/eos/eos_vrf.py#L224 to avid idempotency related issues.
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
If the VLAN exists, you should check the name and state to make sure they are same as requested.
Move this line after 250. You won't need to deepcopy unless you are actually creating a request.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
We don't need tags in this function, I think.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
You don't need the if/else block here.
You are taking me wrong here. I am just saying that adding additional library will add overhead to people who are using this module and people who will maintain it. I am not saying to port other GitHub modules to use `PyGithub`. One way could be using GitHub REST APIs directly rather than relying on any third party Python modules.
Making this as resolved.
``` aliases: ['repo'] ```
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
Looking at the boto3 docs, it looks like cluster ID is required for the describe_cluster call you are making. list_clusters would be a call you could use if no cluster_id is provided. required: false is also the default, so if this remains to be true you can remove this line.
Please remove this. /tmp might not be writable or available.
You should follow standard [Ansible AWS Exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#exception-handling-for-boto3-and-botocore)
`snake_dict_to_camel_dict` already exists in module_utils.ec2, it has recently been updated to allow a second parameter `capitalize_first=True` (because someone made the default dromedaryCase early on)
`camel_dict_to_snake_dict` already exists
use `trail['LogFileValidationEnabled'] = ct_params['EnableLogFileValidation']`
To be consistent with other modules, can you please change this to: ``` validate_certs: description: - If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. required: false default: 'yes' ``` And update code & argspec as needed
Each example task should be a continuous block, please do not have blank lines between sections
Sound, sound sensible
there is no need to version params for new modules
`, no_log=True` here please
I'm not a fan of the "I" word because it's quite jargon-y. But I'll yield to consistency for the time being.
```suggestion - Use this for random-but-consistent password generation. ```
"Netmask in case ..." -> "Subnet mask in case ..."
I'd prefer `runlevel` instead of `run_level` in this case. It is a matter of taste obviously.
> but should a version_added: "2.12" be added here Yes. > how does it then work with backporting new additions? We do not backport new features, only bug and security fixes.
Always sort items in a list, if the order is not important.
This could be optimized to state the used domain_type.
~~~ - name: Ensure a network is present cs_physical_network: ~~~
For consistency, please use the `delegate_to: localhost` syntax.
there is a missing condition for check mode
```suggestion version_added: '2.8' ```
in py3 this is dbm, so try/except
```suggestion - David Taylor (@djtaylor) ```
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion version_added: "2.8" ```
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
`pexpect` could be used to provide the password to the subprocess on stdin.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
In case the file doesn't exist, `keypair.check(module)` returns `False`, whence `changed` is set to `True`. I don't think that's correct.
if `self.path` doesn't exist, `self.path + ".pub"` will never get removed.
This method doesn't handle the update/remove, so it's not fully idempotent, but I think we can go with that for start and improve later. If it's OK for High Perf VM.
This is just integer so: ```python index=numa_node.get('index'), ```
This is just integer in MB so: ```python memory=numa_node.get('memory'), ```
That's OK, I just wasn't sure how it's working.
Once Martin will review.
Rather than bare exception, can we add IndexError as well ? ``` except (KeyError, IndexError) as e: ```
@moshloop Did I not propose that ?? > I would even remove that `except Exception as e` part completely. (And test different type of error conditions to see what other type of Exceptions are common).
@moshloop I don't understand why you think I am promoting to swallow errors. The problem here is that we want to handle all kinds of exceptions where we have no clue how each represents its data. This has lead to the above junk code. The solution is to only catch the specific exception exactly how it represents data.
@moshloop VMware does not have specific Exceptions for each of those, do they ? And if there are a few, you can list them together, or use the base class of which the more specific Exceptions are built from. What we definitely don't want to have is a blank `except:` statement, because we know it leads to issues causing tracebacks.
I warned for this, the catchall Exception above is the wrong approach.
Yes. There are usually many of them, if you don't have a one- or two-node cluster ;-)
LOL ok :D It was apparently a bit late... ;)
```suggestion I(managers) - all manager nodes; I(leader) - the swarm leader node; ```
```suggestion - The plugin returns following groups of swarm nodes: I(all) - all hosts; I(workers) - all worker nodes; ```
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
As previously discussed on https://github.com/ansible/ansible/pull/20787 I much prefer os.path.isfile That way it won't try to read a directory path.
Missed one.. Should just be as below unless you want to also pass module into the function. ``` if os.path.isfile(cert_chain): cert_chain = open(cert_chain, 'r').read() ```
Could probably get rid of the surplus required=False entries I seem to have missed as well
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
I wouldn't write a function which was itself a single function call ;-)
Remark: with regexp factored out this could become just ```python from functools import partial ... _is_vcs_url = partial(re.match, _VCS_RE) """Test whether a name is package name or version specifier.""" ``` (But I bet Toshio would blame it for being unreadable, so don't do it :smile:)
Let native speakers correct me if I'm wrong, but I think `a` article should be moved to before `package` and before `version`.
It's inconsistency, so it's not ok.
if this method terminates in line 278 there will be no `self._requirement` in class instance, which would break things.
the state and status fields are supposed to be generic across init systems, I'm fine with adding optional fields returned when systemd is run, but we should not customize the generic values to systemd specifics.
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
We try not to use "_" as an identifier just in case we want to internationalize the modules someday (the convention for gettext is to mark strings using the function _(). So we don't want to inadvertantly override _ with another identifier).
As long as we're supporting python2 we should make this a new-style class like this: ``` class OSXService(object): ```
please quote version_added as well to not be a float.
no, if the variable is set but empty, you should empty out the options
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
Well you don't need the `if`, you can just run `.replace()` and it'll do the right thing regardless of whether there's a slash in the string.
Right, but `'show_vlan'.replace('2/1', '')` is still `'show_vlan'`. Unless I am missing something painfully obvious, the condition is not needed. (I will admit that I am picking nigh infinitesimal nits here... the rest of this is just fine and you could just merge it if you want)
if not handling become methods update the class variable to indicate this
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
su requires a tty, that is why most 'subprocess' plugins don't support it.
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
Add that the user can specify the backend to use via the ```use``` parameter.
please wrap in block ``` if __name__ == '__main__': main() ```
please use explicit imports .... `from ansible.module_utils.basic import AnsibleModule` ... etc
docs say name is required, spec does not
you just described check mode in general
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
i would consider moving this to a module_utils/tower as I expect other modules will need to use the same auth
... all networks will be synchronized before modification
Can you please write that: Since Ansible 2.8 they are persisted by default? So it's clear.
Ah, I see that this module was added in 2.3 so not needed here.
Same thing here - otherwise we would end up with I(....) everywhere. ```suggestion - If no blob_cors elements are included in the argument list, nothing about CORS will be changed. ```
vms -> VMs
Do you have any references for the inline if being discouraged? If you don't like the inline if, then I'd go with the normal if block.
I'd want to see the role stay atomic and have either everything or nothing change. If the module fails, nothing should change on the system. That might either mean moving the loop into the `semanage_boolean_value` function, or supporting externally-triggered commit for the function.
I'd move this entire block outside of the loop to ensure the module is atomic.
Because it already checks the exclusivity of these 3 options in the module definition, this check can be minimized to `if self.vlan_id == 0:` (the other 2 will automatically be None)
previous state in this case would be `enabled`, additionally on the message: Same as with the other module: I suggest setting the current/desired state to what it would actually become, including the correct message. Check mode should represent what will be the outcome of the change as if it were for real, except not actually make the change.
```suggestion - Gitlab access token with API permissions. ```
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
```suggestion - Create or delete project variable. ```
```suggestion - name: Delete one variable ``` For consistency (compare the other example)
You don't return this one as well. Only specify things in `RETURN` which you actually return!
get_basedir should not be needed, the ansible_search_path should include the correct one
if you are using loader, just use `get_file_contents`
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
this should be prepended, as the list controls the priority in which the search happens, the template itself should be the first location scanned
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
You can safely remove this line.
Let's see if anyone else complains about that when reviewing ;)
I know, but I had the impression that there was a tendency to switch from `true`/`false` to `yes`/`no`. But maybe I'm also mistaken.
Please remove this line. `waitfor` was used in older modules, we've since standardized on `wait_for`
Please remove this line
```suggestion variables = {} ```
Sure, a separate PR sounds good.
For encrypted you should be able to assert something about the format: ``` >>> crypt = getattr(passlib.hash, 'pbkdf2_sha256') >>> crypt.encrypt(u'asda') '$pbkdf2-sha256$20000$PUeoVar1/h8jxNjb./8fgw$UzKj5pfmKEDtguOh.XEvHCqQr2b4AHPgwL/M8BEzez8' ``` Initial string, number of "$", length of the salt and length of the hashed value.
```suggestion Test that the returned value for timezone consists of only uppercase ```
I know, was just wondering if it's intended that it works that way.
Could you please use `AnsibleAWSModule` instead? We didn't have a lot of the aws utils we do now when this was first PRd, it will save having to port it later on. https://docs.ansible.com/ansible/devel/dev_guide/platforms/aws_guidelines.html#creating-new-aws-modules
Missing boto3 will be automatically handled by AnsibleAWSModule, this should just be: ``` try: import botocore.exceptions except ImportError: pass ```
`aws_common_argument_spec` is currently unused, `get_aws_connection_info` and `boto3_conn` shouldn't be necessary.
This should use the standard client setup, which handles exceptions internally: ```self.conn = module.client('iam')```
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
`for key, value in (doc.get('options', {}) or {}).items():`
instead of this check, you can do: ```python for key, value in doc.get('options', {}).items(): ```
`for k, v in opt.items():` <-- gives you key-val pair
yes, as well as `None`
I think this function should return value, which you'd re-assign here: ```python value = to_boolean(value) ```
I think this would be more readable if you do: ```python org_id = self.get_org_id(org_name) net_id = self.get_net_id(org_name, net_name, data) path = '/organizations/{org_id}/networks/{net_id}'.format(org_id=org_id, net_id=net_id) ``` So using positional arguments where there's no discussion, moving different operations in separate steps, and bring the information together at the very end. The path-string could be coming from somewhere else (if this is something that is being reused, but probably not relevant here).
Beware that the fourth positional argument has shifted, so if people used this interface using positional arguments it may break. (I don't think there's a risk, as we can safely assume you're the only user of the interface...)
Should you not be able to enable_vlans support, and update the network ? So I was expecting an `if` instead of an `elif`.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
Why `dict(required=True)` is added here? It is already part of the spec.
You can use iteritems as below ``` from ansible.module_utils.six import iteritems iteritems(parsed) ```
Verifying here that IP address and prefix are in correct format would be good. Look for APIs: `socket.inet_pton(socket.AF_INET, address)` and `socket.inet_pton(socket.AF_INET6, address)`
Please change these vars to ansible Host vars rather OS env vars.
This can be converted to return True. No need of new variable retry_request
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
a try/except LookupError with a fail_json around this should be sufficient to handle any potential api response data changes gracefully.
wouldn't hurt to include some details about the error here. The original exception error message for example. But thats not a blocking suggestion.
How about ```suggestion kv_pairs = [kv_pair.strip() for kv_pair in tags.split(',') if kv_pair.strip()] for kv_pair in kv_pairs: ``` That avoids empty strings showing up in the result, and also allows users to separate with `, ` instead of `,`.
If `tags` is the empty string, you will get one `kv_pair` which equals the empty string. That's probably not what you want.
Since it's the only plugin which does that, I would remove it. Either all plugins should do that, or none.
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
My bad, I forgot that [dict comprehensions were added in Python 2.7](https://www.python.org/dev/peps/pep-0274/). Feel free to ignore my suggestion.
Remove the `if` and make `_parse_healthcheck_options()` handle `self.healthcheck == None`.
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('Europe/Helsinki')), '2019-06-15T14:45:00+01:40'), ```
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
Please use update bolierplate.
Shorter version of header can be used [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/mlnxos/mlnxos_config.py#L4)
There is a short version of the GPL header, and add your copyright to it. "This file is part of Ansible" can be removed.
CI failure due to missing module metadata: ``` 2017-02-03 21:30:34 ============================================================================ 2017-02-03 21:30:34 lib/ansible/modules/notification/logentries_msg.py 2017-02-03 21:30:34 ============================================================================ 2017-02-03 21:30:34 ERROR: No ANSIBLE_METADATA provided ```
please add ``` from __future__ import absolute_import, division, print_function __metaclass__ = type ```
I don't believe this should be a function of the `uri` module, but probably implemented in `ansible.module_utils.urls` instead. However, with that being said, we wouldn't be able to use this specific line, as it could cause other issues, in that this would become a global change, and not specific to just a single request. As such, we'd probably want to make use of `sockshandler` instead.
ssh -W asumes openssh-5.4 or later. Older versions of openssh need netcat to achieve this.
```suggestion {% if no_proxy | regex_search('\/') and ```
If you were to do this as a decorator, you should be calling ```function``` here instead of hardcoding fetch_rpm_from_url.
I mean like: ``` python - package = fetch_rpm_from_url(spec, module) + package = function(spec, module) ``` But looking at this, I still think it should be a context manager rather than a pseudo-decorator. That would look something like this: ``` python from contextlib import contextmanager [...] @contextmanager def set_env_proxy(conf_file, installroot): old_environ = # [old values of the proxy env vars] try: my = yum_base(conf_file, installroot) # [set environment to the proxies that yum knows about] yield except: raise finally: # reset the environment to the values saved in old_environ [...] if '://' in spec: with set_env_proxy(conf_file, installroot): package = fetch_rpm_from_url(spec, module=module) [...] ```
I suggest you use [`shutil.move()`](https://docs.python.org/3/library/shutil.html#shutil.move)
Please use `[ ]`: ```python result['changed'] = True ```
replace this with `return`, the actual `exit_json` call happens later and there is some ssh_wrapper code in the main routine that should run. Where do you remove tempdir/new_archive? Maybe that code got lost in one of the last refactorings. Remove the temp part should also happen before the `exit`.
Instead of lots of if/else, you could follow EAFP principle and do: ```python try: if git_version(git_path, module) < LooseVersion('1.7.5'): separate_git_dir_fallback = True else: cmd.append('--separate-git-dir=%s' % separate_git_dir) except TypeError: # will happen when comparing `None` module.fail_json(msg="Cannot find git executable at '%s'" % git_path) ```
We might want to introduce new/old git dir path in the result.
```suggestion assert wrap_var(dict(foo=None))['foo'] is None ```
```suggestion assert isinstance(wrap_var(set(['foo'])), set) ```
```suggestion assert isinstance(wrap_var(('foo',)), tuple) ```
```suggestion assert isinstance(wrap_var(('foo',))[0], type('')) ```
```suggestion assert isinstance(wrap_var(b'foo'), type(b'')) ```
Are these common aliases with maven? Generally with modules we just use `user:` and `password`
Examples should be in multi-line with `key: value`
Descriptions should be full sentences, eg with capital letter and full stop.
Please add `no_log=True`
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
```suggestion author: Edoardo Tenani (@endorama) <e.tenani@arduino.cc> ``` (Same for the other PR. This will make sure that you will be notified about issues / PRs for this plugin by ansibot.)
```suggestion version_added: "2.10" ```
`PY2` and `PY3` are booleans importable from `ansible.module_utils.six`
two blank lines...
@tstoner I am curious why you are raising `TypeError` if capabilities cannot be fetched. Given that the new options added in this PR are not the required options for `nxos_nxapi` module, I don't think we want to fail the module if `device_info` is None. Same for `os_version` and `os_platform`. The module can simply ignore the task and pass when these parameters are used with a warning message if capabilities isn't available instead of failing/raising exception.
You can use `module.deprecate` to throw a deprecation warning.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
Just an idea. Wouldn't you get the same result if you simply have ```suggestion port_ordered = [sorted(d.items()) for d in port[key]] ``` ? `OrderedDict(sorted(a.items())) == OrderedDict(sorted(b.items()))` should be true if and only if `sorted(a.items()) == sorted(b.items())` (for `dict`s `a` and `b`).
Same order, type first.
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
register it in a playbook and use it later. The module has already parsed the file into a object (self.lines and its records). That avoids the need to refetch and do string parsing to inspect the results.
No, it doesn't become the default until Python3.0
SHould inherit from object because of python2
I would recommend updating to inherit from object. Just because others did it or are doing it, doesn't necessarily make it a thing we wish to have. We are trying to improve and standardize on implementations, and the preference here is that we standardize on inheriting from object. A future task can be to improve modules where this was not followed.
I think `hosts` is a name that does not violate the principle of least surprise. I merely wanted to point the rest of the cfg mgmt ecosystem and possible Windows support. Let's see what @abadger thinks about it given the above.
yeah, proxying can end up being a lot worse than the original issue, just made the note to make sure we all knew 'this is possible' .. but as you said, we write a LOT of info all the time and during shutdown it gets flushed anyways
no trailing conditionals, people tend to miss these (i'm guilty of having written too many of em)
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...
Missing `raise`. I would probably change to `AnsibleAssertionError`.
From the mail I got I saw this obvious typo "receipient_id". Also now that we are at it, parameters can be indicated using C(parameter). So that line should read: ```yaml - The C(recipient_id) type must be valid for the supplied C(recipient_type). ```
`descriptions:` should end with a full stop
missing full stop
Fair enough. It is not a hard requirement.
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
I'd write this as `NTP server IP address or hostname`.
Why do we have `default: ""` here ? The default is `None` but that doesn't have to be exposed. I would leave the default out of this.
So we have had some discussions about modules that are meant to run on the Ansible controller and connect to a remote device. I personally think that adding `delegate_to: localhost` in the examples makes it very clear to the user that this is not a module you run on the target. That's why we started to add this to other modules as well. So the examples work without having to do anything special in the background.
This line does not need quotes. (nitpick)
I would move the state one line below. First the selector, than the action, is what I usually do.
We tend to use snail_case, so all parameters should be snail_case.
This is no longer needed. Ansible adds traceback information automagically. ```suggestion ```
don't leave a file descriptor open. use a context manager (via `with` block)
You may try
wrap these pieces of code into two try/except statements to be precise with what you're trapping. 1) one around with-block (with readfp call) catching `IOError` 2) the other one around creds dict constuction catching `configparser.NoOptionError`
I think this logic should be handled by service instead of ansible client side
What if the rest service_principal missing client/secret field
If the `state` is `absent`, these parameters can be omit, you can use require if to make these required if the state is `present`
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
How about the rest items of `spnprofile`
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
Since we're optimizing to solve this bug, would be good to move regex compilation up to be a one-time thing. Maybe a class attribute or global for each compiled regex. ``` python class LinuxHardware(Hardware): BIND_MOUNT_RE = re.compile(r".*\]") [...] if re.match(self.BIND_MOUNT_RE, fields[1]): ```
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
you use get_bin_path above, i would reuse it for all lsattr calls (and do same for the other utilities below)
Make pep8 happy ```suggestion priv, append_privs, module) ```
```suggestion changed, msg = user_mod(cursor, user, host, host_all, None, encrypted, plugin, plugin_hash_string, plugin_auth_string, ```
You're right, it always returned `True` before. There's a difference to before, though: before, `db_create` *always* returned `True`. Now, it only returns `True` if creating all DBs succeeded. So the `if changed:` can be removed in line 426, and the `if` block can always be executed. As long as `db_create` didn't result in an exception (in which case the module dies), all DBs should be there anyway.
```suggestion module.exit_json(changed=bool(non_existence_list), db=db_name, db_list=db) ```
just return pm.encrypt(password, user) != current_role_attrs['rolpassword']:
also extends `azure_tags`
`required: false` is the default value, we can omit it here
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
I think we need to expand a bit on the description here. From the outset it seems like this is a dict but the examples show it is a list of dicts. Can you expand on what `linux_profile` is, whether it is a list of options or just a dict of options. The other point is that this is not `required: true` as it isn't needed when state == absent. The same applies for `agent_pool_profiles` and `service_principal`.
We may need at least the following features here: - [ ] `list_keys()`: Show the SAS policies of the Event Hub, so that we can have connection string - [ ] `list_consumer_group()` We usually add these with a flag to avoid network overhead. refer: https://github.com/ansible/ansible/blob/1dc8436ed91ef25748dd270c289c05f893cca6e3/lib/ansible/modules/cloud/azure/azure_rm_servicebus_facts.py#L55-L60
The other option is to strip the arguments and keep it as a list
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Ah, this needs to be set to to `type='path'` so it will be automatically expanded.
not a blocker but there is also a helper for json.dumps https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L792
not a blocker, but there would be a little helper code for this in basic.py https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/basic.py#L2301
not a blocker, this open_url/except has been used many times and it would be probably worth to create a function in a shared code module_util under module_utils/opennebula.py. Note that any code under module_utils has to be bsd licensed.
a list action or state is something we have accepted in the past, but not anymore for new modules. please create a separate facts module for this functionality.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
Please fix: '... if it doesn't exist:'
'exists' -> 'exist'
I'd rephrase: 'Obtain data of `vm_name` if specified, ...'
Tell people where we are looking `CONFIG_FILES`
This doesn't work when list of projects is empty (example: exoscale.ch). It results with following error: `Traceback (most recent call last): File "./cloudstack.py", line 232, in <module> CloudStackInventory() File "./cloudstack.py", line 113, in __init__ data = self.get_list() File "./cloudstack.py", line 178, in get_list groups = self.cs.listInstanceGroups(projectid=project_id) File "/Library/Python/2.7/site-packages/cs/client.py", line 105, in handler return self._request(command, **kwargs) File "/Library/Python/2.7/site-packages/cs/client.py", line 157, in _request response.status_code), response, data) cs.client.CloudStackException: ('HTTP 431 response from CloudStack', <Response [431]>, {u'errorcode': 431, u'uuidList': [], u'cserrorcode': 9999, u'errortext': u'Unable to execute API command listinstancegroups due to invalid value. Invalid parameter projectid value= due to incorrect long value format, or entity does not exist or due to incorrect parameter annotation for the field in api cmd class.'})` It works, when I remove `projectid=project_id` form the API calls.
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
These values should all be type `int`
Should be type `int`
Should be type `int`
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
values in choices and default for bool should be `yes/no` according doc of ansible. it is a convention by Ansible. `required` should be true/false as it is a flag to show it is required.
This should be enforced by the argument_spec, not sure how this would happen.
"One of your CIDR addresses has host bits set. To get rid of this warning, check the network mask and make sure that only network bits are set. [full boto3 error message]"
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Another general exception handling that can be removed.
Can you just catch `AttributeError` here instead.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
What exceptions are you planning to catch here ? Because we prefer to catch only the exceptions we know can be raised. Blank statements like this one may hide real logic errors under the premise that it was a known issue all along.
Why not do this in a single statement ? ```suggestion result = dict( changed=False, ansible_facts=dict( tcp_listen_violations=list(), udp_listen_violations=list(), tcp_listen=list(), udp_listen=list(), ), ) ```
Seems like filter can return partial matches: `foo` would match for an existing `foo-bar` service, and would fail with thinking it needs to be updated (which also seems to be deprecated. Maybe it's worth verifying with this condition and adding a workaround: ```python if len(raw_data) == 0 or not 'Name' in raw_data[0]['Spec'] or raw_data[0]['Spec']['Name'] != name: ```
Do a pull request.
Sure, warnings are an option. But if it does work as non-root, I wouldn't add the warning.
I don't think Lightsail allows custom AMIs, at least from what I've seen in the docs and prodding at the console a bit. There is a question of if we should have a default to use the region default key when state=present instead of requiring a user specification, generally the way lightsail does keys is different from the way ec2 does keys though and I'm still familiarizing myself with the differences.
Personal niggle: boto3 doesn't list keyPairName as a 'required' argument. I have some use cases where I bake the keys into the AMI and don't want to pass an additional key to the instances...
You could remove this check since `for o in open_ports` should work as well.
Should inst ever be None without being in the process of being created at this point? Wouldn't it be worth waiting for that too? If so you could remove the call to _find_instance_info(client, instance_name) just above and change this conditional.
It looks like if it isn't a permission error or request expired the exceptions are ignored. It would probably be better just to retry on a specific exception or two and otherwise call fail_json than mask undisclosed exceptions.
and please add space after `)`
please use here `self.param('version')`
please use here self.param('version').get('base_template')
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
```suggestion A command may be either a string or a list of strings. ```
Similar here (and all the other ones, I guess): ```suggestion - Maps C(docker service create)'s C(--constraint) option. ``` or ```suggestion - Corresponds to the C(--constraint) parameter of C(docker service create). ```
A general remark: you should always use complete sentences. So this should end with a period.
Please use formatting like `C(<device-on-host>[:<device-on-container>][:<permissions>])`, and `(e.g. device C(/dev/sdc:/dev/xvdc:rwm))` in the line below.
I would remove this `device` here, and similar the option name in the examples for `device_read_bps`, `device_read_iops` etc.
Python 3 versions are packaged in `python3-libselinux` and `python3-policycoreutils`. But the module needs just `selinux` and `seobject` python modules and version depends on the current interpret version. I don't know how to make it understandable and correct. On lines 267 and 270 I'd probably use module names could be used instead of package names: ```` module.fail_json(msg=missing_required_lib("selinux"), exception=SELINUX_IMP_ERR) module.fail_json(msg=missing_required_lib("seobject"), exception=SELINUX_IMP_ERR) ````
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
`changed` doesn't need to be an attribute.
Just an FYI. I believe the way `no_log` works is my replacing any occurrence of that string in output displayed to the users. Therefore if `admin` is both username and password then we wouldn't see the username if it was returned in a message.
This should be: ```yaml type: bool ```
New person will be confused when you refer to `msg`, adding a brief description will help.
not a blocker, but requried=false is the default and can be omitted.
Return is not compulsory but will help end user to understand return value of module.
Use `env_fallback` ``` from ansible.module_utils.basic import env_fallback ... api_key=dict(fallback=(env_fallback, ['HEROKU_API_KEY', TF_VAR_HEROKU_API_KEY']), type='str', no_log=True), ```
`no_log=True` is argument spec will handle this.
http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#new-module-development There is written: ``` # during the execution of the module, if there is an exception or a # conditional state that effectively causes a failure, run # AnsibleModule.fail_json() to pass in the message and the result if module.params['name'] == 'fail me': module.fail_json(msg='You requested this to fail', **result) ``` AFAIK module should return with `module.exit_json` or `module.fail_json`, not `raise ValueError` for example.
Will this parsing also work when gluster isn't installed at all? In that case any meaningfull message would be nice.
I meant `IndexError` not `ValueError`, but it don't really matter. What I meant is, that isn't it better to have this safe contruct there: ```python try: main() except Exception as e: module.fail_json(msg=str(e), exception=traceback.format_exc()) ``` It's then better to debug issues.
Am not talking about `check_mode`, but about `change=True` / `changed=False`.
It's nicer and less error prone to send a list to module.run_command than a string.
Change description to match `enable` and `disable` dvSwitch.
period at the end of statement.
We are not dealing with Standard switch, right ? Also, we are not creating or removing switch.
Could you please change this to `switch`. We don't want to use `_name` anymore.
period at the end of statement.
Wouldn't it make sense if the module does that as well? Also: ```suggestion - To make the DNS record changes effective, you need to run C(update dnsserver) on the ipwcli. ```
Small typo: `s/affective/effective/`
Remove this as it is already declared above.
There is no need to make an api call just for checking that the zone exists. The ovh python package raise a ResourceNotFoundError that can be caught in the next api call to check if the zone exists.
ok, missed that!
Okay, sounds like an issue on Darwin. Let's convert to text on line 579 and then change the strings to u"" strings: ``` python from ansible.module_utils._text import to_bytes, to_native, to_text [...] system = to_text(platform.system(), errors='surrogate_or_strict') [...] if system == u'Linux': [...] elif system == u'FreeBSD': [etc] if system == u"Darwin": ```
Fedora 25 Linux, Python-3.5.2: ``` >>> import platform >>> platform.system() 'Linux' ``` So this seems to be a text string. If you're getting bytes we should figure out if it's only on Darwin or on some other version of python than 3.5.
Excellent. :-) I'll merge once that code is applied.
If we do have to keep it separate are we able to remove it when we remove tmp_path around line 728
this is basically noop, unless you are under pipelining, in which you get None, tmpdir will still be populated though
You'll need: ``` python retries = sorted(list(retries)) ``` sort() is an inplace sort and returns None.
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
This should not be it's own `display`. Instead it should be added to the existing `msg`
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
No need to quote the path, not using double quotes also means you don't need to double up on `\`, e.g. just do `path: C:\Windows\temp`.
Add the `r'''` to https://github.com/ansible/ansible/pull/49652/files/6dc61c94e3abd3cf74998b78f4fa08956a95c269#diff-1c417562a0944ee1362da84b93d9695dR56 to avoid it. We do this for all our module examples so we don't have to worry about escaping these values.
nope, looks like you missed this one.
since the plugin is called `aws_ssm`, I'd change this to `ansible_aws_ssm_retries`
All these vars should start with 'ansible_'
```suggestion - "Datacenter to search for given cluster. If not set, we use first cluster we encounter with C(cluster_name)." ```
```suggestion - "Name of Host group to use with rule." ```
```suggestion - "Name of VM group to use with rule." ```
`vmodl` is unused.
```suggestion Class to manage VM HOST DRS Rules ```
If you're only going to get `APSCOOKIE_` _or_ `ccsrftoken`, then you can just return `None` if you don't find anything and the existing token will be reused. If you are expecting to have both, then I would just dedent the next line to be outside the for loop, so that the token is always added to the dictionary on every run. Then you should be able to at least remove the manual headers building in `send_request`.
The return value is not strictly cookies. The return value is a dictionary of headers
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
You can do this all in the argspec `node_ip=dict(fallback=(env_fallback, ['rubrik_cdm_node_ip'])), `
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Nowadays we define the authors in a list: ```yaml author: - Trond Hindenes (@trondhindenes) - Peter Mounce (@petemounce) - Pepe Barbe (@elventear) - Adam Keech (@smadam813) - Pierre Templier (@ptemplier) ```
ditto about s/no/'no'/
there is no need to version params for new modules
there is no need to version params for new modules
there is no need to version params for new modules
@gundalow Removed the remark. Thanks again.
Assuming IP address can also work: ```suggestion - Provide the FQDN or IP address for the Itential Automation Platform ``` FQDN should be in caps
```suggestion author: "Itential (@cma0) <opensource@itential.com>" ```
```suggestion iap_port=dict(type='int', required=True), ```
```suggestion password=dict(type='str', required=True, no_log=True), ```
Don't need to import HAS_BOTO3 now.
We can't call this here because it raises an exception which is then unhandled. You'll probably have to make the argument_spec a string type with no limitations (in the argument spec, ie, no longer choices). Then, in the code after the AnsibleModule() has been instantiated, you can check that module.params['region'] is in get_dd_regions() [or 'na' if you keep that as the default value].
For examples we are standardizing on `key: value` Rather than key=value
If something calls `existsTag` before `getProject` is called, `project` will hold `None`, and will then cause problems. I think there should be a `GitLabProject` class (which should also go into the `ansible.module_utils` namespace) which should be passed in to this class through the constructor.
`User has been updated`
Make this a regular function
Tell people where we are looking `CONFIG_FILES`
Sure, a separate PR sounds good.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
This should be a @staticmethod and self removed.
my intention was to allow this but as a toggle, but not by default
Most of these 'regular' are the reason I added the exclusion in the first place, specially nfs, fuse and cifs, but basically all cluster file systems that use networking to deliver mounts are susceptible.
While you are here, can you please add support for - https://github.com/ansible/ansible/issues/24644 - https://github.com/ansible/ansible/issues/41494
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Rather than making these globals, store them as locals and pass them into the functions, or just run `mode.get_bin_bath` within the function. Globals are not worth the future troubleshooting complexity in this case, especially since `RPM_PATH` is the only variable used in two different functions.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Those lemurs at shippable sure need to work harder! ;-)
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
As a side effect on this, it should always result in `changed=True` similar to the `shell` and `command` modules.
Why use the funky `filter(None, ...)` to strip out extra spaces instead of just `.split()`? I.e., in what circumstance would this be insufficient: ``` current_label_list = list(set(current_label.split())) ``` Or, if you really truly need to only split on spaces (not tabs or newlines): ``` space_re = re.compile(' +') ... current_label_list = list(set(space_re.split(current_label))) ```
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
I'd suggest rewriting most of the preceding 25 lines with list comprehensions and/or some more reusable functions. This is all a bit too LISP-y and the readability suffers.
`, no_log=True` to hide secret things.
Wouldn't this create a conflict if someone ran this task twice with the same params, thus resulting in the same name (and a conflict)? Generating the name this way seems good, but can you add a check to make sure there isn't a changeset with that name already? If there is one, then you could return unchanged because the changeset already exists so this task's work is already done.
Prefer `del` over `pop` when not using the return value.
Yeah, I know you need module. That was just a general musing.
I think, unless you have a good reason, that you should use stack_params here and four lines down instead of module.params. Honestly I wish we didn't have to push module around.
```suggestion # require that the final recorded stack state was DELETE_COMPLETE ```
role_name can be lower case as well. For example, user can provide admin for `Admin` value, then this function will return None.
```suggestion "4. The account cannot be removed due to permission issues : %s" % to_native(security_error.msg) ```
```suggestion "on the root node: %s" % to_native(admin_permission) ```
```suggestion self.module.fail_json(msg="The role ID isn't valid %s" % to_native(not_found)) ```
consider calling these `role`, `tenant` with _name suffix, to match module arguments.
```suggestion msg='vRouter with interface %s does not exist' % ip ```
```suggestion cli += ' vrouter-show name %s format name no-show-headers' % name ```
This can be simplified as ```python VROUTER_EXISTS = '' if out else None ```
```python show = [cli, 'access-list-ip-show', 'name', name, 'format', 'ip', 'no-show-headers'] out = module.run_command(show, use_unsafe_shell=True)[1] ```
```suggestion if VROUTER_EXISTS is None: module.fail_json(msg='Vrouter does not exist', failed=True) ```
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
Another test that I would move into version specific classes with pytest skipifs
fixture with load_json
Another test that I would move into version specific classes with pytest skipifs
following task -> the following task
```suggestion type: path required: yes ```
```suggestion type: str default: https://intersight.com/api/v1 ```
The standardized parameter is **validate_certs**. I'd rather stick to the standards for this one. If you use the internal urls API, this would automatically be covered.
I'd rather have the standard behavior from other modules, which is to specify **use_ssl**. Check **uri** module.
```suggestion the original private key back if you created a new one by accident. ```
```suggestion - The value C(auto) selects a format based on the key. The value C(auto_ignore) does the same, ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
Maybe add an empty line above this one and give it a name, it seems like the `assert` task is just a parameter of the `openssl_certificate_info` one.
Note, not a blocker for this backport but a few things to keep in mind: * ````re.compile()```'ing these regexes outside of the loop would be a nice optimization * there may be something that's useful in ```ansible.module_utils.compat.ipaddress``` that would let us not maintain our own regexes for some of the things done here.
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
This is more efficient: ```suggestion key = next(iter(old[0]) ```
Please only import what you need, rather than `*`
Some wrapper modules are very light on this, and escalate the stderr output of the command to the user. I guess it depends on the complexity of the tooling and the possible impact of incorrect input. Is there a big risk of data-loss or data-corruption, then you may want to be more safe. Also if there's a big chance that valid options change more often, you may not want to restrict your module. But this is all mostly up to the maintainer. There's also a real concern related to supporting older/newer versions of the same tool too.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
add a `mutually_exclusive` section
This parameter is required if C(esxi_hostname) is not specified.
`Care should be taken ...`
```suggestion - If set to C(False), will add, reconfigure or remove network adapters according to the parameters in C(networks). ```
Also describe if it deletes the files or not
I don't think you need the `list` here - `for` can iterate over a `set`
I would use `build_full_result()` rather than arbitrary MaxItems. E.g. `paginator.paginate().build_full_result()`
Only do this is module.params.get('managed_policy') is not None
need to separate ClientError and ParamValidationError as the latter doesn't have an e.response object. Both exceptions should have `exception=traceback.format_exc()` (you'll need to `import traceback` at the top)
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
With pytest, we usually go for fixtures so that you'd have a separate fixture function patching staff and yielding some object for testing and the test function will be more readable and contain actual testing code with assertions. For example: ```python @pytest.fixture def patched_openvswitch_bridge(monkeypatch): with monkeypatch.context() as mp_ctx: mp_ctx.setattr( openvswitch_bridge, 'map_config_to_obj', { 'bridge': 'test-br2', 'parent': 'test-br', 'vlan': 200, 'fail_mode': None, 'external_ids': None, 'set': None, }, ) # code before "yield" is executed before test function yield openvswitch_bridge # "yield"ed value is what test function receives as an input # code after "yield" is executed after test function # and can be used for cleanup, we don't need this because # it'll be taken care of by the context manager def test_openvswitch_bridge_updates_vlan(self, patched_openvswitch_bridge): ... # patched_openvswitch_bridge is patched inside this test method ```
We usually prefer dict literals `{}` over `dict()` constructors/factories. (Although it's a holywar topic)
In this case, you don't need a generator, just ```suggestion return openvswitch_bridge ```
Drop `with` block and patch things directly. ```suggestion monkeypatch.setattr(openvswitch_bridge, 'map_config_to_obj', mocked_bridge) ```
Use `mocked_generic_connection_modify` fixture.
I would prefer that we stay away from nested functions like this if possible, moving into a scope where it could be tested independent of the `tests` method. We should probably give it a better name too. In `filters.core` we utilize a `unicode_wrap` function, so maybe we could do similarly here. We also use `partial` there instead of creating our own closure, but either way is fine with me. I'd also write tests to verify this functionality.
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
The pylint error is occurring because this `MockSelector` class shadows the one on line 59.
pyyhon2 -> python2
is_vapp_changed = False
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
move this line 1028
``` â¦ + + is_vapp_changed = True + + new_vmconfig_spec.property.append(new_vapp_property_spec) + + if is_vapp_changed: + self.configspec.vAppConfig = new_vmconfig_spec + self.change_detected = True ``` â ``` â¦ + + is_vapp_changed = True + if is_vapp_changed: + new_vmconfig_spec.property.append(new_vapp_property_spec) + if new_vmconfig_spec.property: + self.configspec.vAppConfig = new_vmconfig_spec + self.change_detected = True ```
Here too, I believe you don't need the `cdrom_exist` variable.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
`is not` vs `!=`? I may not be polished enough on my python...
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
For examples we are standardizing on `key: value` Rather than key=value
Same here. ```suggestion self.cron_file = os.path.join('/etc/cron.d', cron_file) self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict')) ```
The file is opened in binary mode. So there's no reason to try converting here as data is already bytes.
Instead, please set `self.index = json.load(f)`. The JSON library uses the `.load` function to stream straight from files without needing to `.read()` first. This also avoids pesky encoding issues with Python2/3.
i would add `: %s` and to_text(e)` to the end of msg
get_basedir should not be needed, the ansible_search_path should include the correct one
(In order to optionally not make frequent, redundant, probably unnecessary requests to the COPR API)
```suggestion # the variable if it hasn't been set by the user already. ```
Just for sanity sake maybe pull out ```python "copr:{0}:{1}:{2}".format(copr_server, copr_user, copr_project) ``` into its own var, since it's duplicated 5 times.
> Would this be better as `if key not in module.params` so we don't capture the case where the user explicitly sets things to `null`? The ansible way for the user to skip an upon is `{{ omit }}`
```suggestion # copr doesn't do this. This ansible module expects it to be a list so ```
rephrase of 'never used options, now it is recommended to always use options' .. which is 'format neutral', covering both `k=v` and `k: v`
this got named use_backend
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
we should also return if we both delegate executions and delegate_facts
Add that the user can specify the backend to use via the ```use``` parameter.
Looking at how this is handled, I wonder if this could be turned into a sequence of transformations. ```python _RST_TRANSFORMATIONS = ( (re.compile(r".. seealso::"), "See website for:"), # seealso directive (re.compile(r".. note::"), "Note:"), # note admonition (re.compile(r":\w+?:`"), "website for `"), # any role (re.compile(r".. \w+?::"), ""), # any directive ) ``` And then just ```python for regex, replacement in cls._RST_TRANSFORMATIONS: t = regex.sub(replacement, t) ``` (below)
Let's keep the naming aligned with docutils' own RST terminology/definitions, at least: ```suggestion _RST_ROLE = re.compile(r":\w+?:`") _RST_DIRECTIVE = re.compile(r".. \w+?::") ```
i would make these 3 into one (since they are basically same behavior)
And with `\1` you preserve what's matched but I'd argue it should always be normalized to `Note:`.
I wonder if it'd be hard to title-case the matched admonition. They are case insensitive. One can do any of ```rst .. Note:: .. notE:: .. NOTE:: .. NOTe:: ```
We don't need this import of Display since we have it again on line 87.
i don't think we want roles in roles
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion fw_family=dict(type='str'), ```
```suggestion table=dict(type='str'), ```
```suggestion supports_check_mode=True, ```
We avoid adding `required=False` and `default=None`, but we must add `type=str`. Same for the other options. ```suggestion chain=dict(type='str'), ```
Please remove choices for `type='bool'`, as `bool` accepts yes,1,true, etc.
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
I think this should be `if tags and tags != igw.tags:`. Otherwise if we're creating a gateway with no tags this condition will be met and it will crash later since there are no tags. On second thought, just make the default of tags be an empty dict instead of None, [here](https://github.com/ansible/ansible/pull/23782/files#diff-7c7439a69b0a017fb8e03a769c5ef29bR179) and it will fix the problem.
It might also be no IGWs found here.
We don't need tags in this function, I think.
```suggestion description: IP range of the network
The return docs should be changed as follows: ~~~ hcloud_location_facts: description: The location facts as list returned: always type: complex contains: id: description: Numeric identifier of the location returned: always type: int sample: 1937415 name: description: Name of the location returned: always type: str sample: fsn1 description: description: Detail description of the location returned: always type: str sample: Falkenstein DC Park 1 country: description: Country code of the location returned: always type: str sample: DE city: description: City of the location returned: always type: str sample: Falkenstein ~~~
```suggestion description: Subnetworks belonging to the network
An `EXAMPLE` of labels maybe good so people know the structure
i would suggest to make `name` required if `state=present` because idempotency: you should not known the state (already exists or not) in arg spec ~~~python required_if=[[ 'state', 'present', ['name']], ~~~
If you do `module.get_bin_path('subscription-manager', True)` then `get_bin_path` will call `self.fail_json` directly, do you can delete the lines ``` if not SUBMAN_CMD: module.fail_json(msg="Could not find subscription-manager. Please ensure it is installed.") ```
If source is None, the conditional `not source` will be true. So I don't think the second part of this conditional will ever hit.
PS I also modified the last conditional in that list.
```suggestion raise ValueError('Error while adding new LUKS keyslot to %s: %s' ``` While you're at it ;)
You may be able to simplify this buy using the helper functions `required_one_of` `mutually_exclusive` `required_together` Have a look at existing modules for examples
Please add a `version_added` to this as well.
`Telemetry data not capture` to `Telemetry data not captured.` as per below.
Is it possible to add a check for `grafna_user` and `grafana_password` options here ? with a warning message "You must provide a grafana_api_key or a grafana_user + grafana_password option". The rest Looks good to me
@rrey This warning shows up every time `ansible` or `ansible-playbook` is run when the plugin is not being used.
this is not an issue with this callback, `set_options` should never be called unless it is specifically whitelisted
@tstoner I am curious why you are raising `TypeError` if capabilities cannot be fetched. Given that the new options added in this PR are not the required options for `nxos_nxapi` module, I don't think we want to fail the module if `device_info` is None. Same for `os_version` and `os_platform`. The module can simply ignore the task and pass when these parameters are used with a warning message if capabilities isn't available instead of failing/raising exception.
Same question for dropping lambda here as well.
You can use `module.deprecate` to throw a deprecation warning.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
Missing `=dict` on this and the next few lines
We should be using `ansible.module_utils._text.to_bytes` instead of this method.
@phjardas Are we restricting to only use in `tcp://HOST:PORT` format ?, still `tcp:HOST:PORT` is valid, `socat` allows you to read it from. Can you please fix the regex match so that it allows to pick the HOST and PORT for admin socket even if its in `tcp://host:port` or `tcp:host:port` format.
Use `self.module.fail_json` instead of `Exception` ``` self.module.fail_json(msg="Invalid TCP address: '%s'" % self.socket) ```
add CALLBACK_NEEDS_WHITELIST = True this is recent addition, it keeps plugins shipped with ansible from being executed automatically unless whitelisted through config.
New connection plugins should be using the recently added `self._play_context.executable` for executable. Take a look at the lxd plugin for an example.
`six` is [bundled with Ansible](http://docs.ansible.com/ansible/latest/dev_guide/developing_modules_python3.html#bundled-six).
<nod> I've gone back and forth with people. Since dynamic inventory runs out of process, some people don't want to have to depend on six. I've been merging either way.
I'd probably recommend using six, instead of a try/except dance. ansible ships with six in `ansible.module_utils.six` that can be used here.
This can be directly imported from six: ``` python from ansible.module_utils.six.moves import configparser ```
This doesn't really matter since only a single instance of ForemanInventory is created in this script but config_paths should really be an instance attribute (created and given an initial value in ```__init__```) rather than a class attribute. Class attributes exist a single time per class. All instances of the class would share the same instance of that attribute. Instance attributes exist, one per instance and thus can change independently. Modifying config_paths later in the code is a tip-off that this should be an instance-attribute rather than a class-attribute. Also, you can probably move the setting from an environment variable to be with this code when you do that. It would seem to make sense to keep that all together.
This is not a good idea, since `ca_cert` is already a module option. (Due to `url_argument_spec()` above.) Either do ```suggestion feed_ca_cert=dict(aliases=['importer_ssl_ca_cert'']), ``` and make sure that `feed_ca_cert` is set to `ca_cert`'s value if not set, or name the option `ca_cert` and add `feed_ca_cert` and `importer_ssl_ca_cert` as aliases. (Then there's no way to separate these options.)
Hmm, I was pretty sure it was in there. Apparently, I'm wrong. Sorry!
```suggestion feed_ca_cert=dict(aliases=['importer_ssl_ca_cert','ca_cert']), ```
The fallback env variable is called `DOCKER_TLS`, not `DOCKER_TLS_VERIFY` (that's the one below).
this should be a common function in basic.py (i think there is this one or the reverse there already)
I would probably go for an immediate default: ```python command = "ps aux" if terms: command = "%s | grep %s" % (command, ' '.join(terms)) ```
You invoke it yourself, so do validation in lookup plugin class
Oh, and in Python we tend to avoid string concatenation with "+"
You'd probably want to do validation as a first thing in the function and then stop caring about checking things. This seems a logical thing to do.
I bet it's possible that this thing raises `IOError`
It doesn't really work that way, since docker indicates "no healthcheck" by returning `None` (I think), which isn't compatible to what `comparisons` does. I don't understand why this logic (you mean `disable_healthcheck`?) conflicts with `docker`'s original logic? In any way, I think we have to convert the string syntax for `test` to `CMD-SHELL`, otherwise idempotency won't work. That's a good point! (We should also have a test for it.)
I think the `disable_healthcheck` is redundant, we can leave the logic to `comparisons` and users to handle it. Introducing this logic might also conflict with `docker`'s original logic, as `docker run --health-cmd ANYTHING` will always generate a "CMD-SHELL" entry in `HealthCheck.Test`(tested on CentOS with docker 1.13).
Ok, there's one thing we forgot: a `timedelta` object also has `days`, and seconds are up to one day. Fortunately, there's an easier way to do this all: ```suggestion time_in_nanoseconds = int(time.total_seconds() * 1000000000) ```
just call scaleway.ini we are in ansible conflict should not occur
Need a colon at the end here
```suggestion if type is not None: ```
Should this be a call to a function that does handle retries (all the other API calls in this function seem to at least be capable of that)
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
What do you think about making this required=True and removing the default? I think it would be best to make sure that users are fully aware of which zone they're using. Many users don't use the us-central1-a zone.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
Might be worth validating that zones is a list rather than a single zone provided as a string.
Please also add whether filters that are listed in separate list items are an `OR` or an `AND`
Please add that the default is "all accessible zones" or whatever the semantics are of that list-zones call.
The `options:` entry appears to be responsible for the `ansible-doc` failure.
These two lines are not needed, as there is no reason to filter out the option when delegating.
The `u` prefix should not be needed.
Why not this instead? ```suggestion if 'no such image' in ex.stderr: ``` Or use `ex.stdout` if the error is on stdout. The same applies to the other changes as well.
```suggestion return {} # podman does not handle this gracefully, exits 125 ```
You should be able to use `self.vmware_test_platform` here.
If you don't want to put the router data in a separate file, I would prefer the following for readability ```python return_value = """ router ospf 1 bfd router ospf 2 """ I know the alignment looks a bit odd but it's easier to read IMO.
`my_vrf -> obvious_vrf`
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
Make this `elif`.
*nit* `/play.For/playbook. For /`
Oh, and the new PR will need a separate backport to the stable-2.9 branch too since we branched that on Thursday last week.
This doesn't look right. If the user requests that the service is started then the service should be running after the task ends. But with this change, if the service is deactivating when the task runs, then the service could be stopped by the time the task ends (or at some point after the task ends and before a task which needs the service to be running starts).
@kustodian Make a separate PR in devel. Ping me and I'll merge that. Then you can cherry-pick that commit onto this PR and I'll merge this as well. Thanks!
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
Use `msg` instead of `result` attribute ```suggestion module.exit_json(changed=True, service=remote_service.attributes, msg='Successfully deleted service %s' % service) ```
Should we add here that the win_copy module is not a very efficient transfer mechanism and if possible using HTTP downloading using *win_get_url* or *win_uri* is preferred.
Yes, so what I am saying is to keep it simple, and if no name was provided (with `state=absent`), delete the path. If a `(default)` name was provided, remove that key (as in unsetting it, just as the registry editor is not showing an unset `(default)' key). So you don't need the additional `delete_key` parameter, and it's actually as one would expect it to work. The `name` parameter was optional.
I would have preferred a more explicit removal of `name=(default)` for the removal of the default key. This is to me more confusing (because whether it is set to `yes` or `no` it will delete a key. So I would get rid of this option altogether.
resue the function here https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L73 to avoid code duplication
s/./ to avoid infinite hangs waiting for input./
C/P error, should be `AWS ElastiCache is down`? Same on L450
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
You should handle check mode here!
You should always have `type='str'` (or whatever type you have) in all of argument spec.
You could move this a couple lines above and remove the two in the elifs below.
In python, this is probably better represented as a global dictionary in a separate module (as outlined above). Something like file serviceprovider.py: SPKEYS = { 'ID': 'id', 'NAME': 'name', [..] } ```
This will fail if ```updated_list``` has items which are not present in ```original_list```. You probably want something like this instead: ``` python merged_items[item_key] = items_map.get(item_key, {}) merged_items[item_key].update(item) ```
There's a lot of copying going on here as well. Both on this line and on line 456. Copying is slow so you want to eliminate any that aren't needed.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
```suggestion version_added: '1.9' ```
Both `required: true` and `default: null` are not needed anymore. You can leave them if you like, but I thought I'd mention it.
It looks to me like these URLs are better suited for a `seealso` section.
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
```suggestion - The VM to use as the source (template). ```
```suggestion - Will also define the VMs hostname. ```
```suggestion required: false type: str ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
This should be configurable in the module arguments.
If we do go with this approach, I feel like `VMDB_PATH` should be user-configurable
You probably should just exit here with `changed=False`
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
the `and retries >= CONFIRM_UPDATE_MAX_RETRY` is redundant here. If the execution got here, it'll always be `True`
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
period at the end of statement.
We are beyond 2.7 development cycle, we need to update this to 2.8 as it is current development cycle.
We are not dealing with Standard switch, right ? Also, we are not creating or removing switch.
period at the end of statement.
Could you please change this to `switch`. We don't want to use `_name` anymore.
Making `name` optional is probably a good idea.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
From the way the docker modules currently operate, it probably makes sense to add a `AnsibleDockerSwarmClient` to `module_utils/docker_swarm.py`, which extends `AnsibleDockerClient`. Then `docker_swarm`, `docker_swarm_facts`, `docker_node` and `docker_node_facts` could use `AnsibleDockerSwarmClient` instead of using `AnsibleDockerClient` directly.
Wrap the contents of `msg` in `to_native` to ensure it's the proper encoding based on the Python version.
No need to split the line.
Various modules allow to specify the name of the executable in order to use a binary from a non-standard location (i.e. a binary not located in the PATH). Look at e.g. the isoextract on how to do this.
What if the flatpak name contained the string 'error' ? Seems a recipe for disaster.
This could move even more down. After listing apps.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
...The remote host **MUST** support...
I think we need more info here what are possible choices.
s/will created/will be created/
minor: if a user would set display_name: "", this would not be triggered here. Explicitly checking for none? ~~~diff -if not display_name: +if display_name is not None: ~~~
Not pep8, if a user wants to clear variables by providing a emtpy dict, `if variables:` would be false while `if variables is not None:` wouldn't. I don't know if this is a use case, that is why I am asking.
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
we can probably change it to a list, still this would be the wrong executable in some cases as it does not allow per host config, its also redundant to fallback to /bin/sh as it always is set (default is /bin/sh already). In other cases it will still be a problem, specially when privilege escalation is involved, due to the quoting.
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
there could be a function to convert entire list, as this code is repeated below
why fail here? I think we should just do nothing
Shouldn't these be `not_actions` ? ... and the tests should probably include some of these to catch the fact that they're not working... ;)
All of these uses of `str` should be switched to `to_bytes(var, errors='surrogate_or_strict')`. `to_bytes` comes from `ansible.module_utils._text`.
Thanks for the confirmation!
You don't always have a guarantee of `other_var` being the same type. And `'some str %s'` has different types under Python 2 and Python 3. That's why it's important to explicitly use the correct literal.
Oh, and in places with variables where you concatenate that with literals, also apply this function to avoid certain edge-cases which appear sometimes when you try to merge different data types.
Yes, you can convert resulting strings. But when concatenating things it may result in unpleasant side-effects. ```python # WRONG b'some str %s' % other_var # <-- Python (esp Python 2) tries to turn `other_var` into bytes, sometimes incorrectly which may even cause exceptions in obscure cases ``` ```python # CORRECT b'some str %s' % to_bytes(other_var, errors='surrogate_or_strict') # when you convert it explicitly, it'll always succeed ``` If you don't like this `errors='surrogate_or_strict'` part, you can use curring: ```python from functools import partial ... from ansible.module_utils._text import to_bytes ... to_bytes_sos = partial(to_bytes, errors='surrogate_or_strict') # ^ # | # | # somewhere at the top of the module ... # And everywhere else in code: # | # | # v b'some str %s' % to_bytes_sos(other_var) ``` Hope this helps.
You need to check the requirements (PyYAML and GlusterFS > 3.2) there.
`force` parameter: use boolean type
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
This line is too long. Max line length allowed in Ansible is 120 characters.
`changed=True` would be better.
note, that `type: <...>` should be added to all params. here `type: str`. It will be enforce by sanity check very soon
to me it looks that port should only be required if state=present --> see required_if helper
to me it looks that protocol should only be required if state=present --> see required_if helper
not a blocker but the convention is to have `present` as default, please also consider this for your module.
Short description shouldn't have a period.
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
This check can be also moved to `module_utils`.
`delete_volume` does not require size. This check will force user to specify size even if he/she is deleting the volume. I feel this is not intuitive UI/UX.
str? ```suggestion size=dict(type='str') ```
```python if state == 'present': if not volume: create_volume(module, array) elif volume: update_volume(module, array, volume) elif state == 'absent' and volume: delete_volume(module, array, volume) else: module.exit_json(changed=False) ```
Note: This syntax is python-2.7 or greater. Using .format() with positions is 2.6+: ``` python cmd += ' {0}'.format(uuid) ``` It's more pythonic to create a single string rather than two. for instance: ``` python cmd = '{0} {1}'.format(cmd, uuid) # or cmd = ' '.join((cmd, uuid)) ``` If you need to be compatible with python less than 2.6, you need to avoid .format() altogether. So the .join method or percent formatting: ``` python cmd = '%s %s' % (cmd, uuid) ```
note, the spelling of this word is: vacuumed. Probably should change it everywhere.
If this requires a higher python version than 2.4 then there needs to be a requirements section that lists it (for instance): ``` requirements: - python >= 2.6 ```
I don't see any imports that would dictate that this require python 2.6 or higher.
To format this a little better I'd suggest using `C(..)`, also explain what * means. `Image UUID. Can either be a full UUID or C(*) for FIXME.`
No need to re-add these docs, as the default for any non-specified param is `null`
`required: false` already denotes `optional`, but I'm not against this update
The original phrasing is more complete
These lines should also be removed
This is undoing the example.
While you're here could you change it or add a `except botocore.exceptions.ClientError as e:`? (I don't know if it might raise a ValueError, but I see it can definitely can raise a ClientError). In addition if you keep 'except ValueError as e' the module.fail_json below it needs to be left as it was before + exception=traceback.format_exc() since ValueError doesn't have an .response attribute.
Just noticed you're rewriting security_groups that has been set on line 248. This eliminates the ability to specify a mix of security group ids and security group names. You can delete this line.
The CamelCase exception .response attribute is particular to boto3's ClientError. IOError doesn't have .response so you can remove the `**camel_dict_to_snake_dict(e.response)` bit of this.
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
From the way the docker modules currently operate, it probably makes sense to add a `AnsibleDockerSwarmClient` to `module_utils/docker_swarm.py`, which extends `AnsibleDockerClient`. Then `docker_swarm`, `docker_swarm_facts`, `docker_node` and `docker_node_facts` could use `AnsibleDockerSwarmClient` instead of using `AnsibleDockerClient` directly.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
Same function in `docker_swarm` module. It will be better to create a new module `docker_swarm_common` to assemble common code.
Making `name` optional is probably a good idea.
Good catch, thanks @samdoran
Can we have a list of packages which can be locked/unlocked? just like yum module does.
```suggestion - Name of the package to install, upgrade or remove. - The C(all) package can be used to .... ```
use this instead ``` module.get_bin_path('yum', required=True) ```
For the author information we normally only keep name and GitHub handle.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
Could as well drop this now: ```suggestion if not context and arg == 'state': ``` because the intersection with an empty set is always an empty set which will result in no iterations of that for-loop
After the refactoring, it's probably okay to inline it back since it's used in one place now: ```suggestion bad_states = {'list', 'info'} & set(data.get('choices', set())) ```
Ah. I thought you're talking about `dict.get()` being not enough for the validator.
I wonder if there are more correct than wrong uses of `get` :) I mainly know its use in `route53`, where it shouldn't be a state.
(if that doesn't work, change `&` with calling `set.intersection()`)
I would have write: ``` - try: - task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) - success, result = wait_for_task(task) - return success, result - except TaskError as add_task_error: - # This is almost certain to fail the first time. - # In order to get the sslThumbprint we first connect - # get the vim.fault.SSLVerifyFault then grab the sslThumbprint - # from that object. - # - # args is a tuple, selecting the first tuple - ssl_verify_fault = add_task_error.args[0] - host_connect_spec.sslThumbprint = ssl_verify_fault.thumbprint - - task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) - success, result = wait_for_task(task) - return success, result + for _ in range(0, 2): + try: + task = self.cluster.AddHost_Task(host_connect_spec, as_connected, resource_pool, esxi_license) + success, result = wait_for_task(task) + return success, result + + except TaskError as task_error_exception: + + task_error = task_error_exception.args[0] + if self.esxi_ssl_thumbprint == '' and isinstance(task_error, vim.fault.SSLVerifyFault): + # User has not specified SSL Thumbprint for ESXi host, + # try to grab it using SSLVerifyFault exception + host_connect_spec.sslThumbprint = task_error.thumbprint + else: + self.module.fail_json(msg="Failed to add host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) + + self.module.fail_json(msg="Failed to add host %s to vCenter: %s" % (self.esxi_hostname, task_error.msg)) ``` It seems vim.fault.SSLVerifyFault and other vim.faultâ¦ are always packed in a TaskError.
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
if self.state == "absent" should be explicitly checked before unregistering the VM, just to be safe.
`Current host '%s' can not be rebooted...`
`Current host '%s' can not be shut down...`
Might be worth validating that zones is a list rather than a single zone provided as a string.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
You can use get_option() instead of accessing the dict directly.
The inventory still needs to be populated with the results from the cache. The cache plugins themselves get/set data, but do not use it.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
`a['adress']` could be used instead of `(len(a['address']) > 0)`.
You can do `return pg.paginate(Bucket=bucket).build_full_result()` Not a blocker though
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
Should this have some exception handling? (I suggest here rather than paginated_list as paginated_list might not be able to handle exceptions if it does the retry)
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
Empty proxy-init doesn't make sense and should be removed.
this produces an exception when binary cannot be found, you should capture and return parser error
you should probably put these check even before `super()` line
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
Capital letters & full stops please
Create address service object on PanOS devices This may need updating on existing modules
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
`required: false` lines can be removed
Please remove this line
`Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.`
`Description` (capital letter)
That code looks similar to `./bigswitch/bigmon_chain.py`, so that should be fine
typo here `suboptins` I suspect should be `suboptions`
I pushed this change in my commit to the code
Okay... We shouldn't let tests drive implementation (unless it's a case where the implementation is more modular, easier to read, or more flexible once it's adapted to the test case). let me take a look at updating the test case.
the shell itself would have done it before. but might have done it slightly differently.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
tempted to say just use check_opts=True and remove syntax check afterward with remove_option (we do this in ansible-inventory).
I think that makes sense. Right now the fact that we download the collection is an implementation detail. So something indicating `--local-only` or `--no-server-verification`. Just some ideas.
Just to make an attempt at word-smithing > When doing an --list, represent shared variables inside groups or the inventory, > which has a smaller memory footprint but is not Ansible's internal representation
Tell people where we are looking `CONFIG_FILES`
Please fix: '... if it doesn't exist:'
`zone` is returned, but not zoneid
I would suggest to set `type='int' for vlan.
rename to `zone`
rename to `cluster`
missing `if not self.module.check_mode`
better to move this line in else part. something like ``` if hasattr(resp, 'data_xml') or hasattr(resp, 'data_ele'): result = resp.data_xml else: result = resp.xml ```
Can we print entire error rpc. In case of error `message` alone is not very helpful.
You shouldn't need this if you have `required=True` on both options.
Did you try using `jxmlease` for dict to xml conversion? As it is already used in other modules it makes sense to reuse it. ``` from jxmlease.dictnode import XMLDictNode XMLDictNode({'unlock': {'target': {'candidate': None}}}).emit_xml() ```
I'd do ```suggestion if not ignore_errors: raise ```
This should probably be `docker.exec_command()`
kushal found that check_call is 2.5 ; check_output is what is 2.7.
No longer using a temporary file. This issue is resolved
s/write target file {0}/fetch file to {0}/
Yeah, a list is fine.
use ```from ansible.module_utils.vmware import find_obj```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
```suggestion - If set to C(False), will add, reconfigure or remove network adapters according to the parameters in C(networks). ```
`changed=True` would be better.
`force` parameter: use boolean type
You need to check the requirements (PyYAML and GlusterFS > 3.2) there.
I meant `IndexError` not `ValueError`, but it don't really matter. What I meant is, that isn't it better to have this safe contruct there: ```python try: main() except Exception as e: module.fail_json(msg=str(e), exception=traceback.format_exc()) ``` It's then better to debug issues.
Will this parsing also work when gluster isn't installed at all? In that case any meaningfull message would be nice.
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
Please remove this line.
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
With the latest change this import is no longer needed: ```suggestion from ansible.module_utils.six import text_type ```
We should probably put this into ansible.utils.unicode with a note about when to use it and what sort of literals to use it with for those that don't understand the native string distinction.
Please use `load_provider()` defined [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network_common.py#L340). You can refer [this](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L48) action plugin.
You can just `return` without `else`.
`IGNORE[xxx]` is used as something iterable, and I don't think any of the calling code wants a list of letters :)
It should be a dict, flattened like other AWS Ansible modules. You can use boto3_tag_list_to_ansible_dict for the transformation.
This needs BotoCoreError and ClientError exception handling: ``` except (BotoCoreError, ClientError) as e: module.fail_json_aws(e, msg="Unable to terminate job flows for cluster {0}".format(cluster_id)) ```
Needs exception handling here too.
This needs exception handling.
This should be called tags for consistency with the other AWS modules. It also appears tags are only changed/added by this module when first creating the job flow but it should be modifiable since the API supports this with add_tags() and remove_tags(). Here are some general guidelines for dealing with tags. https://github.com/ansible/ansible/blob/bf304832ffb8fc723c4d2f755e2e45ba17809f73/lib/ansible/modules/cloud/amazon/GUIDELINES.md#dealing-with-tags Here are a couple module examples, though there are many: https://github.com/ansible/ansible/blob/ab96a841542478189a6195a05ff748565613056f/lib/ansible/modules/cloud/amazon/ec2_ami.py#L568-L585 https://github.com/ansible/ansible/blob/1905a6e8fb38a6d85eed5632c45250aa676715d9/lib/ansible/modules/cloud/amazon/ec2_vpc_route_table.py#L337-L360
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
we have existing byte/bit functions in module_utils
Could you add at the top of Apply the following line. This will create an ems log event for users with auto support turned on. netapp_utils.ems_log_event("na_ontap_ldap", self.server)
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
Ah yes sorry, ~~prefix~~ suffix
I would add a note saying this does not relate to the partitions file system formatting.
If we have an explicit map we should be using snake_case for this, e.g. `system_partition`, `microsoft_reserved`, and so on.
Would add a note saying this does not deal with disk initialization and file system formatting.
I think this should be a mandatory option when creating a disk and we don't randomly choose one.
rm debugger hook.
missing import of get_exception()
this is one of the pep8 rules we don't need to follow
pep8 stuff ``` if 'names' not in vmap: ```
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
You don't need to specify required=False or default=None or type='str' for any of these as it is the default.
There should be a check before https://github.com/ansible/ansible/pull/24292/files#diff-aaef1b3abde00153e8695bfdf79c5e55R1882 that HAS_BOTO3 is True.
If the tags option is a dict you can use python_dict_to_boto3_tag_list instead of implementing the functionality here.
This module is not idempotent if you can't run it twice with the same arguments. If you have to know the distribution ID to update it, but not create it, then this is not going to work as it should. Really it should be searching for a distribution that matches the unique distribution properties (presumably the origins of the distribution)
I like that you've put some reusable functions in module_utils. I'm still reviewing this, but one thing I've noticed is that this module always shows changed=True and e_tag is always modified. When I run ``` - name: try one cloudfront_distribution: state: present enabled: false e_tag: "E3OUIFFZ9OWBTR" ``` Running that once does modify the expected distribution. But running a second time, a new distribution is created and e_tag disregarded (since with the first run e_tag is modified regardless of whether or not changes should be made). That seems unexpected.
I understand what you're trying to do here, but managing both parent as child objects in a single module is going to be problematic IMO. This can only work if your childs are always fully listed (and replaced/updated).
Same here, the first line should give information what the parameter is about. Subsequent lines clarify the value and dependencies. So in this case you'd have at least 3 items in the description.
Do the same for the following options too.
In the metric system, 'kilo' is abbreviated as 'k'. I guess this is wrong in the UCS interface though.
This line does not need quotes. (nitpick)
Awesome, thanks for making such a comprehensive post ð
```suggestion - Parameters used for Updating or Deleting subscription. type: str ```
Normally your full name here. Not sure what the policy is on commercially supported modules.
```suggestion - Type of desired protocol type: str ```
Replace line 81 to 97 - with ```yaml - name: Create an event subscription spotinst_event_subscription: account_id: token: state: present id: sis-e62dfd0f resource_id: sig-992a78db protocol: web endpoint: https://webhook.com event_type: GROUP_UPDATED event_format: { "subject" : "%s", "message" : "%s" } register: result ```
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
Please replace with `type: false`
`Specify authentication algorithm.` No need to repeat what's in `choices:`
No need for quotes here.
As we no longer care about 2.4, I think this can be cleaned
Yep. In default configurations, pylint will complain that Exception is caught (exception too broad). It does not complain that the exception is not assigned to a variable. (Our configuration of pylint allows catching Exception. Mostly because it would be extremely time consuming for us to clean that up... Having to evaluate every usage of Exception to see if it is valid or should be replaced with something more targeted)
Note for the next time you need to do some work in here: rather than use a dummy variable, it's more idiomatic to just not assign the exception to a variable: ``` suggestion except Exception: ```
I would used the internal urls API for this, it covers a lot more functionality out of the box.
I don't really get this, why not just do. ```suggestion auth_str = "Signature" ```
CTR mode doesn't actually require padding, so this is unnecessary. That said, I assume you're staying compatible with existing vault implementations which already do this. It's not a security thing, just a few wasted bytes/CPU cycles.
Is there no existing Python library to manage BLOCKS API logins & resources? Ansible is ok with modules that require an external client (such as the `boto3` client for AWS APIs, or `shade` for OpenStack). If there's an equivalent for PubNub it would be great not to duplicate code here.
Instead, you can use `return data.get('name')` and it will return None if name is undefined.
To get urlencode, please use `six.moves` instead.
To import urlencode, you can use this line: ``` from ansible.compat.module_utils.six.moves.urllib.parse import urlencode ``` Then for the rest of the file just use `urlencode` as normal.
Ah, I see. Thanks for clarifying!
That's fair, but you can wrap the file descriptor in a `file` object: https://docs.python.org/2/library/os.html#os.fdopen
I'm not positive about this one. Before the `try/except` would catch errors making a tempfile too, but now it will not. I think we need to wrap this individually from the `os.fdopen`, move the existing `module.fail_json` up here, and then reword the `module.fail_json` that handles opening the fd.
It's better to keep the file opened in binary mode and then transform the lines into bytes explicitly. That gives the program explicit control over encoding on both python2 and python3 rather than leaving it up to the whims of python and the underlying platform's configuration. So something like this: ``` python from ansible.module_utils._text import to_bytes [...] f = os.fdopen(tmpfd, 'wb') f.writelines(to_bytes(lines, errors='surrogate_or_strict')) f.close() ```
this is basically noop, unless you are under pipelining, in which you get None, tmpdir will still be populated though
ehm, this should stay here. ;)
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
``` python except KeyError as key_name: ```
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
Please fix: '... if it doesn't exist:'
'exists' -> 'exist'
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
```suggestion type: list elements: str ``` It's helpful to define that the list is a list of strings (or what ever).
```suggestion - Either I(tag_keys) or I(tags) is required when the state is absent. ```
I(....) adds the highlighting that this is an argument name.
```suggestion - A list of tags to be remove from the resources. ```
In this case, you don't need a generator, just ```suggestion return openvswitch_bridge ```
Drop `with` block and patch things directly. ```suggestion monkeypatch.setattr(openvswitch_bridge, 'map_config_to_obj', mocked_bridge) ```
For encrypted you should be able to assert something about the format: ``` >>> crypt = getattr(passlib.hash, 'pbkdf2_sha256') >>> crypt.encrypt(u'asda') '$pbkdf2-sha256$20000$PUeoVar1/h8jxNjb./8fgw$UzKj5pfmKEDtguOh.XEvHCqQr2b4AHPgwL/M8BEzez8' ``` Initial string, number of "$", length of the salt and length of the hashed value.
Unfortunately, pytest3.x broke this syntax. The new syntax is: ``` pytestmark = pytest.skip('skipping as missing required netapp_lib') ```
Could make this into a generated testcase if you were so inclined.
Ah, those just map the shorter names to the longer ones...
Removing `lower()` (and maybe adding a few mappings by hand) seems like the safer/cleaner option... `uid != UID` and `mail != Mail` is already bad enough in OpenSSL's OID mapping...
uid number 1 and...
```suggestion serial_port=dict(type='int', required=True), ```
I think it's nicer to have trailing commas: ```suggestion ], indirect=['mapping'], ```
The answer to that is in the commit message: "If the code fails in shutil.copy2 or shutil.move this should not be related to issue #13981 since they write to b_tmp_dest_name."
so this makes more sense now
so this looks like a problem `shutil.move(b_src, b_tmp_dest_name)`
are you sure this is what we want? b_src should be what we 'tried to copy to b_tmp_dest_name'
You could either do an os.path.exists check here to decide based on whether b_src exists or you could abstract the unsafe_writes fallback into a helper method, and then write two try: excepts that target each section of code. If the code fails in shutil.copy2 pr shutil.move then call the helper function with b_src. If it fails in os.rename then call the helper with b_tmp_dest_name. atomic_move is getting rather long so the latter may be the better option.
This and other instance attributes should be defined inside `__init__`. Recommendation: - Define as `None` in `__init__` and set in another method. - Set in `__init__` directly or by using the return value of another method. This makes it easier to locate all the instance attributes since they're all listed one place.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Missing space after comma.
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
use boolean type, "yes" and "no" are supported for boolean types
choices: [3, 4]
```yaml state: description: - indicates if the ntp peer exists or should be deleted choices: ['present', 'absent'] type: str ```
same as above remark regarding enabled_state for peers
should be bool
this can return an exception
this should probably use the BOOLEAN tests from module_utils
```suggestion elif date_string.match(self.when): ```
It seems like no_log and deprecation are separate things and should be handled in separate functions.
we want want -> we want
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_one_of ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
Similarly, this option is highly `network_cli`-specific, so much that I'm pretty sure `netconf` doesn't even need it. This should go back to `network_cli`
doc typo, s/funcition/function
```suggestion self.queue_message('vvv', "ESTABLISH GRPC CONNECTION FOR USER: %s on PORT %s TO %s" % (self.get_option('remote_user'), port, host)) self._channel = implementations.Channel(channel) ``` This to be consistent with other connection plugins (netconf, paramiko_ssh, etc.)
`Can be configured form the CLI via the C(--user) or C(-u) options.`
`Sets the connection time, in seconds, for the...`
```suggestion short_description: Execute tasks inside a VM via VMware Tools ```
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - Does not work with 'become'. ```
```suggestion - pyvmomi (python library) - requests ```
```suggestion - pyvmomi (Python library) ```
The `â` isn't an ASCII `-`, which is causing CI failures.
```suggestion type: bool ```
```suggestion type: str ```
Missing `=dict` on this and the next few lines
asa_argument_spec import is no longer needed
This is not a blocker, just a thought on the interface.
The only odd behavior I can create is if I set 'collections_paths = :' (an empty list) ``` ini [defaults] collections_paths = : ``` In that case, the collection ends up getting installed into $PWD/ansible_collections/. But I suspect that is a general issue with config types of 'pathspec' and not specific to collection_path.
Yeah, this should probably be an error if the config has explicitly removed the paths...
add a method for a file, then /dev/stdin will be a subset of that
Sure, a separate PR sounds good.
Since a lot of people have been relying on broken functionality (filtering without specifying a unique identifier), perhaps we want to add something to the docs, clarifying how modification should work. The examples for modify do use eni_id though, so perhaps we don't want to add to the docs and instead should just let people know when relevant issues are run across that the functionality only ever would have worked due to chance. Not requesting a change for this, just wondering about your thoughts.
Ah, right, got it :+1:
```suggestion msg = "Couldn't associate Elastic IP address with instance '{0}'".format(device_id) ```
Oh, nevermind, you're right about this. I guess the filters are entirely optional and it will just get all of the enis in this case. It could accidentally work (if you have only a single network interface) if you don't add this.
It may not be forward compatible then, but it seems unlikely AWS would change it unless they introduced something new.
Reading the code, this appears to expect a hostname and not a URI.
Inconsistent number of blank lines between blocks.
Rename this to `validate_certs`
It's safer to quote unvalidated strings with, e.g., [`urllib.quote`](https://docs.python.org/2.7/library/urllib.html?#urllib.quote) before concatenating them into a URL.
```suggestion - Boolean of whether to validate SSL connections. ```
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
Parentheses around `e.message` are useless.
No longer needed.
We now have a one-line GPL license statement.
FYI you can replace this with `type: bool`
```suggestion - The administrator password for the BIG-IP device. ```
The short_description never has a trailing dot. Help keep the index clean !
oh tricky i didn't noticed this typo
The 2 `if` can be merged.
from ansible.module_utils.vmware import get_parent_datacenter
+1 for to_text
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
Incorrect description; "If remote gateways can be used on this virtual network."
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
security group -> security groups
See my point in the non facts module around snake_case.
that should be example of module usage, not return value
I think it would be more helpful to the user to show them both errors by default rather than hiding one in `-v`. Ideally we could have templating errors take precedence over loop errors and only display the templating error first, but that may not make sense in all situations. If we don't want to display both as was done originally, then I'm fine with the current use of `-v` rather than using debug since debug is information overload for users.
Yeah, I had the same problem. I tried changing the exception type raised in `templar.template()` and catching that here, but still couldn't get it quite right. Seems like putting it in `-v` is an improvement over what we have now until we can come up with something better.
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
Aren't we losing some good "text" here? Shouldn't probably do more than just `to_native(e)`
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
unnecessary import - defaultdict is not used
May want to use the configparser in 'ansible.compat.six.moves.configparser' here. Otherwise there are py2/py3 compat issues.
contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionRqstError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.LoginError' imported but unused contrib/inventory/apstra_aos.py:47:5: F401 'apstra.aosom.exc.SessionError' imported but unused None of those imports appear to be used.
unnecessary import - boto is not used in the script
Make this a regular function
No worries- we assumed it was an oversight. ;)
Apparently, Python 2 does not have a `TimeoutError`
```suggestion assert isinstance(wrap_var(b'foo'), type(b'')) ```
It's unclear from the name what this is (or even that it's supposed to be a URL). Please rename.
shouldn't this line and the one below just not be here, and the loop be `for arg, version in self.DEFAULT_DEPRECATED_ARGS` (though those aren't really a default either, so `DEFAULT` is a bit of a misnomer)
The same like above.
This should be indented by 2 spaces. The same bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
It took me a while to figure how 'name' could be in DOCKER_RESERVED_IMAGE_NAMES. And then it hit me, `docker_container`, and probably `docker_image`, split the `image` parameter on ':', and assume that the first element is 'name', and the second element is a 'tag'. I think it would be preferable to have the code recognize when it receives an ID or partial ID value, and search accordingly. It would be nice if this could work with partial IDs, but this code will not support that.
`docker_py` use `id[:10]` as `short_id`, but `docker images` shows a 12-char version. I think there's no "standard" short version of `image[Id]`. "Registry returned more than one result for sha256:8fc" should be good enough. Users know what they're doing.
> I feel like a [WARNING] should pop up when you do that When specify a hash string that matches more than one image? We should `fail` immediately, this is users' fault.
No need to wait twice - the below lines do the same "wait" while respecting max wait time.
Leftover reference to `vcenter`.
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
This check can be also moved to `module_utils`.
`delete_volume` does not require size. This check will force user to specify size even if he/she is deleting the volume. I feel this is not intuitive UI/UX.
str? ```suggestion size=dict(type='str') ```
```python if state == 'present': if not volume: create_volume(module, array) elif volume: update_volume(module, array, volume) elif state == 'absent' and volume: delete_volume(module, array, volume) else: module.exit_json(changed=False) ```
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
```suggestion val = self.data[key] # See notes in VarsWithSources' docstring for caveats and limitations of the source tracking ```
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
Despite the name (comes from the C API unfortunately), set_range() only locates the key or the next greatest key, it does not otherwise constrain the results produced by the cursor :) It needs to be something like: ````python prefix = term[:-1] # strip asterisk cursor.set_range(prefix) while cursor.key().startswith(prefix): ret.append(cursor.item()) cursor.next() ````
if you are using loader, just use `get_file_contents`
Instead of taking a list of `[name, value]`pairs, it'd be nice to accept a map like: ``` values: activerehashing: yes something: no ```
As discussed, this needs a `RETURN` docs section.
This comma isn't valid YAML, since this is an indentation-delimited block.
Instead of nesting under the `elasticache` key, you can pass the info back as `exit_json(changed=[whatever], **camel_dict_to_snake_dict(response))`. That would change usage from: ``` - elasticache_snapshot: [args] register: snapshot_info - debug: var=snapshot_info.elasticache.[things] # to this - debug: var=snapshot_info.[things] ``` For facts modules, it makes sense to nest the returns, as those are returned and automatically entered to the namespace without the user `register`ing them.
The `.key()` call here isn't needed, dictionaries respond to `in` checks by looking at their keys, and calling `keys()` will create a list (Python 2) or generator (Python 3) that will have membership checks run on it.
Unless it is an actual value omit the `default`, I see the description already contains what it defaults to in this case.
this line isn't needed
I'm thinking instead of the 3 `enabled_for_*` options there should be 1 option like `resource_access` (can be any name) that takes in a list of values like `vm`, `disk_encryption`, `resource_manager` which then dictate whether they are set. This is just a suggestion but I think it should be discussed at the Azure WG to get a group consensus. As a side note, whenever you have a boolean option you should set it like ``` bool_options: description: - Description for this option. type: bool default: 'no' # can be 'yes' ``` The Ansible doc generator will automatically add the yes/no options to the choices and format it accordingly.
avoid putting quotes around values unless they are really needed
We are trying to move away from having the `state` key containing the raw Python SDK return values to just what is not known by the client. In this case I would just return the `id` of the object under the root level, e.g. ``` RETURN = ''' id: description: returned: success and keyvault exists type: str example: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXX/resourceGroups/presentation_rg/providers/Microsoft.KeyVault/vaults/ozidatamanagement ''' ``` If the user wants to get more information about a resource that is what the facts module is for.
boto3_conn, ec2_argument_spec, get_aws_connection_info are not needed with AnsibleAWSModule
You'll need to handle pagination if there are a lot of APIs. Should probably handle rate limiting here too https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#api-throttling-rate-limiting-and-pagination
No need to import HAS_BOTO3 now.
I'm working on a PR to update CI for these tests right now. :)
No need to set this, or check it.
lets' decide myAsg or myApplicationSecurityGroup
Please remove your confidential information in PR
here we can just use "image" instead of GalleryImage
same here, snake case, and convert value to lowercase
snake_case, value to lower (linux/windows)
> I feel like a [WARNING] should pop up when you do that When specify a hash string that matches more than one image? We should `fail` immediately, this is users' fault.
`docker_py` use `id[:10]` as `short_id`, but `docker images` shows a 12-char version. I think there's no "standard" short version of `image[Id]`. "Registry returned more than one result for sha256:8fc" should be good enough. Users know what they're doing.
```suggestion msg_format="Error stopping project - %s") ```
```suggestion msg_format="Error stopping project - %s") ```
```suggestion fail_reason = get_failure_info(exc, out_redir_name, err_redir_name, msg_format="Error stopping project - %s") self.client.fail(**fail_reason) else: cleanup_redirection_tempfiles(out_redir_name, err_redir_name) ```
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
s/will created/will be created/
```suggestion - Either I(template_link) or I(template) is required if I(state=present). ```
Use existing methods from `module_utils/vmware.py`
```suggestion self.module.fail_json(msg=to_native(e)) ```
It would be great to see an example rather than just None
Use an informative key instead of `instance` for example `network_protocol_profile_info`
```suggestion ip_pool_assoc = vim.vApp.IpPool.Association() ```
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
Just so you know, because of how param parsing works, this is equivalent to: ``` python self.mode = module.params['mode'] ``` Explicit can be better than implicit though, so I don't object to this. Do we want to keep specifying the default mode here? I would leave it here if we do not care that the user did not specify a mode. Note that the former check is incorrect because it catches a mode of 0 (no permissions). Use this instead: ``` self.mode = module.params.get('mode', None) if self.mode is None: self.mode = 0o600 ``` (Note that we no longer have to use int() because we no longer support python-2.4)
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
I'm not sure about these defaults - a delay of 3 and backoff of 2 for 10 tries would mean that, to fail, this retry decorator would wait for 3069 seconds (`3 + 3*2 + 3*2*2 ....`, or `sum([3 * 2**i for i in range(10)])`) or about 50 minutes. That seems like a really long time, especially since most modules make several calls. A better default might be 4 tries, for a total default wait time of 45 seconds and having a max of, say, a minute between tries. That way, if someone wanted 10 tries it would only take about 7.5 minutes to fail.
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
So the default option in Ansible is named validate_certs and it defaults to 'yes'. So I would prefer we do it like this.
This needs to be: `type: bool`
So the default option in Ansible is named `validate_certs` and it defaults to 'yes'. So I would prefer we do it like this.
Also, this was added for a specific reason which made the module fail for some users, so removing it will also make the module non-functional for those users. Another reason why this is a NO-GO.
While I think this is correct I'm not sure if it uses no proxy or the default proxy configured in the IE settings. I don't have easy access to an environment with a proxy configured so I can't test this assumption.
```suggestion # just get value from attribute itself as normal ```
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
``` pbm_object_ref = pbm.ServerObjectRef(key=str(virtual_machine._moId), objectType="virtualMachine", serverUuid=self.vc_si.content.about.instanceUuid) ```
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
boto3_conn, ec2_argument_spec, get_aws_connection_info are not needed with AnsibleAWSModule
I prefer another from line to a trailing slash. So line 69 would be ``` from ansible.module_utils.ec2 import ansible_dict_to_boto3_filter_list, camel_dict_to_snake_dict, HAS_BOTO3 ```
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
No need to set this, or check it.
spec is also returned
Try this: ```python attrs[name] = list(map(to_bytes, value)) ```
You can add it into this PR.
The same should be applied in the [`ldap_attr`](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/net_tools/ldap/ldap_attr.py#L176) module.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
Thanks - I've replaced all uses of `filter` with comprehensions.
Same change needs to be made to many other uses of filter.
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
a) was just note, not required to pass review b) if libcloud already requries 2.6 we can make an exception in the check as we do for other cloud modules.
These parens aren't necessary, please remove them.
Same here - when this call fails it should surface a nice error message to the user.
The parens around `connection,changed` aren't needed here
For this failure, can you include the exception? Something like `module.fail_json(msg="Couldn't connect to AWS: %s" % e.message, exception=traceback.format_exc())`
Please use a try/except or the AWSRetry decorator here, since this call should provide a nice message to the user about where it failed and what actions they can take.
This line has trailing whitespace, and is causing the shippable PEP8 checks to fail.
Trailing whitespace on a blank line is failing the PEP8 checks.
@s-hertel I believe this is actually incorrect. I must omit the `cluster_id` parameter to get the ElastiCache service to take a snapshot of a replication group. In the next few days, I'll get my changes put into a PR and I can show you. I've also added features for optionally waiting until a snapshot is in the "available" state.
Instead of nesting under the `elasticache` key, you can pass the info back as `exit_json(changed=[whatever], **camel_dict_to_snake_dict(response))`. That would change usage from: ``` - elasticache_snapshot: [args] register: snapshot_info - debug: var=snapshot_info.elasticache.[things] # to this - debug: var=snapshot_info.[things] ``` For facts modules, it makes sense to nest the returns, as those are returned and automatically entered to the namespace without the user `register`ing them.
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
this func takes and returns single dict, not array of dicts.
If you like to replace `None` with `[]`, it sugguest to change it to `response.get('resources') or [] `. The difference is, currently with this code, `[]` will only returned if there is no `resources` key in `response`
as discussed previously, no such thing "alert policies". every mention of "policy/ies" should be renamed...
"new" may sound as "to be added", suggest "desired" instead.
s/if it specified/if specified/
not a blocker but it is usual to use `yes/no` instead of `True/False` in the docs for bool types.
Shorten to `mac` or use hyphens consistently (`mac-address`).
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
You said line 91 & 92 that only reducing the disk size is not allowed. Maybe you should remove line 70.
We should be utilizing `ansible.module.utils.six.string_types` instead of declaring `basestring` in py3.
`ansible.module_utils.basic` already declares `basestring` this way. If the import in this module were updated to include the variable or `*` that would also address the issue. Ref: https://github.com/ansible/ansible/blob/631a10745d344c85817ab504f678d2c40ec8ae4b/lib/ansible/module_utils/basic.py#L195-L200
This change is not covered in the description of your PR. Please amend the description to include the reasoning, or remove it from this PR.
This is more efficient: ```suggestion key = next(iter(old[0]) ```
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
Your logic from the code above is: if `accept_terms` is `True`, `plan` must be specified. (That can also be modelled by `required_if`.) If you want the logic the other way around, you have to change your code (and you can't use `required_if` AFAIK).
You can use `required_if` to make sure that `plan` must be specified if `accept_terms` is `True`.
where to use this parameter? I didn't find it..
Need these to be kwargs for safety; generated Azure SDK is unsafe to use positional args. We're trying to move everything there to use kwargs.
This won't be necessary anymore if you add the suboptions to the argument spec. Ansible will do this validation for you then (and also make sure the options have the correct types).
```suggestion target: /tmp/dump.sql ``` Adding an extra variable in the example may mislead the reader on how to use the module
```suggestion name: db_1,db_2 ```
The remove is in the wrong place and tempdir is not removed. Better: ``` tempdir = tempfile.mkdtemp() new_archive = os.path.join(tempdir, 'archive.' + archive_fmt) git_archive(git_path, module, dest, new_archive, archive_fmt, version) archive_unchanged = filecmp.cmp(new_archive, archive) shutil.rmtree(tempdir) if archive_unchanged: result.update(changed=False) else: ... ```
```suggestion description: numerical ID of the user that owns the destination directory. ```
```suggestion description: Numerical ID of the user that owns the destination directory. ```
I don't see how this is a simplification, we just give modules the information about the dir the controller would have used, but it doesn't force the module to do anything. While this change will alter the behaviour of existing modules that rely on it.
that still happens no matter what info you pass to the module ... unsure how removing this info for the module to CHOOSE to share the dir is a simplification. Speaking of the end user, we CAN show them the tempdir being used since that info is available on the controller, but not when the module itself generates it (and many do).
The thing is that you are removing an existing feature, not simplifying anything, nothing FORCES modules to use this, many don't, that is why we ALSO supply remote_tmp (though that value is not always usable depending on become and other circumstances). Many modules don't use either value and opt to handle it completely on their own. But those that do use it, rely on this behaviour and making this change won't 'break' things in a way that alerts anyone, it will start leaving dangling temp files or attempt to create them in an unexpected directory. Which IMHO is worse, since it is a 'silent break'.
this should not be None, it should already have resolved to the configured system_dirs, so should be changed anyways
Heh, I just meant this code to show that setting _ansible_tmpdir = None was what we needed to do. I think that it's a bit too big a change to set this to None unconditionally. Probably better to revert the changes to how we call tempfile.* until we figure out how to implement this only for privilege descalation.
Elaborate more on case - what happens if state is set to absent. Also, other conditions like if permission does not exists.
`required: False` is default so need to add. Same for other.
Add a note that principal parameter is required if group is not present and same for group parameter.
PyVmomi helper class already calls `connect_to_api`
`This module can be used to manage object permissions on the given host.`
Again, suggest rewording this as suggested for win_http_proxy.
Suggest adding a combined example that also uses win_credential.
Suggest rewording this sentence as "If setting a dict, the keys should be the protocol and the values should be the hostname and/or port for the protocol given in the key."
Nitpick - the term `The value` is used twice here with different meanings each time. I suggest changing `...if IE changes the values...` to something like `...if the IE configuration changes...` to resolve the ambiguity.
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
```suggestion version_added: '2.8' ```
```suggestion version_added: '2.8' ```
Resolved in 0595acc4f78f55103e406b523b7fd67115105162
No need for quotes here.
No need for quotes here.
This is handled by the Azure module utils so isn't needed in the module arg spec
ah, ok... yes, i think when original azure_rm_virtualmachine was done, as_dict() was not available yet. that's why there's serialize_vm function in there. I will actually try to check how it differs from raw REST API response....
i meant that maybe you don't need serialize_vm function at all, you could just use as_dict() which is available from vm object
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
please use here self.param('version').get('base_template')
please use here `self.param('version')`
and please add space after `)`
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
Please remove this, having this toggle in modules you don't own is going to get annoying...
This is going to break old users, think it's worth also accepting `api_url`? Or potentially using an alias and stripping off `/api`? That feels hackish, though. (also applies to `gitlab_hooks`)
I think we can just change "GalleryImage" to "Azure SIG Image"
Perhaps we could add an example to show how to list zones (without filtering).
```suggestion - The name of content library to manage. ```
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
use `get_exception()` instead
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
This command expects results in JSON format (the `TABLE_interface` bits below), so needs to have output set to json
You later test `if vlan not in current_vlans`, so this should probably return `[]` (or something with defined membership) not `None`.
I would `return match is not None` or `return bool(match)` rather than this
Right, break this into two lines
@saichint Is `execute_show_command` even required? We can directly use `run_commands` since this method is calling `run_commands` only.
In order to improve readability (meaning the change described below isn't required): * `delete_cert`, `import_pkcs12_path`, `import_cert_path` and `import_cert_url` never return (either `exit_json` or ` fail_json` are called) * it's quite disturbing that `changed` isn't set (and it doesn't need to be set) when `delete_cert` is called then i would rather call `module.exit_json(changed=changed)` here (then keep `module.exit_json(changed=False)` unchanged at the end the file.
```suggestion self.module.fail_json(msg='Unable to add required signing key for%s ', rc=rc, stderr=stderr, error=to_native(e)) ```
```suggestion self.module.fail_json(msg='Unable to get required signing key', rc=rc, stderr=stderr, command=command) ```
Should not that be: ```suggestion msg="Using 'cert_content' argument requires 'cert_alias' argument.") ```
If it is not required, we don't add `required: false`, so that it is more clear which paramets are required.
Should probably check if region exists before this line.
You can remove this (and the import) now that this uses AnsibleAWSModule.
I think this can raise botocore.exceptions.ProfileNotFound too.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
We don't support Server 2008 with this module so this line isn't needed.
same typo here WinTreshold -> WinThreshold
-> WinThreshold here too
Format this like this: ``` response_add_content_server_group, info = get_response( add_content_server_group) ```
This is never evaluated because you are already in the branch which matches `info['status'] == 200` only.
ditto about s/no/'no'/
ditto about s/no/'no'/
ditto about s/no/'no'/
This note probably no longer applies, unless you'll be making a Windows version. Since this module will not work on Windows, it should be noted. (at least I think it won't? All the windows modules use powershell so Â¯\\_(ã)_/Â¯
Omit these lines please.
minor, convention is to use `yes` or `no`, and not `True` or `False`, for values in case type: bool
to show datacenter is anoter param use I(datacenter)
This would turn everything into a string, not sure if that's what you want for e.g. booleans). Same for the other values that are not strings. Probably not what you want.
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
```suggestion (u'1', u'PB', 1125899906842624), (u'1E', 1152921504606846976), (u'1EX', 1152921504606846976), (u'1Z', 1180591620717411303424), (u'1ZB', 1180591620717411303424), (u'1Y', 1208925819614629174706176), (u'1YB', 1208925819614629174706176), ```
Plz also use `match` arg here
There's subset of cases which are the same, you could put those into a variable and then merge that with extra cases on per-test basis
You copy-paste a lot. It'd be more resilient if you could just put repeatable parts of data sets into reusable vars.
```suggestion (u'1PB', 1125899906842624), (u'1E', 1152921504606846976), (u'1EX', 1152921504606846976), (u'1Z', 1180591620717411303424), (u'1ZB', 1180591620717411303424), (u'1Y', 1208925819614629174706176), (u'1YB', 1208925819614629174706176), ```
Missing full stop
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
Good idea to make all classes new-style objects. You can do that by inheriting from object
this is a common return, please remove it.
Use `camel_dict_to_snake_dict` to return results in standard Ansible format.
this should use atomic_writes (but given how containers normally mount the file, it should note that for them users might need a toggle to allow 'unsafe=true'
Else part is not necessary since we are initialising `b_passwd` already.
Also, I'm not sure if it matters but you could use ```to_native()``` instead of ```to_text()``` if container_config should be byte strings on python2 and text strings on python3. In a quick look at the following code I didn't see anything that would be a problem with text strings on python2 but I put that out there in case @cloudnull does see something.
Need to `return bind_mounts` here
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Use whatever fixture names make sense. Personally I'd probably name the fixture `XenAPI` since that's the import it is replacing. Then there's no need to assign `XenAPI = fake_xenapi`. Setting `autouse=True` only loads the fixture for the test automatically. If you want access to that fixture as a local, it still needs to be a function parameter. The benefit to autouse is that it guarantees the import will be mocked, even if the test doesn't require a reference to the fixture. However, there's nothing wrong with specifying an autouse fixture as a function parameter. Doing so simply makes the auto-instantiated fixture available as a local within the test function. To guarantee correct fixture order, declare that the `fake_xenapi` fixture is used by the fixture providing `ansible.module_utils.xenserver`. Modifying `sys.modules`, or making other changes to global state, outside of a test fixture or function will apply those change to all unit tests (everything under `test/units/`) when pytest collects the tests before they are executed. Since we run unit tests with the pytest `--boxed` option, each test is run in a separate Python process after the initial collection is performed. This means that any global state changes made in-process by a test function are discarded at the end of that test function, but all changes made during collection are shared. Imports handled during collection will result in changes to `sys.modules` that will be shared across all tests. This is fine for regular imports. However, the mocked import for `XenAPI` is specific to the tests in `test/units/module_utils/xenserver/`, so it should be restricted to those tests. If another test, such as one for a xenserver module were to also mock `XenAPI` they would conflict.
This needs to be in a fixture so it doesn't affect all unit tests. To avoid the need to reference the fixture on each test you may want to use `@pytest.fixture(autouse=True)` on the fixture. Perhaps something like this: ```suggestion @pytest.fixture(autouse=True) def fake_xenapi(): xen_api = importlib.import_module('units.module_utils.xenserver.FakeXenAPI') sys.modules['XenAPI'] = xen_api return xen_api ```
You shouldn't need to assign `XenAPI = fake_xenapi`. What mocker.patch calls are you trying to make that require that? To have access to `ansible.module_utils.xenserver` in tests without importing it in each test function, you could wrap it in a fixture.
You could even rename the fixture to something other than `fake_xenapi` if desired.
Why not do ```suggestion if not keyword_definitions_file: return {} ``` This'd reduce the nesting of the following block.
new_X is a bad pattern, if you have a unique identifier a comparison of account_id supplied vs existing should determine if this changes or not
could you but this in the description as a new item like ~~~yaml description: - Should the volume provides 512-byte sector emulation? - Required when C(state=present) ~~~
All descriptions should be full sentences, e.g start with a capital letter and end with a full stop.
Although not required, we generally put `description:` first as we find it makes the source code a little more readable.
in many modules the default is `state=present` please consider it too if it makes sense.
Please do not quote `%r` as it will automatically add quotes in creating a string representation of a string.
This will fail on new modules since `existing_doc` will be `None`.
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
no need for `lower()` here
Parentheses aren't needed here.
This statement raise an exception when user_data isn't specified by the user: `TypeError: argument of type 'NoneType' is not iterable`.
User could set `user_data` parameter to `None`, in such case exception still occurs.
User should be able to delete key. Keys with `None` value could be deleted.
When `user_data` is `None`, an error occurs: ``` AttributeError: 'NoneType' object has no attribute 'items' ```
To match the headers in https://github.com/sieben/ansible/blob/b119f2652a160707ee718566ad1e49a510935553/lib/ansible/module_utils/scaleway.py#L40 `Content-Type` must be `Content-type`
```suggestion type: int version_added: '2.8' ```
This is the default so can be removed. ```suggestion ```
```suggestion type: int version_added: "2.8" ```
Can you change the examples to use YAML rather than `k=v` shorthand? ```yaml - debug: var: lookup('cpm_status', 'temperature', validate_certs=true, use_https=true, cpm_url='rest.wti.com', cpm_username='rest', cpm_password='restfulpassword') ```
Remove this line. If it is required, there is no default (not "no default"). But I would add a default message.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
remove un-used variable.
remove un-used variable.
use ```from ansible.module_utils.vmware import find_obj```
use ```from ansible.module_utils.vmware import HAS_PYVMOMI```
You don't need to escape EOL. Just have two strings and Python will automatically know that it's in fact one string: this ```python ( "series " "of" " words" ) ``` equals ```python "series of words" ```
(but in case of function arg, you don't need additional braces)
Could dedent here if `else:` removed.
I think you could go for `elif:` here.
or entirely omit `else:` since it would fail in case of `if` part.
Oh, nevermind, you're right about this. I guess the filters are entirely optional and it will just get all of the enis in this case. It could accidentally work (if you have only a single network interface) if you don't add this.
Please change this to ```python for current_line, next_line in zip(lines, lines[1:]): ```
I'm not sure why you use exact index slices. Are they always this size? I'd say that it's much safer to do `.split()` and that work with chunks: ```python vlan_id, name, state, interfaces = [v.replace(',', '').strip() for v in current_line.split()] ``` please also note that in python we use so-called `snake_case` for variables, as opposed to `camelCase` (like in java or js)
Please note that in Python we don't use brackets unless really needed.
You won't need this complexity with the snippet I've posted above
Is there precisely one time you can specify this? It sounds to me like this should be allowed to repeat multiple times. So this should be a `list`. Or maybe even better a `dict`, so people can specify things like ``` blkio_weight_device: /dev/sda: 100 /dev/sdb: 200 ```
(In general, I don't think modules should have such options.)
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
Again, suggest rewording this as suggested for win_http_proxy.
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
Returning "magic" status variables, which need checking is required if you write in `C`, but Python has better mechanisms for communicating errors. In Python this is not a good API. Please raise exceptions and do proper processing with try/except.
(but in case of function arg, you don't need additional braces)
You don't need to escape EOL. Just have two strings and Python will automatically know that it's in fact one string: this ```python ( "series " "of" " words" ) ``` equals ```python "series of words" ```
Could dedent here if `else:` removed.
or entirely omit `else:` since it would fail in case of `if` part.
```suggestion - name: Change login times for user ```
```suggestion mode: '0644' ```
```suggestion ``` I don't think this is correct, it would include all the default files-parameters, al lot which are not supported by this module. It is better to only add those that are relevant to this module.
```suggestion type: str choices: [ absent, present ] ```
```suggestion result = dict( ``` More in line with a lot of modules.
this could return here? Then the next stanza doesn't need the extra indent level
Add that the user can specify the backend to use via the ```use``` parameter.
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
we should also return if we both delegate executions and delegate_facts
This needs to be a string: `"2.3"`
Is there a case to be made for `task_definition` being optional, and if not present, returning task definitions for all tasks. Furthermore, I think I'd consider extending this module to become ecs_task_facts, and return the task data along with the task definition and then describing one or more tasks as options.
Thanks for the contribution! Since new AWS modules are required to just use boto3, you can remove this. Your exception handling can also be updated to be for boto3. Each boto3 call should be in a try/except. There's some helpful info here: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md
You don't need this conditional, since Ansible enforces that these are the only choices.
spec is also returned
I think instead of comparing chunks like this, it might be better to sort the lists of policies first, following a heirarchy like: - SID - Effect - JSON-sort-key-dumped Action
Another general exception handling that can be removed.
Another general exception handling that can be removed.
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
`required=False` is the default, and thus not required
Can be `except ImportError:`
The pep8 line length enforced is 160 - can keep this on one line.
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
No need to wrap.
Random musing. I wonder why boto3 isn't returning CreatedTime sometimes. I made a launch configuration in us-east-1 with ami-9be6f38c. It has a creation time in the console. Hm.
Use `https` instead of `http`. Yes, the site currently redirects back to the HTTP version, but that should eventually be fixed.
Leftover reference to `vcenter`.
The `if` statement is useless. If the list is empty, then le `for` loop will not run.
I think here, you should keep the whole `item`. I will prevent unnecessary request to the API in then `update_variable` function : `self.project.variables.get(key)`
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
If for some reason you want to be able to enable without installing, you could add a flag which for `enable`/`disable` fails instead of installing (if the plugin doesn't exist). But the default behavior should be "install if not there, then make sure you have the correct state".
That's **not** how a module should return differences. Some docker_* modules have done this in the past (and some might still do that), but it's simply wrong (and won't show up when the user runs `ansible-playbook --diff`).
That should only be called if the plugin should in `enabled` state afterwards.
You should check if the options actually changed before reconfiguring the plugin. It only makes sense to reconfigure if this actually changes something.
```suggestion for key, value in self.parameters.plugin_options.items(): ```
Drop the extra "Mac" here.
One last thing I thought of: it may be good to catch `AttributeError` and `ValueError` if an invalid value is passed for `namespace`. Otherwise we get a stacktrace. ```suggestion try: uuid_namespace = uuid.UUID(namespace) except (AttributeError, ValueError) as e: raise AnsibleFilterError("Invalid value '%s' for 'namespace': %s" % (to_native(namespace), to_native(e))) ```
```suggestion return to_text(uuid.uuid5(uuid_namespace, to_text(string))) ```
```suggestion uuid_namespace = namespace if not isinstance(namespace, uuid.UUID): uuid_namespace = uuid.UUID(namespace) ```
Values returned from filters should use `to_tex()` for Python 2/3 compatibility. ```suggestion return to_text(uuid.uuid5(uuid_namespace, str(string))) ```
we try to use 'state' instead of action, as ti keeps with the declarative voice of Ansible vs an imperative approach from programming languages.
All `description` should start with a capital letter, and end with a fullstop.
I think this should be a separate command option - `delete` or `create`. `state` seems like something different. At a minimum, I think it should be more explicit - like `action: create | delete`
Actually with the example you updated, this text is good enough. However we explain it, it won't be clear until one looks at examples... Perhaps slight tweak "A list of list of tags, grouped by category".
shouldn't be required, irrelevant for Amazon providers
All of these uses of `str` should be switched to `to_bytes(var, errors='surrogate_or_strict')`. `to_bytes` comes from `ansible.module_utils._text`.
Thanks for the confirmation!
You don't always have a guarantee of `other_var` being the same type. And `'some str %s'` has different types under Python 2 and Python 3. That's why it's important to explicitly use the correct literal.
Oh, and in places with variables where you concatenate that with literals, also apply this function to avoid certain edge-cases which appear sometimes when you try to merge different data types.
Yes, you can convert resulting strings. But when concatenating things it may result in unpleasant side-effects. ```python # WRONG b'some str %s' % other_var # <-- Python (esp Python 2) tries to turn `other_var` into bytes, sometimes incorrectly which may even cause exceptions in obscure cases ``` ```python # CORRECT b'some str %s' % to_bytes(other_var, errors='surrogate_or_strict') # when you convert it explicitly, it'll always succeed ``` If you don't like this `errors='surrogate_or_strict'` part, you can use curring: ```python from functools import partial ... from ansible.module_utils._text import to_bytes ... to_bytes_sos = partial(to_bytes, errors='surrogate_or_strict') # ^ # | # | # somewhere at the top of the module ... # And everywhere else in code: # | # | # v b'some str %s' % to_bytes_sos(other_var) ``` Hope this helps.
`state` argument is probably missing for this module.
just an style thing, any reason for only having 3 elements per line on the list? I'm fine if you want to make it 80 line compliant but let's make it consistent for all module ;)
heh, indeed interesting, just checked it myself
it might be worth adding an option to configure debugging, unless it's explicitly needed by the module.
no worries, let's make it for 2.10, but I think that debug option would be nice ;)
Not sure what "This one go down into the class tree" means. I know it's from the original method, but see if you can improve this language so it's more clear.
I see you fixed this one. :+1:
Maybe C(.pem)? I'm not sure you need to specify that .pem is a file type since it's just the extension. @gundalow might know.
`delay_min_macos = delay_min | 1`
Most other modules default to yes so I would do the same here
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
No wrap needed.
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
No, you still have to check `HAS_BOTO3` (imported [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L229) and checked [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L558) )
This is handled by the Azure module utils so isn't needed in the module arg spec
ah, ok... yes, i think when original azure_rm_virtualmachine was done, as_dict() was not available yet. that's why there's serialize_vm function in there. I will actually try to check how it differs from raw REST API response....
i meant that maybe you don't need serialize_vm function at all, you could just use as_dict() which is available from vm object
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
Right, I personally use and prefer: ```suggestion skydive_meta: >- ``` (which also trims spaces)
Could also be ```suggestion skydive: >- ```
we are trying to move away from this syntax, use this instead: ``` _found_file: "{{ lookup('first_found', findme, paths=['/extra/path/'], skip=True) }}" ```
The following two items are inherited from skydive_capture. They should not be here
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
Is there the potential that the response could be 200, but the JSON not include these keys? Maybe they should be guarded with try/except to avoid exceptions.
to_text() isnt imported
Confusing string concatenation. Look into `printf`-like string formatting or `.format()` I see other places where this should be changed.
A couple of things, we try to avoid 'catchalls' as they don't give good error messages. We try to capture the errors after a specific action "friendly' part that suggests what was being attempted and possibly what user can do to change error to success. Also, the 'exception' field is badly named for python, it is mostly for tracebacks and we normally append the exception string to the msg field after the 'friendly msg'
I like the code organization here ð , but it is a little different than most modules. Some folks may prefer the deeply nested args style. I don't think you should change it, just a heads up that it might be a little unusual to some folks.
we probably want to move this 'adhoc list' into constants.py anyways
this probably needs updating to ansible.legacy.X see constants.py for function that deals with the multiple possible names
Please replace your mail with your github handle (also in cloudscale_server module)
```suggestion - If set to C(present) and library exists, then library is updated. ```
s/run the/run in the/
profile_name is mispelled (and there is a missing quote after profile_name as the tests suggest). No need for two spaces after the full stop.
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
I can't see an import for camel_dict_to_snake_dict
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
```suggestion re.compile(br'[\r\n]?<.+>(?:\s*)$'), ``` And so on for all the entries of both `terminal_stdout_re` and `terminal_stderr_re`.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
Doing this inline is OK for beta- it makes the feature function, but it's a performance problem. Post-beta, we'll want to move most of this to an intermediate lazy indexing process during playbook parsing when a module_defaults clause references a group, where we'd build that global "sieve" I was talking about for O:1 lookup. At that point, we can probably get rid of the transformation in the collection metadata canonicalization phase entirely and just store it plain.
This doesn't currently appear resilient to missing collection(s) in the group's list (eg, you only have `amazon.aws` and not `community.aws` available).
I guess this one's not as obvious because of the "pre-chewed" format, so `action_group` isn't the right name for the current impl either...
personal preference, but since we only want to do the work once based on the result of a looped query, I usually write those things as an explicit query predicate, eg: ``` if any(name for name in redirected_names if name in action_group): tmp_args.update(...) ``` this form also stops the iteration once we know there's work to be done. You could accomplish the same in the existing form by adding a `break` after the update, but IMO the existing form is less clear that you're not really looping over the side effect.
```suggestion 'community.crypto': 'acme', ``` With this, my tests actually work :)
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
This is minor, but put bare imports first followed by `from` imports. ```suggestion import json import grpc import yandexcloud from google.protobuf.json_format import MessageToDict from yandex.cloud.compute.v1.instance_service_pb2 import ListInstancesRequest from yandex.cloud.compute.v1.instance_service_pb2_grpc import InstanceServiceStub ```
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
```suggestion from ansible.errors import AnsibleError, AnsibleParserError from ansible.module_utils._text import to_native from ansible.module_utils.parsing.convert_bool import boolean from ansible.plugins.inventory import BaseInventoryPlugin, Constructable, Cacheable ```
Might be worth validating that zones is a list rather than a single zone provided as a string.
Can you add: ``` type: path ```
Can you add: ``` type: str ```
Can you add: ``` type: path ```
Can you add: ``` type: bool default: no ```
you don't need to use 'original_safe' as that was an import in the base class to maintain backwards compatibility, also you should get this from the base class: `self._sanitize_group_name()`
`_connect` already does nothing if `_connected` is False. It might _look_ weird, but you can call `_connect()` without checking and the right thing will happen.
```suggestion "Error: " + to_text(err)) ```
```suggestion except Exception as err: ```
You don't need to branch on this, `_connect()` already does the check.
```suggestion "Error: " + to_text(err)) ```
there is no need to version params for new modules
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
Please add spaces around the equal sign.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Yes. Either to_native or to_text would be fine in this case.
You can remove this. If there isn't a specified return, None is returned.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Nit: You have an extra period after 'example'
Please make this oauth_token.
Mutually exclusive is argument of AnsibleModule. ```python module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True, mutually_exclusive=[['username', 'service']], ) ```
I would switch the statements, test for dict, test for list, else raise error.
`if credential and ...` could be used here. With Python 3.5, the call to `endswith` raises an exception: `TypeError: endswith first arg must be bytes or a tuple of bytes, not str`.
Unnecessary blank lines here, removing these blank lines is preferable.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
Okay, so to implement the examples like this: ``` with_cyberark_password: appid: 'Application1' query: 'safe=...;' output: 'password ....' ``` We'll want to take the dict from terms instead of from kwargs. terms will hold the dict that the user passed in so you should be able to drop in replace it in your constructor like so: ```CyberarkPassword(**terms)```
Required is False by-default, so no need to describe explicitly in docs.
Examples should be in multi-line with `key: value`
Wrap in try/except please.
import HAS_BOTO3 too and add a check for it in main()
You could fix #19781 real quick right here :D
remove added space
typo: thier -> 'their'
Perhaps, `Will ensure the datacenter resource exists and its properties are compliant with HPE OneView` Or something along those lines. As it is right now I'm not sure if it is clear that this resource can actually be created if it does not exist.
```suggestion - This module creates clones for libvirt. ```
Each option entry should be a full sentence, i.e. it starts with a capital and ends with a full stop.
This can become a function since it no longer makes use of self.
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Another regex that can be precompiled.
<nod> Before working on ansible, I'd do regex compilation at module scope. mpdehaan and jimi-c liked things at class level so I've put more things there but it still doesn't feel natural in python... Global scope and in the `__init__` should both do the right thing for this piece of code (the classes are only instantiated once so there's no performance disadvantage to compiling in `__init__`; I think that **init** should function normally as all of our `__new__` methods are returning a class.)
Rather than using separate variables, you can accomplish this in one line: `result = json.loads(content.decode('utf-8'))`
looks like there are common options for all graylog modules, Shared code are located in lib/ansible/module_utils (note that this must not be GPL here). But this can be done later on. Not a blocker, just a hint.
I don't see the point ;-)
Exception handling here too.
Can the native ElementTree api be used here. ```from xml.etree.ElementTree import fromstring``` This will reduce module dependency on `lxml`.
How is this required if it can also be specified by the environment variable? Compare to openshift plugin via `ansible-doc -t inventory tower` ``` api_key: description: - Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable. ```
I just realized we are missing this in all plugins (i just updated foreman #42355 ): ``` plugin: description: the name of this plugin, it should always be set to 'tower' for this plugin to recognize it as it's own. required: True choices: ['tower'] ```
its fine to have a 'separate pre-existing file', I would just use it as a fallback if other methods are not populated and i would not create one if it were not already standard.
It also might be good to compare these options to the options in https://github.com/ansible/ansible/blob/cdd21e2170b9a47d84624c8c2f792a66f2b0fe57/lib/ansible/utils/module_docs_fragments/tower.py#L23-L42
i actually don't think you should force having the `tower_config_file` entry, but it could be posed as an option and default to the 'normal location'
url is not requried according the arg_spec
Please remove quotes.
Please remove quotes.
The param `provider` is required when creating.
`id`, `name` and `zone` (which should be 'zonename': 'zone') are returned by default. Can be omitted in modules,
You don't need to state default=None as this is the default value.
Please put this on a single line. Lines can be 159 characters wide.
Add trailing comma.
You can remove `required=False` as that's the default.
Please put this on a single line. Lines can be 159 characters wide.
`, no_log=True` here please
Each example task should be a continuous block, please do not have blank lines between sections
`IP` `Netscaler` - Applies to a number of places `Nitro` - Applies to a number of places
Sound, sound sensible
`Ansible control node` (Capital and remove double space)
I would suggest to set `type='int' for vlan.
`zone` is returned, but not zoneid
alright. let's keep it as is.
no need to wipe `self.nic`, but return the nic you just have (or, in check mode, would have) removed. this functionality is required for integration testing.
yes, None values are excluded by the lib cs underneath
comma-separated should not bee needed, just make flags a type=list in argspec, it will accept both actual lists and comma separated strings
instead of flags_on/off just flags .. a canonical list
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
Parameters that are not required, don't need a `required: False`. This is implied.
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
please add `no_log=True` to avoid leaking the password in the logs.
Please add `supports_check_mode=True`. With this seeting, facts modules will also be executed in `--check` mode. ~~~ python module = AnsibleModule( argument_spec = dict( host=dict(required=True, type='str'), login=dict(default='Administrator', type='str'), password=dict(default='admin', type='str', no_log=True), ), supports_check_mode=True, ) ~~~
please add `no_log=True`
#45989 has a response on it. The preferred way is to *not* advance the date or add a range.
Well, it's easily googlable :) I've shared links in some PR recently. Let me see whether I can find them
excellent question, and one we should probably ask of someone with a legal background - I will find someone and ask, then report back on #45989
Basically, copyright comes into play since content creation, so you need a year, when it's been originally created. When you update content, you "create" new parts of it, that requires new year to be mentioned.
Please change this to 2017â2018, as the copyright should normally cover all years of artwork/code creation/updates.
The other option is to strip the arguments and keep it as a list
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Ah, this needs to be set to to `type='path'` so it will be automatically expanded.
community.general also contains some of the modules of the `k8s` module defaults group (the `kubevirt` modules), and some modules of the `ovirt` module defaults group (the deprecated `_facts` modules).
This check (and _is_binary) seem like they belong in executor/module_common.py. Make modify_module responsible for detecting that this is a binary module and returning it unchanged. We might need to create a new module type so that the rest of the code in action/__init__.py knows it's dealing with a binary module but that shouldn't be a problem. We already have "old" and "non_native_want_json" which do nearly the same things.
i would execute AFTER getting module's shebang so you can find the 'right interpreter' also check that ansible_x_interpreter does not exist already
Should have been module.fail_json
print statement can be removed
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
check e.response['Error']['Code'] here too
One more question on this: The checks are to see if the current VM group name _equals_ the new VM group name? (same for hosts), shouldn't that be if they differ? It would make the code: ``` if ((existing_rule['rule_vm_group_name'] != self.vm_group_name) or (existing_rule['rule_anti_affine_host_group_name'] != self.host_group_name and not self.affinity_rule) or (existing_rule['rule_affine_host_group_name'] != self.host_group_name and self.affinity_rule) or (existing_rule['rule_enabled'] != self.enabled) or (existing_rule['rule_mandatory'] != self.mandatory)) ``` (added check to only check for the right host group name depending on type of rule)
If this is set to type='int' this should avoid the later type conversion
This should be botocore.exceptions.NoCredentialsError.
host_storage.type == otypes.StorageType.FCP
This should be botocore.exceptions.NoCredentialsError.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
Catch botocore.exceptions.ClientError instead of Exception here too.
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
The current behavior is: * if the user did not specify `env` (i.e. `self.env is None`), don't compare. * if the user did specify `env`, compare user's `env` to the service's `env`. * if the service's `env` is empty, treat it as `[]`: this simply means that no env variables have been set for the service. So this does not ignore empty lists, but treats them correctly. (What it doesn't do is consider order - you're totally correct on that one.)
(Same for the comparisons below.)
(But that's already what you implemented. So it should be fine.)
A better version would be: ```suggestion if has_list_changed(self.env, os.env): if self.env is not None and has_list_changed(self.env, os.env or []): ```
If the new list is `[]`, you should compare. The user explicitly requests an empty list in that case. If the new list is `None`, don't compare, the user is saying "I don't care".
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
I think this should be using mock.patch? iirc, this can leave ansible.module_utils.facts.system.pkg_mgr monkeypatched to be a mock for the rest of the tests.
we should also return if we both delegate executions and delegate_facts
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
This should be ``` 'supported_by': 'community' ```
Let's see if anyone else complains about that when reviewing ;)
`Range of VLANs such as C(2-10) or C(2,5,10-15), etc.`
Please remove this line. `waitfor` was used in older modules, we've since standardized on `wait_for`
You can safely remove this line.
```suggestion pass # Handled by AnsibleAWSModule ```
Should probably use a [paginator](http://boto3.readthedocs.io/en/latest/reference/services/route53.html#paginators) here to support large accounts.
Handle NoCredentialsError as well
It would be better to check the error code. You can use `if e.response['Error']['Code'] == "NoSuchLifecycleConfiguration":` Caveat: Only ClientError has an e.response, so you will need to break up the exception handling: ``` except ClientError as e: # check e.response['Error']['Code'] # else call module.fail_json_aws except BotoCoreError as e: # call module.fail_json_aws ```
Can be `except ImportError:`
Actually, even more than +1 to changing this to packages because this is in the error messages which we return to the user, not just about variable naming. Everyone will understand what packages means in this context but sysadmins who just need to translate a script to setup the production environment their dev team gave them won't understand "distribution".
Well, it was used to be known worse a while back. They've started working on that tutorial not long ago. Old users don't rush to reread those. That's why I prefer combo compromise to be as explicit as possible. Python packaging is in a weird state for a long time now. I don't want to add any more confusion.
FWIW, +1 to package. Distribution is only applicable to python, making it harder for people outside of that ecosystem to work on this module.
I would call them `packages` instead of `distributions`.
I think you could go for `elif:` here.
```suggestion def _post_request(self): ```
The braces are not needed ```suggestion if not response: ``` However, I don't think `session.get` ever returns `None`. You should also check if it's not an error (HTTP 500) because otherwise `response.json()` later will fail.
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
If the result was a 4xx or 5xx then I think this fails.
I'd also include a check for server errors (500)
boto3 import failure is handled by AnsibleAWSModule. ``` try: from botocore.exceptions import BotoCoreError, ClientError except ImportError: pass # Handled by AnsibleAWSModule ```
This import is unnecessary.
Should catch `BotoCoreError` and `ClientError` here, and use `module.fail_json_aws()`.
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
You don't need connect_to_aws, boto3_conn or get_aws_connection_info if using AnsibleAWSModule
Full stop, rather than comma at the end.
Missing full stop.
You can removed all the `required: false` it's implicit
Missing full stop.
As far as I can tell, the 'in_use' is never used.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
So booleans require the following statements instead if the above: ```yaml type: bool default: 'no' ```
So booleans require the following statements instead if the above: ```yaml type: bool ```
So booleans require the following statements instead if the above: ```yaml type: bool default: 'no' ```
As a side effect on this, it should always result in `changed=True` similar to the `shell` and `command` modules.
This inline doc formatting is odd to me. Are you trying to do sphinx format maybe? ``` :param binary: ... :param subsystem: ... :param other_args: ... ```
we try to avoid kwargs when possible in the internal API
The better API is to take a list for other_args and a dict for kwargs so that we never have conflicts between the two but I see why you went the **kwargs route (since other_args was already using the unpakcing idiom). This is an internal function so we have the freedom to change the function's signature At first glance there's a bunch of options: ``` python def _build_command(self, binary, command, *other_args): [...] def _build_command(self, binary, command, other_args=None): if other_args is None: other_args = [] def _build_command(self, binary, command='ssh', other_args=None): if other_args is None: other_args = [] ``` Looking at what the code does, though, I think this would be even better: ``` python def _build_command(self, command, other_args=None): if other_args is None: other_args = [] if command == 'ssh': binary = self.play_context.ssh_executable else: binary = self.get_option('{0}_executable'.format(command)) ``` Here's my thinking: * If we're limiting the possible commands to the set of ssh, scp, and sftp, then the correct command is really the primary piece of information that this function needs. Therefore, command should both be mandatory and the first argument. * Since command is limited to a few specific values, we can choose the proper value of binary based on the value of command. Therefore we don't need to pass in binary; we can set it inside of this function. My glance at all the callers of _build_command(), this looks like it's the correct way to default binary for all three of the possible commands but you'll probably want to hceck my eyesight ;-) * We need to change the signature of the function and then update the callers so we might as well correct all the deficiencies in the function's signature. (Hence, changing other_args into a kwarg taking a list of arguments). Hope that makes sense.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
also worthy noting, -G won't show actual ssh options used, just those configured
better to move this line in else part. something like ``` if hasattr(resp, 'data_xml') or hasattr(resp, 'data_ele'): result = resp.data_xml else: result = resp.xml ```
Can we print entire error rpc. In case of error `message` alone is not very helpful.
This can be put in the argspec, e.g. `required=False, fallback=(env_fallback, ['GCP_SERVICE_ACCOUNT_FILE']),`
`'get'` is in base_rpc already? ```suggestion ```
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
I don't really get this, why not just do. ```suggestion auth_str = "Signature" ```
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
I'd do ```suggestion if not ignore_errors: raise ```
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
type='str' is a default value not required to mention in separately.
You can use iteritems as below ``` from ansible.module_utils.six import iteritems iteritems(parsed) ```
If the VLAN exists, you should check the name and state to make sure they are same as requested.
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
No need to duplicate these lines of code- just conditionally assign a local `virtual_network_resource_group` as `self.resource_group` or `self.virtual_network_resource_group` as appropriate and use it below the conditional.
This should probably be in the same if statement as `if self.state == 'present'`, this way you know the disk exists and so the initial present check is not required and you never really want to run this additional operation if `state: absent`.
It might also be no IGWs found here.
This is to align new Ansible facts guidelines - ```suggestion return {'changed': self.change_detected, 'failed': False, 'screenshot_info': screenshot_facts} ```
just don't know exactly what's in the properties :-)
So I'd change this description here to required when I(state=present) or something.
I think it would be fine to specify that group_id can just be used with absent. The ability to change security group attributes with the ID could be another feature request/pr. If you're itching to implement that have at it, but do whatever makes sense to you.
```suggestion - Can be a dict which contains I(name) and I(resource_group) of the virtual network. ```
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
```suggestion - If the I(os_type=Windows), a rule allowing RDP access will be added. ```
I don't think the data belongs in constants.py. Using Facts.PKG_MGRS was an attempt to make a single canonical source for the data. We should probably derive this from ```ansible.module_utils.facts.system.pkg_mgr.PKG_MGRS``` now. Tangent: Looking at this now, I realize that when I coded this, I was overly optimistic about the data being usable in this way. Not everything in C.PKG_MGR_MODULES is actually a module. OTOH, it's not a big problem. We just add a few more dictionary keys that map to other Lock() objects. (this is a, preexisting problem, doesn't need to be solved)
The main requirement for me is leaving it in module_utils. Why do you think that there shouldn't be a dependency from ansible into module_utils? (Also default_squash_actions is entirely different. default_squash_actions is only used by controller code. PKG_MGR_MODULES is used primarily by remote-side code.)
this probably needs updating to ansible.legacy.X see constants.py for function that deals with the multiple possible names
we probably want to move this 'adhoc list' into constants.py anyways
Sorry, my bad. I didn't see the implementation of `_run`.
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
`datastore.name` requires access to the datastore itself, and thus might throw a permission error. This value should be wrapped in a try/except.
Cool. Thanks. Let me know once done.
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
missing import of get_exception()
rm debugger hook.
pep8 stuff ``` if 'names' not in vmap: ```
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
```suggestion destination_vcenter_password=dict(type='str', required=True, no_log=True), ```
we should also return if we both delegate executions and delegate_facts
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
This should be a string. ```yaml version_added: "2.3"
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
I think this should be a single line, rather than three
Default not set in argspec.
default will be 'None' which is 'falsey', that should be good enough and even allow for smarter logic when it was 'unset'
I looked through `openstacksdk` and it seems it is expecting `True` or `False`. Defaulting to `False` is a much safer bet than defaulting to `None`.
I would make it a list so user can pass more versions
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
Putting this under a conditional makes it undefined under the opposite condition.
The phrase "unless within a playbook adjacent collections directory" is a mouthful. It's also not immediately apparent what that means unless the reader is well versed in Ansible jargon. > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection may not be picked up in an Ansible run. If there is a strong desire to mention adjacency (I know this was explicitly requested in the related issue, but I don't think it's the clearest phrasing), then something like this is probably best: > The specified collections path '%s' is not part of the configured Ansible collections paths '%s'. The installed collection will not be picked up in an Ansible run unless adjacent to a playbook.
The only odd behavior I can create is if I set 'collections_paths = :' (an empty list) ``` ini [defaults] collections_paths = : ``` In that case, the collection ends up getting installed into $PWD/ansible_collections/. But I suspect that is a general issue with config types of 'pathspec' and not specific to collection_path.
Yeah, this should probably be an error if the config has explicitly removed the paths...
How about selecting a semantically better exception? ```suggestion raise LookupError( 'File "{target_path!s}" not found in collection path "{coll_path!s}".'. format(target_path=path, coll_path=ANSIBLE_COLLECTIONS_PATH), ) ``` P.S. `str()` is unnecessary since the specifier does that already.
You can omit `type` and `default` in the docs for these options.
Sounds fine to me. I don't think I can say shipit yet, but if this gets wrapped up in another PR the rest looks fine to me.
Yep - I'm not against the _notion_ that it be possible, it just shouldn't be possible _accidentally_. Most LUKS containers I've worked with only have one key on them, ever.
I don't know if I like this approach. I can't think of a time when this would ever be desired behaviour, and not a mistake - even so, I feel like we should require a force flag to remove the *only* key on a container, rendering it useless.
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
Actually it needs to be `AttributeError` to keep everything happy (which the import machinery will turn into an `ImportError` if it was sourced by an import)
`delay_min_macos = delay_min | 1`
su requires a tty, that is why most 'subprocess' plugins don't support it.
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
if not handling become methods update the class variable to indicate this
This supports more than just URLs, I would add more points talking about what it actually supports.
Change to source and remove the alias
I would just say, 'Set's the C(InstallationPolicy) of a repository'`.
Please add an example below that shows you how get the newer NuGet provider version.
This is more, requires the [PowerShellGet](https://github.com/powershell/powershellget) module to be installed instead. You can keep a note saying this is installed with PowerShell v5 though.
`memlimit` and `memswaplimit`: allowed units could be mentioned.
Better to call it path.
not a blocker but the convention is to have `present` as default, please also consider this for your module.
I assume `If the datastore cluster should be present or absent`
`state`: a `choice` parameter should be used ([example](https://github.com/ansible/ansible/blob/6cdf91fd35fefec35dca4594db231cc6af5a8620/lib/ansible/modules/system/capabilities.py#L167))
`AclArgs.argument_spec` is returning `None`, which is causing `validate-modules` to stack trace. There's probably a bug in that class.
Please update the sample commands.
Please remove deprecated parameters as this is new module.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
Please move this below the future import statement, to keep the module consistent.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Keep a blank line between examples for readability.
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
The docs state that the hard limit is derived from the soft limit, so we should be able to simplify this: ```suggestion options.extend(['--ulimit', 'nofile=%s' % MAX_NUM_OPEN_FILES]) ```
The `u` prefix should not be needed.
```suggestion return {} # podman does not handle this gracefully, exits 125 ```
Ah, sorry, I should have looked at the type annotations instead of the code you'd already written. The return should be `[]` instead of `{}`. ```suggestion return [] # podman does not handle this gracefully, exits 125 ```
Why not this instead? ```suggestion if 'no such image' in ex.stderr: ``` Or use `ex.stdout` if the error is on stdout. The same applies to the other changes as well.
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Nit: You have an extra period after 'example'
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
Please make this oauth_token.
Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...
Argh, I just realized the PluginLoader attribute stuffing (update_object) has been happening on `class_only` cases, which is broken for "same name, different behavior" cases (since subsequent loads will overwrite the class vars on the existing type object, not instance vars). It works here, since `all` is `yield`ing the plugin class immediately after calling `update_object` on it, but the whole pattern is busted for `class_only`, esp for things that might consult the class var during or after `__init__`. We've needed to rethink that for awhile, and this kinda sets it in a little more concrete. :(
```suggestion # try to get collection world name first ```
don't use print, display.error or raise an AnsibleError exception, Ansible already does not fail due to an Exception from a callback event.
These `os.getenv` calls should likely be updated to use `self.get_option` and potentially `self.set_options`. See the `slack` callback for examples.
Sorry for the late update, just spotted this (caught me out somewhere else) [fail_json_aws is defined](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/aws/core.py#L191) as `fail_json_aws(self, exception, msg=None):` You can simplify this to ``` module.fail_json_aws(e, msg="Unable to delete user {0}".format(user_name)) ``` Probably worth swapping out most of the fail_json calls for similar fail_json_aws calls too.
`policy` should be added to `argument_spec` to be usable.
Looks like another weird conditional slipped through, this should be `if location not in ('us-east-1', None):`
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
Can be replaced with https://github.com/ansible/ansible/blob/a3390b63fe317eb2fea5d78fb99c8a5e8fc8eaf3/lib/ansible/modules/cloud/vmware/vmware_host_ntp.py#L93
``` pbm_object_ref = pbm.ServerObjectRef(key=str(virtual_machine._moId), objectType="virtualMachine", serverUuid=self.vc_si.content.about.instanceUuid) ```
Add more description about module and other things like warnings, recommendation etc.
I suggest showing two examples, one for present, one for absent
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
Could you create a function here as well
server_change_ip_attribute does not return anything
Both `server_change_attributes` and `server_change_ip_attribute` methods call `compute_api.get(path="servers/%s" % target_server["id"])`. If only mutable attributes but no IP are updated (or only IP but no other mutable attributes), `compute_api.get` is called twice whereas one call would be sufficient. Then `server_change_ip_attribute` could be called by `server_change_attributes`, before calling `compute_api.get`.
I would rather use something like: `target_server_updated = server_change_ip_attribute(compute_api=compute_api, target_server=target_server, wished_server=wished_server)` (then return `target_server_updated`).
I guess "terminated" here too.
no, nope, don't do this, a 'do' option is not something we would accept if you want to add a persistent=no|yes option to save or not, that would be acceptable
```suggestion - Must be in the same resource group as VPN gateway when specified by name. ```
```suggestion - Can be the resource ID of the virtual network. ```
```suggestion - Can be a dict which contains I(name) and I(resource_group) of the virtual network. ```
a more generic interface might make this easier, something that loops over the param if not all and just calls matching classes, leave `get_all_facts` as the normal trigger for `all` value.
Seems to be unreachable code to me.
You can move this check to `module_utils` as well.
Values we return are in bytes.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
I would replace these 3 lines by: ``` # Add these imports from ansible.module_utils.compat import ipaddress from ansible.module_utils._text import to_text ### prefix = ipaddress.ip_network(data["prefix"]) network = to_text(prefix.network_address) mask = prefix.prefixlen ``` This way, it will not fail if `data["prefix"]` doesn't have a netmask (default it to /32 for ipv4, /128 for ipv6).
`get_config` is not implemented in the cliconf plugin. This function is not used and will only ever return `"None"` if tried.
You don't need this function
This argument is marked as being removed in the same version it is introduced. This makes no sense.
From 2.5 onwards network platforms using persistent connection will be using cliconf and netconf plugins. To use cliconf plugin you need to add platform-specific plugin in `lib/ansible/plugins/cliconf/<platform-file>` You can refer `asa` modules as it is implemented using cliconf api's https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/asa.py https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/cliconf/asa.py
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
I don't like the `: ` here
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line.
This should be configurable in the module arguments.
If we do go with this approach, I feel like `VMDB_PATH` should be user-configurable
I'm worried about Ruby quoting. If any setting contains a single quote, this will break. What I suggest is passing via ARGV. `rails r` leaves in ARGV any args following the ruby fragment, e.g. this works: ``` # The \' escaping below is only to type this via shell; # run_command() takes an array of strings and I think this way could pass arbitrary JSON with no other escaping at all. rails r 'puts MiqServer.my_server.set_config(JSON.parse(ARGV.last))' '{"goodbye": "Qapla\', Worf"}' ```
I think it would be better to use `MiqServer.my_server.add_settings_for_resource(â¦)` here. This will queue a settings reload for all workers running on the target server after save.
You probably should just exit here with `changed=False`
Move this up to before line 2641 so that the diff is returned in check mode.
```suggestion 'after': '{0} removed\n'.format(user.name), ```
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Exception handling here too.
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
You could move this a couple lines above and remove the two in the elifs below.
Oops, missed something. I think this should still return the describe_db_clusters call so changed is accurately reflected by whether or not the cluster exists. No changes are being made by that call so it's fine and you're checking for module.check_mode in delete_cluster().
Trailing whitespace on a blank line is failing the PEP8 checks.
Removing these lines will re-break: https://github.com/ansible/ansible/issues/24169
this is incorrect, the caller is specifically asking to use shell
Do not move this. You may want to remove setting shell = True in the above conditional block, though.
I don't think this is safe. If someone is calling this function without unsafe_shell they probably have not quoted the arguments to prevent this sort of expansion.
the shell itself would have done it before. but might have done it slightly differently.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
By non-trivial I just mean values that aren't None or empty strings. I'm not sure how much user control we expect over those settings but I might not have read the parameters carefully enough. The following untested somewhat pseudocode illustrates the simpler approach: ``` @AWSRetry(**backoff_params) def list_keys_with_backoff(connection, bucket): pg = connection.get_paginator('list_objects_v2') return [obj['Key'] for obj in pg.paginate(Bucket=bucket).build_full_result()['Objects']] def list_keys(connection, bucket): try: return list_keys_with_backoff(connection, bucket) except botocore.exceptions.ClientError as e: etc... ```
This function seems to be much more complicated than it needs to be. Does anything call this function with non-trivial values for prefix, marker or max_keys? (I'm guessing previously the function called itself to get the next page). I would argue for using paginator with build_full_result in list_keys_with_backoff and then the calling functions (`delete_keys` etc.) can just use that directly rather than having to manage the page combination themselves.
Little :bug: : In **check** mode, the `keycloak_realm` always returns `result['changed']: True` You need to add something like `result['changed'] = (before_realm != updated_realm)` here...
ditto `s/client/realm` :wink:
ditto `s/client/realm` :wink:
copy-paste issue: we should talk about **realm** object here, not a _client_. To be globally replaced in this file...
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
Ok, so long descriptions are not a good idea. Best practice is to do: - First line is a short description of what the parameter is - Subsequent lines for additional information on behaviour, or what different possible values mean
Ok, but that's only the message, which shouldn't be parsed / understood by the calling code. Something useable would be a boolean variable `docker_in_swarm_mode` or `swarm_node_is_manager` which is returned in any case (except maybe when the docker daemon doesn't seem to be there in the first place). It might be a good idea to introduce a general `fail_results` variable in `AnsibleDockerClient`, which is empty by default and passed on to `module.fail_json` in `fail()`. If everyone (i.e. also the code in module_utils/docker/swarm.py) calls `client.fail()` instead of `module.fail_json()`, it will always be returned. Then the facts module can put the booleans into `client.fail_results` with value `False`, and update them to `True` once the corresponding calls succeed. If you want I can prepare such a system in another PR.
No need to explicitly state that a parameter is not required. That's the default. It helps find required parameters when skimming docs if only the required parameter have a required-key.
No need to quote strings in YAML except in very specific cases. We tend to only quote strings when it is required for consistency and educational purposes.
So there are two concerns: 1. the naming of states (add/remove/leave) which are imperative statements 2. the module is managing 2 different object classes I know there are other modules that break on both accounts too. Not being a docker swarm expert, I don't know if I can come up with the best solution. 1. Maybe use states **present**/**absent**/**unregistered** ? Or is it an option to have **present**/**absent**, and a separate parameter **enabled** 2. The main question is whether there are additional properties to manage that affect the swarm, or affect the node. That would be a good reason to have it split.
note, the spelling of this word is: vacuumed. Probably should change it everywhere.
Note: This syntax is python-2.7 or greater. Using .format() with positions is 2.6+: ``` python cmd += ' {0}'.format(uuid) ``` It's more pythonic to create a single string rather than two. for instance: ``` python cmd = '{0} {1}'.format(cmd, uuid) # or cmd = ' '.join((cmd, uuid)) ``` If you need to be compatible with python less than 2.6, you need to avoid .format() altogether. So the .join method or percent formatting: ``` python cmd = '%s %s' % (cmd, uuid) ```
not a requirement, but would be nice to validate all IDs before returning an error (in case more than one is wrong)
we normally prefer to use the same tmp directory as the modules themselves are put into
finding it when not using pipeline is normally `dirname(__file__)` as module itself is located there.. but as discussed, need to create generic and then revisit modules doing this
basic is now a real import, since ansiballz were introduced
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
Yes, please remove the return and update the caller.
check here for the regex fix https://github.com/Qalthos/ansible/pull/5/commits/89f2a106db4f7296822e118ad24f66cea84f3be9#diff-e72efaa6b72beb5339ad847e21a31220L87 Good catch on the first_port / last_port ... will add a fix for those. This is a common pattern to be used by eos modules. I have held off on pushing the modules upstream until we get the initial push of the refactored network shared modules
Should the `continue` be here? The following 3 lines will never get evaluated.
`short_description: Manage VLANs on VyOS devices`
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
As `state` value is fetched at L112, this is not required.
VERSION_ADDED should be "2.3"
Mutually exclusive with I(domain_name).
It's not a big deal either way, but since import sanity actually has to run on 2.x, it'd be *nice* if the type hint support was getting exercised there as well. Honestly I don't have strong feelings either way- I'm happy to merge as-is and we can go fix it and turn on remote-side stuff later (or not), or we can wait for Matt C to be back late next week and see what he says. There are also a couple other ways to fix this for 2.x (but a bit gnarlier at the import sites). I suspect that having the blanket ignores present for 2.x's benefit could mask potential problems or missing typeshed stuff in 3.x, so we *might* want to look at the fully-inline options if/when we light this up for 2.x.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
VM or VirtualMachine
I'm not sure what the point is to assigning a class with only static methods to an instance variable. (For that matter, it is not clear to me why this is a class at all, but that seems less confusing)
The return value is not strictly cookies. The return value is a dictionary of headers
This should be `module.fail_json(...`, not an Exception
Same as above, can be done with sub options
Do we need to do any check on this? Can this fail due to permission issues, or due to the file already existing? I'm fine with this always overwriting the destination file, and coming up `changed=True` every time, i just wonder if there is a risk of exceptions (pretty sure both `fetch_url`, `open` and `write` can throw a bunch of exceptions.)
This assumes that we always make changes, even if the directory already exists (or is already missing), or if the file already exists and is not overwritten.
add a check if vm_id_type is vm_name and not folder then present error "Folder is required parameter when vm_id_type is inventory_path"
and if possible please: `Destination %s is not writable` (the word `is` is missing)
Please change message to `Destination %s does not exist`. (The word `does` is missing)
Note that fail/exit_json should be handling bytes or text; making them the proper string type for that python version before passing them in to the stdlib's json.dumps().
I think a more comprehensive solution is needed here in check mode. If the directory already exists, the permissions check should still be performed. If it does not exist, check the permissions on the nearest parent directory that does exist. This assumes the module will have write access to any additional directories it creates, compared to the existing behavior where that is confirmed by actually creating missing directories.
The module should not wait for `force` here. All `openssl_*` modules also don't do that, including `openssl_privatekey`.
Yes. We'll probably need to consider redesigning defaults separately. Out of scope now.
Yes, it will append flags with `True`, `1`, `1.0`, `y`, `n` (any string) values. And will skip `0`, `0.0`, `None`, `False`, `[]`, `{}`.
It's just a thing, which makes diffs nicer when you add/remove list items. Otherwise the other line where you put comma is always listed as changed in diff, which makes it harder to review :)
This change is causing the CI failure: > failed: [testhost] (item=python2-rpmfluff) => {"changed": false, "item": "python2-rpmfluff", "msg": "Autoremove requires dnf>=2.0.1. Current dnf version is 1.1.10"}
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Another (and possibly cleaner) way to do this is to use `pytest-mock`: ```python class SpiedOnTarget: @staticmethod def do_a_thing(): return None def test_empty_retry_iterator(mocker): decorate_with_no_retries = retry_with_delays_and_condition(backoff_iterator=[]) spyable = mocker.spy(SpiedOnTarget, do_a_thing) invoke_retriable = decorate_with_no_retries(SpiedOnTarget.do_a_thing) invoke_retriable() assert spyable.call_count == 0 ```
Always use raises with `match=` or you'll catch false positives. Especially because almost any exception is a subclass of `Exception`. ```suggestion with pytest.raises(Exception, match='Error'): ```
It'd be interesting to see a test case for something inheriting a `BaseException` too.
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
```suggestion except Exception as err: ```
```suggestion "Error: " + to_text(err)) ```
```suggestion "Error: " + to_text(err)) ```
```suggestion "Error: " + to_text(err)) ```
You still don't need this branch ```suggestion ```
Nit: `(object)` is unnecessary
This should probably make use of `self._code_resp['expires_in']` to save an API call that is guaranteed to fail.
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
That's a really interesting piece of information I did not know.
`AnsibleConnectionFailure` is a generic error, it does not mean the resource is missing. It should be more like an err 500.
Oh! That's actually quite scary. Could people unexpectedly clobber their own variables through ansible_facts? I'm actually much more worried about ansible_facts than I was before - I really don't think it's clear that if you use a module, variables will be set whether you like it or not. I prefer explicit use of `register`.
It'd be better here to catch boto exceptions & other exceptions separately, since generic exceptions (like IOError if the network fails, for example) don't have status codes and other boto-isms.
```suggestion # require that the final recorded stack state was DELETE_COMPLETE ```
```suggestion # require that the final recorded stack state was ROLLBACK_COMPLETE ```
Ooh, this is a nasty bug - if this wasn't in this PR,I wouldn't have spotted this. If this code happens elsewhere, it'll break when 2.4 goes out (because a now valid key is overwritten by the content of a now missing key)
Typo in `module_utils`.
```suggestion author: Edoardo Tenani (@endorama) <e.tenani@arduino.cc> ``` (Same for the other PR. This will make sure that you will be notified about issues / PRs for this plugin by ansibot.)
One odd thing that has come up with the os-release parsing code in module_utils/facts/system/distribution.py is the quoting of some of the right hand side of lines. I'll track down the bug momentarily, but at least one distro did odd things about what was/wasn't quoted (either VERSION wasnt quoted or ID was quoted?). The lsb/os-release spec is kind of vague on that, and different '/bin/lsb_release' tools seemed to do different things. This isn't something that has to be addressed since I don't think there was a clear correct answer, but just mentioning it for context.
```suggestion version_added: "2.10" ```
These tests now run on python 2.7 (though fail on python3 still). I think if we're moving toward using placebo rather than just mocking, it may make more sense to do that here, especially since integration tests won't be run with CI (and running them manually may not happen terribly frequently). Shippable will notice if the placebo recordings lose compatibility with changes made in a PR.
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
`msg="'%s' device group not found in Panorama. Is the name correct?" % devicegroup)`
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
`policy` should be added to `argument_spec` to be usable.
```suggestion type: str required: True ```
```suggestion type: str required: True ```
```suggestion - Whether to power on the VM after cloning. ```
```suggestion type: str required: True ```
```suggestion type: str required: True ```
Please modify this to `elif delta.get('peer-link') and not existing.get('peer-link'):`
Remove this line.
Please remove this alias. No one will be using the older `waitfor` as this is a new module.
Please remove the sentence `Valid values are C(all) or C(any). `, that's covered by the `choices:` section.
Doc describes `intenal`, no `state`
I thought the module was older :)
Would be perfect with `delegate_to: localhost`.
~~~ - name: Ensure a network is present cs_physical_network: ~~~
For consistency, please use the `delegate_to: localhost` syntax.
there is a missing condition for check mode
Please don't add any aliases except for backward compatibility. We don't want to offer more choice than necessary.
This needs to be C(validate_certs) which is the standardized parameter name.
Use best practice to handler this error : ```python GITLAB_IMP_ERR = None try: import gitlab HAS_GITLAB_PACKAGE = True except Exception: GITLAB_IMP_ERR = traceback.format_exc() HAS_GITLAB_PACKAGE = False ```
Put the object creation out of this function in the `main` to be more readable. Then only pass the gitlab object to your function.
Bare `except:` is very rarely (if ever) what should be used. In this case, it means a `ctrl-c` will be caught and Ansible will keep going. I suggest using something more specific (at least `Exception`, which won't catch `ctrl-c`).
i mean `display.warning('file %s was empty and had no tasks to include' % include_file)`
we should add warning about empty file
I'm pretty sure this can use `is_sequence()`.
I think this is acceptable for now, but for the future, I think we should see if we can make use of post validating to cover all arguments in a single standard way.
I haven't looked at this PR in depth yet, but the first thing I notice is that this should use `original_task.copy()` instead of `deepcopy`. Our `copy` methods are specifically designed for copying these objects. We will also need to closely monitor memory usage due to any changes that make copies of objects.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv = {'all': []}`
API version 4 is [no longer experimental](https://github.com/voxpupuli/pypuppetdb/releases/tag/v0.2.0).
[PEP 8](https://www.python.org/dev/peps/pep-0008/#pet-peeves): Remove extra space: `inv.update({env: []})`
Typo in `command`.
[PEP 8](https://www.python.org/dev/peps/pep-0008/#blank-lines): There should be two blank lines before a function.
I'd rephrase: "Kernel command line parameters (formatted as string) to be used with the kernel specified by `kernel_path` option."
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
s/will created/will be created/
```suggestion type: int version_added: '2.8' ```
```suggestion type: int version_added: "2.8" ```
Examples should be in multi-line with `key: value`
Don't add `required: false`. It is implicit.
can be ignored
No need to quote.
No need to quote.
No need to quote.
No need to quote this value.
Ok, so I may have given you the wrong advice before. I was under the impression that these modules were talking to a backend, but (at least) this module seems to run on the remote target (over SSH ?). So delegate_to: localhost` will not work correctly.
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
also need to return AnsibleOptionsError if the value of the config is incorrect
i would move this into the 'else' below when it does not match 'smart', also probably should be .lower()
I'd move this block into it's own method since fetch_file will likely need it as well.
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - To modify the namespace use the I(netns) option. ```
```suggestion - Enable or disable ARP on an interface. ```
This import is unnecessary.
boto3 import failure is handled by AnsibleAWSModule. ``` try: from botocore.exceptions import BotoCoreError, ClientError except ImportError: pass # Handled by AnsibleAWSModule ```
Should catch `BotoCoreError` and `ClientError` here, and use `module.fail_json_aws()`.
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
```suggestion - Requires API version >= 1.30 ```
CI is failing here, you need `version_added: "2.8"`
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
``` - dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in KeyCloak REST API. ``` Example of mentioning the upstream api camel case name.
non-blocker: this doc should be improved, I would have no idea how to use `status`
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
required=False is the default, so you can omit that, same for any of the following. `name_regex=dict()`.
This can be updated to use AnsibleAWSModule from ansible.module_utils.aws.core. Then you will be able to remove the check for HAS_BOTO3, the exception handling around the client, and the use of get_aws_connection_info and boto3_conn (as well as any of the imports for those things) and do `client = module.client('emr')` instead.
It would be good to call out a reboot is required to make it active
You should check if the options actually changed before reconfiguring the plugin. It only makes sense to reconfigure if this actually changes something.
> wirte write
I think you might want to rollback at this point.
it's not a directory, name it according to what it is.
Sure, so fix it please :)
I'd probably put this try/except block into a dedicated function to explicitly name this step.
When required is false, it can be left out (since it is the default).
This seems to be a leftover, there is no state "updated" anywhere else in the code.
space looks unnecessary
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
```suggestion class VMwareExportVmOvf(PyVmomi): ```
Module argument specification ensures this cannot be true. The field is required.
```suggestion except OSError as err: ```
```suggestion - Export an ISO image of the media mounted on the CD/DVD Drive within the virtual machine. ```
Perhaps: ```suggestion def esxi_version_at_least(self, version): """ Check that the ESXi Host is at least a specific version number. Inputs: - version (tuple): a version tuple, for example (6, 7, 1) Returns: bool """ ``` Suggest moving into module_utils/vmware.py and providing a unit test.
get_basedir should not be needed, the ansible_search_path should include the correct one
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
Putting this under a conditional makes it undefined under the opposite condition.
I would reverse order and have parse_kv go first, since it will also still be the most common usage, also the current detection will create many issues, we have used it before (still do for safe_eval). Use a try/fail approach on parse_kv to try yaml parsing afterwards and error out if all fail the module_require_args check should not be limted to kv, but also force skip yaml attempt
If an unknown keyword is specified, `kdata` has not yet been assigned at this point.
I would prefer 'true', actually C(true).
nitpick: you --> your
Apparently, I don't have permissions to push to your branch. I didn't want to hold up merge. Feel free to raise a PR to fix this if you'd like, though don't lose sleep over it
Yes, that file has moved in the meantime. That's also why we have that conflict.
This should be "Delete a tag"
```suggestion if ci: ```
```suggestion npm.ci_install() ```
Booleans should be checked using is instead of ==. ```suggestion if ci is True: ```
Should this be updated to elif when using ci mode? ```suggestion elif state == 'present': ```
This seems wrong. Won't this end up being the equivalent of: ``` /bin/sh -c if [ x"test" = x"test" ] ; then printf "hi" ; fi ``` When what we really want is the former which is the equivalent of: ``` /bin/sh -c 'if [ x"test" = x"test" ] ; then printf "hi" ; fi' ```
period at the end of statement.
Change description to match `enable` and `disable` dvSwitch.
`Name of the datastore cluster from which all child datastores need to be managed`
Indent is required here and below line.
`Name of the cluster from which all child datastores need to be managed` I find this a bit weird, btw... clusters do not really have datastores directly as children, only datacenters have datastores directly: You can not create a datastore specific to a cluster, you create datastores on the datacenter, and connect hosts to them. I assume the `cluster.datastores` just lists all datastores that are connected to hosts in that cluster. Personally, it would make more sense to use datacenter as a grouping parameter instead of cluster (but that might also be a bit excessive, as that would put all datastores in maintenance mode in a DC, basically preventing any VM to run at all...)
period at the end of statement.
Add a note that principal parameter is required if group is not present and same for group parameter.
`required: False` is default so need to add. Same for other.
Elaborate more on case - what happens if state is set to absent. Also, other conditions like if permission does not exists.
Set self.is_group by default to False
<nod> I'd be happy to see fixing it everywhere added here if you want but don't demand it :-)
Does the check module.run_command() through the transformation into smbios_dict have to be inside of the loop? It seems liks we could do that outside of the loop to be much more efficient.
Is there a reason to sort this? Since we're just putting it into a set (to uniquify the list I assume) it doesn't seem necessary to sort. Since we're just iterating over sd_instances, a frozenset is more appropriate than a set.
Need to `return bind_mounts` here
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
according code, it is not required.
according code, there is no default, so can be left off.
Example fields doesn't match the real fields name (server,user, pass)
there is no need to version params for new modules
is this really "<name>" or should this point out that "value of the name param" is taken? Please make this clear here.
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
type should be a 'int'
Please add `type="str"`
Please add `type="str"`, and maybe list the possibilities as `choices=`.
It would IMHO make more sense to move that near the other command, so we can verify both command at the same time.
So, this doesn't verify anymore that user is set, unlike the previous PR, I think that should be corrected.
<nod> I see what you mean about checking the length for the secret leaking information about the secret that the attacker would not otherwise know. However, checking the length for the plaintext doesn't seem to suffer from that same problem. The attacker already has an idea of how long the plaintext is because the length of the ciphertext will reflect that. So checking the length of the plaintext and falling back to os.urandom() if the plaintext is too short seems like it can prevent some problems without revealing new information? (Hmm... it would reveal that the plaintext is less than a precise value whereas looking at the length of the ciphertext would be more vague.... Would that be important or not?) The attacker can learn a lot about what is in a vault file from external sources... for instance, since they're yaml files, they likely have a rough outline of: ``` --- var: value ``` an attacker might also find the precise name to use for "var" by looking at playbooks to see which variable names exist that are not defined outside of a playbook. So then the only thing about the plaintext that they'd be lacking would be the actual value....
```suggestion system = to_text(platform.system(), errors='surrogate_or_strict') if system == u"OpenBSD": ```
For context, this was proposed because the difference between trying to brute force the ciphertext and trying to brute-force the hash being used for the salt was brought up. The pbkdf function making it more expensive to generate the encryption key from the password rather than generating the hash was one difference that was brought up.
This claims support of `check_mode` but then never checks for it in order to call `module.exit_json` without actually making changes.
Do not use print statement. All module output is supposed to be returned as JSON.
use `isinstance(obj, type)`
missing import `from ansible.module_utils._text import to_native`
Use [find_vm_by_id](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L173) instead.
Use [find_datastore_by_name](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L145) instead.
Sorry it's now 2.10
set the type to list then
add an alias to `domain` as `domainname`
This wil fail, as there are 2 actions in the same task.
a teeny typo: ipvr_addresses -> ipv4_addresses
Remove default from `description:`
The doesn't appear to match the code ``` + mutually_exclusive=[['source', 'image']], + required_one_of=[['image', 'image_family']], + supports_check_mode=True ``` Please also use `I(...)` for option names
Please add docs on what this module returns.
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
Please remove empty `aliases:` lines
The CamelCase exception .response attribute is particular to boto3's ClientError. IOError doesn't have .response so you can remove the `**camel_dict_to_snake_dict(e.response)` bit of this.
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
It looks like just setting `instance_monitoring` to `true` now won't really do anything, since basic monitoring is on by default and the value of `advanced_instance_monitoring` would default to `False`. This seems confusing.
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
I think this might explode if `obj_type` is not one of `functions`, `indexes` or `tables`, maybe it would be safer to do something like? ```suggestion obj_func = self.obj_func_mapping.get(obj_type.strip()) if obj_func is not None: obj_func() else: module.warn("Unknown filter option '{}'".filter(obj_type.strip()) ```
```suggestion - Note that to use dedicated tenancy you MUST specify a I(vpc_subnet_id) as well. ```
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
spec is also returned
HAS_BOTO3 doesn't need to be imported since AnsibleAWSModule checks it.
This needs to be CacheSubnetGroupNames. And the associated module parameter type should be set to 'list'.
Include PEP 484 type hints to match the changes and remove the old PyCharm type hints below. ```suggestion def __init__(self, running, # type: bool hostname=None, # type: t.Optional[str] port=None, # type: t.Optional[int] username=None, # type: t.Optional[str] password=None, # type: t.Optional[str] ): # type: (...) -> None ```
Return just the response JSON, rather than the entire response. ```suggestion response=response_json, ```
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
regarding backup, the way this is implemented will backup the file to the location where the module is executed. When we exeucte this as local_action or `ansible_connection=local`, it will backup the file to the control machine, however we run this module with `ansible_connection=ssh` it will be backuped to the remote machine. This is probably not what is intended. So this should be solved as "action_plugin" (identical to ios_config) which will ensure, the backup is going to the control machine.
Please add `, no_log=True`
The the formatting argument is single value, it doesn't have to be in braces: ``` cmd += " --format=%s" % p["format"] ``` It improves the readability slightly. The same should apply across the whole code.
Please add dot at the end. The same applies to the descriptions bellow.
The `default=None` can be removed. And I think the `type=str` can be removed as well as it's the default type.
they don't need to, but can be as long as they are acurate
This can be as `elif`.
Apparently, Python 2 does not have a `TimeoutError`
https://docs.python.org/3/library/exceptions.html#TimeoutError says that `TimeoutError` is an `OSError` subclass that's been added in Python 3.3
The docstring should probably explain that this is to be used in the main thread only... And the implementation should probably do the corresponding runtime checks.
Now that we're making this a module_util, this should no longer be considered a hack.
I think we should have an entry-check to protect from reuse: ```suggestion def __enter__(self): assert not self.timed_out ```
You may try
don't leave a file descriptor open. use a context manager (via `with` block)
You shouldn't use `is`. Just `not mongo_configuration_credentials`.
This clause is exactly the same as in the first branch. This branch will never get executed.
Please don't return different types of data from a function. It should always be consistent and discourage checking the return value. Unlike low-level C-code, Python provides you with a variety of handy ways to communicate failures to the calling code (like exceptions).
Create address service object on PanOS devices This may need updating on existing modules
Capital letters & full stops please
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
`required: false` lines can be removed
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
osx_say is still there as a symlink, unsure if this is the correct solution as this will be the case with any aliased module.
Please change to: ``` from C(osx_say) to M(say) ``` No need to have a link from say to osx_say, as you'd end up on the same page
The alternative would be to always report `changed=False` in check mode, but that could result in an unexpected change during normal execution when you were expecting no change. I would rather Ansible report a change in check mode, but do nothing in normal mode to be on the safe side.
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
following task -> the following task
```suggestion - Status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - URLs to retrieve a public I(blob), I(queue), or I(table) object. ```
I'd remove "Gets" from all of these descriptions, so they would read "The primary blob endpoint and connection string." etc.
```suggestion - Status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - Allows https traffic only to storage service when set to C(true). ```
Another new addition is a bunch of *_config methods raising NotImplementedError if not overriden in the subclass. Which is to say, `replace_config()` is also unnecessary here
This one is a bit newer to CliBase, but also implemented verbatim in superclass
FWIW using `monkeypatch` is preferable because it's pytest-native unless I need something like mocks or spies.
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
self._connected is set by CliBase.connect(), shouldn't need to specify it here
I would make present the default
Please add `, no_log=True`
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
`inspect_service()` returns a `NotFound` exception if it cannot find the service ([CI error](https://app.shippable.com/github/ansible/ansible/runs/108392/51/tests)). Check out module_utils/docker/common.py, it catches that in a few cases I think.
```suggestion elif docker_object == 'networks': ```
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
This `.close()` isn't needed, the context manager closes the file automatically.
These parens aren't necessary for unpacking the return values.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
Just a suggestion. We can rely on the GuestID here to set the default value: If the GuestId starts with "win" -> PowerShell, otherwise, /bin/sh.
```suggestion env: - name: VMWARE_VALIDATE_CERTS vars: ```
missing ini/env var entries (to use global default)
This isn't true anymore.
```suggestion - VM path absolute to the connection. ```
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Please remove `required=False`.
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
Please remove `required=False`.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
`if filters:` should be enough if you are checking for empty dict
use tags.items() here, no need for iteritems import
i don't see a need for this change
we normally add more than the 'library' error as they tend not to be as helpful as giving a user context on what you were attempting to do exactly when the error occurred.
boto3_conn now handles region problems, no need to do it in the module
Please add `, no_log=True`
Please rewrite as ``` if __name__ == '__main__': main() ```
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
This block would be a bit more legible, if you checked use_hostnames, then assigned to a temp variable whichever label the user has requested, and then appended that. Something like (pseudopython): ``` this_host = host if not use_hostnames: this_host = ip if frontend: frontends.append(this_host) else: backends.append(this_host) ``` This is admittedly a style thing, but I think it would be more readable/shorten a few lines.
Will info['body'] be json? Might be a string/HTML.
This looks needlessly generic. why not just do: ``` python if op == 'get_password': get_password([...]) elif op == 'create_host': create_host([..]) ``` If you think you're going to have a lot of operations, you can have a lookup table: ``` OPERATIONS = {'get_password': get_password, 'create_host': create_host} method = OPERATIONS[op]([...]) ``` but for just a few operations I'm not sure I would do that... it obscures what the code is doing in any given situation to code it like that.
This is just style but we try to follow standard python naming conventions. So function and method names should be underscore separated like this: ```get_resources```.
I'd also default to True for validate_certs as that is a safer default.
Doesn't really matter since you're not likely to instantiate more than one PasswordManagerPro object in this short script but these should be instance variables, not class attributes. Move setting of default values into the ```__init__```
It's safer to quote unvalidated strings with, e.g., [`urllib.quote`](https://docs.python.org/2.7/library/urllib.html?#urllib.quote) before concatenating them into a URL.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
`return migs != 0` is equivalent ot lines 380 to 382.
I wouldn't exactly call a dictionary `list`.
A message string would good to say that image is not preset or something similar.
`Check the configuration files` seems vague, I propose: `Check inventory file and vultr configuration files`.
When `hostname_preference` is equal to `name`, there is no need to define `ansible_host`.
`id` isn't used, it is sufficient to iterate on keys.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
@gaudenz for those that really want it, there will be global toggle available, you CAN add toggle at plugin level to do same
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
Yeah, a list is fine.
Do you want the same example for all modules? Normally we don't put any examples in `docs_fragment`
All `description:` need to be full sentences, e.g. capital letter and full stop
in many modules the default is `state=present` please consider it too if it makes sense.
many modules have the default of `state=present`. consider this as a default if you feel it make sense.
Although not required, we generally put `description:` first as we find it makes the source code a little more readable.
This one *might* not be redundant, if it's possible to make changes that will cause the CDN endpoint hostname to change...
Maybe should be AzureRMCdnEndpointFacts, but that's minor
You don't need line breaks for lines less than 160 characters. Noticing a lot of these.
purge_tags doesn't need to remove all tags - you can use compare_aws_tags() (in module_utils/ec2) and then call untag_resource() with the list of tag_keys that are returned.
If the tags option is a dict you can use python_dict_to_boto3_tag_list instead of implementing the functionality here.
```suggestion - name: Update all filesets to latest level from lpp_source lppsource_aix6109-06 ```
```suggestion - name: Deallocate all resources from the nimclient ```
```suggestion - name: Reset the nimclient ```
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
As long as the schema validation will report the issue, it should be fine to ignore the error.
Would that be caught by https://github.com/ansible/ansible/blob/devel/test/sanity/validate-modules/schema.py#L126
This isn't a new problem of course, the previous code would exhibit the same behavior.
Note: It's preferable to use Mapping rather than dict. That way a Mapping object that does not inherit from dict would be recognized.
I'd keep the original style here: ```suggestion version_schema = { Required('removed_in'): deprecation_versions(), } ```
We are beyond 2.7 development cycle, we need to update this to 2.8 as it is current development cycle.
This information is redundant, I would remove it
Instead of `namestr`, `name` would be more apt since it will match rest of the modules.
```suggestion - Only relevant when C(vlanid) is supplied. ```
```suggestion - Create or delete project variable. ```
This might shadow built-in `format`
Use [`fetch_url`](https://github.com/ansible/ansible/blob/240d1a6afb43982f16acebef16778d17aab58160/lib/ansible/module_utils/urls.py#L1197) instead of `requests.get`
```suggestion with open('/var/run/secrets/kubernetes.io/serviceaccount/token') as file: ```
Is there a particular reason for this change in behaviour? More just curious because I see the other `auth_*` methods have a default mount_point as well.
It would be awesome if buildah supported copying from a container.
```suggestion - When set to true, pool member FQDNs are instead resolved on service engines in this cloud. ```
```suggestion - By default, pool member FQDNs are resolved on the controller. ```
Why did you introduce a space here? The original expression looks better to me. ```suggestion - For example in AWS and GCP, 169.254.0.0/16 is used for storing instance metadata. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
`"Allowed values: 1, 2, 3, ''."`
"None" here may be a bit confusing. Choices are numeric here.... but strings afterwards
I'd recommend allowing module users to specify "follow=yes" without error (but perhaps a deprecation warning.) It would be useful to use a common playbook with multiple versions of ansible.
You can enclose a URL in `U(https://...)`, for this to work you would need to also remove the `(v=vs.85)` from the URL.
Would add a note saying this does not deal with disk initialization and file system formatting.
I don't think we can just remove this now that it has been in a release. We'll have to deprecate it, potentially by still accept it but warn when it is given.
Rather than making these globals, store them as locals and pass them into the functions, or just run `mode.get_bin_bath` within the function. Globals are not worth the future troubleshooting complexity in this case, especially since `RPM_PATH` is the only variable used in two different functions.
It does the right thing for me. I whipped up a quick container page: ``` $ cat out/index.rst .. automodule:: ansible.plugins.connection :members: ``` and when I generated it with sphinx-build I got this output for the exec_command sample: https://toshio.fedorapeople.org/ansible/test-autodoc/#ansible.plugins.connection.ConnectionBase.exec_command
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
`default=False` (same for others)
Please add `monitoring` and pass this argument to the request.
Looks like `monitoring:` has been added.
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
@gurch101 here is suggested change to the create method based on the feedback from other individuals. We do need to include the ip addresses at the top level of the response so they can be easily passed into additional tasks or facts. Let me know what you think of this method change.. ```python def create(self): json_data = self.get_droplet() droplet_data = None if json_data: droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=False, data=droplet_data) response = self.rest.post('droplets', data=self.module.params) json_data = response.json if response.status_code == 422 and json_data['message'] == 'Region is not available': self.module.fail_json(chnaged=False, msg=json_data['message']) if self.wait: json_data = self.ensure_power_on(json_data['droplet']['id']) droplet_data = self.get_addresses(json_data) self.module.exit_json(changed=True, data=droplet_data) ``` The address method is used to pull out the different ip addresses DO sends back in the response. ```python def get_addresses(self, data): """ Expose IP addresses as their own property allowing users extend to additional tasks """ _data = data for k, v in data.items(): setattr(self, k, v) networks = _data['droplet']['networks'] for network in networks.get('v4', []): if network['type'] == 'public': _data['ip_address'] = network['ip_address'] else: _data['private_ipv4_address'] = network['ip_address'] for network in networks.get('v6', []): if network['type'] == 'public': _data['ipv6_address'] = network['ip_address'] else: _data['private_ipv6_address'] = network['ip_address'] return _data ```
This isn't valid yaml ` : `
```suggestion - When the webhook does exists and C(state=absent), the webhook will be deleted. ```
```suggestion - When the webhook does not exists in this GitLab project, it will be created. ```
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
While this works, I think the list version is better because it is easier to extend.
```suggestion type: dict ```
Hi @bandit145, You need to bump this to 2.10 now.
shouldn't the deprecated old `change_hostname_to` and `domainname` be mentioned as well? (i don't know the best protocol for ghost parameters)
```suggestion I(minvalue), I(maxvalue), I(start), I(cache), I(cycle), I(rename_to), ```
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
I don't really get this, why not just do. ```suggestion auth_str = "Signature" ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
If this test won't be implemented it should be removed.
Good point. TBH, I have no idea why module_utils/docker/common.py does this replacement Â­â maybe it once was necessary, but isn't anymore. Or maybe it was never necessary...
Why not `... or self.node_attrs['Status']['Addr']`? It can't be worse than `0.0.0.0` :)
Ah, makes sense. I just remembered that there was a port, and somehow assumed it's the one you need here... Just executing code once is already a real benefit. Saves some cycles. Also, it improves readability since a fitting name will show the reader directly what `parse_address(...)[0]` is :)
Please do not use `re.split()` in such simple cases. Use `str.split()` instead. That's way more efficient. (Also, use `maxsplit`: `node_info['ManagerStatus']['Addr'].split(':', 1)[0]`)
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
Use standard boto3 exception handling: - https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2 I've just noticed there's a missing `c` at the end of `traceback.format_exc()`, so just be careful there :) - I've added #23168 to fix that
`required=False` is the default, and no not required. Same for `type=str`
use `trail['LogFileValidationEnabled'] = ct_params['EnableLogFileValidation']`
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
Do you support IPv6, if not then this should say IPv4 address.
`author: Gregory Shulov (@GR360RY)"`
Missing full stop. All `descriptions:` must be full sentences. This applies to a few other `descriptions:` in these modules.
For consistence please ensure all `description:` lines are full sentences (capital letters + full stop at the end)
The example uses `1T`, However later on you have `module.fail_json(msg='size (Physical Capacity) should be defined in MB, GB, TB or PB units')`
Typo in the help message
since force-push ate my previous commit to fix this: s/coloon separated path(s)/path(s) (colon-separated)/
i would prefer to not add more connection specific arguments
Sure, a separate PR sounds good.
Probably some potential for improved grammar here. > use the equivalent become one instead Maybe something more like: > The %s command line option has been deprecated in favor of the "become" command line arguments
I think `if props is not None` is more conventional :smile:
Here's another line which can raise `ValueError` (call to `run_luks_remove()`).
There's another `try/except` missing here.
`run_luks_remove()` does raise `ValueError`.
This line can also raise a `ValueError`.
It is okay for me
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
A better pattern for this is to make exec_module an abstract method (ie: one that the subclasses must implement). Then have the subclass call self.module.exit_json() directly. In python-2.6+ you can use the abc library: https://docs.python.org/2/library/abc.html or for something quick you can just do: ``` python def exec_module(self): raise NotImplementedError() ``` The subclasses then implement exec_module and do **not** call the base class's exec_module method.
Same order, type first.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
space looks unnecessary
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
This seems to be a leftover, there is no state "updated" anywhere else in the code.
When required is false, it can be left out (since it is the default).
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
problem with original, but still `str` is not portable, use `to_text`.
use `to_text()` instead of `str()` as its py2/3 portable
Two times boot_mode
I see there is no grouping in this inventory. Is this intentional for the first patch? Fine to me but I'd like to raise that grouping based on `os_name` of `offer` allow greater flexibility when dealing with a fleet of machine, might be interesting to add.
`str` isn't needed here.
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
```suggestion 'HostSystem', 'DistributedVirtualSwitch', ```
```suggestion if self.object_type == 'DistributedVirtualSwitch': ```
VM or VirtualMachine
```suggestion action: remove ```
`continue` not `break` (with `break` we can miss some VM). Or `fail_json(â¦`, because a VM object without name shouldn't exist.
This will collide with #61522. Also, you should use a similar approach as in there, i.e. don't do an `if` with two copies of `self._run_command()`, but collect the options in a list and then finally call `self._run_command()`.
Anyway, it's probably best to wait until #61603 is merged and then change this.
You also need to store this into a variable, otherwise you can't use the resulting path.
Instead of deriving from `CryptHandler`, why not pass `CryptHandler` as a constructor argument? Otherwise, I don't see why you need both a `CryptHandler` and a `Conditions` instance in the main module code (since you can use the `Conditions` instance for both).
Yes, that's a better solution. BTW, why not put all functionality calling `cryptsetup` into `CryptHandler`, and giving `ConditionsHandler` a reference to `CryptHandler` for the calls it needs to do? Then there's a more clear separation into `CryptHandler`, which does all the `cryptsetup` calls, and `ConditionsHandler`, which contains most of the decision logic.
```suggestion - The VM to use as the source (template). ```
```suggestion - Will also define the VMs hostname. ```
```suggestion required: false type: str ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
Please do not quote `%r` as it will automatically add quotes in creating a string representation of a string.
This will fail on new modules since `existing_doc` will be `None`.
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
no need for `lower()` here
Parentheses aren't needed here.
+ type: str
+ type: int
@gaudenz for those that really want it, there will be global toggle available, you CAN add toggle at plugin level to do same
add_group creates and returns a 'sanitized' group name, to avoid warnings you might want to use `self._sanitize_group_name(name)`
Please replace your mail with your github handle (also in cloudscale_server module)
its not a question of slow, but 'blocking' i.e accessing a bad NFS mount, that puts the process in 'B' status for the kernel and does not allow interruption.
see my loop over waiting on threads here #49398 to get a py2/py3 compatible way
Seems close enough, so I'll take that test as good as the 'unkillable' status is the main issue once the problem surfaces. I still have not been able to reproduce the problem i saw reliably, it just has happens a few time across the many times I've tested the gathering threaded code. It seems to happen less with Py3 versions, but since I'm not sure about how to trigger it, that is just anecdotal data. I was thinking of downgrading to nfsv3 since that was a lot more prone to this kind of issue ... but its probably not worth it.
In py3 this is mitigated by the subproccess methods having a timeout, but this is not available on py2
in py3 TimeoutError inherits from OSError, making this code subject to divergent paths in py2 vs py3, so if you really want to avoid that inherit from OSError, not Exception
no, if the variable is set but empty, you should empty out the options
also worthy noting, -G won't show actual ssh options used, just those configured
may be cleaner to build the list of methods, iterate on that list to build a list of (cmd,in_data,checkrc) for each method, then iterate over that list when invoking it. something like: ``` python method_names =['sftp'] if scp_if_ssh == 'smart': method_names.append('scp') elif scp_if_ssh: method_names = ['scp'] methods = [] for method_name in method_names: if method_name == 'sftp': methods.append(self._build_sftp_put_command(host, in_path, out_path)) if method_name == 'scp': methods.append(self._build_scp_put_command(host, in_path, out_path)) for cmd, in_data, checkrc, method in methods: (returncode, stdout, stderr) = self._run(cmd, in_data, checkrc) if returncode == 0: return if scp_if_ssh == 'smart': <the display warning/debug code here> # nothing succeeded and returned raise AnsibleError... ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Generally we don't treat usernames as secrets, so no need to mask
`required: false` can be removed, it's the default `default: null` can be removed, it's the default
`Allows notifications to be sent using SMS or MMS via the catapult bandwidth API.` No need to repeat the module name,
3rd attempt, it would help if you applied the concept to a working module instead of expecting a perfect example. Consider this pseudo-code instead. ```python if module.check_mode: url = "https://api.ciscospark.com/v1/people/me" payload = None else: url = "https://api.ciscospark.com/v1/messages" payload = { ansible['recipient_type']: ansible['recipient_id'], ansible['message_type']: ansible['message'] } payload = module.jsonify(payload) ```
In check-mode we would like to test as much as possible without inducing changes. So in this case I would expect to connect/authenticate to Spark, but not send a message. That would properly catch connectivity or login-errors in check-mode.
```suggestion - content library id for which details needs to be fetched. ```
`validate_certs: no` is less secure and so, we should avoid to use it in our example.
```suggestion library_id: '13b0f060-f4d3-4f84-b61f-0fe1b0c0a5a8' ``` This will hint user that, user is expected to enter something similar.
```suggestion content_lib_details: ```
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Right, in this case the connection vars are actually `client_id` and `client_secret`, for those we picked standard names, like in `typetalk` or `azure` modules. Using those connection variables, you can modify repositories belonging to any `username` you have access to, be it a team or a user.
The reason I brought it up: https://github.com/ansible/ansible/issues/51757 Though in this case it may not be a connection variable.
```suggestion - The repository owner. ```
```suggestion - The repository name. ```
```suggestion - The public key. ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
```suggestion module.deprecate("Alias \'{aliase}\' is deprecated".format(aliase=aliase), "2.10") ```
use the `missing_required_lib` function from `ansible.module_utils.basic`
```suggestion elif date_string.match(self.when): ```
Spurious `else:` Breaking the tests.
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
please use explicit import statements
`OrderedDict` is not available in Python 2.6, which is why CI tests are failing.
This is weird: you import pytest but then use unittest. FWIW the general consensus in the core team is to use pytest whenever possible, especially for new things.
CI failure due to syntax error (missing `:`).
One space around an assignment operator will be better. Sorry for my OCD of PEP 8 ;-)
You are definitely right! For the sake of consistency, PEP8-incompliance is never a problem. I won't give this advice if I were more familiar with the Ansible source code. Sorry for my self-approbation ;-(
Turns out it was in commit d5f20e6b2163b7bc74f5855f1da58cabd30edcbd that DISPLAY_SKIPPED_HOSTS was added. At that time, it was the only env var in lib/ansible/constants.py to NOT start with `ANSIBLE_`
opened an issue for it: https://github.com/ansible/ansible/issues/52967
normally they don't need it as they got added at same time as the plugin did, but newer options require it.
fyi, make it a string "2.7" otherwise it becomes a float and .. version comparison can break
i would use the find bin function and not assume it is in path
What is the purpose to sorting this? Forgive me if I'm being obtuse, I'm just trying to understand what is happening here, and this step is a little unclear.
If @bcoca suggested it I'm inclined to believe him, I'm just trying to figure out why. Again, probably confused, just trying to get this done and right.
I think you want to call `get_dep_chain` here, as `_dep_chain` only looks in the block called on, and if there is some recursion going on, `_dep_chain` could be `None` while `get_dep_chain` returns a value. I'm not super clear on the specifics of the code, but that seems like it might be an issue. It is possible I am just confused.
DEFAULT_ROLES_PATH should never be in use by a plugin, it should always use the 'current role path' if it exists or fallback to the playbook path. Another issue is that this is treated as a single directory entry when it could be a list of paths.
yep, that is wrong also, going to fix that
This information is used by Ansibullbot so list should be in format "name (@<github_handle>)"
```suggestion - David Taylor (@djtaylor) ```
```suggestion version_added: "2.8" ```
```suggestion ANSIBLE_METADATA = {'metadata_version': '1.1', ```
This is new lookup so no need to add `version_added`
If there's no sample, please remove that line.
The quotes are not needed and not wanted here.
For consistency in the examples, I would do this: ```yaml - name: Gather vmware host facts vmware_host_facts: hostname: esxi_ip_or_hostname username: username password: password register: host_facts delegate_to: localhost ```
We tend to sort the various imports, so swap those two lines.
The description should have a trailing dot. (Only the short_description must not have it)
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
At some point, this will probably be locally cached, as it's done in the script https://github.com/ansible/ansible/blob/4311990c3312b23e87d26c86ebca394501aecd4a/lib/ansible/plugins/inventory/foreman.py#L251 but that intersects the development of reports, https://github.com/ansible/ansible/pull/62438, so it makes sense that's not done right now.
Why is this using `to_native`? On line 262 `to_text` is used and I'm not entirely sure which is the correct one.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
How about using `LooseVersion` from `distutils.version`? It usually handles version numbers pretty well. (Grep for `LooseVersion` in the modules directory to see plenty of examples.)
@mrdrogdrog great! Once you made the adjustments and someone else also tested it (just to be sure), I'll merge it and create a backport PR. If this gets done by the end of next week, it should make it into the 2.9.2 release.
Their are built in helpers for argspec for the this, have a look in other modules for "exclusive"
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
You can use [`env_fallback`](https://github.com/ansible/ansible/blob/8f41270a010c00d058c70bdccdc611df8b454139/lib/ansible/module_utils/basic.py#L726)
ok, well argued.
I think you should do this test right before `pyv = VmBootManager(module)` (at line 350). This way you can call fail_json as soon as possible.
same here (remove the `is True`)
also, merge the two level of `if`. ``` if self.params.get('secure_boot_enabled') and self.params.get('boot_firmware') is None and self.vm.config.firmware == 'bios': â¦ ```
I don't think it make sense to actually allow the user to set a controller_type since only 'ide' is supported. ``` if cdrom_spec.get('controller_type', 'ide') != 'ide': self.module.fail_json(msg='Show up an error here.') ```
Just because a software is installed it does not make it the service manager, i have runnit and daemontools and encore-6 installed, none of them are 'THE' service manager. This is why checking proc 1 is important, also that only resolves the 'general service manager' which is what this fact tries to provide. If the `/proc/1/comm` path is unreadable we either need to find alternate way of figuring out the command (ps?) or return N/A or None as we failed to determine the 'real' manager.
To allow for future growth and other fallbacks ``` elif os.path.islink('/sbin/init'): service_mg_name = os.path.basename(os.readlink('/sbin/init')) if service_mg_name == 'runit-init': ```
yep, sorry it took me so long to realize it could be like this, had not looked at full file, when i did it became a much less invasive change.
was just rethinking this a bit, might be a simpler change in line 100, trap the failure of getting file contents above and do the symlink/basename there and assign to proc_1. But i fear both are invasive, also the proc_1_map should be used instead of the if I suggested previously.
```suggestion service_mgr_name = 'sysvinit' ```
Ok, not sure why this one is still open.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
You can remove this line
No need to have the `required: false` lines, it's implicit.
required: false and default: None are implicit, you can remove both
BTW, if `secondaryip` might be missing, replace `nic['secondaryip']` with `nic.get('secondaryip', ())`
You could use `defaultdict(list)` here to avoid extra if clauses below.
add `return self.remove_nic()`
Can you please include `uuid` as parameter for finding VM ? you can use `find_by_vm_id` API for finding VM using uuid just like other VMware modules do.
Use [find_obj](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/vmware.py#L57) method instead
It'd be cleaner to have only kwargs conditional: ```suggestion optional_kwargs = {'ExtraArgs': {'VersionId': version}} if version else {} s3.download_file(bucket, obj, dest, **optional_kwargs) ```
Oh.. `version` is immutable within the loop. You can move kwargs outside: https://github.com/ansible/ansible/pull/47867/files#r237441147 ```suggestion s3.download_file(bucket, obj, dest, **optional_kwargs) ```
Trying to track down some from_code weirdness before merging this.
An equivalent to this would be `extra['Metadata'].update(metadata)`
Pre-existing, but above this line I think an exception that is not 404 will just be ignored. Should the error messages be the same not found for exceptions other than 404? I think it would indicate something else was wrong.
@goneri [`vmware_guest_custom_attributes`](https://github.com/ansible/ansible/blob/14ab205ea26b99e4a33a092dedd2f5d6ad1ae7c9/lib/ansible/modules/cloud/vmware/vmware_guest_custom_attributes.py#L142) and [`vmware_guest_custom_attribute_defs`](https://github.com/ansible/ansible/blob/14ab205ea26b99e4a33a092dedd2f5d6ad1ae7c9/lib/ansible/modules/cloud/vmware/vmware_guest_custom_attribute_defs.py#L94) has the same code, so it would be great to fix those as well. I am OK with any implementation.
results. ```suggestion results.append(dict( ```
Note that str() can fail if the object's __str__ method returns non-ascii characters. You probably control the objects being used here so you know whether that's the case or not. I usually use ```to_native(self.change_relelvant_keys, nonstring='simplerepr')``` in similar situations so I don't have to worry about it.
Please add our boilerplate to the top of this file. One of those pieces of boilerplate makes all classes defined in the file new-style classes. Without it, a class definition which doesn't inherit from object is an old-style class. ``` from __future__ import (absolute_import, division, print_function) __metaclass__ = type ```
this could probably be simplified with using a dict of dicts: ``` power_policies = { 'high-performance': { 'key': 1, 'short_name': 'static' }, 'balanced': { 'key': 2, 'short_name': 'dynamic' }, 'low-power': { 'key': 3, 'short_name': 'low' }, 'custom': { 'key': 4, 'short_name': 'custom' } } ``` Then it is just a matter of using `power_policies[policy]['key']` and `power_policies[policy]['short_name']` Not really worth a lot of worry over, just a suggestion
current_encryption will only exist if `hasattr(s3_client, "get_bucket_encryption")` is True. You could add an `else` on line 267 to default the value.
ec2_argument_spec is no longer needed after moving to AnsibleAWSModule
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
You can add required=True here too and remove the check below.
``` tenant = module.params['tenant']` ```
All of them should be is None IMHO.
0 is technically valid, so this should be `self.prefix_length is not None`
facts modules can trivially support check mode (#23107)
`aci_argument_spec` is now a function and needs to be called like: `argument_spec = aci_argument_spec()`
This is not a blocker, just a thought on the interface.
Yeah, this should probably be an error if the config has explicitly removed the paths...
The only odd behavior I can create is if I set 'collections_paths = :' (an empty list) ``` ini [defaults] collections_paths = : ``` In that case, the collection ends up getting installed into $PWD/ansible_collections/. But I suspect that is a general issue with config types of 'pathspec' and not specific to collection_path.
add a method for a file, then /dev/stdin will be a subset of that
Sure, a separate PR sounds good.
from ansible.module_utils.vmware import get_parent_datacenter
+1 for to_text
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Sounds a strange behavior to me to apply the change only on the first matched NICÂ when the definition does not indicate a single object. Either apply change on all matched NICs or fails sounds more logical to me.
Use `C` formatting function for the sample list.
Use `U()` for `acme`.
Boolean parameters: add default value (`False` is default value for `has_expired`, `extendedKeyUsage_strict`, `subjectAltName_strict`).
as this is the default, it can be left off
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
azure-mgmt-containerinstance 0.3.0 is out, `models` is on the operation group. https://pypi.python.org/pypi/azure-mgmt-containerinstance/0.3.0 This is a new Api version, but I was able to record the tests I have without changing any code, so should be fine.
Let's start with `azure-mgmt-containerinstance`, and each time you see one shoot me an email or open an issue on the SDK side to ask for it (one issue per wanted package would be ideal)
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_PROFILE') ```
You can avoid inspect with ```python if hasattr(client, 'DEFAULT_API_VERSION') ``` Will not work for azure-mgmt-resource before 1.3.0 if you want multi-api support there as well.
ContainerInstance doesn't support profile, it's why it doesn't have a `models` method
You are not returning this.
```suggestion description: JSON parsed response from the server ```
If `purge` is `true`, it will be empty according to the code you pasted below.
Above you said "They are present before the module ran". In that case, this list should not be empty if `purge` is `true`, but contain the list of variables which were there before the module ran.
```suggestion description: A list of variables whose values were changed. ```
class/objects should validate their FAs when validated, we should generalize this and not make loop_control custom, that opens up having other keywords expand as 'class/object' entries w/o having to repeat custom validation for each
Could we set a default on the FA instead of adding this method? I think it would be as simple as `default=LoopControl`
should be list(attr.items())[0] to work with python3 too. ``` An exception occurred during task execution. The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 310, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 280, in main attrs = EcsAttributes(module, attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 131, in __init__ self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py", line 151, in _parse_attrs name, value = attr.items()[0] TypeError: 'dict_items' object does not support indexing fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 310, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 280, in main\n attrs = EcsAttributes(module, attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 131, in __init__\n self.attributes = attributes if self._validate_attrs(attributes) else self._parse_attrs(attributes)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_xs5l34yw/ansible_module_ecs_attribute.py\", line 151, in _parse_attrs\n name, value = attr.items()[0]\nTypeError: 'dict_items' object does not support indexing\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ********************************************************************* localhost : ok=0 changed=0 unreachable=0 failed=1 ```
As long as the input and ouput of the module are in snail_case, I don't see any issue.
Why capitalized? hookHelper or hook_helper
just for being consistent with other dicts in the module
The expected_state variable only strips the underscore (_) character from the state variable, but the providable power states for vmware_guest_powerstate use hyphens (-), so the expected state will never match the current_state or any of the other conditionals. Using underscores for the state names (ex. powered_off) strikes me as being more consistent with the existing conventions than adding hyphens.
Why do we need to force to change powerstate? Seems over protective.
Please split this message up in 2 parts.
Seems to me that poweredoff state is consistent with shutdown-guest state, and the result should be success and changed=false
Also, this was added for a specific reason which made the module fail for some users, so removing it will also make the module non-functional for those users. Another reason why this is a NO-GO.
Removing a parameter that people are using will break existing playbooks that depend on it. This is a definite NO-GO.
So the default option in Ansible is named `validate_certs` and it defaults to 'yes'. So I would prefer we do it like this.
This needs to be: `type: bool`
So the default option in Ansible is named validate_certs and it defaults to 'yes'. So I would prefer we do it like this.
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
But since Python 2 doesn't support the `default` keyword argument, here's a cross-compatible shim for you: ```suggestion try: return max(v for v in self.versions if v != '*', key=LooseVersion) except ValueError: # ValueError: max() arg is an empty sequence return '*' ```
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
not exactly what i was asking, but good enough
I'm not sure about these defaults - a delay of 3 and backoff of 2 for 10 tries would mean that, to fail, this retry decorator would wait for 3069 seconds (`3 + 3*2 + 3*2*2 ....`, or `sum([3 * 2**i for i in range(10)])`) or about 50 minutes. That seems like a really long time, especially since most modules make several calls. A better default might be 4 tries, for a total default wait time of 45 seconds and having a max of, say, a minute between tries. That way, if someone wanted 10 tries it would only take about 7.5 minutes to fail.
Please split into under 160 character length lines
I think `hosts` is a name that does not violate the principle of least surprise. I merely wanted to point the rest of the cfg mgmt ecosystem and possible Windows support. Let's see what @abadger thinks about it given the above.
I believe this is defined in the docs_fragment.
Did you try using `jxmlease` for dict to xml conversion? As it is already used in other modules it makes sense to reuse it. ``` from jxmlease.dictnode import XMLDictNode XMLDictNode({'unlock': {'target': {'candidate': None}}}).emit_xml() ```
Usage of `eval` is not recommended, please use `ast.literal_eval` Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L432-L435
typo... It should be I(text)
Please remove deprecated parameters as this is new module.
...The remote host **MUST** support...
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
Like above, I think this should be `userid, name, password, group, email`
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
space looks unnecessary
shouldn't this be group instead of group_id? ~~~diff - result = dict(changed=False, msg='', diff={}, group_id='') + result = dict(changed=False, msg='', diff={}, group='') ~~~
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
I think this should be using mock.patch? iirc, this can leave ansible.module_utils.facts.system.pkg_mgr monkeypatched to be a mock for the rest of the tests.
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
we should also return if we both delegate executions and delegate_facts
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
```suggestion - Whether to automatically try to install Python apt or not, if it is not already installed. ```
```suggestion - If python-apt Python library is not installed this module will not work. - Note that it is installed by running C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3. If you are using a Python on the remote that is not the system Python, this will not work. In that case, you should set I(install_python_apt=false) and need to ensure that the Python apt module for your Python version is installed in another way. ```
```suggestion - Runs C(apt-get install python-apt) for Python 2, and C(apt-get install python3-apt) for Python 3. - Only works with the system Python 2 or Python 3. If you are using a Python on the remote that is not the system Python, set I(install_python_apt=false) and ensure that the Python apt library for your Python version is installed some other way. ```
This probably needs some rewording. I'm also curious as to when it was added. I'll leave this open for review from the docs team.
```suggestion - If the clone should be present or started - default present. ```
The change you are making here is allowing `-` to be returned. We can replace `-` with `_` with what we control, but we _cannot_ replace `_` with `-` after the plugin has already sanitized them - which is the current state of `devel`. This toggle does not replicate the ec2.py behavior, because that replaced dashes inconsistently. The simple explanation of the functionality of _this_ toggle is "dashes are not replaced". For compatibility, the user is on their own. The reason this is related to compatibility is that it's theoretically impossible to have compatibility until we get something in `devel` that does not replace the dashes.
does aws_ec2 have any auto added groups? I am not aware of any.
yes, that's fine, the toggle per-keyed-group would been a different solution for this, but this PR is sufficient.
redundant, this info is already in the description
This looks for tags with the `Name` key set to `dev` - maybe a better example would be: ``` # all instances with their `Environment` tag set to `dev` tag:Environment: dev # all dev and QA hosts tag:Environment: - dev - qa ``` Since `tag:Name` could be confused for "tags with the name dev" as in `dev : true` or something
same here for arg bools vs strings- this needn't exist
Yes, but we can address this in another release.
@carchi8py : enable/disable UDP protocol It would be nice to have a default of 'enabled'
definitely seems like there should be an else with an error here...
All of them should be is None IMHO.
Could probably get rid of the surplus required=False entries I seem to have missed as well
Missed one.. Should just be as below unless you want to also pass module into the function. ``` if os.path.isfile(cert_chain): cert_chain = open(cert_chain, 'r').read() ```
As previously discussed on https://github.com/ansible/ansible/pull/20787 I much prefer os.path.isfile That way it won't try to read a directory path.
if state is present but cert, key or chain is not passed in, then these variables won't be set at all. That is bad. Just get rid of the `if` statements.
This is nicer wrapped without line continuation markers: ``` orig_cert_names = [ctb['server_certificate_name'] for ctb in iam.get_all_server_certs().list_server_certificates_result.server_certificate_metadata_list] ```
```suggestion return to_text(v.ip) ```
0 is technically valid, so this should be `self.prefix_length is not None`
All of them should be is None IMHO.
If all these options identify the object, then it's fine.
```suggestion "id": None, ``` Since `id` is no longer a module option, it will always give `None`.
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
ah, nvmd, we overwrite the _task with original_task anyways, need to capture it before that happens or ensure the task_fields are not the original but 'templated results'
this can also create divergences since the task itself might have changed variables it originally used: ``` set_fact: myvar={{ myvar +1 }}```
instead of forcing templating here, when you don't have task_vars yet, just set run_once based on 'bypass' and then template below in 890 with full task_vars. That way you avoid a 2nd very expensive call for vars and actually get the complete ones (with host).
We should be able to merge the two cases with something like this? ``` if collections is None and collection_from_task: collections = [collection_from_task] ``` Now `collections` is either the non-None contents of `collections`, or the task's collection, or `None` if neither exist, which means we can drop the `collections` check from the `all()`s and just use `collections` regardless
Hi, That can be done in a follow up Pull Request when you have time. Thanks again for for help module.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
I think this message should just be `botocore and boto3 are required for this module`.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
Handle all AWS exceptions as per guidelines https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
You should use `module.add_cleanup_file()` (somewhere above) instead of manually trying to clean up.
`pexpect` could be used to provide the password to the subprocess on stdin.
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
You need to make sure `tf` doesn't write a unicode string. tf.write(u("#!/bin/sh/\necho %s" % quote(self.passphrase)).encode("utf-8")) Ansible may have a utility function to do this.
Have you tried ```suggestion monkeypatch.setattr(datetime.datetime, 'now', lambda: TIMESTAMP) ```
If you do this, you'll reduce the amount of copy-paste: ```suggestion return data['date_time'] ```
I'd argue that it'd look cleaner and would better correspond to the fixture name that implies that it returns only the date-related subset of facts.
Since you only check keys of the same object in the same fashion, you could collapse this using parameterize (for example, extend with other params): ```suggestion @pytest.mark.parametrize( ('fact_name', 'fact_value'), ( ('year', 2020), ('weekday', 'Saturday'), ), ) def test_date_time_facts(date_collector, fact_name, fact_value): assert date_collector['date_time'][fact_name] == fact_value ``` This will generate a separate test per each param while allowing you to keep the test function logic the same. https://docs.pytest.org/en/stable/example/parametrize.html
In Python, it's common to include docstrings as per PEP 257: ```suggestion def fake_now(monkeypatch): """Patch `datetime.datetime.now()` to return a deterministic value.""" ```
But since Python 2 doesn't support the `default` keyword argument, here's a cross-compatible shim for you: ```suggestion try: return max(v for v in self.versions if v != '*', key=LooseVersion) except ValueError: # ValueError: max() arg is an empty sequence return '*' ```
You don't need a copy of the list in memory here. Better use a generator expression: ```suggestion versions = (v for v in self.versions if v != '*') ```
eliminate intermediate list ```suggestion new_versions = set(v for v in self.versions if self._meets_requirements(v, requirement)) ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Make this a proper YAML list: ```yaml author: - Joseph Callen (@jcpowermac) ```
Short description should not have trailing dot. (Other descriptions do...)
there's away to have this checked in the declaration of the module: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/nuage/nuage_vspk.py#L1019-L1020 (same for esxi_hostnames)
Can be covered in the `AnsibleModule` instantiation by using `required_if`
Just an idea, Could we move this functionality to new module rather than putting in same module ? Same like `vmware_guest_disk_info` and `vmware_guest_disks` Nothing blocker as such.
I have submitted a couple of modules with the new approach that takes care of check-mode. I am waiting to hear back from @schunduri that this approach is acceptable before continuing to enhance other modules being developed.
@jedelman8 you're right. @schunduri ^
Yes, so we plan to fix this and @jedelman8 and @jmcgill298 are involved in some new code that may help with this. However if this does not hit the tree before the freeze I will make sure this module is pulled from the tree. *It is unfortunate this PR was merged, but granted the PR should have been indicated with a WIP-tag to have prevented this.*
There is a deprecation marker, you could add here see Dag's PR
``` tenant = module.params['tenant']` ```
Please add `type: bool`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
Indentation doesn't look right here. You can have upto 160 character lines
You also need to add the choices in the `argument_spec`.
```suggestion filter: "sAMAccountName -like 'test*'" ```
You can move this check to `module_utils` as well.
Missing boto3 will be automatically handled by AnsibleAWSModule, this should just be: ``` try: import botocore.exceptions except ImportError: pass ```
This should use the standard client setup, which handles exceptions internally: ```self.conn = module.client('iam')```
AFAIK this test is wrong. The previous version had `until: server.ssh_fingerprints`. The API always returns the ssh_fingerprints key, but until the fingerprints are available the value is `null`. So the new condition is always true even if the fingerprints are not yet available. If you are concerned that the key might not be available (this should never happen) you might want to write it as `until: server.ssh_fingerprints is defined and server.ssh_fingerprints`.
The API currently allows multiple groups with the same name. Do we need some logic similar to the logic in `cloudscale_server` to detect this? Otherwise this could lead to surprising results... And tests for this case would be nice too.
I don't think the `or []` is needed here. If there are no server groups defined, the API already returns an empty list.
I would probably make this a module level constant like `ALLOWED_STATES`. I also noticed that you don't transform the output for the diff. I don't think it matters much but for consistency this should ideally also be transformed. Maybe the best way to handle this would be to transform the values already in `def _get_server_info`. This way the module internal name would always be "state" and there would be no confusion between "state" and "status". That's also how this was handled before your change.
I think something like this will be better (please test it to ensure you do get an error if the param/ENV isn't set) `api_token=dict(fallback=(env_fallback, ['CLOUDSCALE_API_TOKEN']), no_log=True, required=True),` Then you can delete ``` api_token = module.params['api_token'] or os.environ.get('CLOUDSCALE_API_TOKEN') if not api_token: module.fail_json... ```
I am not clear as to why `before` `hostname` and `vmnic` are required, whatever the input parameters can be obtained from `module.params`
SR-IOV can be enabled only if `C(num_virt_func) > 0.`
optional parameter, related to `C(num_virt_func)`.
```suggestion - Desired SR-IOV state on interface. ```
```suggestion - number of functions to activate on interface. ```
Again, path concatenation is not something that would be used much when dealing with Redfish. And in this particular case, we may get invalid path from the concatenation, since `self.manager_uri` can have a trailing `/` (and on most systems I encountered, this is actually true).
`Name` field does not need to be unique (and on the Lenovo recording I have all the disk firmwares have the same name "Disk firmware"), so this has the potential to overwrite data from previous iterations, returning only the last non-unique entry.
Last six lines can be simplified to `return dict(ret=True, entries=response["data"]["Attributes"])`.
Again, path concatenation is bad. And in this case it is not needed at all, since we have a path stored in `device["@odata.id"]`.
Last six lines can be simplified to `return dict(ret=True, entries=response["data"]["Attributes"])`.
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
This has to be done only once, since the binary is always the same (`docker-machine`).
``` from ansible.module_utils.common.process import get_bin_path ```
i would use the find bin function and not assume it is in path
catchall ignore ....
could be just `if module.params['dns_domain'] is not None:`
```suggestion if not HAS_OVH: self.fail_json(msg=missing_required_lib('python-ovh'), exception=OVH_IMPORT_ERROR) ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
use the `missing_required_lib` function from `ansible.module_utils.basic`
Bare `except:` is very rarely (if ever) what should be used. In this case, it means a `ctrl-c` will be caught and Ansible will keep going. I suggest using something more specific (at least `Exception`, which won't catch `ctrl-c`).
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
Keep a blank line between examples for readability.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
This is wrong, already explained.
can delete this line
ansible.module_utils.ec2 sets HAS_BOTO3 to the correct value.
Don't need to keep the `get_aws_connection_info` or `ec2_argument_spec` since AWSModule has `.client` now.
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
The imports for boto3_conn and get_aws_connection_info can be removed
Phantom Module Syndrome . . . that explains it. Thanks @bcoca.
because its not a real module
same thing here- a strip() for leading spaces in the shebang might be a good idea- less an issue here since it's our code...
```suggestion to iterate use a C(with_) directive. ```
You could add the minimum required version (`>= 1.0`) here too.
Examples should be in multi-line with `key: value`
Are these common aliases with maven? Generally with modules we just use `user:` and `password`
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
Yes, but this module doesn't run on machines where ansible is installed...
Too few format values ``` Unable to get hooks from repository : %s" % to_native(err) ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
For integers please: use `type='int` remove the `isdigit` check from `check_params`
This can also be an ARN, right? In which case the length can be up to 140 characters.
None is the default.
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
So the issue I was thinking might come up was that the API may "fix" lists of one and only return the list content (as S3 does). So running a playbook with a list of one item always displayed changed. I looked at the boto3 docs and since these options must be strings it's a non-issue. Testing this out though, I notice that if an invalid option is provided (such as specifying a list of two actions for a statement) or a typo results in a failure (good, as expected) but also deletes the existing policy (that seems weird). I don't know if that's easily fixable in a way other than validating the options before making API calls... ``` "error": { "code": "ValidationException", "message": "1 validation error detected: Value '['lambda:CreateFunction']' at 'action' failed to satisfy constraint: Member must satisfy regular expression pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])" }, ```
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
Isn't `raise` missing there ? Calls to `str` are useless.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
This syntax is not supported in python2.6. You will need to index your format like `{0}`
missing default value
Should be enforced by argspec
typo: it's validate_certs
``` - If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. ```
No need to repeat the choices.
Format replacement strings with nothing inside of them, {}, are only available in python-2.7 or better. So you'll need to make sure that all your formats have numbers inside of them. For example, this line would then be: `record_ids = client.get('/domain/zone/{0}/record'.format(domain))`
``` ttl=dict(type='int', default=0), ```
You could add here an example to add a record to main A record => mydomain.com
Remove this as it is already declared above.
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
Please add `type: bool`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
I would write this all on a single line as: ```python diff = parse_diff(out) if module._diff else {} ```
`short_description: Manage VLANs on VyOS devices`
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
a teeny typo: ipvr_addresses -> ipv4_addresses
for declarative intent modules plan to use cliconf api's? Example usage: ``` from ansible.module_utils.connection import Connection conn = Connection(module) data = conn.get_config() conn.edit_config(commands) out = conn.get(cmd) ```
Same for VMs.
The same like above.
This should be indented by 2 spaces. The same bellow.
I kind of don't like returning from a function from a condition. What about to define `code` variable which you assign in the condition and then return at the end of the function? ``` ... output = flatpak_command(command) code = 0 if 'error' in output and 'already installed' not in output: code = 1 return code, output ``` The same anywhere bellow.
What about to insert new line in front of the `if`? It would make nice visual separation between the variable definitions and the condition. The same at any place bellow.
This should be wrapped like this: ``` state=dict( required=False, default="present", choices=['present', 'absent']) ```
needs to be a string, "2.7" otherwise it will be used as a float and not fare well in comparissions
and 'logdna lib'
DO NOT AUTOINSTALL use the HAS_LOGDNA variable as a flag and return an error with the requirement when the plugin is invoked, plugins should NOT autoinstall libraries, also pip might not be installed on target systems and is also a possible error point. you can look at other lookups (like consul_kv) for how to deal with this issue
2.0 is what you want here
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Exactly one of I(name) or I(group_id) must be provided. ```
```suggestion - Does not currently support some features of ip link set, such as ```
```suggestion - To modify the namespace use the I(netns) option. ```
`check_rc` is false by default, no need to pass.
Please replace with `type: false`
`required: false` is default so you can remove this.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
OK, if we are being consistent with something else that makes sense. I personally find putting the message in quotes can be useful for checking for trailing whitespace, , as well as making the message stand out more.
If there are uncommitted changes on the prompt, this will not exit. Assuming there are no uncommitted changes, you can use `end` instead of `exit` to exit from configure mode. If stale uncommitted changes are expected by any chance; use`abort`. This will abort any uncommitted changes and bring prompt out of configure mode. This may apply to other platforms as well.
If you have an option of `end` command (similar to IOSXR) or an `abort` command (this will take care of any stale uncommitted changes), use those Also, when you exit out of configure mode, I believe you will be in `exec` mode? In that case, you might want to run `enable` command every time and not just in the `else` part? OR even better (however make sure you are in exec mode before doing this) ``` if to_text(out, errors='surrogate_then_replace').strip().endswith('>'): conn.send_command('enable') ```
Could we not just change this to `True` instead? I get erroring by default, but there are clearly cases where one might want the current functionality.
Since this check-in action plugin ensures the prompt is out of `configure` mode, we can use `exit discard` here as it always ensures the prompt is changed to operational mode.
> Well, as I state in PR description, version in trunk practically disables ec2.py cache when using python 3. The idea was to replaces `hash()` call with any hashing function that gives stable results between script runs. Anything from hashlib module will do, `md5` does not have any advantage. One important note: `md5` will not be available on some systems (such as FIPS compliant systems). It's probably better to use `sha256` (as `sha1` could also be removed). > hashlib functions require byte string as input. Python 2 and 3 differ in what is stored in `__file__` variable: python 2 has simple string and in python 3 all strings are unicode. You could do ```.py from ansible.module_utils._text import to_bytes ``` and then ```.py cache_name += '-' + hashlib.sha256(to_bytes(__file__)).hexdigest()[:6] ``` This will work for both Python 2 and Python 3.
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
Okay, so alancoding says that this could throw an error that it can't figure out which organization you meant if there is more than one organization. Perhaps what we need here is: ``` python if organization is not None: try: organization = organization_res.get([....] ```
nit-picky optimization, but if the prior step was successful then 'id' should already be in `result` Also, if the state is "absent", then you need to be sure that you don't hit this code. Either that, or it should throw an error if schema is provided and state is absent.
in all cases, I would default `group_contents.get('hosts', [])`
If the source is not provided, there is an endpoint that lets you update all inventory sources for an inventory (future enhancement, I would not suggest doing that here, just pointing it out)
I would default vars to `{}`
No need for quotes here.
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
Please remove this property since ansible already exposes `changed` so users can see whether a resource was altered during a task.
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
This isn't really needed - the task should already be returning changed==[true | false], so users interested in whether the resource was altered can just check that property instead.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same as for the updated, I'd rather say `has been deleted`
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
LGTM To simplify this more, you could remove line 244 and do: `for container in module.params.get('containers', []):` You could do that below as well: `for environment in container.get('environment', []):`
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
```suggestion self.container = PodmanContainer(self.module, self.name) ```
AFAIR the flag is `failed`, not `fail`
or entirely omit `else:` since it would fail in case of `if` part.
I think you could go for `elif:` here.
(but in case of function arg, you don't need additional braces)
You don't need to escape EOL. Just have two strings and Python will automatically know that it's in fact one string: this ```python ( "series " "of" " words" ) ``` equals ```python "series of words" ```
Could dedent here if `else:` removed.
You can use [`env_fallback`](https://github.com/ansible/ansible/blob/8f41270a010c00d058c70bdccdc611df8b454139/lib/ansible/module_utils/basic.py#L726)
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
You can do this all in the argspec `node_ip=dict(fallback=(env_fallback, ['rubrik_cdm_node_ip'])), `
@logan2211 you are incorreclty assuming that this is a toggle for each plugin's validation, it is not, it is for the global validation. Each inventory plugin is free to add it's own validation on top, most do and it is not controlled by that toggle. This PR alters the behaviour of the plugin which was always meant to filter the invalid names, the plugin itself never allowed - in group names.
Tested your suggested change snippet. It still mangles group names when `ANSIBLE_TRANSFORM_INVALID_GROUP_CHARS=never` is set in environment. The PR does the fix the bug as-is though.
Should likely be `prefix, sep, key`
Need to ensure that the group actually exists - currently when using this, the inventory plugin fails here because the previous code containing ``` if group_name not in self.inventory.groups: self.inventory.add_group(group_name) ``` has not been added here.
parent name also needs to be 'safe'
Now that there are two lines, "it" is a bit unclear. I'd change this to "Setting C(default) to C(yes) causes an error if the path is a file."
Since we have a line for `version_added`, I'd remove the "(added in Ansible 2.0)".
this is a common return, please remove it.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
I would add this to a new paragraph, so it will be easier to read (and harder to miss). ```suggestion - If not specified the default value will come from client_cert. Which will ```
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
Just making a note that we should probably restrict this to the exceptions that will likely occur and call fail_json instead of raising an Exception again.
"One of your CIDR addresses has host bits set. To get rid of this warning, check the network mask and make sure that only network bits are set. [full boto3 error message]"
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
I'm not sure you need the `ctl_exist` variable.
Just hardcode the value: `cdrom_ctl = 'ide'`
I don't think it make sense to actually allow the user to set a controller_type since only 'ide' is supported. ``` if cdrom_spec.get('controller_type', 'ide') != 'ide': self.module.fail_json(msg='Show up an error here.') ```
`if self.params["cdrom"].get('type') not in ['none', 'client', 'iso']:`
You can just use initialize `ide_device = None` and drop `ide_exist` variable.
```suggestion version_added: "2.10" ``` The current devel version is 2.10, so I think `version_added` is `2.10`. https://github.com/ansible/ansible/blob/devel/lib/ansible/release.py
Thanks for the quick fix :)
update description, remove dump
```suggestion version_added:'2.10' ```
```suggestion version_added:'2.10' ```
If that's too much of a headache, even just removing the accidental line would be good.
You inadvertently added a third blank line. Probably worth running flake8 and removing what issues you can
No cmp with python3.
no need for `lower()` here
Parentheses aren't needed here.
please add the httplib in requirements
correct, in any case i would advise using the open_url function that Ansible provides as it deals with many issues that httplib/urllib don't (versions, proxy, ssl, etc) and I would add a couple of options to allow users to deal with custom setups (validate_certs, etc).
send ansible events as annotations on charts to grafana over http api
you can use from `ansible.module_utils.urls import fetch_url` instead of import additional library
This should be `2.6` currently. If it is not merged by code freeze on Friday the 25th it will need to be `2.7`.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
You forget to make the change.
`def get_recommended_datastore(self, datastore_cluster_obj=None):` â `def get_recommended_datastore(self, datastore_cluster_obj):`
I like the regex approach. Another modification: ``` if disk_size_m: â¦ ``` â ``` if disk_size_m: â¦ else: self.module.fail_json(â¦) ``` (PS: I didn't finish this PR review)
I suggest to add an example of this
Please add spaces around the equal sign.
I used to do a lot of Perl before as well. You can take that as a good opportunity to get into the Python programming. I think it would be worth using the Python module instead of calling the shell command.
Please add spaces around the equal sign.
This line is also too long even by the Ansible code style guide. It should be under 120 chars per line. Please format it like this: ``` notice( "redhat_repository: in main | list=" + str(p_list) + " | id=" + str(p_id) + " | state=" + str(p_state) + " | mode=" + str(p_mode)) ```
Please remove whitespaces around the braces.
Sorry, i was unclear, I didn't mean just this line, meant the vars copy/update block . Revisiting this line, I would actually put outside loop, after it ends. Also the existing `variables.copy()` will bypass your efforts as 'container types' will copy by ref, making modifications persist across not only invocations but in returned vars. see deepcopy or deepish_copy.
the moving is more stylistic (prep on top), so you can ignore
We do not want to do it this way because it means resultant could be a text string or could be a byte string later on. As the internal APIs evolve one of those two cases is sure to throw an error. I think that we probably need to leave the output as text here and convert to bytes later.
Additionally, the use of encode can raise an error if there are characters in the template which are not present in the encoding. We'll want to catch that exception and display a nicer error.
use `to_native` instead of `str` and add a space after like this ``` to_native(e), e.lineno ```
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
This statement seems useless.
`timeout` and `username` aren't the same thing.
Use `elif` instead of `if`.
afaik, winrm is only one using v X 6 and no one is doing the `display.verbose( ..., caplevel=23)`, I was pointing it out JIC you wanted a more precise wording.
since force-push ate my previous commit to fix this: s/coloon separated path(s)/path(s) (colon-separated)/
i would prefer to not add more connection specific arguments
Typo in the help message
Just to make an attempt at word-smithing > When doing an --list, represent shared variables inside groups or the inventory, > which has a smaller memory footprint but is not Ansible's internal representation
```suggestion module.fail_json(msg='Unable to find the specified virtual machine : %s' % (module.params.get('uuid') or module.params.get('name'))) ```
from ansible.module_utils.vmware import get_parent_datacenter
@Tomorrow9 Can we flat out settings instead of dict of configuration ? This is just suggestion and I am OK with dict of configuration as well.
Something like - ```yaml - vmware_guest_video: hostname: "{{ vcenter_server }}" username: "{{ vcenter_user }}" password: "{{ vcenter_pass }}" datacenter: "{{ datacenter }}" validate_certs: no name: vm_42614_3 gather_video_facts: false use_auto_detect: false display_number: 3 video_memory_mb: 8 enable_3D: true renderer_3D: automatic memory_3D_mb: 1024 ```
Cool. Thanks. Let me know once done.
Default not set in argspec.
Required not set in argspec
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
I would format this like this: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'metadata_version': '1.0' } ```
And you don't have to quote it.
The author string should be formated like `<name> (@<githubhandle>)`
This should be quoted.
`Manage Cisco NSO configuration and service synchronization`
Why not also do this when `module.check_mode` is `True`? Then the check mode behavior is closer to the real thing.
```suggestion sample: false ```
```suggestion - List of tables in the publication at the end of runtime. ```
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
This is now auto-handled by AnsibleAWSModule
You already have the retry decorator set on the client
So down here, instead of needing a separate `_with_backoff()` function, you could write this code: ``` arn = client.create_assessment_template( aws_retry=True assessmentTargetArn=get_target_arn(client, module, target), assessmentTemplateName=name, durationInSeconds=duration * 60, rulesPackageArns=get_rules_arns(client, module, rules), userAttributesForFindings=ansible_dict_to_boto3_tag_list( attributes, 'key', 'value' ) ) ```
Can `state` default to `present`? I usually expect this, I'm not sure if the flaw is with me or not :)
Add traceback here as well (for line numbers).
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
I feel like this should be moved to `else:`
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
As we no longer care about 2.4, I think this can be cleaned
Catch botocore.exceptions.ClientError instead of Exception here too.
This should be botocore.exceptions.NoCredentialsError.
If this is set to type='int' this should avoid the later type conversion
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
yeah, there's a missing chunk of code.
I would be consistent and pick one of them. Although, returning after in place modification doesn't add a value, it only makes sense if you will do a deepcopy of the dict and never modify the passed one.
Instead of using the *getter* it should use operator "**in**", `netbox_hosts_list.get("results")` can return an empty list, `[]`. That is treated as falsey and then *results* are not wrapped.
Please fix: '... if it doesn't exist:'
I'd rephrase: 'Obtain data of `vm_name` if specified, ...'
just call scaleway.ini we are in ansible conflict should not occur
Could add to the line above rather than lots of line breaks
Unnecessary line break
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
@abadger I checked the source of that `warning()` function and it seems like it concatenates input with native strings which concerns me.
```suggestion json=facts, ```
This is probably the only line which should be wrapped with try/except.
no prints, no str , use display and to_text
Same here: move url outside of the loop: ```suggestion ```
This should probably mention both slash and no-slash paths...
How about: ```suggestion if not os.path.exists(file_path): continue ```
I'd do this unconditionally.
May I ask you to implement an exponential backoff algorithm here? https://en.wikipedia.org/wiki/Exponential_backoff
maybe just ```suggestion part_boundary, b"--", ```
```suggestion message_text = self.get_deprecation_message(msg, version=version, removed=removed, date=date, collection_name=collection_name, warn_change=warn_change) ```
```suggestion parts = to_native(date.strip()).split(':', 1) ```
```suggestion elif date_string.match(self.when): ```
This should be `fail_json()`.
This should be `fail_json()`.
probably. It is a tradeoff between information that you have locally that may help with debugging versus having a complete traceback. So if ```policy_json_string``` has important information that won't be available in the outer try/except yo may want to do this here. A solution common in our modules is to call module.fail_json() at this level so you can have access to both the traceback and the additional information. (But then you have to pass the module into the do_grant() function).
This code is better than what was here before but do note that catching an exception and rethrowing it like this (in Python2) loses the exception information. We wouldn't know whether the traceback leads into the json.dumps() call or the kms.put_key_policy() call from the traceback, for instance. Not a blocker since it is better but something to consider in the future.
@s-hertel using client exceptions rather than botocore exceptions is nicer when they actually exist (which they do here for a kms client): ``` except connection.exceptions.NotFoundException: return None except (botocore.exceptions.ClientError, botocore.exceptions.BotoCoreError) as e: # Legitimate failure module.fail_json_aws(e, ... ```
`policy` should be added to `argument_spec` to be usable.
Another general exception handling that can be removed.
Please also use proper doc formatting like: "C(template) and C(storage_domain) parameters are provided"
Please add ` version_added: "2.4"`
But won't be moved if the storage domain is changed, no? The note should be added only if the parameter is NOT idempotent. The default is meant to be idempotent.
```suggestion - Only used for images that contain the Windows Server operating system. ```
If module-level version_added is 2.5 this can be deleted
```suggestion [datastore_name] path/to/file.vmdk ```
Needs a check to see if it is empty, and if so, fail the module
Please remove the raising of an exception and properly fail the module.
Please remove the raising of an exception and properly fail the module.
I have already cleaned that up in a follow-on that I was going to submit after this..
This line can also raise a `ValueError`.
Here's still another one.
`run_luks_remove()` does raise `ValueError`.
Here's another line which can raise `ValueError` (call to `run_luks_remove()`).
There's another `try/except` missing here.
That `get_multi_something` pattern repeats itself quite a few times in the file, which makes it a good candidate for a refactor into more general function. Something similar to this should work: def aggregate(self, func): ret = True entries = [] for systems_uri in self.systems_uris: inventory = func(systems_uri) ret = inventory.pop('ret') and ret entries.append(inventory) return dict(ret=ret, entries=entries) def get_multi_storage_controller_inventory(self): return self.aggregate(self.get_storage_controller_inventory) def get_multi_disk_inventory(self): return self.aggregate(self.get_disk_inventory) This should reduce the code duplication significantly.
Since we are now aggregating inventory info from multiple systems, the output should show which system the inventory info belongs to. Suggest changing L280 above to: ``` entries.append(({'systems_uri': systems_uri}, inventory['entries'])) ```
In case no 'entries' were added, need to avoid a KeyError. ```suggestion if 'entries' in inventory: entries.append(({'systems_uri': systems_uri}, inventory['entries'])) ```
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
Minor suggestion - I think this would be more natural than using string split(). ``` resource_uris = [self.manager_uri] ```
Personally i'd like it better if this was `changed_state`, for instance, as that better indicates the purpose of this variable, looking at the code
``` def __init__(self, module): super(VmwareConfigFactsManager, self).__init__(module) cluster_name = self.params.get('cluster_name', None) esxi_hostname = self.params.get('esxi_hostname', None) if cluster_name: cluster_obj = self.find_cluster_by_name(cluster_name=cluster_name) if cluster_obj: self.hosts = [host for host in cluster_obj.host] else: module.fail_json(changed=False, msg="Cluster '%s' not found"%cluster_name) elif esxi_hostname: esxi_host_obj = self.find_hostsystem_by_name(host_name=esxi_hostname) if esxi_host_obj: self.hosts = [ esxi_host_obj ] else: module.fail_json(changed=False, msg="ESXi '%s' not found"%esxi_hostname) ``` @Akasurde What do you think ? No variable except `hosts` has to be attributes. The module should fail if the cluster or ESXi isn't found.
you should set the default state to "list" at argument_spec, not here.
`continue` isn't necessary
update_ntp_settings â update_ntp_servers (or re-change the update_ntp_servers method name)
according arg spec, required=False
`rolling_order` should not be removed, it is still a valid setting in vSphere 6.7 API: https://code.vmware.com/apis/358#/doc/vim.host.NetworkPolicy.NicTeamingPolicy.html#rollingOrder
Ok, sounds good, i get that :).
Do we know other supported vendors? (Don't think there are others than VMware currently in vSphere 6.7, but there were others like Cisco and IBM in the past)
I would remove that parameter to avoid confusion and just set spec.productInfo.vendor to 'VMware, Inc.'.
I like the `warn: no` but using `env` is less typing ;o)
Listing data should be in a lookup plugin, not a module.
This is still something we shouldn't really want to explicitly support.
What about to format this like this: ```yaml with_items: "{{ rhsm_repository.repositories | map(attribute='id') | difference(['rhel-7-server-rpms']) }}" ```
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
`client.start_execution` is idempotent but `start_execution` always returns `changed=True` if `action=start`. We probably want to `client.list_executions` to see if the execution is already running before proceeding.
```suggestion module.exit_json(changed=True,**camel_dict_to_snake_dict(res))) ```
You can achieve this same result output with `module.exit_json(changed=True,**camel_dict_to_snake_dict(execution))` which can be imported from `ansible.module_utils.ec2`. That will automatically cover if AWS ever starts returning additional keys from this API and is generally easier to maintain.
This should go in a facts module instead.
It would be nice if the current tags were added to the response.
Like many other statements in the examples.
No need to use quotes. We tend to not quote when it's not needed, as this helps people understand the YAML rules better.
So I noticed this long list of options without defaults or choices. Possibly this is exactly what is intended. However, in a lot of cases there is an implicit default that could be mentioned (even when it's not enforced when missing). If you initialize a new swarm I expect there are defaults set.
What are the default values for te below parameters if you do not specify it on creation ? - task_history_retention_limit - keep_old_snapshots - log_entries_for_slow_followers - heartbeat_tick - election_tick - dispatcher_heartbeat_period - node_cert_expiry - ca_force_rotate - autolock_managers These possibly require an additional entry in the description to state the defaults on creation. (So you can't add a real default value, because that may modify an existing entry)
This one I still find confusing. I would expect this would remove/destroy the swarm ? What is leaving the swarm in this case ? (It may just be terminology and I simply am that ignorant guy)
This doesn't work as expected, unfortunately. ``` >>> test_dict = {'one': 1, 'two': None} >>> print(test_dict.get('two')) None >>> print(test_dict.get('two', 2)) None >>> print(test_dict.get('three', 3)) 3 ```
``` The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1353, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 1342, in main create_changed, asg_properties = create_autoscaling_group(connection, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_module_ec2_asg.py", line 967, in create_autoscaling_group update_asg(connection, **ag) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_ypla3C/ansible_modlib.zip/ansible/module_utils/cloud.py", line 153, in retry_func botocore.exceptions.ParamValidationError: Parameter validation failed: Invalid type for parameter DesiredCapacity, value: None, type: <type 'NoneType'>, valid types: <type 'int'>, <type 'long'> ``` Even though this is prettier, I think we might need to do what you initially did by checking if not None: `desired_capacity = desired_capacity if desired_capacity is not None else as_group['DesiredCapacity']` etc.
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
Same - please use `len`
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
Shouldn't this use the value of ansible_python_interpreter? There is a mechanism (winrm.py uses it) to pass in some host variables to connection plugins, so this should probably implement that.
connection plugins should not have their own python logic. If distros are using different python/missing python it is up to user to add (plenty of examples with raw and ansible_python_interpreter).
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
this is not in core and will result in exceptions if not present, use same pattern as we do with boto
requests is required by docker, but not normally installed, put in same try/except as docker import or in it's own to give 'graceful' import error messages, this should be the norm for all non-core libraries
Please use updated boilerplate. [Reference](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/iosxr/iosxr_banner.py)
We try to avoid the requests library as it has many issues across older versions and even major incompatibilities across it's own versions, look at using the ansible open_url/fetch_url functions instead.
Do we really want to use `_text` while it's still marked as unstable. This could potentially have an impact a number of DO modules if we begin to use this before it's stable.
this should be in the run method, otherwise ansible itself will fail to run
we should capture possible import exception and explain that this lookup requires the credstash python library when it fails
You could use: ``` CLIPASSWORDSDK_CMD = os.getenv('AIM_CLIPASSWORDSDK_CMD', '/opt/CARKaim/sdk/clipasswordsdk') ``` or even `ansible.constants.get_config`. `get_config` allows to define a default value and will search a defined value in an environment variable and the config file).
one space around...
You are definitely right! For the sake of consistency, PEP8-incompliance is never a problem. I won't give this advice if I were more familiar with the Ansible source code. Sorry for my self-approbation ;-(
Do you really need this extra var? Maybe just save stuff there right away? ```suggestion b_output, b_tmp_stdout = self._examine_output('stdout', b_tmp_stdout, sudoable) ```
I don't really like storing flags on the instance level. I think it'd be cleaner if this var was scoped to this method. Or maybe even factor out state store into a separate class (w/ Enum values maybe).
It probably makes sense to clean-up flags before exiting this method.
This should probably be `docker.exec_command()`
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
```suggestion assert isinstance(wrap_var(('foo',)), tuple) ```
```suggestion assert isinstance(wrap_var(('foo',))[0], type('')) ```
```suggestion assert isinstance(wrap_var(set(['foo'])), set) ```
```suggestion assert wrap_var(None) is None ```
```suggestion assert wrap_var(dict(foo=None))['foo'] is None ```
```suggestion into namespace I(netns). ```
```suggestion - Note, when the interface changes namespace it loses ```
```suggestion - To identify an existing interface within a namespace, use the I(namespace) option. ```
```suggestion support (for example 'type vcan'). ```
```suggestion - Removing aliases from an interface is not currently supported. ```
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
Use `self.assertEqual(d, d)` instead of `self.assertTrue(d == d)`.
It's a good practice to have a trailing comma after the last sequence item as well. This way, when someone will add or remove an item it will generate only one line of diff, as opposed to two lines: one for the logical change and one for editing comma next to unrelated item. This practice makes doing reviews easier and more joyful :)
no, if the variable is set but empty, you should empty out the options
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Please test if `default=False` is the default value when using type `bool`.
No, the default is None. So you can tell if the parameter was set or not.
You seem to have gone through the process of making this class a context manager, but don't use it as a context manager.
What is the need here for writing and reading from a JSON file? Seems this file would be created during execution, but in a temporary directory, and deleted immediately. Not sure what benefit there is to doing this, as opposed to just storing in a variable for use.
This file will be kept locally and will not be deleted. It's to reduce amount of API calls during the execution.
Currently this file is created in the folder that you are running the playbook from. I can make the opt-in feature.
How is that? ``` self._arg_spec_filename = "FortiosAPIArgSpecs.json" ``` That defines the path to that filename as relative, which will be relative to the executing script. modules are executed in a temp dir that is then deleted, so this file should be deleted. If the file is kept around, I would be concerned with that. This is force creating a cache file without telling the user you are doing it, or giving them a way to opt out. The default should be no cache, and a user must opt-in, should this feature really need to exist.
this doesn't look good to me yet, but I see my previous suggestion looks wrong too. How about the following? ~~~python # set banner if empty value or value differs if state == 'present' and (not current_banner or current_banner != module.params['banner']): set_banner(module, array) # clear banner if it has a value elif state == 'absent' and current_banner: delete_banner(module, array) ~~~
this seems not to be idempotent, my suggestion ~~~python if current_banner != module.params['banner'] if state == 'present': set_banner(module, array) else: delete_banner(module, array) ~~~
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Same typo as above
There seems to be an assumed structure of what is returned by the API endpoint, operating under the pretense that the structure won't change since the API is versioned, is there any chance that this assignment could fail and cause an unhandled exception? (similar question for other functions doing similar things below)
is there a reason why you have a native str, I would have assumed it was a byte str beforehand for a reason. I know the tarfile is very particular about the type of string being used.
This needs to be a byte string so you aren't trying to join a str and bytes together. ```suggestion to_bytes(output_path, errors='surrogate_or_strict'), ```
This should be `b_output_path` to indicate it is a series of bytes. Even if the caller is sending in bytes, this function should convert it to bytes just like `b_collection_path` at the beginning. That allows our `b_` naming convention to hold, making this code look incorrect (trying to join `bytes` and `str`).
I'd do this unconditionally.
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
Minor, please append `type: str` here as well
I think what you've got it good, thanks
there is a helper in `AnsibleModule` for mutually exclusive params: ~~~diff module = AnsibleModule( argument_spec=argument_spec, + mutually_exclusive=(('positional_args', 'named_args'),), supports_check_mode=True, ) ~~~
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
When using format, you will need to specify the index `{0}` so this would still work with Python 2.6
Not needed as it is already set to False
No update supported? As far as I know, the `azure-cli` supports update
This shouldn't be set.
My point is the self.credentials may not has a key named 'tenant' if not login
Do not add `required=False` or `default=None` as these are implied. But please do add the parameter type explicitly. ```suggestion extra_args_precommand=dict(type='str'), ``` PS Yes, the other definitions are incorrect too, they should all include type information.
@dagwieers Could there be a semi-automated cleanup of unnecessary `required` and `default` statements over all modules? Slow-changing ones like `zypper_repository` could benefit from that.
It's a matter of aesthetics, but I do think the `argument_spec` is clearly laid out and very readable as it is (i.e. with all the `=` lining up). Which is why I requested it be left alone.
Please remove `required=False`.
Please remove `required=False`.
Look like you could set ``` python res_list = tuple() ``` here and then the for loops can just be: ``` python for res in res_list: ```
Can we narrow this check a little bit, since re-running this call will only help if `InstanceInitiatedShutdownBehavior` is set to `stop`? How about `if "InvalidParameterCombination" == e.error_code and params['instance_initiated_shutdown_behavior'] != 'terminate'` so if that's already the case, we just reraise and don't make the extra API call.
See if it's possible to use `e.error_code` instead of matching on the message.
Wouldn't this end up returning `changed=200` to callers? Usually we keep this a boolean.
Can get rid of required=False.
changed is displayed as False by default so you don't even need to specify it at all. Can delete this line.
Formatting nitpick. You can add this to the line above.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
```suggestion - Private IP allocation method. ```
```suggestion - Private IP allocation method. ```
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
Seems the line after the conditional check is a potential bug..
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
`required=False` is not needed as it's the default
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
this seems like it should be shared with the main one rather than duplicated here
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
`then` -> `the`
VM or VirtualMachine
As I understand it, this module isn't about gathering facts.
Change sample to `data` that will represent what is being returned to the user. Example task: ```yams - debug: var: resp.data ``` Outputs: ``` "resp.data": { "droplet_limit": 100, "email": "sammy@digitalocean.com", "email_verified": true, "floating_ip_limit": 20, "status": "active", "status_message": "", "uuid": "b0ea118ed29548573729203027a0442f9" } ```
```suggestion - content library id for which details needs to be fetched. ```
Remove the "See examples."
Should be removed.
This needs to be '2.8' since freeze dates for 2.7 have passed.
```suggestion - Use with I(state) C(present) and I(purge) C(true) to specify content paths to be purged. ```
```suggestion version_added: '2.10' ```
pep8 will probably complain about missing a space before the ```in```.
Since we aren't sending the errormsg to an exception, we want to use to_unicode rather than to_bytes. to_bytes won't cause any problems with the code here in python2 but it will fail in python3 (because the string literals will be of the text type and so it won't match with errormsg as bytes then.)
task_uuid seems unused
It would be awesome if buildah supported copying from a container.
pyyhon2 -> python2
All `description` should start with a capital letter, and end with a fullstop.
Full sentences + full stops Capitals for acronyms `The ManageIQ environment URL.`
`ManageIQ username. C(MIQ_USERNAME) env var if set. otherwise, it is required to pass it.` and delete the `default:` line. This applies to the remainder of this file
we try to use 'state' instead of action, as ti keeps with the declarative voice of Ansible vs an imperative approach from programming languages.
I think this should be a separate command option - `delete` or `create`. `state` seems like something different. At a minimum, I think it should be more explicit - like `action: create | delete`
I would write this as ``` if current_values.get(key, "").lower() != val.lower(): ```
I am OK with either of the solution.
Validate_certs can accept 'yes' or 'no', this will break all playbook which uses `validate_certs=no/yes`
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
This should be an error by default, created #17902 to allow this to be configurable so this change should be removed from here.
this still has the #73643 issue, we might want to store the 'raw' notification instead and reprocess handler matching so we always get the 'latest' version of that handler
I know, was just wondering if it's intended that it works that way.
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
Please, at most one alias, even better none. Having a long list of aliases is really bad UX IMO.
The corresponding option for restart is called `force_restart`. Calling this one `force_recreate` would be much better.
Space missing before `(megabytes)`.
This should really be a `dict` with `suboptions`.
This should also be a `dict`.
`choices` : the new value must be added.
I'd rephrase to: "Path to a kernel image used to boot the virtual machine"
So it's in gigabytes or in percentage? it's not clear from the description.
I'd rephrase: "Kernel command line parameters (formatted as string) to be used with the kernel specified by `kernel_path` option."
following task -> the following task
to avoid dual stripping, change to ``` res = [] for p in patterns: p = p.strip() if p: res.append(p) return res ```
you REAAAALLY don't want a `for ` loop ....
patterns from the regex won't be stripped? also this traverses the list x2, not sure what is more expensive, strip x2 or list x2
Could you please dedent everything below including this line? There's no point in keeping it inside of context manager block, which _may_ swallow some types of exceptions.
Rather than copying the whole file in-memory you could iterate over it right away: ```python for line_number, line in enumerate(module_file, 1): ```
Should catch `BotoCoreError` and `ClientError` here, and use `module.fail_json_aws()`.
boto3 import failure is handled by AnsibleAWSModule. ``` try: from botocore.exceptions import BotoCoreError, ClientError except ImportError: pass # Handled by AnsibleAWSModule ```
This import is unnecessary.
You should use AnsibleAWSModule, which reduces this setup portion of main() to something like: ``` argument_spec = dict( instance_id=dict(required=True), attribute=dict(required=True), ) module = AnsibleAWSModule(argument_spec=argument_spec, supports_check_mode=True) connection = module.client('ec2') ```
This isn't required. If filters is the empty dict (which it is by default), `ansible_dict_to_boto3_filter_list(filters)` is the empty list, and `connection.describe_addresses(Filters=[])` does the right thing
no need to be sorry (i'm the tpyoe king!)
I missed this earlier, this module uses several classes to create a 'per system' object to handle the actions, you only updated the class for Alpine (which is derived from busybox, which is derived from user). We need to ensure that all variants get the update.
Long name option (`--type` instead of `-t`) could be used here.
```suggestion return (None, 'Key already exists, use "force: true" to overwrite', '') ```
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
```suggestion why: Deprecated in favor of C(_info) module. ```
Normally your full name here. Not sure what the policy is on commercially supported modules.
Awesome, thanks for making such a comprehensive post ð
```suggestion - Parameters used for Updating or Deleting subscription. type: str ```
`loose_driver_version = LooseVersion(PyMongoVersion)` <-- it's already calculated above. I think this case could go to the dict above if done carefully. This could be some hack like `{'-inf': '2.5'}`. But, looking at the error message, I'd say it'd be just `{'2.4': '2.5'}` and the error message would be normilized as well then.
Use module.fail_json_aws(e), which will handle calling ansible.module_utils._text.to_native() on e for you.
You can make use of some of the helpers in AnsibleAWSModule ```suggestion connection = module.client('cloudwatch') ``` This then moots the pieces below.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
This `.close()` isn't needed, the context manager closes the file automatically.
If this is set to type='int' this should avoid the later type conversion
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Ah ok. Yeah, after I posted, I was like "Oh wait this may just be a version thing"
Mutually exclusive is argument of AnsibleModule. ```python module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True, mutually_exclusive=[['username', 'service']], ) ```
```suggestion - name: Ensure that /exports/nas key in auto.direct map is absent ipa_automountkey: ```
add a sample here - ``` sample: { ... } ``
Don't quote strings when that's not necessary, and add spaces in Jinja variables for readability. ```suggestion msg: TCP port {{ item.port }} by pid {{ item.pid }} violates the whitelist ```
```suggestion RETURN = r''' ```
Add a few more examples of just listing the ports: ```suggestion when: tcp_listen_violations - name: List TCP ports debug: var: ansible_facts.tcp_listen | map(attribute='port') | sort | list - name: List UDP ports debug: var: ansible_facts.udp_listen | map(attribute='port') | sort | list - name: List all ports debug: var: (ansible_facts.tcp_listen + ansible_facts.udp_listen) | map(attribute='port') | unique | sort | list ```
Please remove the "required: false", you only have to add `required: true` if it is required.
Please remove the "required: false", you only have to add `required: true` if it is required.
And we tend to start with the `type=`, since this is the only key that every parameter defines. The order usually is: `type`, `required`, `default`, `choices`, ...
~~i dont see the need for changing the internal variable names~~ this is argspec, it is needed here
Please do not add `required=False`, it is implicit.
No, the previous formatting was much better here for this block, much more readable.
Please remove `required=False`.
These 3 tests are actually one test. It should be parametrized rather than copy-pasted.
It's probably not a good idea to make imports outside of the top of the module. Besides, only the first import will get evaluated while others will just load modules from the cache.
It is highly recommended to use `assert` statements in the pytest env because it integrates with its reporting better and more natively. ```suggestion assert len(ret) == 3 ```
It's a standard practice to use separate args for different params. Also, autogenerated param ids aren't very readable when they are complex so in such cases it's better to assign them meaningful names (they are displayed in the pytest report): ```suggestion @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout'), ( (3, (DOCKER_OUTPUT_MULTIPLE, '')), (2, (PODMAN_OUTPUT, '')), (0, ('', '')), ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) def test_docker_images(docker_images, mocker, returned_items_count, patched_dc_stdout): mocker.patch( 'ansible_test._internal.docker_util.docker_command', return_value=patched_dc_stdout) ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ```
I guess more of the preparation activities could be moved outside making the tests cleaner: ```suggestion DOCKER_IMAGES_CALLS = [ call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'], capture=True, always=True), call( '', ['images', 'quay.io/ansible/centos7-test-container', '--format', 'json'], capture=True, always=True), ] @pytest.fixture def docker_command_patch_kwargs(docker_images, mocker, request): patch_kwargs = request.param if not patch_kwargs: return mocker.patch( 'ansible_test._internal.docker_util.docker_command', **patch_kwargs ) @pytest.mark.parametrize( ('returned_items_count', 'patched_dc_stdout', dc_calls_num), ( (3, {'return_value': (DOCKER_OUTPUT_MULTIPLE, '')}), (2, {'return_value': (PODMAN_OUTPUT, '')}), (0, {'return_value': ('', '')}), ), indirect=('ansible_module_args', ), ids=('docker JSONL', 'podman JSON sequence', 'empty output'), ) @pytest.mark.usefixtures('docker_command_patch_kwargs') def test_docker_images(returned_items_count, patched_dc_stdout, dc_calls_num, ansible_test): ret = docker_images('', 'quay.io/ansible/centos7-test-container') assert len(ret) == returned_items_count ansible_test._internal.docker_util.docker_command.assert_has_calls( DOCKER_IMAGES_CALLS[:1], ) def test_podman_fallback(ansible_test, docker_images, subprocess_error, mocker): '''Test podman >2 && <2.2 fallback''' cmd = ['docker', 'images', 'quay.io/ansible/centos7-test-container', '--format', '{{json .}}'] docker_command_results = [ subprocess_error(cmd, status=1, stderr='function "json" not defined'), (PODMAN_OUTPUT, ''), ] mocker.patch( 'ansible_test._internal.docker_util.docker_command', side_effect=docker_command_results) ret = docker_images('', 'quay.io/ansible/centos7-test-container') ansible_test._internal.docker_util.docker_command.assert_has_calls(DOCKER_IMAGES_CALLS) assert len(ret) == 2 ```
And you don't have to quote it.
The author string should be formated like `<name> (@<githubhandle>)`
This should be quoted.
Wrapping of this paragraph is a bit weird.
Missing dot at the end of the sentence.
Use iface['subnet'] in the fail_json().
Use of ()'s in this "if not" is not necessary.
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
It might also be no IGWs found here.
@resmo Aren't both same ? ```py def x(): return (1, 2, 3) def y(): return 1, 2, 3 x() == y() #True
if `self.path` doesn't exist, `self.path + ".pub"` will never get removed.
Ah thanks, I checked the implementation again, it verifies this here: https://github.com/ansible/ansible/blob/f2dccb90e893df30c2b8bfc925dba80f6ceed6a7/lib/ansible/module_utils/basic.py#L1376
That's indeed quite a problem. I don't see how this can be solved in a good way (except to essentially rewrite ssh-keygen in Python). Related, but unrelated: to execute commands from an Ansible module, there's `module.run_command()`. There's also `module.get_bin_path()` to get hold of the path of the binary. Search the modules for examples.
`pexpect` could be used to provide the password to the subprocess on stdin.
result is always changed when rerunning playbook with your first example (create of zabbix user). This breaks module idempotency. I believe this can be solved by comparing all `update_user()` arguments with information returned from `user.check_user_exist(alias)`
`final_interface = dict((k,str(v)) for k,v in final_interface.iteritems())` seems to be required here since the values from new_interface may contain non-strings while the values returned by the API are always strings. With this added line, the module becomes idempotent with passive proxies.
Maybe have it as `default=True`? Imo it won't have any impact on searches using `host_name` and will prevent duplicate responses when using `host_ip` if it has more than one host interface.
This one is a bit odd as you are expecting that user will skip both `host_name` and `host_ip` arguments. In that case it is equal to not using your module at all. I would just replace with `fail_json`: ```yaml module.fail_json(msg="No host name or IP provided") ``` Same goes for the line 235, but that should be removed with the whole `is_host_exist` check.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Description should be a sentence and include a full stop at the end
No need if there isn't a default variable
Change to source and remove the alias
Where possible, generally its a good thing to keep the parameter names the same as the linux module equivalent. is 'replace_dest' the same thing as 'force' in the git module https://docs.ansible.com/ansible/latest/modules/git_module.html ? If it is the same it would nice if it has the same name.
This supports more than just URLs, I would add more points talking about what it actually supports.
Duplicate with `get` method? This logic can be handled as `if get_traffic_manager_profile`
Fail here make the process exit, but we need to create it if the state is present
Make a method to determine constructing dict from which object will be confused
Is 'the name used in the DNS prefix' check required to create the traffic manager? Or the error is already handled by the create API? If so, I don't this this logic is needed here. If it is required, it should be include in check_mode
What are the properties? * As other modules, we flatten the properties in the ansible module's parameter. * And for the second level of dict type, we can use `options` to specific another spec to define the key-value pairs in the dict. Like ``` py props_spec={ name=dict(type='str') } self.module_arg_spec = { props=dict(type='dict', options=props_spec) } ```
You can use get_option() instead of accessing the dict directly.
The inventory still needs to be populated with the results from the cache. The cache plugins themselves get/set data, but do not use it.
I think for consistency we should add `.gcp_compute.ya?ml` as an accepted suffix, since that's the actual plugin name.
Might be worth validating that zones is a list rather than a single zone provided as a string.
Instead of global exception, catch JSON errors and requests errors separately, as this block will apply to both.
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
catchall exception handling is generally not a good idea as it neither gives a better user message nor aids in debugging. If you feel you must do it this way, be sure to return the stacktrace (retrieve that using raceback.format_exc() and put it into the exception parameter to fail_json).
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
indentation of the end of the string should match with the beginning (I see this in a few other places as well)
I think this line isn't needed.
you can use get_id_by_name, and don't have care about checking.
What if the template is already registered? We shouldn't fail, but rather exit with `changed=False`
Ah, sorry, you are right. It's actually sending: ``` DELETE /ovirt-engine/api/storagedomains/123?host=myhost ``` Not the XML data.
This must be a proper Python SDK object, so: ```python host=otypes.Host( name=host_param ) if host_param is not None else None, ```
This needs to be changed, make it `Not applicable to endpoints of I(type) C(external_endpoints).`
refer to the actual options in the traffic manager profile module and not just a copy/paste of the MS docs. In this case it should be something like `The weight of the endpoint when the traffic profile has a routing_method of C(weighted)` This has the benefit of showing both the trafficmanagerprofile method name (routing_method) and the value of it in Ansible.
`Only application to an endpoint of I(type) C(nested_endpoints).
See my point in the non facts module around snake_case.
What are the properties? * As other modules, we flatten the properties in the ansible module's parameter. * And for the second level of dict type, we can use `options` to specific another spec to define the key-value pairs in the dict. Like ``` py props_spec={ name=dict(type='str') } self.module_arg_spec = { props=dict(type='dict', options=props_spec) } ```
``` diff diff --git a/lib/ansible/galaxy/collection.py b/lib/ansible/galaxy/collection.py index caa22308eb..52272cde52 100644 --- a/lib/ansible/galaxy/collection.py +++ b/lib/ansible/galaxy/collection.py @@ -381,6 +381,12 @@ def publish_collection(collection_path, api, wait, timeout): :param timeout: The time in seconds to wait for the import process to finish, 0 is indefinite. """ import_uri = api.publish_collection(collection_path) + if 'v3' in api.available_api_versions: + parsed = urlparse(api.api_server) + import_uri = parsed._replace(path=import_uri).geturl() + else: + import_uri = import_uri + if wait: display.display("Collection has been published to the Galaxy server %s %s" % (api.name, api.api_server)) with _display_progress(): ```
That diff is a light reworking of this PR. When I made it I saw that it still had most of the problems of this one (to be fair, we probably can merge my changes with that initial attempt and fix some of those problems) and additionally split the responsibilty for compatibility between GalaxyAPI and the caller. So I discarded that and pushed most of the changes inside of GalaxyAPI instead. I did parse the data from the API and normalize it (as a task_id) before sending it into the class, though. That seemed like the best way to split the responsibility.... The caller ends up knowing about the information that was returned to it. The GalaxyAPI class knows how to turn the normalized data into a url on each of v2 and v3.
I also found `n_url` to be a bit confusing and collide with our string type prefixes for bytes, native, and unicode. It would be good to change `n_url` to something more descriptive, but probably in a separate PR.
I've been meaning to ask... what's the deal with n_url? I thought at first that it needed to be a native string for the APIs it's being used with but the more places I see it, the less that looks like the case. Is it "normalized_url"? If so, could you start using that? We do not want to use `n_` or `b_` prefixes for anything other than variables containing native strings and variables containing byte strings. It will defeat the purpose if we start doing this in other places.
Using EOL escaping is prone to accidental line breaks during refactoring so I usually prefer using parens instead. Also, it's better to use `str.format()` with named params having in mind that we'll be moving towards 3.7/3.8+ codebase in the future and such syntax would be easier to upgrade.
Please add `type: bool`.
Indentation doesn't look right here
`No reason given` is fine
slience -> silence
` 'metadata_version': '1.0'`
Actually it needs to be `AttributeError` to keep everything happy (which the import machinery will turn into an `ImportError` if it was sourced by an import)
`delay_min_macos = delay_min | 1`
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
su requires a tty, that is why most 'subprocess' plugins don't support it.
if not handling become methods update the class variable to indicate this
Why are all of these `@property`s? They don't return anything, so I don't see what the use of that is.
So we tend to not do the else if the previous if-block returns from the function. The else is unneeded.
It is not recommended to log commands executed on the remote device due to security reasons.
I don't think there's any reason to keep this path, ComplexDict needs a module parameter
The error message can be "timeout value %s seconds reached while trying to send command %s"
version compares should be done differently (as, for instance, dnf-10.0 should satisfy the check). You can use something like this: ``` python from distutils.version import LooseVersion [...] if LooseVersion(dnf.__version__) >= LooseVersion('2.0.1'): ```
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
```suggestion commit: no ```
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
I'm not sure what the point is to assigning a class with only static methods to an instance variable. (For that matter, it is not clear to me why this is a class at all, but that seems less confusing)
Most of these options are handled from the connection plugin, and are not necessary here. In particular, you should not need to define `host`, `username`, `password`, `use_ssl`, or `timeout`. and you don't appear to be using the actual plugin option framework for any of them anyway (none of them have `env`, `ini`, or `vars` keys, so they can't be set directly).
If you're only going to get `APSCOOKIE_` _or_ `ccsrftoken`, then you can just return `None` if you don't find anything and the existing token will be reused. If you are expecting to have both, then I would just dedent the next line to be outside the for loop, so that the token is always added to the dictionary on every run. Then you should be able to at least remove the manual headers building in `send_request`.
The return value is not strictly cookies. The return value is a dictionary of headers
It would be better avoiding changing method signature, you can pass the config and state as a dictionary to the method and unpack the them inside the render_config.
Not sure if we need `normalize_interface` when fetching interface names from running-config.
This condition can be removed
If this is not required it can be removed
I'm not sure in what sorts of cases this works and isn't just always True or False. If it's always a boolean, you can use it directly, but if the value is not guaranteed to be a boolean, you can do the following instead ```suggestion config["enabled"] = bool(conf["enabled"]) ```
@pascalheraud You can check https://docs.ansible.com/ansible/latest/dev_guide/developing_python_3.html#import-ansible-s-bundled-python-six-library `from ansible.module_utils import six` and then `six.moves.urllib.parse.quote_plus`
@pascalheraud Removing 3sec sleep does not change what I wrote above. The module exit with changed=true before the ip has moved to its new location (I just tested right now). The move is planned, but not done. As is, your code does not check for a task completed at all, because the task is not created yet when the waitForNoTask function is called. The way waitForNoTask function is written, it returns true if the task does not exists (it checks tasks with a status=todo). It should indeed wait for the task created and then check the task status. PS: I am testing with ips inside public cloud projects, maybe that is why the move task creation takes longer than with other services.
The 3 sec delay is not good. We have to check with an api call if the task is created. if not, continue polling until timeout. I just tested the module, I get a changed=true, whereas the ip was not moved yet. What happened: - the module created the task - the module wait for 3 sec (but the task is still not created yet after 3 sec) - the module wait for no task (waitForNoTask function) - the module immediately returns true for waitForNoTask, because there is no task with status='todo' and function='genericMoveFloatingIp' (not created yet after 3 sec) - the module ends with changed=true, but the ip move is not finished yet on the OVH side
``` ttl=dict(type='int', default=0), ```
Remove this as it is already declared above.
Should also have trailing dot :-/
Should also have trailing dot :-/
`mutually_exclusive` could be used here ([example](https://github.com/ansible/ansible/blob/94eab56d51c8810bbf1ca39015f58f9112e83b07/lib/ansible/modules/system/systemd.py#L323)).
Maybe add at least one more example where a plugin is activated.
```suggestion for key, value in client.module.params.items(): ```
All the more reason to not use key=value format in the samples; works fine with YAML
You're correctly using `type='list'` in the arg_spec, so probably better if at least one example used the native YAML format and showed multiple values as list elements. The arg validator will properly handle coercion of a single value to a list (as the current examples show).
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
<nod> I'd be happy to see fixing it everywhere added here if you want but don't demand it :-)
Does the check module.run_command() through the transformation into smbios_dict have to be inside of the loop? It seems liks we could do that outside of the loop to be much more efficient.
Is there a reason to sort this? Since we're just putting it into a set (to uniquify the list I assume) it doesn't seem necessary to sort. Since we're just iterating over sd_instances, a frozenset is more appropriate than a set.
Need to `return bind_mounts` here
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
We tend to have full descriptions, so that the meaning is more clear to the end-user. The first line is a description of the parameter. Subsequent lines clarify the value, its use or dependencies. All descriptions (except the short_description) should have a trailing dot, so please add those everywhere. ```suggestion - The ID of the Hetzner server to manage. ```
```suggestion - Only required if no server I(id) is given or a server does not exists. ```
I would put an note about updating here
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
The 2 `if` can be merged.
add `return self.remove_nic()`
missing `if not self.module.check_mode`
+1 for to_text
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
remove the register line, kind of confused
instead of example now we need proper description of returned values, please check facts modules like azure_rm_webapp_facts or azure_rm_containerregistry_facts as a reference
yes, it's ok to iterate and change, as long as users will get simpler structure :-)
there is no need to set a temp variable for `images`
```suggestion - name: list hooks for a repository (password auth) github_webhook_facts: ```
```suggestion - name: list hooks for a repository on GitHub enterprise (token auth) github_webhook_facts: ```
``` aliases: ['repo'] ```
Making this as resolved.
You are taking me wrong here. I am just saying that adding additional library will add overhead to people who are using this module and people who will maintain it. I am not saying to port other GitHub modules to use `PyGithub`. One way could be using GitHub REST APIs directly rather than relying on any third party Python modules.
Should this just be folded into `process_username`? You'd lose the `required_together` validation, but probably make it up by ditching some of the masking code.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
please add `no_log=True` to avoid leaking the password in the logs.
s/does not do anything/has no effect/
s/run the/run in the/
Does this need to be a nested function? The overall cyclomatic complexity of this method is 8. I bet it could be reduced by removing this nested function. It would also make this method (and the function) easier to test.
> Are you suggesting to just duplicate the code from build_summary() within each for loop? Nope. It just seems like this nested function could be a method or a standalone function. > I don't see how having the nested function within _create_role_list() makes testing harder, In order to unit test `build_summary()` you would need an instance of `RoleMixin`, then call `_create_role_list()`, and then write the test in such as way as to only run `build_summary()`. It just makes it harder to get to _just_ `build_summary()` for testing, which makes it harder to throw tons of varying inputs at `build_summary()`.
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
`get_provider_argspec` again added to support local connection type with platform agnostic modules. This function can be removed.
Are these still necessary? It looks to me (as I said, I'm not familiar with network modules) that this was a now deprecated way to specify the parameters, which you copied from another network module. Since this is a new module, you can probably leave them away.
Make `verify_cert` configurable. You can take a look at [this](https://github.com/ansible/ansible/blob/959395f4b40a4f9e44a4bce890f633f8364c43a6/lib/ansible/module_utils/vmware.py#L466)
Please rename it as `get_provider_argspec()` to be in sync with other platforms
This extra check is not required after above provider spec changes
You can use `C(sf\_) ` to format this as code, which may be clearer.
we have existing byte/bit functions in module_utils
Docs uses `512emulation`: add an alias if you like to keep the code as is ~~~python enable512e=dict(type='bool', aliases=['512emulation']), ~~~
modules already have logging and debug facilities, do not create alternates as you bypass things like `no_log`
I believe the previous 3 lines can be deleted.
This should also check for `provider['timeout']` value. Something like `persistent_command_timeout = C.PERSISTENT_COMMAND_TIMEOUT or self._module.get(âproviderâ, {}).get(âtimeoutâ)`.
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
`capabilities` can be cached instead of fetching it from remote host each time. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/vyos/vyos.py#L80
The logic to set command timeout can be moved to nxos action plugin ``` conn = Connection(self._connection.socket_path) timeout = conn.get_option('persistent_command_timeout') conn.set_options(direct={'persistent_command_timeout': 241}) ```
In other modules that support `authorize` we have some code here to check we are in the right context (privileged shell vs non-privileged). If you were to test the code with a task that requires privileged then one that requires non-privileged then I believe the current code would fail. `ios` supports `authorize` as well: https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L72-L86
Resource path should not be manipulated by hand, since we should only use paths that Redfish API returns (with one exception that has been actually removed from the latest version of the Redfish standard).
As before, this will not catch non-200 statues of response.
Same duplication of functionality as with `post_request` function.
This will fail if there are no systems present (`data["Members"]` is empty list).
Last four lines could be simplified into `self.systems_uri = response["data"]["Members"][-1]["@odata.id"]`, but I would say that the function should probably store the `systems` path as the name of the function suggests.
You could change this to `if not (module.params.get('exact_count') and module.params.get('min_count') and module.params.get('max_count')):`
Here, `self.count_upgrade` is an int, and `outdated` (as above) a `dict` resp. `list`.
I wouldn't exactly call a dictionary `list`.
```suggestion for app in sorted(set(apps)): ``` This way, you won't have trouble if apps show up more than once in the list (in which case `is_installed` and `is_outdated` can return wrong information), and the order is still deterministic also for older Python versions.
still: https://github.com/ansible/ansible/pull/44070#discussion_r212981844 https://github.com/ansible/ansible/pull/44070#discussion_r213508181
doc string doesn't match actual return value
return value does not match RETURN doc string
`required: false` lines can be removed
doesn't match actual return string
does not match actual return dict
I believe selinux uses native strings (byte strings in python2 and text strings in python3) rather than always using byte strings. So that's why we weren't using to_bytes here earlier. We may need to move the to_native call earlier, though. I'm not sure if it was all selinux functions or only some of them which had bugs if the wrong type of string was passed to them.
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
to_text and prefix the string with u.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
Read operation: ditto
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
Read operation: ditto
Read operation: ditto
Okay, I see. (should not look at code before the first coffee)
The `physcialNetwork` API is an async API, that is why the `poll_async` function should be used (e.g. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/cloudstack/cs_vpc.py#L334-L336) to query the updated resource and return it to the user.
Ok, I see.
I think it's time to move this method to Cloudstack module utils.
OK, not a blocker anyway.
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
Need a space here
Need a space here
I have a concern on pagination here, `list_objects` is going to default to 100 or 500 items, which is fine most of the time (it was like this prior) but would make a nice enhancement.
`**{'Bucket': bucket}` is equivalent to `Bucket=bucket`. Please use the latter :)
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
We don't need this import of Display since we have it again on line 87.
This example will not work. Use loop with lookup/query/q instead. Any of the following will be fine: ``` loop: '{{ lookup("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true, wantlist=true) }}' loop: '{{ query("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true) }}' loop: '{{ q("aws_ssm", "/TEST/teset-list", region="ap-southeast-2", bypath=true) }}' ```
Do we also need to copy the file from controller to target? I've only ever tried this with controller == target.
Instead of oct, use '0%03o' % os.stat(source_full).st_mode & 0o777 for python3 compat. I just remembered there's also a function in the python stat module which may do the & 0o777 a bit prettier: ``` import stat lmode = '0%03o' % stat.S_IMODE(os.stat(source_full).st_mode) ```
make the conditional check is None since someone could specify mode=0.
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
Rather than str, use to_text from ansible.module_utils._text to ensure compatibility with python 2 and 3: `to_text(option, errors='surrogate_or_strict')` Looks good to me besides that.
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
I think something like this will be better (please test it to ensure you do get an error if the param/ENV isn't set) `api_token=dict(fallback=(env_fallback, ['CLOUDSCALE_API_TOKEN']), no_log=True, required=True),` Then you can delete ``` api_token = module.params['api_token'] or os.environ.get('CLOUDSCALE_API_TOKEN') if not api_token: module.fail_json... ```
Please replace your mail with your github handle (also in cloudscale_server module)
Not a blocker, but I would append an alias `server_uuid` ~~~diff - server_uuids=dict(type='list'), + server_uuids=dict(type='list', aliases=['server_uuid']), ~~~ This allows to have a bit more syntax sugar for the users for attaching volume to a single server: ~~~yaml # Attach an existing volume to a server - name: Attach volume to server cloudscale_volume: uuid: my_ssd_volume.uuid server_uuid: ea3b39a3-77a8-4d0b-881d-0bb00a1e7f48 api_token: xxxxxx ~~~
not a blocker, I would probably not error out here, instead you could print out a warning message, up to your decision: ~~~python module.warn(warning='Cannot change type of an existing volume.') ~~~
i removed this as even if you respect the play's no_log there is no current way to respect the module spec's no_log
Add that the user can specify the backend to use via the ```use``` parameter.
Still need to add something like ```You can manually specify use_backend to tell the module whether to use the yum (yum-3) or dnf (yum-4) backend.```
`elapsed_sec`/`'elapsed_seconds`? I personally dislike time values/args without units...
this got named use_backend
I'd use `elif` here.
Defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['present']), ```
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
This is wrong, already explained.
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
```suggestion - Export an ISO image of the media mounted on the CD/DVD Drive within the virtual machine. ```
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
likely on s2016 as well. Maybe just remver this line since its effectively 'all versions of windows that ansible works on', so perhaps a bit redundant now.
+1 for this.
Add a sample dict returned by module.
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Sorry, was out all of last week. I'm looking for my reproducer right now.
Here is my reproducer, consistently fails: ``` --- - hosts: localhost connection: local vars: elb_app_lb_name: "{{ elb_app_lb_name }}" tg_name: "{{ tg_name }}" tasks: - name: create an application lb elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 listeners: - Protocol: HTTP Port: 80 DefaultActions: - 'Type': 'forward' 'TargetGroupName': '{{ tg_name }}' - name: update subnets elb_application_lb: state: present name: "{{ elb_app_lb_name }}" subnets: - subnet-cbdf56ae - subnet-17bbda4c - subnet-5c7ecc60 security_groups: sg-29d13055 ``` Traceback: ``` TASK [update subnets] ************************************************************************************************** task path: /Users/shertel/Workspace/ansible/my_playbooks/elb_application_lb/iterate_over_NoneType.yml:22 Using module file /Users/shertel/Workspace/ansible/lib/ansible/modules/cloud/amazon/elb_application_lb.py <127.0.0.1> ESTABLISH LOCAL CONNECTION FOR USER: shertel <127.0.0.1> EXEC /bin/sh -c 'echo ~ && sleep 0' <127.0.0.1> EXEC /bin/sh -c '( umask 77 && mkdir -p "` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" && echo ansible-tmp-1499709521.38-260285283136193="` echo /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193 `" ) && sleep 0' <127.0.0.1> PUT /var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/tmpiiu8JI TO /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py <127.0.0.1> EXEC /bin/sh -c 'chmod u+x /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/ /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py && sleep 0' <127.0.0.1> EXEC /bin/sh -c '/Users/shertel/Workspace/ansible/venv/python2.7/bin/python /Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/elb_application_lb.py; rm -rf "/Users/shertel/.ansible/tmp/ansible-tmp-1499709521.38-260285283136193/" > /dev/null 2>&1 && sleep 0' The full traceback is: Traceback (most recent call last): File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1005, in <module> main() File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 1000, in main create_or_update_elb(connection, connection_ec2, module) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 895, in create_or_update_elb listener_changed = create_or_update_elb_listeners(connection, module, elb) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 704, in create_or_update_elb_listeners listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) File "/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py", line 487, in ensure_listeners_default_action_has_arn for listener in listeners: TypeError: 'NoneType' object is not iterable fatal: [localhost]: FAILED! => { "changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1005, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 1000, in main\n create_or_update_elb(connection, connection_ec2, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 895, in create_or_update_elb\n listener_changed = create_or_update_elb_listeners(connection, module, elb)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 704, in create_or_update_elb_listeners\n listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get(\"listeners\"))\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_CNtIaB/ansible_module_elb_application_lb.py\", line 487, in ensure_listeners_default_action_has_arn\n for listener in listeners:\nTypeError: 'NoneType' object is not iterable\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0 } PLAY RECAP ************************************************************************************************************* localhost : ok=1 changed=1 unreachable=0 failed=1 ```
This is what I think fixes it: ``` diff --git a/lib/ansible/modules/cloud/amazon/elb_application_lb.py b/lib/ansible/modules/cloud/amazon/elb_application_lb.py index 046dbc5468..92ccd6997c 100755 --- a/lib/ansible/modules/cloud/amazon/elb_application_lb.py +++ b/lib/ansible/modules/cloud/amazon/elb_application_lb.py @@ -701,7 +701,7 @@ def create_or_update_elb_listeners(connection, module, elb): listener_changed = False # Ensure listeners are using Target Group ARN not name - listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners")) + listeners = ensure_listeners_default_action_has_arn(connection, module, module.params.get("listeners") or []) purge_listeners = module.params.get("purge_listeners") # Does the ELB have any listeners exist? ```
Please do not add `required=False`, it is implicit.
Rather than treating the option type here as a string and parsing via ast.literal_eval(), I think it would be better to declare it as type dict (and name it as network_protocols to match the command naming I mentioned above): ``` network_protocols=dict( type='dict', default={} ) ```
The default values of `graph_width` and `graph_height` in the code used to be `None`, not 200 resp. 100. Is this change intended? I don't know how the settings work internally (didn't bother to check), but such a change could modify the behavior of the module (if `None` was "keep whatever the user currently had configured").
Great, the only thing to do is to add the param `timeout=dict(type='bool', default=True),` (and the docs for the new param)
I meant `validate_certs=dict(type='bool', default=True),` which is missing,
You're right. I also checked the source at tag `2.1.0`, and it contains that parameter. I guess they did some refactoring between 2.2.x and 2.3.0 which resulted in that commit...
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
we want want -> we want
If `name` is an alias of `display_name`, and the user sets `name: xxx`, `params['display_name']` will be `'xxx'`. Ansible does that internally so no module has to do that.
The aliases should be available via the standard name. I'm not sure what this function is for ie ```python display_name=dict(type="str", required=False, aliases=["name"]), foo = module.params["display_name"] # foo would be set to the what's passed in as `display_name` or `name` ```
missed .copy() so that should not be an issue, thought you were polluting `environ` .. still i would just refactor the call to one location vs keeping dupe code around
it can stay in this file, but i would make into a function that we can then also use in persistent, at least until we remove that. That way we avoid 'bugfixing only one path' in the future.
```suggestion verbosity = [] if display.verbosity: verbosity = ['-%s' % ('v' * display.verbosity)] ```
If an unknown keyword is specified, `kdata` has not yet been assigned at this point.
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
would you mind minimalizing the example for state=absent to the things required: ~~~yaml - name: Remove a vpc offering local_action: module: cs_vpc_offering name: my_vpc_offering state: absent ~~~
All client calls should have exception handling. https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
facts modules can trivially support check mode (#23107)
We don't need tags in this function, I think.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
please use explicit import statements
please wrap in block ``` if __name__ == '__main__': main() ```
please use explicit imports `from ansible.module_utils import AnsibleModule`
Why `dict(required=True)` is added here? It is already part of the spec.
please wrap in `IF` block
This is a "set" method called from redfish_command (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
This "multi" method isn't needed in this PR since this is for a "set" method called from redfish_config.
This "multi" method isn't needed in this PR since this is for a "set" method called from redfish_command.
This is a "set" method called from redfish_config (which doesn't pass in the systems_uri param). So need to remove that param here and just use self.system_uris[0] below.
Small introduced typo: ```suggestion # Search for 'key' entry and extract URI from it ```
Not sure if we need `normalize_interface` when fetching interface names from running-config.
This condition can be removed
I'm not sure in what sorts of cases this works and isn't just always True or False. If it's always a boolean, you can use it directly, but if the value is not guaranteed to be a boolean, you can do the following instead ```suggestion config["enabled"] = bool(conf["enabled"]) ```
If this is not required it can be removed
It would be better avoiding changing method signature, you can pass the config and state as a dictionary to the method and unpack the them inside the render_config.
+1 and the same for all the other fail_json's as well.
split headers and/or payload to different items in the fail_json? ``` python fail_json(msg='asfad', headers=headers, payload=payload) ``` Suppose that depends if it would ever be useful on its own instead of part of the error msg.
I would suggest 'except Exception as e' unless there is a reason for the sys.exc_info()
having such a large try/except can lead to troubleshooting problems for the end user. Please break it up into smaller blocks.
use Errror instead of exception, most users know what an error is, only programmers understand what exception means in this context
This doesn't really matter since only a single instance of ForemanInventory is created in this script but config_paths should really be an instance attribute (created and given an initial value in ```__init__```) rather than a class attribute. Class attributes exist a single time per class. All instances of the class would share the same instance of that attribute. Instance attributes exist, one per instance and thus can change independently. Modifying config_paths later in the code is a tip-off that this should be an instance-attribute rather than a class-attribute. Also, you can probably move the setting from an environment variable to be with this code when you do that. It would seem to make sense to keep that all together.
The json library entered the python stdlib with python-2.6. Code that runs on the controller (which includes dynamic inventory scripts) need python-2.6 or greater. So there's no need to fallback to simplejson here. the json stdlib library should always be available.
Note, we try to organize imports into three blocks (all optional). stdlib imports at the top, then third party library imports (requests in this case), and finally any imports from ansible itself.
it would be better to avoid the requests lib, but if you cannot you should at least specify a min version.
Make this a regular function
I don't see a backup option in the code
please fix version_added to 2.3
`required: false` is the default, can be omitted
But if you are creating the database based on the name, how would you know the ID as it hasn't been created yet.
`default: null/None` is the default, it can be omitted
needs to be a string, "2.7" otherwise it will be used as a float and not fare well in comparissions
and 'logdna lib'
DO NOT AUTOINSTALL use the HAS_LOGDNA variable as a flag and return an error with the requirement when the plugin is invoked, plugins should NOT autoinstall libraries, also pip might not be installed on target systems and is also a possible error point. you can look at other lookups (like consul_kv) for how to deal with this issue
2.0 is what you want here
this is not a safe across py2 and py3, use the provided `string_types` instead ... but better yet, jsut define the option as type: list and this will be automatically handled for you. Single element, comma separated string and 'actual list' will all be normalized so you always get 'a list'.
Can that raise a ClientError? I don't think boto3 verifies the connection like boto does when it's first created.
Same here. Also, the individual `describes` should be in separate retries from the list describe, since a throttle here would cause the whole function to re-execute. Really we'd want an individual throttle to just keep retrying that call, not start over completely.
Pretty sure catching/failing here overrides the awsretry.backoff above.
facts modules can trivially support check mode (#23107)
Catching this while inside a retry.backoff means that if this call fails, you'll never do any retrying.
How about we deprecate `vmware_dns_config` and not to make `vmware_host_dns` as drop-in replacement. (Sorry for typo)
We are not removing it, we are renaming it to another module. Which is something we could not do with **vsphere_guest** because **vmware_guest** is not a drop-in replacement.
One last thing: ```suggestion - Must be executed on a host running as Swarm Manager, otherwise the module will fail. ``` Whether the playbook task fails can be [configured](https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html#controlling-what-defines-failure).
```suggestion - When identifying an existing node name may either the hostname of the node (as registered in Swarm) or node ID. ```
```suggestion - This module creates clones for libvirt. ```
IMO, we can move the `get_connection_string` and construct the endpoints to one conditional check `if self.show_connection_string`.
`boto3_dynamodb` variable is not used
This might be a simpler way to get the AWS account ID. I quickly tested that it works. ``` boto3_sts = boto3_conn(module, conn_type='client', resource='sts', region=region, endpoint=ec2_url, **aws_connect_kwargs) ... account_id = boto3_sts.get_caller_identity()["Account"] ``` It also means we don't require the `iam:ListUsers` AWS permission for this ansible module to work.
This can also be an ARN, right? In which case the length can be up to 140 characters.
I suspect this policy comparison is not going to work quite right, but since the AWS APIs vary so much I might be wrong. Probably not a blocker, just a bug that at some point will probably need to get fixed.
I think we should have "Get info" considering renaming ;-) but that's minow
it's ok, such things we can rename later anyway if we decide to
change this to `vault_tenant`. `tenant_id` is too close to the base option `tenant` used as a credential arg.
security group -> security groups
See my point in the non facts module around snake_case.
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
I'm not sure what the point is to assigning a class with only static methods to an instance variable. (For that matter, it is not clear to me why this is a class at all, but that seems less confusing)
If you're only going to get `APSCOOKIE_` _or_ `ccsrftoken`, then you can just return `None` if you don't find anything and the existing token will be reused. If you are expecting to have both, then I would just dedent the next line to be outside the for loop, so that the token is always added to the dictionary on every run. Then you should be able to at least remove the manual headers building in `send_request`.
The return value is not strictly cookies. The return value is a dictionary of headers
Please remove `, no_log=True` from the username line
but this all in a try/except/pass to avoid leaving other temp dirs if one fails all way through
ignore if it is missing, warn if we fail to remove
I'm not sure we want to traceback on a failure to remove the tmpdir. We should probably wrap this in a try/except, and either explicitly ignore the exception, or warn.
`raise` is missing. Call to `str` is useless there.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
Be more specific in this message about what was happening when the exception happened, and remember to include the `exception=traceback.format_exc()` argument to fail_json to include the stacktrace.
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
For this case, the user may just want the parameter group to exist, but not care about what the params are set to (if they have some other tool to set them, for example) so instead of failing, this case should just exit as a success with the current values of the group (since you already got the info above).
You don't need to check the group name here, since that's a required parameter Ansible will fail before this executes.
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Supporting multiple endpoints doesn't add value unless thresholds are implemented by the ansible-core-ci service.
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
This `.close()` isn't needed, the context manager closes the file automatically.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
You can replace this line through line 363 with simply: `client = module.client('es')`
BotoCoreError could be handled here. Since only ClientError has an e.response, you can do something like ``` except connection.exceptions.from_code('ResourceNotFoundException') as e: return None except (BotoCoreError, ClientError) as e: module.fail_json_aws(e) ``` Same for ensure_deleted()
This should catch more specific exceptions since as a rule of thumb we try to avoid `except Exception`.
You can compare two dicts with compare_policies() since it fixes comparisons with lists of length one vs a string and different dictionary order: `from ansible.module_utils.ec2 import compare_policies` ``` if compare_policies(existing_access_json, supplied_access_json): modifications_needed['AccessPolicies'] = module.params['access_policies'] ```
e is added to the exception in fail_json_aws so doing it again here will result in a redundant error message. Same for the other exception handling. You could use `.format(module.params['domain'])` instead to let the user know which domain failed.
```suggestion - If an API has a specific timeout that is less than this value, this value will become the new timeout. ```
```suggestion - Period for refresh pool and gslb DNS job. ```
```suggestion - This setting enables the controller leader to shard API requests to the followers (if any). ```
```suggestion - By default, pool member FQDNs are resolved on the controller. ```
```suggestion - When set to true, pool member FQDNs are instead resolved on service engines in this cloud. ```
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
Since it's the only plugin which does that, I would remove it. Either all plugins should do that, or none.
catchall ignore ....
```suggestion # with the same name and value but with a dm_ name prefix. ```
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Since we know that the message returned from Tower CLI isn't very helpful here, lets replace `excinfo` with `organization`. When I originally did this, I made a (bad) assumption that the Tower CLI error message would be useful. except exc.NotFound: module.fail_json(msg='Failed to update project, organization not found: {0}'.format(organization), changed=False)
I'd rather not have a variable `scm_credential` and `credential`. You could just call this `scm_credential`, and supply that in the `project.modify` call.
no, it's probably not fixable anyway
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
credential is particularly problematic because it may be owned by a single user, in which case the organization will be null. This is a common case, and wouldn't be possible by assuming the organization is shared as you are doing here.
Please could you change it to: ``` if ( fstab_file and fstab_file != '/etc/fstab' and get_platform().lower() != 'sunos'): ```
It looks good!
You are not tracking timeout per child with this code. The time you're recording here is when you ask the library to queue the work.... It's not when the work starts. Therefore, you might as well save a single general timeout at the top of the method.
Need to import reduce from ansible.module_utils.six.moves.
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
I'm not sure if making this and lock_file conditional upon check_mode is the right thing to do. A module might need to lock a file in order to read it and decide if changes should be made.
With a timeout, this function will return False if the lock cannot be created. Without a timeout, this function will raise an exception. You should decide on one strategy or the other and implement it for both.
This seems like it will make for a hard API to use because it will fail when the lock_file is owned by another user (so playbooks run by different users or async with tasks that become different users will raise Permission denied errors). It seems like problems opening the lock_file should be part of the timeout.
makedirs_safe already does this, just use that function
that isn't only issue, many users require specific directories on their remotes for different reasons, this violates 'remote_tmp' configurations, which are normally per user, that is why most of our focus on creating these lock files had to do with the target file and not a common temp dir.
one more question, this would also be "true" for enlargement of the disk, would this work as expected? if yes, `allow_root_disk_shrink` would be a misleading name because it would not only resize to smaller, but also resize to bigger volume --> `allow_root_disk_resize`
No, you can resize the volume up or down, ***but*** if you want to resize it down you must specify the flag `shrink` to ensure you know what you are doing since it requires some preparation of the volume.
ok, got it! :+1:
Shall we catch a *just in case* missing volume in the response to be cleaner?: ``` volume = res.get('volume') if volume: .... ```
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
+1 for this.
Add a sample dict returned by module.
Seems like a bug? `self.datacenter` doesn't exist ```suggestion datastore_name, datacenter=self._datacenter) ```
You should add the type for each option: https://github.com/ansible/ansible/pull/47271#discussion_r226381898.
Could you add `aliases: [ 'datacenter_name' ]`? Lots of other modules use datacenter_name and don't have an alias defined..
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
No longer need deepcopy
I think we need to emit a deprecation warning so that it'd be discoverable by users and also the module docstring should be the first AST node in the module: ```suggestion """ .. warn:: Use ansible.module_utils.common.text.converters instead. """ import warnings # Backwards compat for people still calling it from this package from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text warnings.warn( 'Importing to_bytes, to_native, to_text from _text ' 'has been deprecated. Please import them from ' 'ansible.module_utils.common.text.converters instead.', DeprecationWarning, stacklevel=2, ) ```
The official name is "Docker SDK for Python" ([docs](https://docker-py.readthedocs.io/en/stable/)).
You might also want to say which versions you support.
```suggestion type: str required: true ```
```suggestion type: str required: true ```
```suggestion type: str ``` `required` shouldn't be specified if it is not true, but `type` should always be specified.
The grow and shrink booleans are used for allowing to grow and shrink the image. (That is why they default resp. to true and false). So you have to compare the original size against the wanted size, and if it shrinks and shrinking is allowed, only then should it resize (otherwise it needs to escalate). Similar for the grow-case.
The final command should probably return its stdout, stderr and rc back to the playbook.
There is a much easier way to do this, by using the index in the list. Something like: ```python unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
You could make the unit mandatory (which is what I would do), or you could allow no unit (which means in bytes) and in that case you will have to consider that case as well. (i.e.if unit is a digit)
The mixup to me is that people using incorrect units will silently be using bytes, whereas it should report this as an error.
If `date` and `time` is not added as part of a file name (in case of a configurable backup path option) `date` and `time` logic can be changed to fetch from the file information probably using os.stat()
regarding backup, the way this is implemented will backup the file to the location where the module is executed. When we exeucte this as local_action or `ansible_connection=local`, it will backup the file to the control machine, however we run this module with `ansible_connection=ssh` it will be backuped to the remote machine. This is probably not what is intended. So this should be solved as "action_plugin" (identical to ios_config) which will ensure, the backup is going to the control machine.
I don't recommend going the action plugin route, just make sure description points out that backup is where module executed. backups via action plugins are a bad pattern, now that include_role exists it makes more sense to move to a role.
As this function and module looks quite identical to the network modules `backup: yes`, my proposal was to also make backup functional identical. I am not saying the way it is implemented in network modules is the way I would prefer, though.
Move import statements after Line 81 or after RETURN
docs needed to say at which version the aliases are available
according arg spec, required=False
Ok, sounds good, i get that :).
`rolling_order` should not be removed, it is still a valid setting in vSphere 6.7 API: https://code.vmware.com/apis/358#/doc/vim.host.NetworkPolicy.NicTeamingPolicy.html#rollingOrder
Do we know other supported vendors? (Don't think there are others than VMware currently in vSphere 6.7, but there were others like Cisco and IBM in the past)
Here be dragons. I don't see check-mode being tested anywhere in the module. So I expect the module to perform a reboot in check-mode. Probably not what people expect.
Make this: ```python result = set_vm_power_state(pyv.content, vm, module.params['state'], module.params['force']) ``` Remove the stuff below.
Why not simply do: ```python match_first = (self.params.get('name_match') == 'first') ```
The `failed=False` is assumed, so I wouldn't add it by default. The only reason when this has to be add explicitly is when you return a non-zero return code (rc-value) and don't want it to fail.
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
I would separate individual examples by an empty line.
Please put this on a single line. Lines can be 159 characters wide.
Right but this seems arbitrary, cut off at 40 characters ? For readability I think it's better to not split lines if it is not required. But you are right, it's not mandatory. So you can ignore this :-)
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
Instead of building regexes to match the link parameters and extract them, it would be easier to use `parse_qs` which pulls values from valid query strings. For example: ``` >>> from ansible.module_utils.six.moves.urllib import parse >>> query = parse.parse_qs('/foo/bar?page=6&per_page=20') >>> print(query) {'per_page': ['20'], '/foo/bar?page': ['6']} >>> int(query['per_page'][0]) 20 ``` Or for more advanced parsing, you could use `urlparse` to remove the query string and path to use. ``` >>> parse.urlparse('/foo/bar?page=6&per_page=20') ParseResult(scheme='', netloc='', path='/foo/bar', params='', query='page=6&per_page=20', fragment='') ```
Oh, I see. `run_commands()` runs list of commands and returns list of results.
@pierremahot we'll need a test for this
self._connected is set by CliBase.connect(), shouldn't need to specify it here
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
Can get rid of required=False.
you can use get_id_by_name, and don't have care about checking.
call create, so we are sure the disk is up to date with parameters provided by user.
You can remove this. If there isn't a specified return, None is returned.
Yes. Either to_native or to_text would be fine in this case.
This can just be ``` if module.params.get('version') is not None: return str(module.params['version']) elif module.params['alias']: return str(module.params['alias']) ``` And that would be functionally equivalent.
I would replace these 3 lines by: ``` # Add these imports from ansible.module_utils.compat import ipaddress from ansible.module_utils._text import to_text ### prefix = ipaddress.ip_network(data["prefix"]) network = to_text(prefix.network_address) mask = prefix.prefixlen ``` This way, it will not fail if `data["prefix"]` doesn't have a netmask (default it to /32 for ipv4, /128 for ipv6).
Sorry, I know it was in my changes, but I forgot to remove that lineâ¦ Changing the data seems a bit ugly here, could you remove this line and changing the next one by: ``` prefix = ipaddress.ip_network(data["prefix"] + "/" + data["prefix_length"]) ```
according to doc spec, there should be an alias: ~~~diff - ip=dict(), + ip=dict(aliases=['network']), ~~~
I think something like this will be better (please test it to ensure you do get an error if the param/ENV isn't set) `api_token=dict(fallback=(env_fallback, ['CLOUDSCALE_API_TOKEN']), no_log=True, required=True),` Then you can delete ``` api_token = module.params['api_token'] or os.environ.get('CLOUDSCALE_API_TOKEN') if not api_token: module.fail_json... ```
I would propose to give the json paylod in the error message, as it would help for debugging
Please also write that either id or name is required in case of upload/download and add code that checks it was properly passed.
Either C(disk_id) or C(disk_name) is required when C(upload_image_path) or C(download_image_path) is specified.
Same here, the first line should give information what the parameter is about. Subsequent lines clarify the value and dependencies. So in this case you'd have at least 3 items in the description.
I understand what you're trying to do here, but managing both parent as child objects in a single module is going to be problematic IMO. This can only work if your childs are always fully listed (and replaced/updated).
I'd define the (common) `vars:` just once and list the different examples one after each other within the same `tasks:` section.
facts modules can trivially support check mode (#23107)
You should explicit the fact that vm_name is not a string, but a vmodl.â¦ object containing a propSet containing the VM name.
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
This will fail if ```updated_list``` has items which are not present in ```original_list```. You probably want something like this instead: ``` python merged_items[item_key] = items_map.get(item_key, {}) merged_items[item_key].update(item) ```
In python, this is probably better represented as a global dictionary in a separate module (as outlined above). Something like file serviceprovider.py: SPKEYS = { 'ID': 'id', 'NAME': 'name', [..] } ```
You reassign this var on each loop iteration, please move it outside. ```suggestion ```
Same here: move url outside of the loop: ```suggestion ```
I don't like that in this case. It's a defaultdict which means that if no facts are collected in this run at all, the host will still end up in `self.facts`. The result is that it will `POST` an empty hash to Foreman which removes all facts for that host. This version avoids that by first checking it.
Maybe? ```suggestion self.facts[host].update(value.get('ansible_facts', {})) ```
How about: ```suggestion from ansible.module_utils.parsing.convert_bool import boolean as to_bool try: verify = to_bool(option) except TypeError: # it wasn't a boolean value verify = option # Set to a CA bundle: finally: if verify is False: # is only set to bool if try block succeeds requests.packages.urllib3.disable_warnings() self._display.warning( u"SSL verification of %s disabled" % self.foreman_url, ) return verify ```
oh, that was a misunderstanding. I didn't want to change the default, I just wanted to suggest you choose the python boolean `False` instead of string 'no'. Sorry for the confusion.
please add `no_log=True` to avoid leaking the password in the logs.
choices=BOOLEANS is obsolete and not needed anymore, type='bool' is all it is needed
Please add `supports_check_mode=True`. With this seeting, facts modules will also be executed in `--check` mode. ~~~ python module = AnsibleModule( argument_spec = dict( host=dict(required=True, type='str'), login=dict(default='Administrator', type='str'), password=dict(default='admin', type='str', no_log=True), ), supports_check_mode=True, ) ~~~
please add `no_log=True`
```suggestion type: str choices: [ absent, present ] ```
```suggestion - The full path to a list of block devices such as hdd, nvme or nvme. ```
```suggestion - Whether to enable or disable automatic pool expansion when a larger disk replaces a smaller disk. ```
Why only autoexpand and autoreplace are added as an option? I can see a value of having all or nothing and just use sets.
```suggestion - Automatically replace a bad device in pool using a spare device. ```
I bet it's possible that this thing raises `IOError`
So refactored I would have a function like this, in case if you want to have **one optional arg for grep**: ```python from ansible.module_utils import six ... ... def run_command(needle=None): command = "ps aux" if needle is not None: command = '%s | grep "%s"' % (command, needle) display.vvv(command) try: proc = ( subprocess. Popen( command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, ) ) return to_text(proc.stdout.read()) except OSError as os_err: six.raise_from(AnsibleError("Failed to fetch processes."), os_err) except IOError as io_err: six.raise_from(AnsibleError("Failed to read subprocess output."), io_err) ```
You'd probably want to do validation as a first thing in the function and then stop caring about checking things. This seems a logical thing to do.
You invoke it yourself, so do validation in lookup plugin class
Oh, and in Python we tend to avoid string concatenation with "+"
```suggestion out = run_gluster(['volume', 'heal', name, 'info'], environ_update=dict(LANG='C', LC_ALL='C', LC_MESSAGES='C')) ```
If rc != 0 it is always err. You don't need out or err.
This will throw an exception every time when a server is down. When glusterfsd is down the output looks like this: Brick 10.70.43.200:/mnt/engine Status: Transport endpoint is not connected Number of entries: - And you'll be trying to do int('-') which will throw ValueError. And the module throws error: fatal: [10.70.42.25]: FAILED! => {"changed": false, "msg": "Invalid heal status option."} in the function main.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
not sure we need this here as we should always be writing to a tmp file
~~don't you still need the else? won't this fail when using stdin/stdout?~~ nvmd, missed the 'return'
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
```suggestion type: list elements: str ``` It's helpful to define that the list is a list of strings (or what ever).
```suggestion - Either I(tag_keys) or I(tags) is required when the state is absent. ```
I(....) adds the highlighting that this is an argument name.
```suggestion - A list of tags to be remove from the resources. ```
While you can create dict comprehensions in python 2.6, you don't need to here: > tags (dict or list) â Either a dictionary containing name/value pairs or a list containing just tag names. If you pass in a dictionary, the values must match the actual tag values or the tag will not be deleted. If you pass in a value of None for the tag value, all tags with that name will be deleted. ``` tag_remove_list = [x for x in tagdict if x not in tags] ``` The 2.6 equivalent, for reference, is ``` dictremove = dict((x, None) for x in tagdict if x not in tags) ```
can probably remove the `tagger = ` here, as nothing is using it
Same order, type first.
`policy` should be added to `argument_spec` to be usable.
This logic seems ignore the use case of removing all tags.
We should probably do more here than just reraise the exception with a different type. Add a message here so it gives context about the failure. The same with the next one too.
This can be removed
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
```suggestion b_opath = os.path.realpath(to_bytes(os.path.join(path, group))) ```
Try using `.format()` or `%s` formatting instead: ```suggestion self._display.debug("recursive_group_vars - Matched file : %s" % to_text(found)) ```
Add a blank after this to notify that these are two separate tasks.
I don't see this change in latest commit.
It is not mandatory to have return but I would recommend to add one, from UI/UX point. :)
```suggestion host = find_obj(self.content, [vim.HostSystem], name=esxi_host_name) if host is None: self.module.fail_json(msg="Unable to find host system %s in the given configuration." % esxi_host_name) ```
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
I see did some changes of single quotes to double quotes but you left all double quotes are the were. You should change all other cases than named above to single quotes (e.g. keys in the dict vars - `my_dict['my_key']`).
That all sounds correct.
Capital letter at the beginning and period at the end of the sentence.
The value should not be quoted.
This should be: ```python msg = ( "Physical volume %s is already used by volume group %s." % (pv, lspv_list[pv])) ```
`return migs != 0` is equivalent ot lines 380 to 382.
Use `==` to compare booleans. The `is` test should *only* be used when you really want to compare identities of objects! Finally, there's no need to compare a boolean to `True` or `False` explicitly; simply write `elif self._has_migs(local):`.
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
This would also match version 10.x. Also, `4.[0-2]` will also match `421` (an unescaped dot matches anything). You probably want: ```suggestion if re.search('^([0-3]\\.|4\\.[0-2])', min(self._build_list)): ``` Or (using raw strings, to avoid double escaping): ```suggestion if re.search(R'^([0-3]\.|4\.[0-2])', min(self._build_list)): ```
Also, why do you compute `data.split(delimiter)` again instead of using `data_arr`? ```suggestion metric.split("=", maxsplit=1) for metric in data_arr) ```
No need to have the `required: false` lines, it's implicit.
You can remove this line
Ok, not sure why this one is still open.
Parameters that are not required don't need `required: false`.
Make this a separate item in the list.
> Speaking of which, I should submit a PR to add Python 3.5 to tox.ini and .travis.yml #12627.
Hm, given those 15(?) other tests that failed on Python 3 in calls to syslog.syslog(), could we monkey-patch the rest of the tests so this is the only test that actually writes to the real syslog/journal? (EDIT: when I say "the rest of the tests", I mean in test_basic.py.)
no, if the variable is set but empty, you should empty out the options
Don't assign a lambda function, use def
Don't assign a lambda function, use def
```suggestion - The default key (C(alias/aws/ssm)) is automatically generated the first ``` and a period at the end of the sentence (in the next line). Maybe also clean up the sentence above :)
Could you clarify what's happening by adding an example 2-line CSV file? I think that would improve the docs.
Could you please keep the same string quoting style across the module? ```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('UTC')), '2019-06-15T14:45:00+00:00'), ```
```suggestion (datetime(2019, 6, 15, 14, 45, tzinfo=tz('Europe/Helsinki')), '2019-06-15T14:45:00+01:40'), ```
No need to parametrize with just one case.
This would be handled by the `AnsibleAWSModule` ```python try: import botocore except ImportError: pass # handled by AnsibleAWSModule ```
You can remove these imports except ec2_argument_spec
snake_dict_to_camel_dict can be removed.
compare_aws_tags returns the tags to add and the tags to remove. The tags to remove are in the format of a list of keys. You could call that once in main rather than handle it in each function (you'll need to pass True as the last argument to compare_aws_tags, so it returns the list to remove if state is absent).
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
```suggestion if self.client.module.params['disk_usage']: ```
```suggestion elif docker_object == 'networks': ```
I think this description is off :)
Shouldn't this be `When I(containers) is C(yes)`? (Same for the others.)
How about moving this `if` below the next `if`? Then you don't need the inner `if`.
```suggestion return False, 'Command "%s" found no files in archive. Empty archive files are not supported.' % self.cmd_path ```
This isn't showing changed=True for me when is succeeds. In fact, I don't know if it will ever complete without changing something, since right now we're failing if the git archive command isn't successful and if the directory creation isn't successful. Maybe a nice addition would be to compare the checksums of the contents of the archive destination to see if they are different than initially so changed could be False. But that would entail putting adding the zipfile to the directory, since I think we wouldn't want to rewrite the possibly existing file. Not sure what the best course of action is here. But exit with changed=True here, for now at least.
The remove is in the wrong place and tempdir is not removed. Better: ``` tempdir = tempfile.mkdtemp() new_archive = os.path.join(tempdir, 'archive.' + archive_fmt) git_archive(git_path, module, dest, new_archive, archive_fmt, version) archive_unchanged = filecmp.cmp(new_archive, archive) shutil.rmtree(tempdir) if archive_unchanged: result.update(changed=False) else: ... ```
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
This will fail if the destination exists. Is that the desired behavior? Since it is making a directory, maybe it should check if the directory already exists and if not create it? If it does exist, maybe we should be able to continue onto the archiving step. In addition, here's a hypothetical scenario: if this archiving fails the first time because the user uses an invalid URL to archive this part of the operation will succeed and the directory will be created. When the URL is fixed and this operation will run a second time it will fail here and not be readily apparent why. I think importing traceback and then failing with `module.fail_json(msg="Failed to clone source", exception=traceback.format_exc())` would be really helpful here for future debugging.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Same here. required=False and default=None are obsolete. Only specify them if they are set.
Move the check_mode test into the `do_notify_teams` function, and see if you can do something relevant instead e.g. test the connectivity so you do as much as possible in check-mode.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
type='str' is the default so I think you can remove those.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same as for the updated, I'd rather say `has been deleted`
use the `missing_required_lib` function from `ansible.module_utils.basic`
Please use 'msg' for returned messages, this is a standardized return value.
s/will created/will be created/
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
```suggestion - Either I(parameters) or I(parameters_links) is required if I(state=present). ```
This could cause problems if certain characters sneak into the repr() of the exception. (For instance, "{") Probably need to avoid writing to stdout and stderr.
Should be able to just do _fact_ids = set() without instantiating a temporary list.
This isn't needed as Windows hosts don't use the Python modules. If you wanted to add it into Windows have a look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/windows/setup.ps1
Thanks, if you push those changes I can re-review
Doesn't seem to have been done
```suggestion if not os.path.exists(to_bytes(xdg_path, errors='surrogate_or_strict')) and euid != 0: ```
This probably needs to be bytes.
I think this may read better: ```suggestion if missing_keys: ```
Are you only doing this to support Python 2.6? Those keys are already unique.
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
It looks like scaleway modules allow a series of fallback environment variables as well as a module option. If you wanted to do the same thing for this plugin you could do ``` options: ... oauth_token: env: # in order of precedence - name: SCW_TOKEN - name: SCW_API_KEY - name: SCW_OAUTH_TOKEN ``` Then you can use self.get_option('oauth_token').
Most modules using public cloud providers offer a `validate_certs`/`validate` option[1][2]. I think the same apply here. [1] https://docs.ansible.com/ansible/latest/modules/ec2_snapshot_facts_module.html#ec2-snapshot-facts-module [2] https://docs.ansible.com/ansible/latest/modules/os_volume_snapshot_module.html#os-volume-snapshot-module
not what i meant, dont access config_data directly, using `get_option()` will verify type and ensure you get the default you set.
It doesn't make sense to use `id` parameter with `state=present`. Currently when `state=present` is used and `id` is specified, a new IP with another `id` is created.
nit: I would scope/namespace this to `scaleway_snapshots` to ensure it doesn't overrite another `snapshots` in `ansible_facts` scope
Please rename **follow** to **insertafter**, that is an existing parameter already used by **lineinfile** and better describes what it does.
BTW The most important reason for not adding that parameter, is because it can cause real idempotency issues.
typos: persistent / reboots
Should be: - Tested on AIX v7.1
This is the wrong way of doing Ansible. The user should describe the desired state, not instruct modules to perform actions. The module itself should determine what actions the specific state needs based on the current state and the desired state. That is what is needed for idempotency anyway. So rather than action=install, it should be state=present. Also, check-mode support and diff support are very important for a tool like this one IMO.
Could you please update `lib/ansible/utils/module_docs_fragments/docker.py` to mention these variables, see `lib/ansible/utils/module_docs_fragments/vmware.py` to an example
The fallback env variable is called `DOCKER_TLS`, not `DOCKER_TLS_VERIFY` (that's the one below).
Use the existing `DEFAULT_DOCKER_HOST` constant.
this should be a common function in basic.py (i think there is this one or the reverse there already)
already have this in basic.py, no need to create your own, it also includes sanitation and no_log
You could as well just call `exit_json` in `execute()` since you're already not using functional approach.
The functional approach is having functions returning values and not storing a shared state between different parts of the processing flow. It's fine to use the object-oriented style, it just doesn't feel right when you combine different style and it looks like a weird soup mixture. I like the code to be elegant, readable and maintainable. That's why I tend to be so nitpicky...
Please stop calling `get()`
That `__metaclass__ = type` line in the top of this module turns all classes into new-style automagically. So you don't need to inherit from `object` explicitly anymore. ```suggestion class PodmanManager: ```
AFAIR the flag is `failed`, not `fail`
Write a method to generate final diff so it can be used anywhere in the code when required.
`commands` should always be a list.
This should be handled in the method where commands are being generated.
This isn't necessary as facts will always be empty if running-config has no lldp config.
No need to set `have`, `want` explicitly as it is always be empty dict if not resource is given/present.
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
Again nitpicker - sentence sounds a bit weird. Maybe something as follows would be better? ``` Nested keys must be quoted when specified in abbreviated form (e.g. C("DesktopViewSettings:IconViewSettings:arrangeBy")), since colons are treated as part of YAML syntax itself. ```
Examples should use HTTPS
The doesn't appear to match the code ``` + mutually_exclusive=[['source', 'image']], + required_one_of=[['image', 'image_family']], + supports_check_mode=True ``` Please also use `I(...)` for option names
You could fix #19781 real quick right here :D
Required when I(shared_access_key) not defined.
```suggestion type: list elements: str ```
Since this check-in action plugin ensures the prompt is out of `configure` mode, we can use `exit discard` here as it always ensures the prompt is changed to operational mode.
Thanks! Note that that only fixes it for v230, not for versions < v230, so #56571 should still be reopened.
When creating a portgroup in the UI, by default, notify_switches is yes. I think we should stay in line with that.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
For automation, `yes` or `accept-new` are probably more secure choices than `no`. In the end, it's up to the user to decide what kind of security requirements they have and which default setting they want.
Ah, ok. As I said, I've never used docker-machine, so I assumed that it actually connects to the machine (using that shell) and exports the environment from there. If that's just the format, then yes, it really doesn't matter (as long as it is a format you can parse :) ). Both `bash` and `sh` are fine for me, use whatever you want then.
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
```suggestion # Install all filesets to latest level f.i. install a TL or ML ``` Not sure what all this means.
```suggestion - name: Update all filesets to latest level from lpp_source lppsource_aix6109-06 ```
```suggestion - name: Install version 6.1.9.30 of OpenGL.OpenGL_X.rte.soft from lpp_source lppsource_aix6109-06 ```
```suggestion commit: no ```
```suggestion - name: Deallocate all resources from the nimclient ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
No need for params: * they are accessible via module * they aren't used here at all ```suggestion def __init__(self, module, name): ```
Please don't use inconsistent return values throughout the function. Currently, you use `NoneType` and `bool`. Use just one type. This is unnecessary. ```suggestion ```
Add spaces between if-blocks. It's quite painful to read it when everything is so dense.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
This should not be moved. They're libraries from the current project so go below the imports for stdlib and third party libraries.
Nitpick: ```suggestion from ansible.module_utils.common.text.converters import to_bytes, to_native, to_text ```
Minor nit: this import should be on line 276 so it's alphabetical.
What happens if it is missing? Will the module still work? (Right now, it never checks this variable again.)
s/CONSTURCTOR/CONSTRUCTOR/ (and usages)
should be superfluous unless you want to add a different command for check_mode support (since `supports_check_mode` is false)
same here with the collapse
Same here with exception handling collapse. You could use something like `type(exc).__name__` in the string if you don't want the whole stacktrace but still want to know what it was- I'm guessing that's not useful info to an end user, but might be for troubleshooting.
oy, thanks Github
s/./ to avoid infinite hangs waiting for input./
vault is also used to encrypt private keys and certs, so you cannot always assume its valid yaml
This introduces a different race condition, file can now be looked at in 'intermediate' state.
we've avoided using _ as a 'unused var' in case we decide to use i18n .. which also has special uses for _
example that supports all defaults except 'su' ``` become_methods = frozenset(C.BECOME_METHODS).difference(('su',)) ```
su requires a tty, that is why most 'subprocess' plugins don't support it.
Yes, please remove the return and update the caller.
no need to check for present as it is default state
@azaghal I would leave it as you have it, with the explicit check for 'present'
You are not returning ansible_facts here. This will break backward compatibility.
ditto as `required_if`
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
I know you aren't fond of the current name, but for clarity I'd consider referring to the ConfigureRemotingForAnsible.ps1 name here
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
Might as well return all the tags: ``` customer_gateway['tags'] = boto3_tag_list_to_ansible_dict(customer_gateway.get('tags', [])) customer_gateway_name = customer_gateway['tags'].get('customer_gateway_name') if customer_gateway_name: customer_gateway['customer_gateway_name'] = customer_gateway_name ```
spec is also returned
Since you're using AnsibleAWSModule, you don't need to call get_aws_connection_info or boto3_conn. You can do `connection = module.client('emr')` (no exception handling needed around that either). You can pass connection and module to get_emr_cluster in addition to cluster_id.
The return docs list the results just under cluster, but it's just being added to ansible_facts here. I think if multiple clusters may be returned, that should be changed to `clusters` (if cluster_id is not requried). But since there is only the ability to return one right now, to make this consistent with the return docs add **emr_cluster_info to the end of the exit_json call.
default is false by default so no need to have false
Incorrect description; "If remote gateways can be used on this virtual network."
```suggestion - List of IP addresses. ```
```suggestion - Only used for images that contain the Windows Server operating system. ```
```suggestion - To remove all resources related to the VM being removed, including auto-created resources, set to C(all). ```
@thomwiggers `line.partition(':')[2]` yes, I have no problem with that.
If you're going to do partition, I'd rather use the fact that it'll always return a 3-tuple instead of using `-1` to index the third element. i.e.: ```python line.partition(':')[2] ```
```suggestion rcmd = "%s --sync --info %s" % (pacman_path, realname) ```
```suggestion ``` I don't think you should do this, case is meaningful: ``` max@mde-oxalide % pacman -Q libreoffice-en-US libreoffice-fresh 6.1.3-1 max@mde-oxalide % pacman -Q libreoffice-en-us error: package 'libreoffice-en-us' was not found ```
```suggestion cmd = "%s --query --quiet --explicit --info" % pacman_path ```
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
The value should not be quoted.
Missing period at the end of the sentence.
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Shippable doesn't like this line for whatever reason.
You should be able to use `self.vmware_test_platform` here.
I suggest: if parser.get('DEFAULT', 'vmware_validate_certs').lower() in ('no', 'false'):
Are we doing singleton `__new__`/`__call__` magic internally on some of the callback plugin types? Seems like this would never be `False` otherwise...
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
```suggestion - 'If a I(checksum_url) is passed to this parameter, the digest of the ```
```suggestion - 'If a I(checksum_algorithm) is passed to this parameter, the digest of the ```
Please remove this line, for various reasons. - We use examples to showcase possible values - It shows the old key=value syntax If you remove this, you also do not need to quote the whole paragraph.
Please remove this line, for various reasons. - We use examples to showcase possible values - It shows the old key=value syntax If you remove this, you also do not need to quote the whole paragraph.
```suggestion (unless C(force) is C(true)). ```
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
No need to compile explicitly, `re` will hold compiled cache internally anyway.
you should probably put these check even before `super()` line
You use `re.match` which already checks the beginning of a string. So caret `^` is not needed. https://docs.python.org/3/library/re.html#search-vs-match
Options that are not required don't need a `required: False`. It is implicit. You can leave that out.
Fair enough. It is not a hard requirement.
`descriptions:` should end with a full stop
From the mail I got I saw this obvious typo "receipient_id". Also now that we are at it, parameters can be indicated using C(parameter). So that line should read: ```yaml - The C(recipient_id) type must be valid for the supplied C(recipient_type). ```
Only slightly frustrated ;-) Thanks !
If the line would be `cmd = self.docker_cmd`, the original value of `self.docker_cmd` (which is a list) would be modified by the `cmd += ...`'s below. That's why a copy must be created.
You should either use ```suggestion cmd = self.docker_cmd[:] ``` or ```suggestion cmd = list(self.docker_cmd) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
It would be awesome if buildah supported copying from a container.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
```suggestion - I(update_password) must be C(true) for an existing user's password to be updated. ```
You also need to add the choices in the `argument_spec`.
to me it looks that protocol should only be required if state=present --> see required_if helper
to me it looks that port should only be required if state=present --> see required_if helper
That's not how `diff` should look like. It should be a `dict` with elements `before` and `after`. These will be converted (depending on the callback plugin, i.e. JSONify or YAMLify) and then diffed.
I meant the `headers` variable. I just don't see it used anywhere else.
i would mention this plugin is Windows specific
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
I believe it's ```suggestion raise ImportError("We weren't able to import the module {0}".format(module_name)) ```
I would name the method `passwd_check`.
You use `re.match` which already checks the beginning of a string. So caret `^` is not needed. https://docs.python.org/3/library/re.html#search-vs-match
No need to compile explicitly, `re` will hold compiled cache internally anyway.
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
```suggestion return next(platform for platform, rule in platforms.items() if rule.match(text), 'unknown') ```
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
```suggestion - Whether the VMs in the linked Virtual Network space can access all the VMs in local Virtual Network space. ```
```suggestion - Whether gateway links can be used in remote Virtual Networking to link to this Virtual Network. ```
```suggestion - Whether forwarded traffic from the VMs in the remote Virtual Network will be allowed/disallowed. ```
This should be either "Success" or "Succeeded".
Here too, should either be "Success" or "Succeeded".
I don't like to frame such big block of code into an exception. Please put the exception only around the command which actually can throw an exception.
Shippable doesn't like this line for whatever reason.
The value should not be quoted.
This should be: ```yaml with_items: "{{ ret.bindep_packages.missing }}" ```
Missing period at the end of the sentence.
This looks like debugging code that should have been removed? It causes the module to fail to detect installed OpenCSW packages. All tests succeed iff these two lines are removed.
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
This leads to another issue. The `pkgutil` command will quietly prefix package names with `CSW` if absent, and users might reasonably expect this Ansible module to behave in the same way. Consider the following play, which will always return `changed`, `ok`, successfully installing the package but then neglecting to remove it. ```yaml - pkgutil: name: top state: present - pkgutil: name: top state: absent ``` It would be better to throw an error in this case rather than silently considering such packages never to be installed.
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
Please remove this line.
Actually, we had some discussions about group names the previous days on IRC. Apparently dashes have been not allowed in group names from Ansible 2.4 on; this hasn't been enforced so far, but now (with Ansible 2.8) it will be. It's still possible to disallow it, but every group with a dash (or other invalid chars) in them will trigger a big fat warning. So please get rid of the dashes here so users of this inventory plugin won't automatically get a list of warnings, even if they don't have invalid chars in their labels.
Maybe it makes sense to prefix the label-based groups by something like `docker_swarm-label-` or so, so that short/generic labels don't overwrite existing groups. Or maybe also make this prefix an option for the inventory plugin so users can overwrite it or leave it away if they don't think there will be collisions.
```suggestion if self.node_attrs['Spec'].get('Labels'): ``` This will prevent a crash when `'Labels' in self.node_attrs['Spec']`, but `self.node_attrs['Spec']['Labels']` is `None`.
don't raise errors on import, expose them on `parse` see developer docs for examples
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Also, this would break while deleting a stack without providing a template.
Instead of infinite checking, please cap the amount of time to some (can be long) value. 5 or 10 minutes would be *plenty* for CFN to generate a changeset.
It'd be better here to catch boto exceptions & other exceptions separately, since generic exceptions (like IOError if the network fails, for example) don't have status codes and other boto-isms.
Needs to be `changeset_name = stack_params['ChangeSetName']` to match PEP8 style of whitespace around operators.
We can't leave this 100% unbounded, in general a higher timeout (10 minutes should be sufficient for most every stack changesets) is fine, and avoids us accidentally creating an infinite loop.
the tests should not really be for hostfile, as we are going to remove it. a mock setting with 2 entries would test the functionality, not the specific setting
I think this can be simplified to just: ``` if not section: ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
Also, add ```vmodl.fault.SystemError``` here,
same here, we really dont want to test the particular setting, just that both the default (dynamic template) and the nii entry are correctly parsed.
All these vars should start with 'ansible_'
This is now `'2.10'`
since the plugin is called `aws_ssm`, I'd change this to `ansible_aws_ssm_retries`
nope, looks like you missed this one.
No need to quote the path, not using double quotes also means you don't need to double up on `\`, e.g. just do `path: C:\Windows\temp`.
I think that wildcard imports are generally discouraged, because it makes it difficult to refactor and determine the origin of a function or class. For example, at first the `boto3_conn` function used in the constructor seemed undefined.
Small typo here probably: `Retreived -> Retrieved`
You don't need to specify required=False or default=None or type='str' for any of these as it is the default.
If the tags option is a dict you can use python_dict_to_boto3_tag_list instead of implementing the functionality here.
There should be a check before https://github.com/ansible/ansible/pull/24292/files#diff-aaef1b3abde00153e8695bfdf79c5e55R1882 that HAS_BOTO3 is True.
result is attempted to be used below
This feels to me like it would be better as a function that would take a dbinstance and convert it to the facts dict, then a separate one to diff dictionaries rather than a class.
`del` is a builtin, not a function. These parens don't have to be here
This doesn't support aurora snapshots. Besides that, this looks great.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
This is fragile, and just a wild guess as to what we should do here. Instead of this, we should be extending the functionality of the `file` lookup, to accept an `encoding` parameter.
delay this to 'parse' and issue a 'missing nma binary' explanation there, we don't want plugins to fail on instanciation
I think this warning text should be reworded as it will be displayed to customers: Maybe: "Updating more than one load balancer on VMSS is currently not supported" Just this one and we can merge
Or maybe ```suggestion self.default_inventory_hostname = '_'.join(( vm_model['name'], hashlib.sha1(to_bytes(vm_model['id'])).hexdigest()[0:4], )) ```
Are `vmss_name` and `name` different? I'm guessing they are: ```suggestion - Virtual machine extension name. ```
```suggestion msg = "" ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
```suggestion module.exit_json(msg=msg, changed=changed) ```
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
AFAIR the flag is `failed`, not `fail`
```suggestion self.container = PodmanContainer(self.module, self.name) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
A message string would good to say that image is not preset or something similar.
If you use a catchall exception handler like this then you should also provide the traceback like this: ``` python import traceback from ansible.module_utils._text import to_native [...] module.fail_json(msg='Unanticipated error running atomic: %s' % to_native(e), exception=traceback.format_exc()) ```
An example of using values would be good to have.
Default needs adding to docs
Only import what you need, rather than `*`
I'd do: ```python from functools import partial ... def is_satisfied_by(current_version, constraint_predicate): op, ver = constraint_predicate return op_dict[op](current_version, LooseVersion(ver)) satisfies_target_version = partial(is_satisfied_by, current_version=LooseVersion(version_to_test)) return all( satisfies_target_version(spec) for spec in self._requirement.specs ) # or return all(map(satisfies_target_version, self._requirement.specs)) ```
`'>=', '<=', '!=', '==', '>', '<'` is duplicated with that operator map. you could do global map and use `that_map.keys()`
As far as I understand this is only necessary to support stuff like `djang>1.11.0,<1.12.0,bottle>0.10,<0.20,!=0.11`. Why should we support this? Using a list is to me the obviously better API and support this structure adds a lot of (to me unnecessary) complexity.
Cross-compability, backwards compatibility, command line compatibility, ease of discovery. * Other packaging modules support comma separated package entries. * The pip module itself supports comma separated package entries * pip supports single string entries as valid packages * comma separated list entries are the natural way to write lists on the commandline. * error messages if people were to violate these rules (for instance: ```ansible localhost -m pip -a 'names=django>=1.11.0,<1.12.0'``` wonn't point to the actual solution unless we implement this sort of detection for creating the error message... in which case we might as well do the right thing.
Can you give an example for the error message coming from this? As stated above I would rather remove support for construtcs, which can raise exceptions here.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
If a parameter is not required, no need to explicitly put this in. (If you would put in all possible values here, you'd be defining a handful of defaults)
Make this two entries in your description. Especially because the first entry is the description of the option, the next entries are specifications or additional notes.
Don't add a trailing dot to the `short_description` ! Keep the index clean.
Ahh that makes sense I've re-read it now and can see what you mean. I would prefer it to be just `name` to keep it consistent with the other stuff but will defer to you for the final decision.
```suggestion serial_port=dict(type='int', required=True), ```
This module fails in check mode since it is not calling `module.exit_json()`. Since this module does not look at the state and compare it before making changes, I would suggest removing check mode support from the module currently.
Since this accepts a list of ports, change the type to `list`. This requires it to be transformed a bit, but would be a better UI. A `list` type parameter will accept a comma separated string as well as single items, which field validation will return as a string.
If `port` is changed to a `list`, you'll need to do this here: ```suggestion ports = module.params['port'] if isinstance(ports, list): ports = ','.join(to_native(x) for x in ports) fullurl = ("%s%s/api/v2/config/serialports?ports=%s" % (protocol, to_native(module.params['cpm_url']), ports)) ```
Combine this import with line 114.
I think you added a little too much here: ```suggestion - The passphrase for the privatekey. ```
`C(3)` could be used instead of `3`.
Fair engough. Then, if I haven't overlooked anything, there is no need to pass `privatekey` to `_check_signature()` as you can call `csr.verify(self.privatekey)` directly.
This isn't needed anymore as it is part of the parent class value. **Note**: Default has been set to `False`, so the logique about self.changed needs to be updated in the rest of the code.
This check doesn't work as-is and raises issues when running the following playbook two times in a row: ``` --- - hosts: localhost tasks: - openssl_privatekey: path: /tmp/private.key - openssl_csr: path: /tmp/csr.csr privatekey_path: /tmp/private.key commonName: www.ansible.com ``` This is due to the fact thatthe current code relies on `expected` being an array when it could be actually None, hence raising: ``` TypeError: 'NoneType' object is not iterable ``` Here is an alternative implentation that did what was expected, feel free to modify adapt/modify/get ideas from it: ``` usages_ext = [str(ext) for ext in extensions if ext.get_short_name() == extName] if (not usages_ext and expected) or (usages_ext and not expected): return False elif not usages_ext and not expected: return True else: current = [usage.strip() for usage in usages_ext[0].split(',')] expected = [long[usage] for usage in expected] return current == expected ```
add 'version_added: 2.5' here.
period at the end of statement.
This is not required if using `super`
This is handled by `argument_spec`
I would remove that parameter to avoid confusion and just set spec.productInfo.vendor to 'VMware, Inc.'.
Use `==` to compare booleans. The `is` test should *only* be used when you really want to compare identities of objects! Finally, there's no need to compare a boolean to `True` or `False` explicitly; simply write `elif self._has_migs(local):`.
`return migs != 0` is equivalent ot lines 380 to 382.
I think you can simply delete this and the next line. `namespace_tx` and `namespace_rx` are already `int`s at this point.
This would also match version 10.x. Also, `4.[0-2]` will also match `421` (an unescaped dot matches anything). You probably want: ```suggestion if re.search('^([0-3]\\.|4\\.[0-2])', min(self._build_list)): ``` Or (using raw strings, to avoid double escaping): ```suggestion if re.search(R'^([0-3]\.|4\.[0-2])', min(self._build_list)): ```
https://stackoverflow.com/a/2239753 ```suggestion if consecutive_good == self.module.params[ ```
This is also not properly idempotent- you're not comparing to the existing port list, so always returning "changed: True" even if it's already in the right state.
If `ports_expand` took a rule rather than the value of its `ports` key this entire function could be replaced with ``` return [ports_expand(rule) for rule in rules] ``` Edit: of course `ports_expand` returns a list, so you need to flatten the result: ``` return [rule for expansion in ports_expand(rule) for rule in expansion] ```
I'm also making the rash assumption that the underlying API is itself idempotent (eg that it will succeed if you ask it to set a state that it's already in)- if not, this is a much bigger problem.
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
Add trailing comma for multi-line lists and dicts. ```suggestion whitelist_udp=dict(type='list', default=list()), ```
iirc we had specifically stated that .yaml was an invalid extension for galaxy file.
If I remember how this worked in 2.9 the 2nd tuple entry controls whether the file is excluded from the root only or throughout the collection. I would have thought we would want the latter so this should be ```suggestion b_ignore_files = frozenset([(b'*.pyc', False), (b'*.retry', False), (b'.git', False), ``` Then again looking at devel the pattern is `.git` so this does act the same as devel.
not for this PR, but we might want a 'configurable ignore facility' ala gitignore in the future
Plz use a context manager to have a safe resource closing ```suggestion with tarfile.open(tar_filepath, mode='w:gz') as tar_file: ```
Where's it? I cannot see it.
Please add `no_log=True`
Remove spaces before operator `=`
This can be simplified as `if resp.json()`
use `fetch_url` instead of `requests.get`
Remove spaces before operator `=`
This class isn't really providing any value. Usual practice is to create the client in main and then call a describe_task_definitions method.
Is there a case to be made for `task_definition` being optional, and if not present, returning task definitions for all tasks. Furthermore, I think I'd consider extending this module to become ecs_task_facts, and return the task data along with the task definition and then describing one or more tasks as options.
Thanks for the contribution! Since new AWS modules are required to just use boto3, you can remove this. Your exception handling can also be updated to be for boto3. Each boto3 call should be in a try/except. There's some helpful info here: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
host, username, password, timeout and vdom is already in fortios.py in module_utils
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
Why change the old format at all? That works on all relevant pip versions and also allows multiple versions joined by comma.
It's probably because of how distutils' predicate parser work, that's why we need to have a good distribution requirement representation.
This could also move to a class after all.
FTR It's incompatible with outdated versions of pip
You can just `return` without `else`.
```suggestion def validate_wwn(module): ```
```suggestion module.fail_json(msg='wwn is required for adding initiator.') ```
Nice to have return values here for better UI/UX
```suggestion msg = "" ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
As far as I understand this is only necessary to support stuff like `djang>1.11.0,<1.12.0,bottle>0.10,<0.20,!=0.11`. Why should we support this? Using a list is to me the obviously better API and support this structure adds a lot of (to me unnecessary) complexity.
Cross-compability, backwards compatibility, command line compatibility, ease of discovery. * Other packaging modules support comma separated package entries. * The pip module itself supports comma separated package entries * pip supports single string entries as valid packages * comma separated list entries are the natural way to write lists on the commandline. * error messages if people were to violate these rules (for instance: ```ansible localhost -m pip -a 'names=django>=1.11.0,<1.12.0'``` wonn't point to the actual solution unless we implement this sort of detection for creating the error message... in which case we might as well do the right thing.
Can you give an example for the error message coming from this? As stated above I would rather remove support for construtcs, which can raise exceptions here.
Here you can simply write: ``` if name_parts: ``` Python considers empty containers to be False-y.
Whenever you're doing more than simle parsing (simple parsing is usually, one command, like ```variable.split(",")```) you should give some examples of what the code is expecting as input and what it will give as output.
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
This is new lookup so no need to add `version_added`
Might want to check `rc` status before return output.
Sorry, my bad. I didn't see the implementation of `_run`.
```suggestion version_added: "2.8" ```
We try to avoid the requests library as it has many issues across older versions and even major incompatibilities across it's own versions, look at using the ansible open_url/fetch_url functions instead.
Full sentences + full stops Capitals for acronyms `The ManageIQ environment URL.`
we should capture possible import exception and explain that this lookup requires the credstash python library when it fails
this should be in the run method, otherwise ansible itself will fail to run
I mentioned this recently in an unrelated PR, mentioning here as well so that everyone is on the same page. Rationale for import location is in the "New Files" section of https://github.com/ansible/proposals/issues/50 .
I don't know the `purestorage.FlashArray` API behind the `array` type, but was curious if there a potential error condition or unhandled exception that could occur here in the event the attempt to `set_hgroup` fails? (same question for various `set_hgroup`, `connect_hgroup`, and `set_hgroup` calls in this patch).
Move this to line 175
```suggestion module.fail_json(msg='volume group {0} modify failed.'.format(vg_name)) ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
```suggestion module.exit_json(msg=msg, changed=changed) ```
`default=True` (as it's a bool, not a string)
`default=True` (as it's a bool, not a string)
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
permissions aside, we can tell user if organization exists and description matches and if it would be updated/deleted.
you just described check mode in general
I see did some changes of single quotes to double quotes but you left all double quotes are the were. You should change all other cases than named above to single quotes (e.g. keys in the dict vars - `my_dict['my_key']`).
That all sounds correct.
This should be: ```python """ Creates or extend a volume group. """ ```
Capital letter at the beginning and period at the end of the sentence.
This should be: ```python msg = ( "Physical volume %s is already used by volume group %s." % (pv, lspv_list[pv])) ```
Datacenter parameter is used in [`get_vm`](https://github.com/ansible/ansible/blob/a62f0a2fdafc283203ff62a2a2de3c83916cdee1/lib/ansible/module_utils/vmware.py#L917) API, so I would say this is a required parameter.
You can removed `required: false` lines as that's the default
```suggestion - Destination datacenter for the register/unregister operation. ```
recurse (boolean): Not required, default (false)
Remove this line.
No need to wait twice - the below lines do the same "wait" while respecting max wait time.
may be blind, but think this will never get fired if v is empty. you create an empty list, which will be skipped in the for loop.
If you are removing the last user, users_to_add == ['None'], which is truthy so it fails on line 280. Same problem with remove the group "all".
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
You can add required=True here too and remove the check below.
Leave the trailing comma. This is explicitly allowed by python in order to make line-modifications (like moving the order of lines, or adding lines) without having to update unrelated lines.
`findGroup` and `findProject` are repeated in a few places, worth moving out into `module_utils`? There's a `gitlab` library out there already that won't be needed anymore, you could use that for generic stuff.
So removed `required=False` and add `type='str' instead. Do this for the others as well.
use the `missing_required_lib` function from `ansible.module_utils.basic`
Use `missing_required_lib` from `ansible.module_utils.basic`
or maybe you just don't accept a 'list of terms' but only named parameters, specially cause you only take 'the first term' in your code below vs looping over them.
description is a list, you can do list items, no need for \ continuations, im not even sure they'll display correctly
aws_ip_ranges -> aws_service_ip_ranges
Probably need to use to_native() (from ansible.modoule_utils._text) to make sure that body is a native string type on both python2 and python3.
Since this is setting data, you also want to use an error handler like this: ``` python from ansible.module_utils._text import to_text [...] for resource in json.loads(to_text(response.read(), errors='surrogate_or_strict'))['resources']: ``` The default error handler is replace which is good for things displayed to the user but not good for preserving data.
I prefer `if not module.check_mode and change_string:`.
It could be better to rename `src_intf` and `dst_intf` module parameters reusing names of the API (`srcintf` and `dstintf` respectively). The same for `*addr` parameters below.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
Use `elif` instead of `if`.
This statement seems useless.
You can remove `required=False` as that's the default.
You don't need to state default=None as this is the default value.
You don't need to state `default=None` as this is the default value.
Please put this on a single line. Lines can be 159 characters wide.
Please put this on a single line. Lines can be 159 characters wide.
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
Nitpick, you can use a list comprehension here instead of calling list on a generator expression.
Maybe rename this to substitute_crypto_req since it's replacing the one from requirements.txt with the one we autodetect rather than simply appending.
What is this supposed to achieve? Modules are cached on import, they'll be picked up from that cache regardless of the pointers being listed in `sys.modules`.
Can you add: ``` type: bool default: no ```
Can you add: ``` type: path ```
That's why I would also say `yes`. If someone thinks this is too much data, that person can simply turn it off with the option.
There are only two docker modules which do that: docker_swarm_facts and docker_node_facts. And there it's only for lists of objects returned. This is very different to for example the output of docker_node_facts, and all other _facts modules. So I don't think this is a good reason why the default should be `no`. @morph027 since we can't make up our minds, just pick whatever *you* prefer.
Please remove the list. `default` specifies one value, not a list. A list is only needed for `choices`.
Suggestion: ``The name of the node to be renamed. If I(name) already exists, no action will be performed.`
Oh, ignore this
Not sure what you've done in other modules, though allowing this to take `type=list` maybe nicer
Why are username and password define here, though should be in the docs_fragment.
I would prefer to say ânameâ. So each resource has a name, independently of the ZAPI internals.
This method will retrieve only inventory of the last system that Redfish API returned in `_find_sytems_resource`.
Not catching non-20x responses.
Previous two lines are useless, since they can be easily merged into next loop by doing for c in data["Members"]: uri = self.root_uri + c["@odata.id"]
Not catching non-200 responses.
Not catching non-200 responses.
Various modules allow to specify the name of the executable in order to use a binary from a non-standard location (i.e. a binary not located in the PATH). Look at e.g. the isoextract on how to do this.
No need to split the line.
What if the flatpak name contained the string 'error' ? Seems a recipe for disaster.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
This could move even more down. After listing apps.
```suggestion - The type of the port that should be created ```
Please remove the shade dependency, it is no longer required.
I'd change this to keypair if it can be a name too.
```suggestion module.fail_json(msg=to_native(e.details)) ```
You can change this to `from botocore.exceptions import BotoCoreError, ClientError` since those are the two that need handling.
Please add spaces around the equal sign.
I used to do a lot of Perl before as well. You can take that as a good opportunity to get into the Python programming. I think it would be worth using the Python module instead of calling the shell command.
Please add spaces around the equal sign.
Please add spaces around the equal sign.
Please add spaces around the equal sign.
If it is not required, you don't have to state it as it's the default.
The list of option could be ordered alphabetically.
The `RepoIDs` is not the module option and therefore it should not be decorated in `C()`.
This is indented only by one character. Please indent it by two chars like elsewhere.
The default value is "None", so this is not needed.
... and then the call to instantiate AnsibleModule can look like this: ``` python self.module = AnsibleModule(argument_spec=merged_arg_spec, required_if=merged_required_if, **kwargs) ```
Upon further reflection, I think these three lines along with `check_mutually_exclusive` are erroneous for subspecs. We don't currently have a way to specify `required_if/one_of/together` or `mutually_exclusive` for subspecs, so in every case *but* the networking "aggregate" thing, this is severely broken (as you'd be making nonsensical checks in most cases)
In general argument_specs should be returned to the caller rather than subclassing AnsibleModule just to add it. AnsibleModule's behaviour could change in the future and subclassing makes it more likely that things would break than if you are simply passing an arg_spec to the module which it then uses to instantiate an AnsibleModule.
May be true but this is general speaking. What behavior specific changes would you expect? Can we possibly test against those? I don't think it is meaningful to duplicate code in n modules when using OOP style.
Please add our boilerplate to the top of this file. One of those pieces of boilerplate makes all classes defined in the file new-style classes. Without it, a class definition which doesn't inherit from object is an old-style class. ``` from __future__ import (absolute_import, division, print_function) __metaclass__ = type ```
You can remove this `module.exit_json` since the one on line 219 can be used.
boto3_conn now handles region problems, no need to do it in the module
ec2_argument_spec is no longer needed after moving to AnsibleAWSModule
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
Move to new style module imports
reading listdir output, they are unicode objects, so these should be `u' '`
also they can be made into a single tuple: `if not spath.startswith((u'.',u'~')): `
this is redundant as if `(not ext or ext in C.YAML_FILENAME_EXTENSIONS)` if True means it is not a blacklisted extension, if false .. no need to check blacklisted.
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
Please remove this. /tmp might not be writable or available.
You should follow standard [Ansible AWS Exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#exception-handling-for-boto3-and-botocore)
`snake_dict_to_camel_dict` already exists in module_utils.ec2, it has recently been updated to allow a second parameter `capitalize_first=True` (because someone made the default dromedaryCase early on)
`camel_dict_to_snake_dict` already exists
use `trail['LogFileValidationEnabled'] = ct_params['EnableLogFileValidation']`
Isn't duplicate this loop in here? I also think we could simplify it here starting after the first line ```python for line in out.splitlines()[1:] ```
We don't need it. It could be simplified using: ```python keys = out.splitlines()[0].lower().split() ```
keys in lowercase
This will throw an exception every time when a server is down. When glusterfsd is down the output looks like this: Brick 10.70.43.200:/mnt/engine Status: Transport endpoint is not connected Number of entries: - And you'll be trying to do int('-') which will throw ValueError. And the module throws error: fatal: [10.70.42.25]: FAILED! => {"changed": false, "msg": "Invalid heal status option."} in the function main.
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
`run_luks_remove()` does raise `ValueError`.
There's another `try/except` missing here.
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
`"items" in result` will do same.
I think we should add an `allow_overwrite` or similar param.
```suggestion elif date_string.match(self.when): ```
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
It would be neat if `randomize_list` also accepted a similar `seed` arg for repeatable (pseudo-random) ordering.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
I would only add the second example. They differ only in a syntax detail which is not that important.
```suggestion - name: Create new databases with names 'foo' and 'bar' ```
Task seems irrelevant to me.
```suggestion query=dict(type='list', elements='str'), ```
There is a default value for `executable` module parameter: then `get_bin_path` will never be called.
So you can remove the following lines (and from docs) ``` # this argument is deprecated in favor of setting match: none # it will be removed in a future version force=dict(default=False, type='bool'), ```
Please remove this line.
Please remove this line.
Please remove this line.
Please remove this line.
It would be useful to tell the user which `key` is invalid.
like diff = load_config(self._module, config_xml, [])
You don't need this function
No need to set `have`, `want` explicitly as it is always be empty dict if not resource is given/present.
This isn't necessary as facts will always be empty if running-config has no lldp config.
```suggestion - The value C(auto) selects a format based on the key. The value C(auto_ignore) does the same, ```
Maybe add an empty line above this one and give it a name, it seems like the `assert` task is just a parameter of the `openssl_certificate_info` one.
...The remote host **MUST** support...
Ansible 2.7 dropped support for Py2.6
Presumably you want `It *will* always use`, or something to the effect
vnc_port can be of type `int` so `type='int'`
```suggestion type: str required: True ```
I think it's better to do: ``` if result.get('failed') is True: ``` Just so that it is clear that this is the only acceptable value where it should in fact fail.
The `failed=False` is assumed, so I wouldn't add it by default. The only reason when this has to be add explicitly is when you return a non-zero return code (rc-value) and don't want it to fail.
```suggestion type: str required: True ```
Can we update the `description` text to be a little more explicit that it is the controlling host (the machine running Ansible) and not the target node that must have an established Conjur identity for the lookup plugin to work? Right now it's a bit confusing because the `requirements` is clear about that but the description just says `...the server's Conjur identity` without saying what 'the server' is in this context.
requests should be removed completely in favor of utilizing `ansible.module_utils.urls`
@jvanderhoof or @ryanprior, could you add below here? ``` ANSIBLE_METADATA = {'metadata_version': '1.1', 'status': ['preview'], 'supported_by': 'community'} ```
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like {0}
```suggestion if not os.path.exists(to_bytes(ldir, errors='surrogate_or_strict')): ```
shouldn't this be '/proc/1/root/.' ? also it requires root to establish chroot status, if running as normal user you are 'always' in chroot. looking at adding this as a 'fact' that the module can import, but that needs to be more generic (this one is linux specific) and work w/o root if possible
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
IMHO this will always return changed as False. `Changed` should be change according to action module performs.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
this should really happen in the connection
that is why we deprecate, give them a message for 4 versions and then remove (then it will break, but they were warned)
We aren't guaranteed that the stderr coming back from a connection plugin is any particular type- in this case, it's coming back from a test as a bool. Recommend type-checking and supplying a single-element repr list if it's not a type that supports splitlines()
Sorry, that was a bit "dense". :) The test that's failing is because the stderr object that comes back is not guaranteed to be something that has splitlines() defined (in this test, for whatever reason, it comes back as a bool). It isn't for stdout either, but all the connection plugins have been normalized to fix that (otherwise this would've blown up before on stdout). In Python it's actually cheaper to just call splitlines() and catch the exception if it's not there- I'd suggest setting the stderr_lines value to `[ str(stderr) ]` in that case.
My next question was going to be if the random boot ID is widely available. I guess I'll have to do some research to see when it was added. I created a WIP PR (#45656) exploring what it would look like to add platform and dist to the plugin. I'm not terribly happy with it, but it's a start (and it accounts for Alpine, which is particularly annoying since it lacks both `who` and `uptime` for no good reason (IMO)). That PR also changes to using the random boot ID by default rather than `who -b`. That has the nice side effect of being able to remove the `uptime -s` command for systems that lack a RTC, but at the cost of all the added complexity of platfrom and dist checking.
Missing full stops at the end of descriptions
You can avoid the need to import boto3 by just importing HAS_BOTO3 from module_utils.ec2
You can actually skip all the expanduesr business by using `type='path'` instead, then Ansible will parse out a fully qualified path automatically.
There are a lot on non PEP8 assignations here. Basically, in a dictionary or method call, there shouldn't be a space around the `=` operator. For assignments, there should be a space around the `=` call. So line 171 here is wrong, lines 168 and 172 are right
everything below here should be in a create_api_gateway_deployment function. That function should only be called if state is present. Might be worth raising a NotImplementedError if state is absent (or just failing with a similar message)
Please use `has` in the beginning. Also, I feel like this should be a `@property`.
Apparently, it will not work well under Python 2.6.9. It seems to be requiring you to call `Requirement.parse()` to construct an instance of this class. So we'll need to shuffle a couple of things around to make it work.
1. `@property`. 2. It's not an installation command, it's a version spec. 3. You don't need it, as it's stringified automatically during string interpolation, under 3.6.5: ```python In [3]: from pkg_resources import Requirement In [5]: rqc = Requirement('cherrypy') In [11]: '%s ' % rqc Out[11]: 'cherrypy ' ``` 2.6.9: ```python $ python Python 2.6.9 (unknown, Apr 10 2018, 17:32:50) [GCC 7.3.0] on linux4 Type "help", "copyright", "credits" or "license" for more information. >>> from pkg_resources import Requirement /home/wk/.pyenv/versions/2.6.9/lib/python2.6/site-packages/pkg_resources.py:17: DeprecationWarning: the sets module is deprecated from sets import ImmutableSet >>> rqc = Requirement('cherrypy') Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> rqc = Requirement.parse('cherrypy') >>> '%s ' % rqc 'cherrypy ' >>> ```
please note that behavior for non-caught exceptions is to return `None`, so please add another `return False` in the end and maybe replace this one with `pass` or a docstrinig with the explanation.
And, of course, it accepts `names`, not one name.
I am a bit surprised, since "state" is describing action. That sound a bit weird to me to mix 2 differents concepts in one single argument.
I guess this should be updated somehow.
Is there any reason why this method accepts `level` and `md_device` as argument? IMHO, it would be natural to use `self.level` and `self.md_device` instead.
I would not as .format breaks in older versions and we are trying to still keep this kind of module working on older machines
oh I see, it makes sense then.
Hm, good point. I'm not sure. Maybe making exceptions more specific will be a pr for the future since it's used elsewhere in the module anyway.
@alexlo03 only inadvertently, I somehow switched from thinking about boto to boto3 exceptions. The same guidelines have boto exception handling - not sure if `boto.exceptions.BotoServerError` will suffice for timeouts or not. http://boto.cloudhackers.com/en/latest/ref/boto.html#module-boto.exception Given that we use `ClientError` with boto3, chances are `BotoClientError` will work with boto
Instead of Exception you could use boto.exception.EC2ResponseError
The parenthesis around `group, groups` aren't needed.
Once we have a client, I don't think we need to handle this exception again.
actually .. uptime is a bad check then, since you get a race condition in the case of 'chained reboots' not something that will happen often, but you can get to the point in which the previous uptime < current uptime even though you rebooted. You should check the uptime vs the time since you started the reboot.
I'm wondering if we should just switch to using this command rather than `who -b`, then `uptime-s`, then `cat ...`. Since this is Linux specific, it doesn't work on FreeBSD/Darwin/Solaris, so we would have to implement a lookup dict for boot time commands as well.
The `uptime -s` (and `who -b`) command return a string that is the time the last system was booted, different than what `uptime` is normally used for, which is reporting _total_ system up time. The plugin doesn't do anything more than look for the output of this string to change. If it has not changed, it assumes the system has not been rebooted. Since it is not doing `timedelta` comparison on the uptime output, I do not believe we will hit the scenario you describe.
My next question was going to be if the random boot ID is widely available. I guess I'll have to do some research to see when it was added. I created a WIP PR (#45656) exploring what it would look like to add platform and dist to the plugin. I'm not terribly happy with it, but it's a start (and it accounts for Alpine, which is particularly annoying since it lacks both `who` and `uptime` for no good reason (IMO)). That PR also changes to using the random boot ID by default rather than `who -b`. That has the nice side effect of being able to remove the `uptime -s` command for systems that lack a RTC, but at the cost of all the added complexity of platfrom and dist checking.
I would aggregate both errors here, both 'uptime' and 'cat /proc..'
The docs say this should be `servers`, I'm ok with either but it should be consistent.
real sample value
This behaviour is really not Ansible like, it seems to indicate if a create or "update" will report a change which is ok but the trouble is that we aren't checking if an update is actually required. So a check mode run will always report a change if the database exists. We should be putting a check above this to verify that if the database exists, then we check the details like `charset`, `collation` to see if they match our parameters. If they do then no update is required, if they don't then we would report a change. This module makes things a bit difficult as I'm not sure you can change the collation and charset after it has been created so we would need to error out or display a warning saying we couldn't update it.
This should not run in check mode and should we actually be doing this. Deleting a database because a change needs to occur seems to be pretty extreme and would have thought you would want a flag to set whether to do so like the container instances module.
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
`check_rc` is false by default, no need to pass.
Please replace with `type: false`
`required: false` is default so you can remove this.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
and please add space after `)`
please use here `self.param('version')`
Can you move this logic to `__get_storage_domain_and_all_template_disks` and just call: ``` return otypes.Vm( ... disk_attachments=self.__get_storage_domain_and_all_template_disks() ... ) ```
I think it's `disk.disk.id`
Do not use print statement. All module output is supposed to be returned as JSON.
I think this would be 2.7.
```suggestion version_added: "2.8" ```
This is new lookup so no need to add `version_added`
in py3 this is dbm, so try/except
this should be moved into the run method, as we only want this to error on running, not on loading, which will always happen if this is included in ansible. or in the hasivault class init, which gets called from run.
this is not needed as the 'super' already would trigger this from the base class, this is actually dead code and should be removed
Note that fail/exit_json should be handling bytes or text; making them the proper string type for that python version before passing them in to the stdlib's json.dumps().
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
You want to swap these conditionals, so that check mode can actually report anything. `load_config()` should be the only thing gated by `if not module.check_mode`, that way the result is correct
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
Could you add a RETURN block? You can find an example [here](https://github.com/ansible/ansible/blob/42e63d429c63e078e406d95edebd8f86cd44cfbd/lib/ansible/modules/cloud/google/gce_mig.py#L180)
@erjohnso I'm not familiar with the labels API, but if what @ryansb is asking for is true, there are some [helper functions in gce_tag](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/google/gce_tag.py#L133) that can handle the union, intersection, what's different, etc.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
I think this code should just be: ``` dummy, dummy, boto_params = get_aws_connection_info(module, boto3=True) profile = boto_params.get('profile_name') s = session.Session(profile_name=profile)(**boto_params) credentials = s.get_credentials() return credentials.access_key, credentials.secret_key, credentials.token ```
You could also just return `credentials` rather than the three attributes
you need to do `get_credentials` even if `profile` is not set (IAM instance profiles mean that neither environment variables, module parameters nor profile contain the keys)
What about the session token? (That this stuff is hard to do is why `connect_to_aws` was abstracted so early on!)
I don't really get this, why not just do. ```suggestion auth_str = "Signature" ```
```suggestion file_name, file_exts = os.path.splitext(str(url.rsplit('/', 1)[1])) # Preserving double filename extensions like .tar.gz _, double_ext = os.path.splitext(file_name) if double_ext: file_exts = double_ext + file_exts: ```
This check doesn't work as-is and raises issues when running the following playbook two times in a row: ``` --- - hosts: localhost tasks: - openssl_privatekey: path: /tmp/private.key - openssl_csr: path: /tmp/csr.csr privatekey_path: /tmp/private.key commonName: www.ansible.com ``` This is due to the fact thatthe current code relies on `expected` being an array when it could be actually None, hence raising: ``` TypeError: 'NoneType' object is not iterable ``` Here is an alternative implentation that did what was expected, feel free to modify adapt/modify/get ideas from it: ``` usages_ext = [str(ext) for ext in extensions if ext.get_short_name() == extName] if (not usages_ext and expected) or (usages_ext and not expected): return False elif not usages_ext and not expected: return True else: current = [usage.strip() for usage in usages_ext[0].split(',')] expected = [long[usage] for usage in expected] return current == expected ```
Read operation: Ideally should be in a try/catch block, in case file does not exist, permission issue, ...
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
Read operation: ditto
No quotes for None, makes it unclear if it's python `None`/yaml `null` or a string.
```suggestion vmware_host_snmp: ```
```suggestion to iterate use a C(with_) directive. ```
Please add the kwarg `exception=traceback.format_exc()` to this failure.
I think this needs to move out one indentation level to match `Field`
Default value mentioned but not added in argspec.
Default value mentioned but not added in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value should either be removed or added in argspec.
I'm not sure the `if seconds` makes sense here since we'll never get to this point if `seconds` is defined.
`0o600` is more readable than `384`.
The convention in other connection plugins seems to be to raise an `AnsibleError` instead of `IOError`.
the error should go to stderr, since sys.exit does this by default (and still returns rc=1) just use that.
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This needs to be bumped to 2.4 as time marched on a little too fast for us.
could add requirements to the docs
As fair I as know, this is used only for block storages? Can you maybe add a note here? Someone can think that he obtain info about other storages as well..
Yeah - I get the idea of "take a config and use it" but I think that's a touchy enough project that I'd rather have users transfer stuff either through facts or manually, since I can see a lot of weird edge cases being a problem with a "duplicate" command.
Are these the only two valid options? If do please add as `choices:` and add as choices to the arg spec. Of write `.. returned key, such as ssh or pen.`
@bcoca yes, it would - but it's not worth fixing that underlying issue, since we don't really need a link there at all
I normally split this sort of statement onto multiple lines. Something similar to... ``` description: - The boto profile to use. - This plugin supports boto3-style... - See U(... ```
#31024 pending instead of putting the env vars in description use ``` env: - name: EC2_ACCESS_KEY ``` and config will automatically read them from top to bottom from least to highest precedence, you might also want to add 'ini' entries so this can be configured in ansible.cfg ``` ini: - section: inventory_ec2 key: access_key ``` then you just need to check `self._options['aws_access_key_id']` and all will have been 'resolved for you' I still need to do 2 things, a) create facility to allow 'keys from inventory source file' to override the above AND a callback/fallback to external config ... for when plugins already have a std config outside ansible i.e boto profiles
Ah, sorry. I mean `split_tags` and `split_separator`.
On IRC, @bcoca mentioned that this should be doable with `construct`. It is currently not possible, though, but it is better if this can be solved in a plugin-independent way in the future, than now having plugins do it differently. @ximon18 do you mind removing this? Or is this a feature you absolutely need? With `construct`, you can do essentially the same, but not for arbitrary key-value pairs, but only for keys you know about in the inventory config. If that's ok, removing this probably speeds up getting this merged :)
The method does nothing, should not this method be removed ? * [X] Done
Same as above, can be done with sub options
The Shippable CI failure is due to: ``` 2016-12-19 16:09:41 Run command: python2.4 -m compileall -fq ./lib/ansible/modules/infrastructure/stacki/stacki_host.py 2016-12-19 16:09:41 Compiling ./lib/ansible/modules/infrastructure/stacki/stacki_host.py ... 2016-12-19 16:09:41 File "./lib/ansible/modules/infrastructure/stacki/stacki_host.py", line 174 2016-12-19 16:09:41 rc = stack_r.status_code if stack_r.status_code != 200 else stack_r.status_code 2016-12-19 16:09:41 ^ 2016-12-19 16:09:41 SyntaxError: invalid syntax ``` This may also apply to line 210
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
I'm assuming the output in `result['msg']` is fairly descriptive of the specific type of error so that the user could tell what went wrong and how to fix it.
Use module.fail_json_aws(e), which will handle calling ansible.module_utils._text.to_native() on e for you.
Unnecessary line break
You can make use of some of the helpers in AnsibleAWSModule ```suggestion connection = module.client('cloudwatch') ``` This then moots the pieces below.
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
This logic seems ignore the use case of removing all tags.
I would also add the deprecation warning here in addition to the failure.
You're correct. I misread that this `if` statement is indented. Looks good!
I wonder if ansible itself has something for this in its `authorized_keys` module.
It might be better to use a similar regex that awx itself uses: https://github.com/ansible/awx/blob/devel/awx/main/validators.py#L51 Maybe just validate the format of the first line? ```python if re.search(r'^(?P<dashes>-{4,}) *BEGIN (?P<type>[A-Z ]+?) *(?P=dashes)', ssh_key_data): ```
My only feedback is that this is a _bit_ repetitive (would probably be better as a loop over a list of these keys) though I don't think I'd let it hold up a merge.
@jmighion would be great if you can update ios_config as well. Thanks!
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
You can remove `, required=False`
This `else` branch is unecessary cruft, remove it.
Sure, warnings are an option. But if it does work as non-root, I wouldn't add the warning.
Let boto3_conn handle region failures - region can be picked up in a number of ways that mean that the `region` variable doesn't get set but the connection is fine.
create_vault returns a dict with `location` and `ResponseMetadata`. You'll probably need to call describe_vault to return the expected parameters (and please use camel_dict_to_snake_dict, and don't forget to also call list_tags_for_vault, convert the tags using boto3_tag_list_to_ansible_dict and then add those to the results too) Edit: no need to call boto3_tag_list_to_ansible_dict as tags are actually in the right format for once. This service must be unique!
Sure, but I don't believe it ever happens (and if it does ever happen, use `.get` to return an empty list)
You haven't answered my question :). It just seems unlikely that you'd get a response object with a list of vault objects that don't happen to havethe `VaultName` key, without some other exception being thrown.
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
What is this option needed for? After all, these are secrets you're dealing with, and if the user wants to print them she can use the `debug` module.
This syntax is not supported in python2.6. You will need to index your format like {0}
```suggestion - This lookup does not understand 'globing' - use the fileglob lookup instead. ```
Indeed :) I totally missed that...
```suggestion version_added: "2.10" ```
Line is too long.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
This can be as `elif`.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
This could be `elif`.
I don't think you need `new` anywhere.
`data[k]` is the same as `v`: ```suggestion items[self.key_map[k]] = self.sanitize_keys(v) ```
Instead of `list`, use `Sequence`. Similarly, replace `dict` above by `Mapping`. (You'll need `from ansible.module_utils.common._collections_compat import Mapping, Sequence` to be able to do that.)
Why not use a list comprehension here? It's probably more efficient: `return [self.sanitize_keys(i) for i in data]`
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
```suggestion - true, Run Puppet agent with C(--noop) switch set. ```
```suggestion - false, Run Puppet agent with C(--no-noop) switch set. ```
If we have an explicit map we should be using snake_case for this, e.g. `system_partition`, `microsoft_reserved`, and so on.
I would add a note saying this does not relate to the partitions file system formatting.
Would add a note saying this does not deal with disk initialization and file system formatting.
This isn't valid yaml ` : `
```suggestion - When the webhook does exists and C(state=absent), the webhook will be deleted. ```
Since each of your attributes have only one attributes, what's the point of making a list ? Usage of a simple dictionary should be more easier to understand. ```yaml vars: ACCESS_KEY_ID: abc123 SECRET_ACCESS_KEY: 321cba ```
Why capitalized? hookHelper or hook_helper
As long as the input and ouput of the module are in snail_case, I don't see any issue.
data is too generic, and template_json was the first thing that came to mind. I'm not married to it though.
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
Not really sure what the desired behavior for this bit is. If I run a task with ``` launch_permissions: group_names: ['all'] user_ids: ['123456789012'] ``` and a subsequent task removes the group_name 'all': ``` launch_permissions: group_names: [] ``` should that also remove the user_ids? That is what happens now.
This `.close()` isn't needed, the context manager closes the file automatically.
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
```suggestion self._module.fail_json(msg=("An error occurred trying to get the ADOM Info. Error: " + to_text(resp_obj))) ```
```suggestion + to_text(err))) ```
hi Luke, I see from the code, you query the lock info and try to unlock the adoms upon logging out. however, I don't see any places where lock_adom() is called to lock a domain. if we don't explicitly lock the domain in our plugin, is it required to unlock it every time when the plugin is logging out? + @frankshen01 thanks, Link
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
Missing new line
We should use `display.deprecated` here, and if we are doing so, we also need to indicate in which version they will be deprecated. We have a +4 version requirement on deprecations. So if this goes into 2.6, they could be removed in 2.10.
Would it maybe be better to only check the beginning of the query? Assume that the query is `SELECT * FROM USER_UPDATES`; in that case, because `INSERT` appears in `q.upper()` and `cursor.rowcount > 0` (assuming the table isn't empty), the module will say something was changed.
OK, not a blocker anyway.
This is wrong. It is too easy. Check-mode in this case does not bring anything to the table. The user might have made mistakes and it has not been tested as it would be for a real run.
`current_version` could be mentioned in the error message.
Why go through all this trouble instead of ``` start = get_timestamp() responses = run_commands(module, commands) end = get_timestamp() timestamps = (start, end) ```
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
`display` won't work in module code, hence this line should be removed
`wait_for=dict(type='list'),` (remove waitfor)
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
Not required with AnsibleAWSModule
Should be AnsibleAWSModule now you're using fail_json_aws
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
All the boto3 client methods in this module should handle BotoCoreError. There are a number of places that need this added.
Please use named parameters with parameter lists this long, and without abbreviations which makes is much harder to read.
```suggestion locally, you can call the module with the image name, then check whether the result list is empty (image does not ```
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
`DigitalOcean OAuth token. Can be specified in C(DO_API_KEY) or C(DO_API_TOKEN) environment variables`
```suggestion - Only used for images that contain the Windows Server operating system. ```
Looks like `monitoring:` has been added.
This could be either a repeat of the `count` input param, in which case it is redundant (like `dest`, below), or it is set to the same value as `packets_tx`, in which case it is completely redundant. In either case, I don't see any reason for this to be included in `RETURN` nor `results`.
`dest` is never added to `results`, but that's fine because the returning a required argument back to the user is pointless. Remove it from `RETURN`.
These values should all be type `int`
Should be type `int`
Should be type `int`
Create address service object on PanOS devices This may need updating on existing modules
Capital letters & full stops please
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
`required: false` lines can be removed
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
Another variable with value using `special characters outside of AâZ, aâz, 0â9` and enclosed with quotes might be added there.
I don't think the `lambda` is necessary here. You should be able to set [`return_value`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.return_value) instead.
One odd thing that has come up with the os-release parsing code in module_utils/facts/system/distribution.py is the quoting of some of the right hand side of lines. I'll track down the bug momentarily, but at least one distro did odd things about what was/wasn't quoted (either VERSION wasnt quoted or ID was quoted?). The lsb/os-release spec is kind of vague on that, and different '/bin/lsb_release' tools seemed to do different things. This isn't something that has to be addressed since I don't think there was a clear correct answer, but just mentioning it for context.
I think this should be using mock.patch? iirc, this can leave ansible.module_utils.facts.system.pkg_mgr monkeypatched to be a mock for the rest of the tests.
Not sure what "This one go down into the class tree" means. I know it's from the original method, but see if you can improve this language so it's more clear.
```suggestion - This module creates clones for libvirt. ```
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion required: false type: str ```
```suggestion - Will also define the VMs hostname. ```
I think that wildcard imports are generally discouraged, because it makes it difficult to refactor and determine the origin of a function or class. For example, at first the `boto3_conn` function used in the constructor seemed undefined.
Small typo here probably: `Retreived -> Retrieved`
purge_tags doesn't need to remove all tags - you can use compare_aws_tags() (in module_utils/ec2) and then call untag_resource() with the list of tag_keys that are returned.
This module is not idempotent if you can't run it twice with the same arguments. If you have to know the distribution ID to update it, but not create it, then this is not going to work as it should. Really it should be searching for a distribution that matches the unique distribution properties (presumably the origins of the distribution)
There should be a check before https://github.com/ansible/ansible/pull/24292/files#diff-aaef1b3abde00153e8695bfdf79c5e55R1882 that HAS_BOTO3 is True.
`required: false` is the default, can be omited. Also, I would prefer to see the parameter types here.
No need to list the options as that's what `choices:` is for
For consistency, please use the `delegate_to: localhost` syntax.
~~~ - name: Ensure a network is present cs_physical_network: ~~~
`zone` is returned, but not zoneid
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
There should be period at the end of the `msg`. Check the other occurrences.
You are not returning `state` in any of the `exit_json`. You should drop the `status` as that can be determined from the `state` and the `changed` values.
Well, how do you determine which action was just run if you only return `changed`? The `state` is standard key which is expected to be return by any module. Please add it (`state=state`).
Format this like this: ``` module.fail_json( msg='Error while performing wildfly operation', details=info['msg']) ``` The same anywhere else in the code.
This is unreachable code.
I meant, `return` as `module.fail_json` will return anyways.
```python if dc is None: module.fail_json(msg="Failed to find the datacenter %s" % module.params['datacenter']) ```
``` + # VM already exists + if vm: + â¦ ``` â ``` + if vm: + # VM exists + â¦ ``` But that's a matter of taste.
You could actually make this fancier: ```python vmid = module.params.get('name') or module.params.get('uuid') module.fail_json(msg="Unable to wait for tools for non-existing VM '%s'" % vmid) ```
Would be good to state this was added in Ansible 2.9.
This change seems to have snuck in.
Mode is actually `type='raw'` https://github.com/ansible/ansible/blob/f367cba1ab202ca43ee0b140e042dc00a41c144d/lib/ansible/module_utils/basic.py#L244 ```suggestion type: raw ```
Not sure this is correct (before or after patch), since the sentinel check is usually checking object identity. I would expect this to be: ``` python _sentinel = object() def results_thread_main(strategy): while True: try: result = strategy._final_q.get() if result is _sentinel: break ```
tempted to move to base class and make static
hmm, most of the things in other modules are in lower case, better to be consistent
What if the template is already registered? We shouldn't fail, but rather exit with `changed=False`
if the user hasn't provided status module.params.get('status') should be == "enabled" since it's defaulting to that in the arg spec. You should be able to just do `if state == 'present' and module.params["status"] == "enabled":`
I think some other changes to the config have landed that should certainly eliminate the need for this, in particular the `TowerModule` class.
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
facts modules can trivially support check mode (#23107)
This whole connection block can be replaced with `conn = module.client('ssm')`
You should use `AnsibleAWSModule`, it has a lot of helpers around boto3
This will be handled by the `AnsiblleAWSModule`
You can remove this `module.exit_json` since the one on line 219 can be used.
tempted to say use subdirs and read them as 'container lists', avoids much hardcoding
We get good messages for free if we use unittest.assertIsinstance(), assertEq(), etc. Need to inherit from unittest.TestCase to have access to those.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
The double backslashes are not needed here. They are actually unwanted.
Some stuff complains if the .py file is missing the final LF- can't remember if we hit that anymore or not, but not a bad idea to add it just in case.
Please, we are trying to get people do the right thing, read http://docs.ansible.com/ansible/devel/user_guide/windows_usage.html#path-formatting-for-windows All our examples should keep things simple, so make this: ```yaml - name: Copy test file win_copy: src: test01.test.ps1 dest: C:\Pester\test01.test.ps1 ```
Are you also able to add the `backup` and `err` return values and a description for those.
This seems to leave open the possibility of collision... Probably unlikely, but possible (`EOF` is common with embedded heredoc). Though i guess the user could prevent by providing anchors to the `EOF` if they wanted to match text (`^\s+EOF` or something).
There's no need to do the 'else', because everything that follows is also your 'else'. It's the continuation of your program.
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
No longer need deepcopy
```suggestion type: str default: https://intersight.com/api/v1 ```
consider using `ansible.module_utils.urls` instead of `requests` for better compatability
use `required_one_of` kwarg when creating AnsibleModule instead
```suggestion to iterate use a C(with_) directive. ```
wrap exceptions in `to_native` when stringifying them
no, host_list and advance_host_list use an 'inventory string' , which is why they dont call super version of verify_file as 'its not a file'
How will fmg handle idempotency ? Does it return 200 even if you try to add same object again ? This return code should be retuned to ansible with result['changed'] value 1 if add was done for new object, 0 if same object exists earlier on system.
Looks like this function is not used anymore
Hi @ftntcorecse Unfortunately we cannot accept the modules as-is. Until the modules are modified to clean design which is a) Move the connection handling to connection plugin. b) Modularity- Common functionality which has been duplicated in so many modules should be moved to module_utils/network/fortimanager and should not be repeated c) Idempotency should be handled d) Probably we don't need one module for each FortiManager operations unless we can not handle some corner cases of idempotency. We should have only bunch of modules which will do REST operations on ANY object. Specific use-case should go to galaxy role. Until the modules are modified to best practices listed, they can be posted to Ansible Galaxy in the meantime. Thanks, Deepak
Please remove `, no_log=True` from the username line
Missing new line
`A list of virtual machine names starting with the given regex`
A sample of output would be helpful.
Can be removed, indeed, check other newer modules :)
I learned yesterday that nowadays we can simply do `import json` as we no longer support Python 2.4
@phemmer , We've discussed this in the weekly Ansible VMware meeting. In my opinion, having a dict is useful, IF the key is useful: * The reason to have facts is to use them in a task later on * With a list, to find the proper disk, it is harder to find the item you want to match on ( `{{ (disks | selectattr('label', 'search', 'Hard disk 1') | list | first) }}` for instance) * With a dict, if the key is useful, it doesn't require that. If you want to match on another criteria, the loop is still a possibility. Proposal is to have the label as the dict key as it is what is visible in vCenter and is orderable, does that make sense to you? Any other criteria you might find easier? (disk.key is another possibility, but less 'visible' in vCenter)
Just noting that this RETURN is incomplete
If you pipe this through to the URL, then this should really be "resource". In Kube "kind" is the schema, "resource" is the thing you access via a client. Kind is always a constant (uppercase), resource is always the lowercase RESTful name. I would recommend `resource: service` (if you're doing discovery) or `resource: services` (if you're hardcoding). Mapping `kind` to `resource` is something we explicitly do on the client by looking up a Kind in the discovery doc, so overlapping them can be dangerous.
Am I correct that we've still got no tie-in with the advanced 3-way merge logic currently baked into the kubectl/oc client binaries? That functionality seems so important for Ansible, and rumored to head for the API server soon but still may be a few releases out.
Really like this raw access to the kubernetes yaml, personal preference I don't want a layer of declarative config on top of a layer of declarative config so it's great to see this available.
I completely missed that, apologies
`if not check_rc` is not required. It can go in else part
This return statement is not required.
Only import what you need, rather than `*`
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
print statement can be removed
But you don't call it without this argument anywhere.
It makes no sense to have default for `worktree_dir`. Remove it.
Also, this might probably raise something like `IOError` or `OSError`, so it should also be processed with `fail_json()`.
This will fail if the target dir exists
Sure, so fix it please :)
not a blocker but `required: false` is the default and can be omitted.
version added is 2.4
set `required: false` please.
Thank you for the review. I've set `required: false`.
Should have `reqiured: true`, along with `obj_username` and `obj_password` according to the module argspec
All of these uses of `str` should be switched to `to_bytes(var, errors='surrogate_or_strict')`. `to_bytes` comes from `ansible.module_utils._text`.
Thanks for the confirmation!
You don't always have a guarantee of `other_var` being the same type. And `'some str %s'` has different types under Python 2 and Python 3. That's why it's important to explicitly use the correct literal.
Oh, and in places with variables where you concatenate that with literals, also apply this function to avoid certain edge-cases which appear sometimes when you try to merge different data types.
Yes, you can convert resulting strings. But when concatenating things it may result in unpleasant side-effects. ```python # WRONG b'some str %s' % other_var # <-- Python (esp Python 2) tries to turn `other_var` into bytes, sometimes incorrectly which may even cause exceptions in obscure cases ``` ```python # CORRECT b'some str %s' % to_bytes(other_var, errors='surrogate_or_strict') # when you convert it explicitly, it'll always succeed ``` If you don't like this `errors='surrogate_or_strict'` part, you can use curring: ```python from functools import partial ... from ansible.module_utils._text import to_bytes ... to_bytes_sos = partial(to_bytes, errors='surrogate_or_strict') # ^ # | # | # somewhere at the top of the module ... # And everywhere else in code: # | # | # v b'some str %s' % to_bytes_sos(other_var) ``` Hope this helps.
``` tenant = module.params['tenant']` ```
``` bd = module.params['bd'] ```
No point adding code to deprecate it in the future, please remove.
Doesn't seem to be used anyway...
`aci_argument_spec` is now a function and needs to be called like: `argument_spec = aci_argument_spec()`
You can import HAS_BOTO3 from ansible.module_utils.ec2
YAML check doesn't like this: `ERROR: lib/ansible/modules/cloud/amazon/ssm_parameter_store.py:0:0: E313 RETURN is not valid YAML. Line 131 column 83 (75%)` I would propose to change it to: `description: The type of parameter. Valid values include [ String, StringList, SecureString ]`
Bad copy and paste here. Don't use nacl, it's really quite confusing.
Please follow the [AWS exception guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2)
Really not convinced by `show` Might be better to have an ssm_parameter_store lookup plugin for this need.
The way this is done is going to lead to unicode errors eventually. This is probably the least messy way to handle that: ``` python msg = u"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s" % (name, type(e), to_text(e)) if errors == 'warn': display.warning(msg) elif errors == 'ignore': display.log(msg) else: raise AnsibleError(to_native(msg)) ```
I got that error using an inventory plugin, not a lookup.
INTERNAL_DEFS.get(plugin_type, ()) since Nonetype isn't iterable
I like the fact that you move the potential conversion from text to bytes lower in the call stack, to where the API actually needs a byte string.
IIRC should be just `raise` to re-raise the existing error
```suggestion - The full path to a list of block devices such as hdd, nvme or nvme. ```
```suggestion type: str choices: [ absent, present ] ```
```suggestion - Whether to enable or disable automatic pool expansion when a larger disk replaces a smaller disk. ```
Why only autoexpand and autoreplace are added as an option? I can see a value of having all or nothing and just use sets.
```suggestion - Automatically replace a bad device in pool using a spare device. ```
I think it makes sense - the user is responsible for making sure the library is available for specified Python interpreter. Similar to how user is required to install necessary prerequisites for modules, for example.
Again nitpicker - sentence sounds a bit weird. Maybe something as follows would be better? ``` Nested keys must be quoted when specified in abbreviated form (e.g. C("DesktopViewSettings:IconViewSettings:arrangeBy")), since colons are treated as part of YAML syntax itself. ```
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
s/fo/of/ + ('security' or 'distribution')
Example should reflect the basic attribute (`portgroup`) instead of the alias
Example should reflect the basic attribute (`portgroup`) instead of the alias
Yeah, i understand the backward compatibility, can you add in the description of `port_binding` that it takes precedence over the deprecated `portgroup_type` value? That way people understand the precedence.
So if both `portgroup_type` and `port_binding` are defined, it ignores `port_binding`? I think it should check for this and if they are not the same from the API perspective, it should fail with an error
Because it already checks the exclusivity of these 3 options in the module definition, this check can be minimized to `if self.vlan_id == 0:` (the other 2 will automatically be None)
Can we emit a warning/info instead of silently failing
As the `return_timestamps` is reverted, `msg_timestamps` is not needed anymore. lgtm otherwise.
`'get'` is in base_rpc already? ```suggestion ```
`result` is empty and no capability is returned. Is this expected? You might want to call `get_device_info` here to get the device capabilities.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
```python cmd = [self.nmcli_bin, 'con', 'add', 'type', 'ip-tunnel', 'mode', 'sit', 'con-name'] ```
same as above. ```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
```python cmd = [self.nmcli_bin, 'con', 'mod'] ```
You are not executing command returned by `modify_conn_disable_ipv4` so I am sure that it has no effect.
My bad. Didn't see if in later stages.
doesnt --> does not
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
Yes, you can- so long as a default is not specified, an unset value will still be `None`
@carchi8py : enable/disable UDP protocol It would be nice to have a default of 'enabled'
use `choices`, ditch inline "possible values" text
version added is 2.4
`Description` (capital letter)
not a blocker but `required: false` is the default and can be omitted.
Please remove `required: false`
I've updated `required` to `false`.
The more the AWS modules look the same, the easier they are to understand. The majority don't use classes, and those that do are less understandable as a result.
I believe ClientError only gets thrown when the connection is used (unlike boto2 which can throw the ClientError equivalent), so you can remove that one.
Yeah, not a blocker. Before merging I can add a commit to fix that one line.
Formatting nitpick. You can add this to the line above.
Tend to favour YAML data structures rather than JSON style ``` sample: - name: my_bucket creation_date: "2017-07-06T15:05:12+00:00" ```
Please add `type="str"`, and maybe list the possibilities as `choices=`.
Please add `type="str"`
type should be a 'int'
No, maybe @mscherer is talking about `copies`. Do ``` copies=dict(default=1, type='int') ``` rather than ``` copies=dict(default='1') ```
It would IMHO make more sense to move that near the other command, so we can verify both command at the same time.
`required=False` is the default, and thus not required
need to separate ClientError and ParamValidationError as the latter doesn't have an e.response object. Both exceptions should have `exception=traceback.format_exc()` (you'll need to `import traceback` at the top)
given the size of this dict, `params = dict(GroupName=name)` would be simpler!
You don't really seem to be using `params` as a useful dict at all in this method. Setting `group_name = module.params.get('name')` and then using `group_name` rather than `params['GroupName']` would make more sense
Please import only what you need, rather than `*`.
Use module.warn() instead.
This is the wrong way of doing Ansible. The user should describe the desired state, not instruct modules to perform actions. The module itself should determine what actions the specific state needs based on the current state and the desired state. That is what is needed for idempotency anyway. So rather than action=install, it should be state=present. Also, check-mode support and diff support are very important for a tool like this one IMO.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
Looking at the logic, I am confused by why we are only sending out a warning when an entry cannot be added. The correct action here is to fail.
I would add here as well some code to set the `result['failed']` according to what the module should do. ``` if action in ['started', 'restarted', 'reloaded']: result['failed'] = result['status']['current_state'] != 'running' elif action == 'stopped': result['failed'] = result['status']['current_state'] != 'stopped' ```
This line is too long. Max line length allowed in Ansible is 120 characters.
To enable the module to work with debuggers can you please rewrite this as: ``` if __name__ == '__main__': main() ```
I believe @Console32 had this as separate commands for Windows and non-Windows but it should be separate. Use the actual cmdlet name and full parameters for `Invoke-WebRequest` on PowerShell to avoid confusion.
Line is too long.
```suggestion - Accepts a list of dicts where each dictionary contains two keys, I(path) and I(key_data). ```
Same thing here - otherwise we would end up with I(....) everywhere. ```suggestion - If no blob_cors elements are included in the argument list, nothing about CORS will be changed. ```
```suggestion Set I(version=latest) to get the most recent version of a given image. ```
Examples should be in multi-line with `key: value`
```suggestion - Must end with '.vhd'. - If no name is provided, defaults to the VM name + '.vhd'. ```
this was correct before IMHO
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
I suggest to add an example of this
since we are only interested in the creationToken field, is it possible to scope the query to only return this field? I'm concerned this can generate a lot of traffic if all attributes are returned. Can be delayed.
fileSystem is not set yet, so cd_action always believes the fileSystem does not exist. I confirmed this prevents 'delete' to work correctly.
should be moved after line 205 (otherwise the error message is reporting None).
The else: is not really necessary here since there is a return just above. But it does not change the behavior.
why do we need a deep copy of self.parameters? It seems self.data is redundant.
Please restore, or the module will fail to work in v2.7+
Please restore, or the module will fail to work in v2.7+
All configuration values should not include default values, as that leads to accidental overwriting of existing configs that the end user did not expect.
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
Make this `elif`.
_tmp_args should be a local variable rather than an instance attribute. But if we do that the unittests will need changing in a more intrusive way. I think that's the right choice but I haven't looked at how to achieve that yet.
if that is an issue for the test, the test might not be correct, if this is an issue in general, it should be fixed in the code.
Still need to add the ansible_pkg-mgr fact to results if: * We selected one of yum, yum4, or dnf * And we are not delegating.
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
there is a missing condition for check mode
Thanks - I've replaced all uses of `filter` with comprehensions.
`if network['type'] != 'static' and ( 'ip' in network or 'netmask' in network):`
there is a missing condition for check mode
OK, not a blocker anyway.
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
Please replace with `type: false`
`Specify authentication algorithm.` No need to repeat what's in `choices:`
No need for quotes here.
As we no longer care about 2.4, I think this can be cleaned
BotoCoreError should be caught here as well and all other places catching ClientError https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-1 BotoCoreError does not have a .response, so using AnsibleAWSModule will cut down on exception handling logic as I suggested above.
boto3_conn() now handles NoRegionError and ClientError so you can remove that here.
This needs to be `class CloudFrontOriginAccessIdentityServiceManager(object):` to use new-style 2.7 classes.
To share code between modules, please use module_utils instead of importing other modules directly.
`type='str'` is the default so you can remove that. `default=None` and `required=False` are also defaults that can be removed.
better to move this line in else part. something like ``` if hasattr(resp, 'data_xml') or hasattr(resp, 'data_ele'): result = resp.data_xml else: result = resp.xml ```
Can we print entire error rpc. In case of error `message` alone is not very helpful.
You shouldn't need this if you have `required=True` on both options.
Did you try using `jxmlease` for dict to xml conversion? As it is already used in other modules it makes sense to reuse it. ``` from jxmlease.dictnode import XMLDictNode XMLDictNode({'unlock': {'target': {'candidate': None}}}).emit_xml() ```
Usage of `eval` is not recommended, please use `ast.literal_eval` Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/network/common/utils.py#L432-L435
Missed one.. Should just be as below unless you want to also pass module into the function. ``` if os.path.isfile(cert_chain): cert_chain = open(cert_chain, 'r').read() ```
Could probably get rid of the surplus required=False entries I seem to have missed as well
As previously discussed on https://github.com/ansible/ansible/pull/20787 I much prefer os.path.isfile That way it won't try to read a directory path.
if state is present but cert, key or chain is not passed in, then these variables won't be set at all. That is bad. Just get rid of the `if` statements.
I don't have the answer, but was hoping to prompt discussion about it and maybe get this moved along in the process.
This also needs bounds checking and (maybe) retries if the ASG isn't yet available.
This is a bit confusing since it's assigning to the same name name as comes in. I think this section could be cleared up with the use of `set`. So something along the lines of: ``` for dead_tag in set(have_tag_keyvals).difference(want_tag_keyvals): dead_tags.append(..... and so on ...) ```
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
Same - please use `len`
Same - please use `len`
```suggestion parts = to_native(date.strip()).split(':', 1) ```
```suggestion message_text = self.get_deprecation_message(msg, version=version, removed=removed, date=date, collection_name=collection_name, warn_change=warn_change) ```
```suggestion elif date_string.match(self.when): ```
Line is too long.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
Move `FOREMAN_URL` and the other variables that follow inside the `CallbackModule` class.
This docstring should be used for the `CallbackModule` class instead of the module.
there should be no need to implement these when using callback base, also you should use v2_ events as the old ones are not guaranteed to work, in some cases they get slightly different data or lack the data they had in pre 2.0 Ansible.
this is never invoked as the v2_ method that would forward to this in the callbackbase is overridden below
How about: ```suggestion from ansible.module_utils.parsing.convert_bool import boolean as to_bool try: verify = to_bool(option) except TypeError: # it wasn't a boolean value verify = option # Set to a CA bundle: finally: if verify is False: # is only set to bool if try block succeeds requests.packages.urllib3.disable_warnings() self._display.warning( u"SSL verification of %s disabled" % self.foreman_url, ) return verify ```
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
It's rarely appropriate to catch all Exceptions.
Can get rid of required=False.
Could raise botocore.exceptions.NoCredentialsError or botocore.exceptions.ProfileNotFound
Should note about `is_dir` and `is_link` here.
This note probably no longer applies, unless you'll be making a Windows version. Since this module will not work on Windows, it should be noted. (at least I think it won't? All the windows modules use powershell so Â¯\\_(ã)_/Â¯
excellent question, and one we should probably ask of someone with a legal background - I will find someone and ask, then report back on #45989
This string doesn't have to be quoted.
The list of options should be in alphabetical order.
You can add required=True here too and remove the check below.
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
This should go in a facts module instead.
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
It would be nice if the current tags were added to the response.
I am not sure if you have anything presentable in the result with `check mode` here. Here is a brief example on how `check mode` is perceived: If check_mode is set, and say a module is configuring IP address on an interface, the module would show the output of actual task performed minus the final `commit` operation that brings the task in force.
Please add `type: bool`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
If you update the argspec as I suggested you can change this to something like: `Exactly one of I(inputFile) and I(fileName) is required.`
Indentation doesn't look right here. You can have upto 160 character lines
Sam here, add a blank line before this line and make it: ```python # Copyright: (c) 2016-2017, Hewlett Packard Enterprise Development LP ```
Blank line before this one, and format like: ```python # Copyright: (c) 2016-2017, Hewlett Packard Enterprise Development LP ```
short_description shouldn't need a trailing dot, as the index does not have trailing dots.
Short description should not contain a trailing dot
No trailing dot in short_description. Keep the index clean and tidy ;-)
Thanks for that clarification. Upon reviewing the code, it wasn't obvious to me that this module is actively using both connection paths (to the k8s API and also to the Upload Proxy.) I've taken your word for it and updated my related PR.
`type: complex` Have a look at other modules with the above line for how to format this
This syntax is not supported in python2.6. You will need to index your format like {0}
This syntax is not supported in python2.6. You will need to index your format like `{0}`
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
Can you use a different example here? It's easy to confuse this with a dummy VGW ID. Maybe "main-virt-gateway" would be a better docs slug.
Just say `boto3` here, since botocore is a transitive dependency of boto3.
`descriptions:` should be sentences, eg capital letters and full stops
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
Please use our best practices for AWS exception handling https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws
For integers please: use `type='int'` remove the `isdigit` check from `check_params`
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Does `mask` require `addr`, and does `addr` require `mask`, if so you may wish to add: ``` required_together ```
specifying `type='int'` removes the need for this, so you only need to check the range.
is this ```suggestion :type required_one_of: list[list[str]] ```
Or maybe ```suggestion :type required_together: list or None ``` per https://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html#python-signatures
it's probably this? ```suggestion :type mutually_exclusive: list[str] or list[list[str]] ```
This property should probably also be `_` prefixed- the way the aliases are encoded in here right now makes it pretty useless for anything but generating that string in the error case.
Maybe just `_` prefix `warnings`on `ValidationResult` for now? This definitely doesn't seem like it'd be generally useful as-is, and we'd almost certainly have to restructure it later to create actual warning objects if we have more than one (rather than a list of dicts).
perhaps "if not region"? that keeps the standard flow from being in an "else", lets us bring the indenting back a level, etc. Otherwise this is fantastic. Thanks for pep8 and removing the stray code.
This looks more like boto3 exception handling than boto - I'm pretty sure e.message is just a string, so passing it through camel_dict_to_snake_dict seems pointless.
I can't see an import for camel_dict_to_snake_dict
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
```suggestion b_colldirs = list_collection_dirs(coll_filter=coll_filter) ```
On further thought, this actually might break something with the new stuff, since you're relying on pyyaml blindly `call`ing whatever is passed in, but the prototype logic that supports object instances only does that call if `isinstance(loader, Reader)` is true. We could probably tweak that somehow, like `callable()` instead, which might be a little more resilient/Pythonic anyway... So this is definitely fine for released code, and it's something I'll keep in mind for the new stuff.
Are you only doing this to support Python 2.6? Those keys are already unique.
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
I think this may read better: ```suggestion if missing_keys: ```
You need to use `.sort()` first and then use it in comparison, since `.sort()` returns None and will always results True in comparison. ``` >>> a = [1, 3, 2] >>> b = [1] >>> a.sort() == b.sort() True >>> a [1, 2, 3] >>> b [1] >>> a == b False ```
ah I see duplicate code...never mind
call create, so we are sure the disk is up to date with parameters provided by user.
you can use get_id_by_name, and don't have care about checking.
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
Please update formatting as per `mcp_user`
`If not specified, will fall back to the C(MCP_USER) environment variable or credentials specified in C(~/.dimensiondata).`
+1 to adding that note :)
You can delete this line.
No full stop needed on `short_description`. All other `description:` fields should be full sentences.
What will happen if `ssh-keygen` outputs something different (like not a valid file)? This will probably break.
I would add `check_rc=False` anyway, to make clearer your intention that you accept non-zero return codes.
This check always fails on my machine: `self.principals == None`, `principals == ['(none)']`
```suggestion if cert_valid_from <= self.convertToDatetime(module, self.valid_at) <= cert_valid_to: ```
I tried to use camelCase in Python for some time some years ago for the same reason, but eventually gave up (since all library calls etc. don't use it, and mixing both styles is even worse ;) ) and switched to snake_case. I was just curious what's your motivation ;)
Please remove `The only valid value is 1Minute.` That is covered by the `choices:` line
Please use [standard exception handling guidelines](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#boto3-2)
It requires `botocore>=1.13.21`
is the `any` required here - `if metrics_to_disable:` should suffice, I'd think
its new in 2.4 so it doesn't apply to older versions
As we talked about in the WG yesterday, please set the API version in the module and pass it along here.
No need for the try/except, `get_resource_group` already handles this.
This isn't really how we usually go update operations in Ansible. Is there way of checking if a change needs to occur and then making or rather than making a request and seeing if it was changed. The benefit of the former approach is that when running in check mode you can see if a change needs to happen while in this scenario you wouldn't know.
Use kwargs instead of positional args
SHould have `type: bool` and the default option
we normally add more than the 'library' error as they tend not to be as helpful as giving a user context on what you were attempting to do exactly when the error occurred.
i don't see a need for this change
yeah, there's a missing chunk of code.
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
End with period
End with period
`required: False` is the default and usually we just omit it.
This isn't technically true, the default is None so just omit this entry. Just add a new entry to description to state this, e.g. ``` count: description: - Host many messages to collect from the queue. - If not set, defaults to getting all the messages in the queue. ```
`default: All messages` still there
It seems name param removed from the return, but it should not.
use `missing_required_lib` from `ansible.module_utils.basic`
```suggestion module.fail_json(msg=to_native(e), errno=e[0], reason=to_native(e), **result) ```
Use `missing_required_lib` from `ansible.module_utils.basic`
Please rewrite as ``` if __name__ == '__main__': main() ```
Get rid of this.
Again, this should become: ```yaml type: bool ```
Please break this up in 2 distinct items. The first is an explanation what the option is, subsequent items clarify how to use it, etc.
Same here. No need to state this.
You probably want this here: ```yaml type: bool default: 'no' ```
This place in code **does not affect** cloning/initing, while operating on **existing repo**, which makes it pointless. Also, it would be architecturally wrong to do it from some random phase of module execution. We would still have to bypass it to clone/init anyway.
Yes, but it is still unrelated to the env var.
should the line start with `gitdir` or should it be in the end of line with smth prefixed? you might want to prefix the regex with `^`. On the other hand, taking into account that regexps are expensive, you could just use str.split or partition with bits of validation on top, like: ```python try: ref_prefix, separate_git_dir = data.split('gitdir: ', 1) if ref_prefix: raise ValueError('.git file has invalid git dir reference format') if not os.path.isdir(separate_git_dir): raise TypeError('%s is not a directory' % separate_git_dir) os.environ['GIT_DIR'] = separate_git_dir except (TypeError, ValueError) as err: """``.git`` file does not have a valid format for detached Git dir.""" module.fail_json( msg='Current repo does not have a valid reference to a ' 'separate Git dir or it refers to the invalid path', details=str(err), ) ```
Please dedent all the following code, so that it would be outside of `with`-block.
Also, in case of not match `gitconfig` would have `None` value, which would've broken this module in some place being executed later.
`no_log=True` is argument spec will handle this.
Rather than saying they're not allowed to be the same, treat this as a no-op (nothing needs to change)
This should be handled by the required_one_of argument to AnsibleModule
This should be handled by the mutually_exclusive argument to AnsibleModule
Most examples I know of only add their own checks if they need something more complex (for example your "netns != namespace" check). Personally I'd not block the PR for these, but you might get more push back from the 'core' team who'll also need to review.
I think `hosts` is a name that does not violate the principle of least surprise. I merely wanted to point the rest of the cfg mgmt ecosystem and possible Windows support. Let's see what @abadger thinks about it given the above.
No, it doesn't become the default until Python3.0
SHould inherit from object because of python2
I would recommend updating to inherit from object. Just because others did it or are doing it, doesn't necessarily make it a thing we wish to have. We are trying to improve and standardize on implementations, and the preference here is that we standardize on inheriting from object. A future task can be to improve modules where this was not followed.
Mispelling of "region"
Should also have trailing dot :-/
Should also have trailing dot :-/
Use `I()` around parameter names. ```suggestion - I(url) and I(host)/I(port)/I(user)/I(pass)/I(vhost) are mutually exclusive, use either or, but not both. ```
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
I would return an explicit boolean flag which informs whether the plugin is activated or not (for `state != 'absent'`).
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
Bad name again, since body of the method only sets one attribute.
Method name is deceiving, since the body of the method will only set a single attribute.
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
Jobs seems to be Dell specific, since standard does not talk about jobs at all. What standard does talk about is that some actions may be asynchronous and that in such case `Location` header value points to the `TaskMonitor` for this action. And again, constructing OData ids using concatenation is just bad.
`If an empty list C([]) is specified`
`If an empty list C([]) is specified`
databsae -> database
get_exception is deprecated in favor of native exception handling - ``` except Exception as e: module.fail_json(msg=to_native(e)) ```
Is there a way to find this out by introspecting in boto3 instead? Manually updating this is kind of a pain.
Actually, that's different case. The code above I've sent: ```python achitecture=otypes.Architecture( self.param('cpu_arch') ) if self.param('cpu_arch') else None, ``` Ensures it sent `<achitecture/>` xml element when creating/updating cluster only when user passes `cpu_arch` parameter to Ansible. The current code you've sent will sent `<achitecture/>` element also when user don't `cpu_arch` parameter.
please use here self.param('version').get('base_template')
please use here `self.param('version')`
and please add space after `)`
As far as I understand functionality of the API, when you sent: ``` PUT /api/clusters/123 <cluster id='123'> <external_network_providers/> </cluster> ``` You will detach the external network providers from the cluster, even if you didn't intent to. I think `_get_external_network_providers_entity` method should return None, in case `self.param('external_network_providers')` is None.
You cannot move this outside of the `if not callback_sent:` block, because it will send a debug log that the callback is being sent, before we know that it is. This applies to other lines as well. Just move the templating outside, and leave the debugs in the `if` block.
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
@bcoca corrected me that _execute_module() takes care of delegation so this is fine. After discussion, though, we did decide that we should set the ansible_pkg_mgr fact when we return from this action plugin so that we don't end up having to discover it every time the actin plugin is run on the same host.
When delegating, I'd think that we'd need to run the facts module for the delegated host rather than for the inventory_hostname host....
bcoca also mentioned that the facts end up being set on the host that's being processed in the task loop, not one that's being delegated_to. So we should only return the ansible_pkg_mgr fact if we are not delegating.
and if possible please: `Destination %s is not writable` (the word `is` is missing)
Please change message to `Destination %s does not exist`. (The word `does` is missing)
note, if expanded paths is large, this might be slow. It's faster to do it like this, if so: ```suggestion expanded_paths=to_native(b', '.join(b_expanded_paths), errors='surrogate_or_strict') ```
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
I am a bit scared by this. Because the module indicates it supports check-mode, but if I look at the code it seems to be doing all the stuff and only at the end appear to say there hasn't been a change. That cannot be right (it's dangerous!).
This is probably more a bigger-picture usability thing with inventory plugins, but it seems like making the plugin do this validation is error-prone, and potentially opens the door to malicious or poorly-written plugins to consume stuff they shouldn't. A realistic setup might have multiple cloud inventory plugins enabled (eg, I'd argue that all the ones we ship in the box should be enabled), which means there's a lot of refusal going on. Regardless, it seems like for config-based plugins like this, that this should be handled by the engine, not the plugin itself. Topic for broader discussion, I'm sure.
the cache will be by 'plugin/source' initially it will be globally enabled, but i hope to implement per plugin and even per source settings
Is this call redundant? The manager already calls this earlier, so seems like it shouldn't need to happen again (plus we're ignoring its result).
Probably need a third clause on this for `aws_security_token`- IIRC that can be specified alone.
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
What's the reason for using the shell here? There's no redirection, pipes, or other needs for the shell that I can see.
Same question here about unsafe_shell as in get_default_interfaces()
```suggestion result = dict( ``` More in line with a lot of modules.
Instead of making the plugin aware of the tests, use `mock.patch` to mock the `LPass` class in the tests.
Probably the same with `--label` instead of `--uuid` here.
Please add spaces around the equal sign.
Please remove whitespaces around the braces.
Please add spaces around the equal sign.
This line is too long even by the Ansible code style guide. It should be under 120 chars per line. Please format it like this: ``` module.exit_json( changed=has_changed, state=p_state, id=p_id, enabled=changed_repos['enabled'], disabled=changed_repos['disabled']) ```
There should be two blank lines between top level functions.
I'd do ```suggestion if not ignore_errors: raise ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
You do iterable unpacking in all places where you use this. Maybe it's easier to just use accept an iterable rather than a bunch of separate args? ```suggestion def _urljoin(slugs): ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
The default here is to use 'yes'. That's how all modules work, by default they take the system configuration.
Doesn't need to be quoted. We tend to only quote strings when it is required.
Lowercase yes :-)
It's the version of the returned data. As long as they don't make any incompatible update to the output, it will stay at 1.0. It does not need to map to a specific API version though. Although if at some point they change the output, it probably will be related to a specific new (major) release.
It would be nice to have the complete output (maybe in gist) to understand what the data structure looks like.
It's unclear from the name what this is (or even that it's supposed to be a URL). Please rename.
```suggestion assert isinstance(wrap_var(b'foo'), type(b'')) ```
Apparently, Python 2 does not have a `TimeoutError`
https://docs.python.org/3/library/exceptions.html#TimeoutError says that `TimeoutError` is an `OSError` subclass that's been added in Python 3.3
Now that we're making this a module_util, this should no longer be considered a hack.
This may seem obvious, but it'd be nice to add to this doc something like "WARNING: if the stack does not exist, it will be created. If the state is `absent`, the stack will be deleted immediately with no changeset." since I can see people missing that part.
```suggestion - Note that to use dedicated tenancy you MUST specify a I(vpc_subnet_id) as well. ```
spec is also returned
These calls need to be wrapped in try/except to handle exceptions, otherwise the exception will just bubble up to the user. We provide a decorator in the EC2 module utils that handles boto3 exceptions and does retries for you. https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ec2.py#L71
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
is_map should be done using global re 'MAP_RE' so we have one way to identify map in a column value.
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
type='str' is a default value, not require to explicitly mention it
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
while purging all username we should preserve the username which is used to run the playbook otherwise we might hit connection timeout in middle and leave the box with partial configurations
If `ports_expand` took a rule rather than the value of its `ports` key this entire function could be replaced with ``` return [ports_expand(rule) for rule in rules] ``` Edit: of course `ports_expand` returns a list, so you need to flatten the result: ``` return [rule for expansion in ports_expand(rule) for rule in expansion] ```
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
What exceptions are you planning to catch here ? Because we prefer to catch only the exceptions we know can be raised. Blank statements like this one may hide real logic errors under the premise that it was a known issue all along.
Why not do this in a single statement ? ```suggestion result = dict( changed=False, ansible_facts=dict( tcp_listen_violations=list(), udp_listen_violations=list(), tcp_listen=list(), udp_listen=list(), ), ) ```
Why don't you run `netstat -lnptu` instead and parse everything in one go ? Also beware that if this is run as a normal user, you may not get pid information.
Returning an error on Ansible module protocol level shouldn't be mixed up with just identifying a directory. Use exceptions to communicate failures to the calling code and process them there, outside of this function. So no `module` argument is needed here â let's separate different abstraction layers.
Instead of lots of if/else, you could follow EAFP principle and do: ```python try: if git_version(git_path, module) < LooseVersion('1.7.5'): separate_git_dir_fallback = True else: cmd.append('--separate-git-dir=%s' % separate_git_dir) except TypeError: # will happen when comparing `None` module.fail_json(msg="Cannot find git executable at '%s'" % git_path) ```
You calculate `os.path.abspath(separate_git_dir)` in more than two places. Save it to a variable and reuse, please.
We might want to introduce new/old git dir path in the result.
I suggest you use [`shutil.move()`](https://docs.python.org/3/library/shutil.html#shutil.move)
Ah, let me see if I can find an example of mocking run_command.
This isn't needed as Windows hosts don't use the Python modules. If you wanted to add it into Windows have a look at https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/windows/setup.ps1
you use get_bin_path above, i would reuse it for all lsattr calls (and do same for the other utilities below)
Another regex that can be precompiled.
Rather than doing the `if not cmd` dance, pass additional search paths to `get_bin_path()`: ```suggestion cmd = get_bin_path('iscsiutil', opt_dirs=['/opt/iscsi/bin'], required=True) ```
depends ... some DNS servers allow multiple entry as a way to skew the load, i.e: ``` www.example.com 10.10.1.1 www.example.com 10.10.1.1 www.example.com 10.10.1.2 ``` ^ will send 2/3 of traffic to first IP and 1/3 to the last .. so technically it should be accepted .. but that depends on the server software (some do this, some ignore, some error out).
@nerzhul this 'feature' predates the RFC that introduced SRV and was used as a 'cheap' load balancing trick
i really don't like a such crap in DNS nsupdate should take care about all DNS implementation , and bind9 is the reference and doesn't support a such thing
what if empty result ? This should be tested also we can have a different TTL per record value, not only per record if i'm correct
ok, missed that!
This will not be idempotent, is that intended? We should try to support `present`, or if this is not possible warn users that there is no idempotency.
Ok then we should have a message in the docs then to warn users that this module/option will not be idempotent, so that it doesn't catch them unawares.
I don't like the `new` state too. This will be confusing for the users since it's a rather non-standard behaviour. And worst, this breaks the idem-potency of the module. May I suggest something like: ```yaml - name: Set the disk of the VM vmware_guest_controller: name: test_VM controllers: - state: present type: sata - state: present type: sata - state: present type: nvme - state: present type: usb3 ```
You forget to make the change.
I propose: `expect = disk['size'].rstrip('tgmkb')` It allow use to fail (later) if the user try to use something like '1gb500mb'.
In the metric system, 'kilo' is abbreviated as 'k'. I guess this is wrong in the UCS interface though.
I understand what you're trying to do here, but managing both parent as child objects in a single module is going to be problematic IMO. This can only work if your childs are always fully listed (and replaced/updated).
Same here, the first line should give information what the parameter is about. Subsequent lines clarify the value and dependencies. So in this case you'd have at least 3 items in the description.
Do the same for the following options too.
@dsoper2 I think I mentioned it once before, but this one big try-except block you are using in almost every module is considered a bad practice. We tend to prefer small try-except blocks and catching specific exceptions with specific error-messages guiding users. I understand that that's not always the easiest path, because you may not always know in advance in what ways something can break, but that's something you learn along the way. In this example, there are a lot if statements that can't go wrong (like assignments and conditionals). On the other hand, you're calling class-methods that might as well catch their own exceptions, so there's no need to catch them in the module. Maybe the only call you want to add in a try-except block is the call to CommDnsProvider, because it's external you may need the handle raised exceptions.
You should either use ```suggestion cmd = self.docker_cmd[:] ``` or ```suggestion cmd = list(self.docker_cmd) ```
If the line would be `cmd = self.docker_cmd`, the original value of `self.docker_cmd` (which is a list) would be modified by the `cmd += ...`'s below. That's why a copy must be created.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
Why not use keyed groups and let the users decide themselves whether they want to create such a group, instead of creating it by default? (There should be an example of how to do this if the user is suposed to do it by herself.)
Since it's the only plugin which does that, I would remove it. Either all plugins should do that, or none.
Should not be needed, it can only be "present" or "absent"
This should be: ```python if state == 'present': ```
align is always lowercase.
It's better to have a single definition of this list and use it both for parameters and here.
If it is not required, you don't have to add `'required: False`.
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
This should be a string. ```yaml version_added: "2.3"
If a parameter is not required, you do not have to add `required: false` as that is implicit. Is is easier to find what is required if these are not listed.
Are these the only valid options, in which case you should add `choices: ['SG_TYPE_STRING', 'SG_TYPE_KEYVAL'] and similar in `argument_specs`
I think this should be a single line, rather than three
```suggestion @pytest.mark.parametrize( 'input_value,expected_outcome', ( (i1, r1), (i2, r2), ...etc ), ) def test_lenient_lowercase(input_value, expected_outcome): ```
Please use `pytest.mark.parametrize()` instead of a loop
You mess up separate test cases into one. While they should show up separately. Also, one failure shouldn't affect other tests.
This is usually not needed
it'd be nice to get a hieroglyphic test (Asian langs)
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Looking at the code now, it's wrong. You don't have `self.error` anymore. And the KeyError will never hit, so you surely didn't test these failures. (integration tests !) There's also no difference between `>= 300` and `>= 400` so I guess `>= 300` only would do (but I don't know if that is intentional).
This won't work if 'name' is an alias, rather than the parameter name.
This was very specific to ACI, I don't see a good reason to repeat this here.
following task -> the following task
```suggestion The C(address_list) is a comma-separated list of one or more address/netmask pairs in CIDR format." ```
@thomwiggers you also seem to like the "suggested change" feature :D
Can you use here: ```python host_id = get_id_by_name(hosts_service, host_name) ``` you won't have to check if host exists and it raises the exception for you. And you are insterested in host id only anyway.
you can remove line 124 and 125, the check is done by `get_id_by_name` function, if host is not found.
This is duplicated 15 lines above that ;)
This should probably guarded with `if __name__ == '__main__':`
Initialized must go first.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
Suggest changing to `if 'tags' in host:`
This can become a function since it no longer makes use of self.
Don't modify things inside of a function unless there's a huge performance hit. Just return the values. Also, don't pass in a meta object like mount_info... Instead be explicit that you need the mount and the device by passing just those two arguments in. Looking at this further, though, it probably makes more sense to call each of those separately as they're disjoint information and could timeout separately.
This piece on mount should be moved to the outer level as it isn't in danger of timing out and will then always be provided to the caller (whereas if it's in here, it will be omitted if something else fails).
should probably have an upper bound of < 10 just for sanity
From our triage meeting, we all found we were confused by this line. Making it more verbose will likely make it easier to understand.
```suggestion ssl_keyfile=dict(type='path'), ```
```suggestion ssl_ca_certs=dict(type='path'), ```
`validate_certs` and default should be `true`
This is not a good idea, since `ca_cert` is already a module option. (Due to `url_argument_spec()` above.) Either do ```suggestion feed_ca_cert=dict(aliases=['importer_ssl_ca_cert'']), ``` and make sure that `feed_ca_cert` is set to `ca_cert`'s value if not set, or name the option `ca_cert` and add `feed_ca_cert` and `importer_ssl_ca_cert` as aliases. (Then there's no way to separate these options.)
If postgres doesn't care, let's standardize on None in all three modules.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together ```
Note that fail/exit_json should be handling bytes or text; making them the proper string type for that python version before passing them in to the stdlib's json.dumps().
i need to think about the if in 411, it does not look right to me ... but there are many complex combinations here
the changed = True from 410 should be moved below this
Might be worth adding a `note:` to say that only the hash of the file is used for comparisons, not any filemode/permissions/etc.
Use to_native instead of str
Only those two lines are required, and it works for me with it
please also do same fix on the update. Without it i got: ``` "msg": "error : Unable to update the dashboard eNWYzQUmz : Dashboard not found" ```
Exception handling here too.
This logic could be simplified by using `.get()` such as `if data.get('slug'):`
Exception handling should be added around here, incase either the file doesn't exist, can't be opened, or cannot be parsed as json.
Python 2.6's `re.sub` doesn't accept `flags` -- but `re.compile` does.
`shlex.join` was added in Python 3.8, so an alternative is needed here.
Thanks! Note that that only fixes it for v230, not for versions < v230, so #56571 should still be reopened.
Since these are for tests we probably want to set play_context.prompt and check the output. Then unset play_context.prompt and check the output.
This should probably be `docker.exec_command()`
Maybe we can remove the `if min_version:`? min_version has a useful default, and if `min_version=None` is passed, it is OK to explode, from my point of view.
> The current code isn't compatible with openstacksdk < 0.10.0. > Because this is a module_utils, other module not belonging to the ansible repository might use this method with another value than the default one. Sounds like min_version should be set to max(StrictVersion('0.10.0'), StrictVersion(min_version)) here. This would avoid the redundancy below, too.
> Did you read the stacktrace mentioned in the description of this PR and in the first commit ? Sure, but I did not understand how this is related, but with your additional exlaination, I understand now. The commit message could be improved by writing something like "`openstack.version.__version__` expression raises an AttributeError exception when openstacksdk < 0.10.0 is used. openstack.version is now imported as a module, which works for all openstacksdk versions.
This has broken OpenStack ansible modules in 2.8.9. min_version should be a string, not a StrictVersion. We get the following error: TypeError: expected string or buffer This affects kolla-ansible, and probably a few other things too. https://bugs.launchpad.net/kolla-ansible/+bug/1866181
The old comparison is doing <=, not just <. So we need min_version='1.9.0' I believe.
This logic seems ignore the use case of removing all tags.
can be ignored
hm maybe that's what I've searched for
can be ignored
Same order, type first.
Not saying that: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/collection_loader/_collection_finder.py#L703 is the authoritative way of doing that, but it certainly looks leaner than above. ```suggestion COLLECTION_NAME_RE = re.compile(r'^(\w+(\.\w+)+)$') FULLY_QUALIFIED_COLLECTION_RESOURCE_RE = re.compile(r'^(\w+\.\w{2,})$') ```
We shouldn't be adding content-specific rules to the validation code. Why not allow any non `@` prefixed string to be used for collections instead? That will preserve the more strict check for ansible-base while allowing collection authors more flexibility.
Why include the `.` in the character groups? `[\w.]` is the same as `[.]`- and allows lots of things we don't want...
This one is a bit newer to CliBase, but also implemented verbatim in superclass
disconnect() is likewise handled in CliBase, and should be entirely unnecessary here.
Should we just hardcode this instead of using `__name__`? Using `__name__` could make this dynamic, as it could be `__main__` or `ansible.utils.display`. We might benefit from just making it `ansible`
it should also check if it can write there
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
It seems like no_log and deprecation are separate things and should be handled in separate functions.
this is never invoked as the v2_ method that would forward to this in the callbackbase is overridden below
This method is technically deprecated from Microsoft, if the executable manifest hasn't been set correctly it will always return `6.2` (Windows 8) even when it is newer. I don't see a need for this to be done in Windows and can potentially return None or a blank value as we shouldn't care there.
No need to parametrize with just one case.
Both cases test the same thing, don't repeat yourself. Test things based on their properties. Here you'd probably want to test iterables, not just sets.
Use match arg instead: ```suggestion with pytest.raises(TypeError, match='Cannot json serialize'): ```
It probably makes sense to test that the exception reason also matches expectations
this should be moved into the run method, as we only want this to error on running, not on loading, which will always happen if this is included in ansible. or in the hasivault class init, which gets called from run.
now in utils, can drop from here.
Ah :+1:. I should have started by saying I don't know anything about tenants in manageiq :)
not a blocker but I am missing some docs here, there are a few returns which gets returned under various conditions.
I think for `http:` connections `verify_ssl` is meaningless and can be omitted.
This could be less nested once you apply `choices`.
Well, if we want flexibility, we could have a dict value but I still expect it to we inside a dict, not inside a list. It's `{'ns.coll': {'fqcn': 'ns.coll', 'ver': '1.2.0'}}` vs `[{'fqcn': 'ns.coll', 'ver': '1.2.0'}]`: with a list, it's harder to access a specific collection as you'd have to do a full list scan to find in which element your target is while with a dict you can access it by key instantly. cc @shanemcd
Oh, I see it's addressed now.
Why add another level of nesting with a list? Just have a dict comprehension.
In case we ever add more field to this like author name or something of the sort. Keeping it as a dict entry in a list gives us more flexibility in the future.
This shouldn't be needed, just do `to_bytes(cmd, errors='surrogate_or_strict')` without the PY3 conditional. Doing `""` on Python results in a byte string so `to_bytes()` will just be a no-op for that version. Also one style we try to follow in Ansible it to prefix any byte strings to `b_`. That was we can easily infer the type of string being used based on the variable name. If you have an explicit native string (bytes on 2, unicode on 3) then we prefix with `n_`. Otherwise a general text string has no prefix.
It looks like there may be an issue with the tests. I've restarted the failed test.
Why a 1 second sleep here, I had this removed in my testing and was fine without it. 1 second is a long time for each command, especially since tasks can execute more than 1.
With the removal of `$?` this shouldn't be needed.
Use `to_text(line)` instead.
This module doesn't support check mode. I'm not sure if this is the best method to do this either though.
I'm going to add a commit to do `if os.path.exists(module.params.get('cert')):` instead of try/except.
I don't have the answer, but was hoping to prompt discussion about it and maybe get this moved along in the process.
You'll also note I updated the else statement to correctly reflect the vars used later. eg. cert_chain not chain.
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
I think this needs to be a dict since it's used as-is in the call to ansible_dict_to_boto3_filter_list().
Isn't paging for boto rather than boto3. This should just use standard boto3 pagination methods including build_full_result() I wrote this long before I understood boto3 pagination!
This doesn't support aurora snapshots. Besides that, this looks great.
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
You can add required=True here too and remove the check below.
This is not needed for parameters that are not required. Guideline dictates to leave it out.
Here also `required=False` is not needed for parameters that are not required. Guideline dictates to leave it out.
This seems to be a leftover, there is no state "updated" anywhere else in the code.
When required is false, it can be left out (since it is the default).
Please add `note: Version 4.4.3 or high required.`
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
I think it makes sense - the user is responsible for making sure the library is available for specified Python interpreter. Similar to how user is required to install necessary prerequisites for modules, for example.
Again nitpicker - sentence sounds a bit weird. Maybe something as follows would be better? ``` Nested keys must be quoted when specified in abbreviated form (e.g. C("DesktopViewSettings:IconViewSettings:arrangeBy")), since colons are treated as part of YAML syntax itself. ```
Typo - `use` -> `used`. (your friendly neighbour nitpicker :)
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Just making a note that we should probably restrict this to the exceptions that will likely occur and call fail_json instead of raising an Exception again.
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
This is fine, but we should only update (all labels) if one changed, misses or should be added.
An `EXAMPLE` of labels maybe good so people know the structure
i would suggest to make `name` required if `state=present` because idempotency: you should not known the state (already exists or not) in arg spec ~~~python required_if=[[ 'state', 'present', ['name']], ~~~
If one of both is required, it is better to force this as part of the argspec.
This would turn everything into a string, not sure if that's what you want for e.g. booleans). Same for the other values that are not strings. Probably not what you want.
Please remove this as it is not common across all influxdb modules
that is why database_name is not a common arg
i suggested same fix to lib/ansible/module_utils/influxdb.py some time ago in PR #31566
Please take a look in init of InfluxDb(): and then on connect_to_influxdb(self): they both use database_name and it's mandatory in such way.
it may be possible that each module will override it inside by under argument_spec.update()by adding database_name
Just to reduce duplication, you could switch the 'else' below to a ``if not module.check_mode:`` and leave the ``result['changed'] = True`` outside the if statement. the result won't be returned if an exception is thrown while making the change. (and the same below)
`read_config_from_file` could return the content of the file or `None` if the file doesn't exist (instead of a tuple).
Don't use `except` without exception type ([ref1](https://docs.python.org/2/howto/doanddont.html#except), [ref2](https://docs.quantifiedcode.com/python-anti-patterns/correctness/no_exception_type_specified.html)). Here checking file existence could replace `try/except`.
This logic seems ignore the use case of removing all tags.
The cgroup name must be checked.
This line has to go: ```suggestion ```
```suggestion fail_reason = get_failure_info(exc, out_redir_name, err_redir_name, msg_format="Error scaling {0} - %s".format(service.name)) self.client.fail(**fail_reason) else: cleanup_redirection_tempfiles(out_redir_name, err_redir_name) ```
```suggestion msg_format="Error stopping project %s") ```
```suggestion msg_format="Error stopping project - %s") ```
```suggestion msg_format="Error stopping project - %s") ```
If the VLAN exists, you should check the name and state to make sure they are same as requested.
Move this line after 250. You won't need to deepcopy unless you are actually creating a request.
You have identical code on lines 159-163, 193-197, 228-232... Move it into a function.
Thanks for the changes! Looks good.
`commands` should always be a list.
Thanks for your work on this! It works as expected (although I wish describe_db_instances() could filter by tags as it would be simpler not to filter out the results while retrieving them).
use tags.items() here, no need for iteritems import
No need to wait twice - the below lines do the same "wait" while respecting max wait time.
Should probably use `compare_aws_tags` for future reference but not a blocker here as it is only recently available
note: tests for zero length and nonzero length containers can test the container directly: ``` python # equivalent: if unmatched: pass if len(unmatched) == 0: pass # also equivalent: if not unmatched: pass if len(unmatched) > 0: pass ```
Fails because self_host is not defined for accelerate transport.
I would probably go for "Exit" here, but that's more cosmetic than functional.
Again self_host is not defined for winrm.
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
Since this is displayed after the polling has occurred, I think the new messaging isn't any more clear. How's this? ```python display.info('Retrieved %s/%s instance %s (status: %s)' % (self.platform, self.version, self.instance_id, status), ```
I suggest: if parser.get('DEFAULT', 'vmware_validate_certs').lower() in ('no', 'false'):
Same thing here about using a single log entry instead of two. Use the same format as suggested above.
You should be able to use `self.vmware_test_platform` here.
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
Maybe use ```suggestion type: path ``` instead? Then Ansible will replace things like `~` IIRC.
```suggestion - Required when I(release_state) is set to C(present) ``` Use `I(...)` for option names, `C(...)` for option values.
```suggestion - Run C(helm repo update) before the operation. Can be run as part of the package installation or as a separate step. ```
Afaik the `version_added` line is not necessary for new modules
Maybe add a link to PyPi or something, one of these is a Python library and the other one an external binary.
Unfortunately, shlex.split() needs a bit of code to make it compatible with both python-2.6 and python3.x On python-2.6, it only works on byte strings. In python3.x it only works with text strings. So you have to test for python version and then convert appropriately. Code like the following is what I use: ``` python from ansible.compat import six from ansible.module_utils._text import to_bytes, to_text [...] nspawn_args = self._play_context.nspawn_args if six.PY2: nspawn_args = shlex.split(to_bytes(nspawn_args, errors='surrogate_or_strict')) else: nspawn_args = shlex.split(to_text(nspawn_args, errors='surrogate_or_strict'))
I think it would be more helpful to the user to show them both errors by default rather than hiding one in `-v`. Ideally we could have templating errors take precedence over loop errors and only display the templating error first, but that may not make sense in all situations. If we don't want to display both as was done originally, then I'm fine with the current use of `-v` rather than using debug since debug is information overload for users.
Yeah, I had the same problem. I tried changing the exception type raised in `templar.template()` and catching that here, but still couldn't get it quite right. Seems like putting it in `-v` is an improvement over what we have now until we can come up with something better.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
```suggestion def _post_request(self): ```
Probably cleaner to use a different variable than before to make sure you're not using the incorrect response.
I'd also include a check for server errors (500)
If the result was a 4xx or 5xx then I think this fails.
Shouldn't this be using `.get()` ```suggestion inventory = self._cache.get(self.cache_key)[url] ```
ehm, this should stay here. ;)
Very interesting. I haven't seen this happening for all my `letsencrypt` PRs over the last few weeks. I'll investigate a bit, this made me very curious :)
I found something: https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-underscore-variable.rst Interesting... So the recommended name is `dummy`. I'll create another PR for `letsencrypt`...
That's fair, but you can wrap the file descriptor in a `file` object: https://docs.python.org/2/library/os.html#os.fdopen
use `required_one_of` kwarg when creating AnsibleModule instead
Should be a string.
That doesn't sound like proper English. The original neither.
Starts a program is very specific. Why not just: > Run commands in a VMware guest operating system
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
`network_id` is a `vim.Network` instance, so you should actually set `network_id.name` in `deviceName`.
This may apply to some of the other PRs in flight, as well as some of your existing modules.
Verifying here that IP address and prefix are in correct format would be good. Look for APIs: `socket.inet_pton(socket.AF_INET, address)` and `socket.inet_pton(socket.AF_INET6, address)`
Is `address` option required as part of this module? I think address can be configured as part of `vyos_l3_interface` module.
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
...Or being root and running ansible locally. (bcoca suggests the wording: "root privileges are required"
Add minimum version if needed.
As long as we're supporting python2 we should make this a new-style class like this: ``` class OSXService(object): ```
Only use a single leading underscore for private methods. Typical python style is about convention rather than forcing (and the name obfuscation is just obfuscation anyway.... it's still possible to call a private method if you convert the name yourself).
We try not to use "_" as an identifier just in case we want to internationalize the modules someday (the convention for gettext is to mark strings using the function _(). So we don't want to inadvertantly override _ with another identifier).
required=False, default=None is default for an argument
get rid of this if it's empty
Should be changed to new style imports. Also then no need to set HAS_BOTO3, you can import it.
This can also be an ARN, right? In which case the length can be up to 140 characters.
None is the default.
I am not sure this will work. It is unlikely that resp is set when there's an Exception.
`urls.py` does not use `urllib`. It uses `urllib2` on py2, and `urllib.request` on py3.
I don't believe this should be a function of the `uri` module, but probably implemented in `ansible.module_utils.urls` instead. However, with that being said, we wouldn't be able to use this specific line, as it could cause other issues, in that this would become a global change, and not specific to just a single request. As such, we'd probably want to make use of `sockshandler` instead.
i don't see a need for this change
I think it's likely the proxy code won't work as I haven't been able to test it well under Meraki
Tiny optimization: check self.check_mode before checking os.path.exists. That way in the common case we don't have to use a system call to determine if the path exists.
Note that b_path is not yet set here.
The `elif attributes.startswith('='):` isn't required. The `else` arm has the same code.
I believe selinux uses native strings (byte strings in python2 and text strings in python3) rather than always using byte strings. So that's why we weren't using to_bytes here earlier. We may need to move the to_native call earlier, though. I'm not sure if it was all selinux functions or only some of them which had bugs if the wrong type of string was passed to them.
can be ignored
This line can also raise a `ValueError`.
Here's still another one.
Here's another line which can raise `ValueError` (call to `run_luks_remove()`).
`run_luks_remove()` does raise `ValueError`.
There's another `try/except` missing here.
No need to split the line.
What if the flatpak name contained the string 'error' ? Seems a recipe for disaster.
This could move even more down. After listing apps.
Various modules allow to specify the name of the executable in order to use a binary from a non-standard location (i.e. a binary not located in the PATH). Look at e.g. the isoextract on how to do this.
Move it down the stack.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
If it's not required, you can leave out `required: false`.
```suggestion 'Socket path %s does not exist or cannot be found. See the socket path issue ' ```
```suggestion 'Unable to connect to socket %s. See the socket path issue category in ' ```
You're missing `%s` in the string. `to_text(exc)` is rendered to `/dev/null` now :)
If you have an option of `end` command (similar to IOSXR) or an `abort` command (this will take care of any stale uncommitted changes), use those Also, when you exit out of configure mode, I believe you will be in `exec` mode? In that case, you might want to run `enable` command every time and not just in the `else` part? OR even better (however make sure you are in exec mode before doing this) ``` if to_text(out, errors='surrogate_then_replace').strip().endswith('>'): conn.send_command('enable') ```
use `str(e)` (this is not the optimal, but that is true for most of this file) cc @abadger
This will remove check for datacenter from line 215 ```suggestion dc_obj = self.find_datacenter_by_name(datacenter_name=self.params['datacenter']) if not dc_obj: self.module.fail_json(msg="Failed to find the datacenter %s" % self.params['datacenter']) objects = get_all_objs(content, vimtype, folder=dc_obj.networkFolder) ```
+1 for to_text
from ansible.module_utils.vmware import get_parent_datacenter
We could add a check to send at least an warning if a `mac` is specified with `state=new` in place of `manual_mac`: ``` if network['state'].lower() == 'new' and 'mac' in network [â¦]msg="MAC address '%s' define in `mac` attribute will not be used. If you want to define a manual MAC address, please use `manual_mac`." % (network['mac'])[â¦] ```
Yes, 'msg' key and value should always present on *_exit() calls
Do you have any references for the inline if being discouraged? If you don't like the inline if, then I'd go with the normal if block.
Ping @willthames - other than this validation fix this is good to go.
It would be nice to return the object you created too: `res['provider'] = self._get_saml_provider(self._get_provider_arn(name))`
pep 8 wants all imports at the top
This is handled by `AnsibleAWSModule`.
To get urlencode, please use `six.moves` instead.
To import urlencode, you can use this line: ``` from ansible.compat.module_utils.six.moves.urllib.parse import urlencode ``` Then for the rest of the file just use `urlencode` as normal.
Ah, I see. Thanks for clarifying!
Is there no existing Python library to manage BLOCKS API logins & resources? Ansible is ok with modules that require an external client (such as the `boto3` client for AWS APIs, or `shade` for OpenStack). If there's an equivalent for PubNub it would be great not to duplicate code here.
Slightly longer key names are ok - in this case, can you use `password` instead since "pwd" can be confused for "print working directory".
I think you can get away with `str(group_ids)` here: ``` >>> a = ["sg-123", "sg-abc"] >>> str(a) "['sg-123', 'sg-abc']" >>> import json >>> json.dumps(a) '["sg-123", "sg-abc"]' ```
No list comprehension needed here either ``` ','.join(group_ids) ``` should work fine
Probably won't make any difference here but there's a stdlib function to split filename from directory name: ``` python import os.path os.path.basename(k) ``` or you can make this more targeted by doing it like this: ``` python instance_vars["ec2_block_devices"][ k.rsplit( '/' )[ -1 ] ] = v.volume_id ```
For python3 compat, avoid iteritems unless you're dealing with large data sets. If you are, then use ansible.compat.six.iteritems.
The CamelCase exception .response attribute is particular to boto3's ClientError. IOError doesn't have .response so you can remove the `**camel_dict_to_snake_dict(e.response)` bit of this.
[`get_param`](https://github.com/spotify/pyfg/blob/master/pyFG/forticonfig.py#L249) should not raise an exception. I guess you could check if `f.running_config[path]` contains `module.params['name']Ì`.
Don't use except without an exception type. What could be the exceptions here ? It would be better to check if `get_param` returns `None`.
Parentheses around `e.message` are useless.
There is some code duplicated between this pull-request and other FortisOS pull-requests ([`fortios_ipv4_policy`](https://github.com/ansible/ansible/pull/21849/files/d49860f735c162acda87f5232f1de0e148453203#r103181410) and [`fortios_address`](#21542)): - block calling `connect` method - block calling `load_config` method These blocks must be moved together in [`module_utils/fortios.py`](https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/fortios.py).
Same as https://github.com/ansible/ansible/pull/21849#discussion_r103172035, `timeout` isn't `username`.
You could fix #19781 real quick right here :D
Can add example with `prompt` and `answer` for more clarity
You can refer ios_command module doc ``` - name: run commands that require answering a prompt ios_command: commands: - command: 'clear counters GigabitEthernet0/1' prompt: 'Clear "show interface" counters on this interface \[confirm\]' answer: 'y' - command: 'clear counters GigabitEthernet0/2' prompt: '[confirm]' answer: "\r" ```
iirc we decided to allow configure commands as part of cli_command to support config commands that result in a command prompt
Do this in the module parameters rather than here
I don't have a strong preference. LGTM!
Please use a try/except or the AWSRetry decorator here, since this call should provide a nice message to the user about where it failed and what actions they can take.
Don't need these parens.
These parens aren't necessary, please remove them.
Instead, you can just return the results of `ensure_present` since this is the last line of this branch
Line is too long.
Line is too long.
Too long line.
This line is too long. Max line length allowed in Ansible is 120 characters.
it might not be relevant in this particular case but be aware to better handle LANG when searching in output. use `module.run_command_environ_update = dict(LANG='C', LC_ALL='C', LC_MESSAGES='C', LC_CTYPE='C')` early after `module` has been instantiated to get that covered.
I would also do `not host` as `''` is both a string and not None, but i would argue still an invalid host
so this is valid ``` - hosts: - mailer - local1, local2 ``` but this is not? ``` - hosts: - mailer - [local1, local2] ```
remove 116 and 117 as dupes
I'm pretty sure this can use `is_sequence()`.
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
You need a paginator here still.
You should handle BotoCoreError here instead of NoCredentialsError: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#using-fail_json_aws Same applies for all of the following exception handling. BotoCoreError and ClientError together should suffice.
You're importing ClientError itself as well as botocore, but still using `except (botocore.exceptions.ClientError, ...` instead of `except (ClientError, ...`. Could remove this import. Or add , BotoCoreError to this too and save some line length in places below.
you might want to call vault = self.exists(self.name) immediately after `create_vault`. Otherwise you are not returning what you say you are when creating a new vault.
Yes, please rename. Also, ensure that it returns the tags from the vault too (and update the docs to reflect that)
Awesome. This is much better now.
I think this may read better: ```suggestion if missing_keys: ```
Are you only doing this to support Python 2.6? Those keys are already unique.
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
How about: ```suggestion if not os.path.exists(file_path): continue ```
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
`required: false` lines can be removed
Capital letters & full stops please
`Filename of the SSH Key to use for authentication. Either I(key_filename) or I(password) is required.` Similar for `password` field.
Commit if changed.
I see... it's putting them near split_xpath_last which is where they're used. Maybe move both the variables and the split_xpath_last function up to below the imports.
Instead of including a stacktrace in the message, better to put it into the exception field: ``` module.fail_json(msg="Xpath %s causes a failure: %s\n -- tree is %s" % (xpath, to_native(e), etree.tostring(tree, pretty_print=True)), exception=traceback.format_exc()) ```
Instead of child.encode(), use to_bytes(child, errors='surrogate_or_strict"). to_bytes() protect against calling encode() on something that is already a byte string. (calling encode on a byte string can sometimes traceback).
In general, it's better to use``` collections.MutableMapping``` in isinstance as that allows duck-typing.
Since we're now targetting python-2.6+ we can just ```import json```
please fill this in
Please check if this is still valid for `icx` parameter since current release is 2.9
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
```suggestion - ID of the project, get it with U(https://api.ovh.com/console/#/cloud/project#GET) ```
```suggestion - ID of the instance, get it with U(https://api.ovh.com/console/#/cloud/project/%7BserviceName%7D/instance#GET) ```
```suggestion - ovh_monthly_billing: project_id: 0c727a20aa144485b70c44dee9123b46 instance_id: 8fa89ad2-8f08-4220-9fa4-9695ea23e948 ```
```suggestion import traceback ```
```suggestion short_description: Create, update and delete VMware content library ```
Please check this.
...The remote host **MUST** support...
Ansible 2.7 dropped support for Py2.6
Presumably you want `It *will* always use`, or something to the effect
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
We can use `urlparse.urlunsplit()` and `urlparse.urljoin()` here.
Could we use `vm` too, maybe as an alias. This is shorter, clear enough IMO and it's actually already VMware naming convention.
VMware may add new resources in the future and if we don't hardcode a list, the user will be able to use it without any update of the module. So I would prefer to avoid the `choices` key.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
If we use `self.api_client` then this API will look like - ```suggestion self.datacenter_id = self.get_datacenter_by_name(datacenter_name=self.datacenter) ```
Same for other description.
```suggestion - The certificate in PEM format. ```
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
For an info module you will only need the name as this will be the identifier. Please remove the other options
```suggestion - Web SSL (HTTPS) to enable or disable. ```
```suggestion - Simple Network Monitoring Protocol (SNMP) to enable or disable. ```
```suggestion - State the action to perform. Use C(update) to modify the igmp-snooping. ```
```suggestion - Web (HTTP) port to enable or disable. ```
type is missing
i would still not make this an option, but try to capture the copystat error on hp/ux and issue the warning as we do for enosys case
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
Why don't you just encode suffix like `u'-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8'.encode('utf-8')` and for the no_temp_unicode override just do `suffix = b'-ansible'`? No need for this check which is arguably more confusing.
This introduces a different race condition, file can now be looked at in 'intermediate' state.
both forms are valid ... string is more descriptive to users (non programmers)
There can't be spaces in cluster name.
Create vm pool and override the pool values.
This should state: ```python except: e = get_exception() module.fail_json(msg="failed to send msg: %s" % e) ``` or we won't see why sending failed.
Types are missing above. token, msg and api are of type "str", port is of type "int". So something like: ```python token = dict(type='str', required=True) ... port = dict(type='int', default=80) ``` Please also add check-mode support. In whatever form you think is appropriate (either log messages adding check-mode run, or not sending messages but e.g. still attempt to connect).
```suggestion module.fail_json(msg="At least one resource ARN must be provided") ```
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
Please order the options alphabetically.
The value should be quoted.
This should be: ```yaml type: bool ```
If it's not required, leave this out. It's implied that parameters are not required.
`present` is a value of a parameter so it should be decorated like this: `C(present)`. The same for the `absent` bellow.
self.ec2 still needs to be defined here. Also, AnsibleAWSModule lets you do `self.ecs = module.client('ecs')` and `self.ec2 = module.client('ec2')`, so you could remove the imports get_aws_connection_info and boto3_conn.
SubnetIds expects a list `[result['subnets'][0]]`
How about ```suggestion error = error_tuple[0] ``` That makes it look less like a typo :)
Module argument specification ensures this cannot be true. The field is required.
```python if threshold_mode == "absolute": delimiter = ' ' else: delimiter = '%' min_val = int(min_threshold.split(delimiter)[0]) max_val= int(max_threshold.split(delimiter)[0]) congestion_control = dict( control=mode.lower(), threshold_mode=threshold_mode, min_threshold=min_val, max_threshold=max_val) ```
Instead of checking `if existing_source_type and existing_source:` after `source: default`, I think it would make more sense to add this after Line 285.
I have been getting `no ntp None None` is one of the 9K devices. `peer_type`, `address` check is necessary here. Since you are using `get()` checking `if existing` isn't enough as `get()` returns None if key doesn't exist. Please add the check `if existing.get('peer_type') and existing.get('address'):` or if the keys exist in existing.
instead of: ```python servers.update({header_list[2]: server_entry}) ``` it is more efficient to call: ```python servers[header_list[2]] = server_entry ```
no need for this mapping, you can change the current config dictionary to be aligned with the required config or vise-versa
type is a keyword, use another variable name
I don't think we need python 2.6 listed as a requirement since that is the standard minimum version for all modules unless otherwise specified.
spec is also returned
```suggestion - Opaque blob of data which is made available to the EC2 instance. ```
Oops, missed something. I think this should still return the describe_db_clusters call so changed is accurately reflected by whether or not the cluster exists. No changes are being made by that call so it's fine and you're checking for module.check_mode in delete_cluster().
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
spec is also returned
The import for HAS_BOTO3 can be removed
Since you're using AnsibleAWSModule, you don't need to call get_aws_connection_info or boto3_conn. You can do `connection = module.client('emr')` (no exception handling needed around that either). You can pass connection and module to get_emr_cluster in addition to cluster_id.
The return docs list the results just under cluster, but it's just being added to ansible_facts here. I think if multiple clusters may be returned, that should be changed to `clusters` (if cluster_id is not requried). But since there is only the ability to return one right now, to make this consistent with the return docs add **emr_cluster_info to the end of the exit_json call.
You can remove all of these imports except ec2_argument_spec.
Can you please write that: Since Ansible 2.8 they are persisted by default? So it's clear.
... all networks will be synchronized before modification
The three migration modes referred to in the bug report are defined in the `placement_policy` option. Giving users a pointer to that option will help them understand all possible settings. ```suggestion - If I(true), the VM will migrate when I(placement_policy=user-migratable) but not when I(placement_policy=pinned). ```
...The remote host **MUST** support...
Please check this.
`key: write_csv` should be `key: write_files`
~you don't seem to use 'cli' why import it? also the base class does this already.~ v1 compatibility it seems.
this whole section is not needed, just use `self._plugin_options[<option name>]`
its new in 2.4 so it doesn't apply to older versions
don't use print, display.error or raise an AnsibleError exception, Ansible already does not fail due to an Exception from a callback event.
I was suggesting the ansible core could add an ipaddr argument type and validate it early enough that the concern from @pdellaert would be addressed both here and elsewhere in an easier way for everyone. It doesn't have to be done as part of this PR.
Why did it even get to the module at all? If there was an ip_addr (or ip_addr_v4, or ip_addr_v6) field type in the ansible core validator for module inputs, ansible would have rejected it before executing the module's main().
Input validation should be done before doing API calls to fetch information (you already fetch the hosts and the network stacks before we hit this). It's better to fail early and quick...
There are no assertions in the integration test to ensure this message is correct.
This code duplication is also candidate for refactoring.
Refer https://github.com/ansible/ansible/pull/59914#discussion_r313247935 Same doc guideline is followed for other modules.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
In the notes section, you can point to the icx platform guide https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/network/user_guide/platform_icx.rst Refer: https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/network/junos/junos_interfaces.py#L107 Applicable for other icx modules as well.
Keep a blank line between examples for readability.
Sort alphabetically, add defaults before choices. ```suggestion state=dict(type='str', default='present', choices=['absent', 'present', 'query']), ```
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
No quoting needed, no indentation needed, don't fool others :-) ```suggestion - http://www.ansible.com/* ```
Thanks - I've replaced all uses of `filter` with comprehensions.
Same change needs to be made to many other uses of filter.
Yes, the revisions you'v emade to this look good to me.
I took a closer look at the module and the concern here is still valid but I have (for real!) left the information in the module PR now :-) So we can decide what to do there. It doesn't block this one from going in.
it seems inconsistent as you do capture it in some cases
```suggestion - List of paths to include. ```
```suggestion - List of paths to exclude. ```
```suggestion short_description: Local Backup Utility for Alpine Linux ```
I would put all these variables inside the `main()` function as there is no reason to have them global because you don't share them across multiple functions.
You can move this check to `module_utils` as well.
Do you have any references for the inline if being discouraged? If you don't like the inline if, then I'd go with the normal if block.
`policy` should be added to `argument_spec` to be usable.
You can reuse boto3_tag_list_to_ansible_dict from ansible.module_utils.ec2 instead of doing this.
You can add required=True here too and remove the check below.
You can change this to `instance_name=dict(required=True)` and remove the check/failure below if it isn't provided. You don't need to specify `type='str'` because it is the default. I don't think the state 'list' belongs in the module, but for future reference, if you want something to be required for only certain states you could use: ``` module = AnsibleAWSModule( argument_spec=argument_spec, supports_check_mode=True, required_if=[('state', 'present', ('instance_name',)), ('state', 'absent', ('instance_name',))] ) ```
Please rename **follow** to **insertafter**, that is an existing parameter already used by **lineinfile** and better describes what it does.
BTW The most important reason for not adding that parameter, is because it can cause real idempotency issues.
typos: persistent / reboots
Should be: - Tested on AIX v7.1
This is the wrong way of doing Ansible. The user should describe the desired state, not instruct modules to perform actions. The module itself should determine what actions the specific state needs based on the current state and the desired state. That is what is needed for idempotency anyway. So rather than action=install, it should be state=present. Also, check-mode support and diff support are very important for a tool like this one IMO.
please use here self.param('version').get('base_template')
please use here `self.param('version')`
and please add space after `)`
```python otypes.Core(index=core) for core in numa_node.get('cores') ```
```python sso=( otypes.Sso( methods=[otypes.Method(id=otypes.SsoMethod.GUEST_AGENT)] if self.param('sso') else [] ) ) ```
I'm not 100% sure this is correct, or at least maybe not exact enough, although it probably works correct. You could probably just do: ``` term_results = [to_text(g, errors='surrogate_or_strict') for g in globbed if os.path.isfile(g)] if term_results: ret.extend(term_results) break ```
tempted to add a warning 'path not found'
```suggestion raise AnsibleError('Invalid setting identifier, "%s" is not a string, it is a %s' % (term, type(term))) ```
Adding the exception string to the error would help the user narrow down what the issue is.
It likely makes sense to add the remaining psycopg2 parameters including host and port.
AFAIR the flag is `failed`, not `fail`
```suggestion self.container = PodmanContainer(self.module, self.name) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
Looks like we could keep this pretty much as-is if you also remove the getattr() defaults. That will cause line 284/285 to throw an error, and then we can rely on later code to warn the user that the secrets.py file wasn't found.
I think if you revert this part of the code and remove the getattr defaults below, it should be fine.
We use `pytest` to run tests and the helpers from `unittest.TestCase` should be avoided (ideally, `unittest.TestCase` should never be used because it limits the compatibility with `pytest`). Instead, use `pytest.raises()`: ```suggestion expected_error_msg = ( r'^The --prompt option is not supported if ' r'also reading input from stdin$' ) with pytest.raises(errors.AnsibleOptionsError, match=expected_error_msg): cli.parse() ```
Might be worth validating that zones is a list rather than a single zone provided as a string.
My point is the self.credentials may not has a key named 'tenant' if not login
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
Could add to the line above rather than lots of line breaks
Unnecessary line break
It would be good to wrap this in a try/except botocore.exceptions.ClientError as e
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
same here for arg bools vs strings- this needn't exist
Not mandatory, but a good practice: a trailing comma here too ;-) ```suggestion ), ```
What exceptions are you planning to catch here ? Because we prefer to catch only the exceptions we know can be raised. Blank statements like this one may hide real logic errors under the premise that it was a known issue all along.
Add trailing comma for multi-line lists and dicts. ```suggestion whitelist_udp=dict(type='list', default=list()), ```
Why not do this in a single statement ? ```suggestion result = dict( changed=False, ansible_facts=dict( tcp_listen_violations=list(), udp_listen_violations=list(), tcp_listen=list(), udp_listen=list(), ), ) ```
Are there any other IDs/names that a url_map would be known by? If so, we should call this "url_map_name" or something.
the `f.close()` is implied as part of the with block. Also, I don't think this should be in the module since it looks like a debug statement.
Fair enough, I'm good with that.
I think this can just be `name`
Please remove this property since ansible already exposes `changed` so users can see whether a resource was altered during a task.
use `fetch_url` instead of `requests.get`
This can be simplified as `if resp.json()`
Remove spaces before operator `=`
Remove spaces before operator `=`
Please add `no_log=True`
```suggestion - Network backend to use for this definition. Currently supports `networkd` (default) and `NetworkManager`. ```
Please clarify the description
Can we autogenerate it instead? If not, please provide a more useful description.
Simplify that description, it is too redundant as-is.
```suggestion - Control DHCP autoconfiguration for IPv4. Disabled by default. ```
So why are you setting `ip_configuration` with `ip_configurations`, if there is only 1 IP configuration then shouldn't the Azure SDK be able to handle that within the `ip_configurations` field making this a moot parameter.
you can just do: new_hostvars['mac_address'] = nic._nic_model['properties'].get('macAddress') because get() returns None by default if key doesn't exist
if i am correct, that image reference may contain 'id' instead of sku/publisher/version/offer
just do sth like: ``` if image.get('publisher'): new_result['image'] = { 'publisher': image['publisher'], 'sku': image['sku'], 'offer': image['offer'], 'version': image['version'] } else: new_result['image'] = { 'id': image.get('id') } ```
Ah, it's nice that the syntax checker caught this bug. This should be `network_interface['tags'] = boto3_tag_list_to_ansible_dict(tag_set_copy)`
This regexp should be put into a constant, especially since it is reused multiple times. Also, maybe it makes sense to precompile it (and potentially others) with `re.compile()`.
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
This can be a key-value map with key as the fact name and value as the pattern to be searched for
type='str' is a default value not required to mention in separately.
`check_args()` is a empty function. Is this call required? For other networks platforms `check_args()` is present for legacy reason.
+10k to what @sivel states above
This line should be "prettified" by adding indentation and line breaks, so that it properly fits within our line limits.
The return msg should be indentical in normal and check mode
This definition hasn't been updated since a long time. Just made a quick check, there are new services : `discord`, `hangouts-chat`. We need a more recent version of this dump
Split GitLab authentification en project gathering. Add a custom check on `git.projects.get(project)` with a custom message
use `fetch_url` instead of `requests.get`
This can be simplified as `if resp.json()`
Remove spaces before operator `=`
Remove spaces before operator `=`
Please add `no_log=True`
This module only deregisters a module if `current_target_state` is `unused`. I would like to use it to deregister used targets. This fails silently now.
Yes, from what I can see this doesn't work now. My `state: absent` is ignored when target is used by target group. Where is `else`? :)
yeah, there's a missing chunk of code.
could add HAS_BOTO3 to the imports from ansible.module_utils.ec2 instead of manually setting
Catch botocore.exceptions.ClientError instead of Exception here too.
Just a matter of opinion, I don't like the strings symbolic_link, junction_point and hard_link. I would prefer: *symlink*, *hardlink* and *something* else for junction_point :-) The strings for Linux/Unix is *link* and *hard* which is also not optimal ;-)
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
Well, how do you determine which action was just run if you only return `changed`? The `state` is standard key which is expected to be return by any module. Please add it (`state=state`).
There should be period at the end of the `msg`. Check the other occurrences.
You are not returning `state` in any of the `exit_json`. You should drop the `status` as that can be determined from the `state` and the `changed` values.
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
Format this like this: ``` module.fail_json( msg='Error while performing wildfly operation', details=info['msg']) ``` The same anywhere else in the code.
Method name is deceiving, since the body of the method will only set a single attribute.
Is there a reason for first creating a JSON string and then parsing it? Why not simply do something like this: val = attr["mgr_attr_value"] payload = {"Attributes": {attr["mgr_attr_name"]: int(val) if if val.isdigit() else val}}
Bad name again, since body of the method only sets one attribute.
And again, why does this function go through string and JSON parser to get a dict? Last two lines are simply `payload = {"Attributes": attr}`.
Concatenating this way will produce bad path in `self.systems_uri` has a trailing slash. And `BootSources` is something that I cannot find in any of the recordings or in Redfish standard, so I must assume that this is something Dell specific again.
Capital letter at the beginning and dot at the end.
Capital letter at the beginning.
You don't have to quote the values in the list.
Dot at the end.
You don't have to quote the values in the list. And no spaces needed at the beginning and the end.
It's rarely appropriate to catch all Exceptions.
This should be more specific about the contents of the data structure that's returned.
Also, this will mean you need to `import traceback`
Is it possible to narrow the exceptions handled here? This loop could just keep retrying over and over for an error that won't be fixed by waiting longer.
The scenario is that, instead of list ordering (or if they want to check existence of something), they want to use a string-y key like `{{ my_lbs.load_balancers_by_name.myAlbName.someproperty }}` when they're listing several load balancers.
Same for other description.
```suggestion - The certificate in PEM format. ```
```suggestion - Optionally enable encryption. ```
```suggestion - Optional private key in PEM format. ```
For an info module you will only need the name as this will be the identifier. Please remove the other options
You should be able to use `self.vmware_test_platform` here.
This no longer accepts `VMWARE_TEST_PLATFORM=''`. The var be unset or set to worldstream or govcsim. This is probably fine, just want to note the change.
```suggestion self.vmware_test_platform = os.environ.get('VMWARE_TEST_PLATFORM', '') ```
```python # warn when failing to skip due to lack of support for skipping only some versions display.warning('Including test "%s" which was marked to skip for --windows %s but not %s.' % (target, ', '.join(skip_valid), ', '.join(skip_missing))) ```
task_uuid seems unused
This feels wrong because if it matters that we get inventory_hostname when using delegate_to then we wouldn't want to also use inventory_hostname in the non-delegate_to case... that probably means that this happens to make some test cases work but hte real bug is elsewhere (or we shouldn't have inventory_hostname in the else?) Would need to explore this more to understand what's actually happening here.
you should NOT use ansible_ssh_user directly, it might be the wrong var, play_context.remote_user should always be the correct one.
catch all exception should be avoided
No, I mean ``` except (vmodl.fault.SystemError, Exception) as e: ```
Also, add ```vmodl.fault.SystemError``` here,
We can use `urlparse.urlunsplit()` and `urlparse.urljoin()` here.
Could we use `vm` too, maybe as an alias. This is shorter, clear enough IMO and it's actually already VMware naming convention.
VMware may add new resources in the future and if we don't hardcode a list, the user will be able to use it without any update of the module. So I would prefer to avoid the `choices` key.
use ```from ansible.module_utils.vmware import get_parent_datacenter```
If we use `self.api_client` then this API will look like - ```suggestion self.datacenter_id = self.get_datacenter_by_name(datacenter_name=self.datacenter) ```
When the new iLO version is installed, this argument is not used. I think you should hint at this in the docs or use this argument to create the ssl_context in the new version. If I set ssl_version to TLSv1_2 I expect that a TLSv1_1 connection would fail, but that is not the case with this implementation.
So the default option in Ansible is named `validate_certs` and it defaults to 'yes'. So I would prefer we do it like this.
This needs to be: `type: bool`
`C(3)` could be used instead of `3`.
```suggestion if you add another one in your string, your prompt will fail with a "Timeout" error. ```
"Post the tags" is not very clear (and the fact it uses POST not interesting). "Perform assign/unassign action" ? More importantly I'd say a few words about what `tags` is.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
there could be a function to convert entire list, as this code is repeated below
you should not need to checked disabled, as the plugin itself wont be called at all if true
Not needed with AnsibleAWSModule
Ah, I misread that. Totally makes sense :)
Maybe you should put the `BEWARE` part into a new paragraph (i.e. a new list item in `description`).
It's probably better to put each requirement into its own item.
Yep - I'm not against the _notion_ that it be possible, it just shouldn't be possible _accidentally_. Most LUKS containers I've worked with only have one key on them, ever.
I don't know if I like this approach. I can't think of a time when this would ever be desired behaviour, and not a mistake - even so, I feel like we should require a force flag to remove the *only* key on a container, rendering it useless.
No longer need deepcopy
Imports for `ModuleStub`, `add_argument`, and `Command` should be able to be removed without consequence. `NetworkModule` and `NetworkError` are being imported by your modules, but they should probably be removed from here and the imports changed to network anyway, to clarify where the code is coming from.
Which transport type is used by RouterOS API? You can check [httapi](https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/connection/httpapi.py) connection type and implementation plugins for [nxap/eapi](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins/httpapi).
Provider spec is required to support connection=local type and is present in other network platform for legacy reason, in future local connection type for network module will be deprecated. As this platform is newly added supporting local connection type is not required imo and this spec can be removed.
Please rename it as `get_provider_argspec()` to be in sync with other platforms
Also, you could go for a generator comprehension with extending the command: ```python cmd += ''.join(' "%s"' % dist for dist in distributions) ```
```python cmd += ''.join(' "%s"' % d for d in distributions) ```
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
A generator expression is fine here. Just remember to use to_native instead of str(). ``` cmd.extend(to_native(p, errors='surrogate_or_strict') for p in packages) ```
I'd prefer ```python # a generator expression: cmd.extend(str(p) for p in packages) # or: cmd.extend(map(str, packages)) ```
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
I think this message should just be `botocore and boto3 are required for this module`.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
When returning output from boto3 calls, remember to use `camel_dict_to_snake_dict` to make capitalization consistent.
This `.close()` isn't needed, the context manager closes the file automatically.
No wrap needed.
Random musing. I wonder why boto3 isn't returning CreatedTime sometimes. I made a launch configuration in us-east-1 with ami-9be6f38c. It has a creation time in the console. Hm.
Can you make this something like: `module.fail_json(msg="Failed to create launch configuration", exception=traceback.format_exc(), **camel_dict_to_snake_dict(e.response))`? It will be helpful for future debugging.
No wrap needed.
No, you still have to check `HAS_BOTO3` (imported [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L229) and checked [here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/cloudfront_facts.py#L558) )
It seems network integration test is failing because of PR #47345, hence reverting the PR
```suggestion else: ``` I'm trying to make sure I understand what's happening here, will this change have the same intended effect? (I don't know if anyone else likes for-elses as much as I do, but it would allow you to get rid of the `ignore_line` sentinel variable)
I think this should be 'exit' instead of 'abort'
What is the reason to add second while loop here? Does the call to `recv_ready()` increase the delay amount. How about chaging it to ``` while True: if self._ssh_shell.recv_ready(): data = self._ssh_shell.recv(256) <--snip--> ```
It is not recommended to log commands executed on the remote device due to security reasons.
Maybe we can remove the `if min_version:`? min_version has a useful default, and if `min_version=None` is passed, it is OK to explode, from my point of view.
I'd prefer having the type specified for all parameters, like this: ```python argument_spec = openstack_full_argument_spec( service=dict(type='str', required=True), interface=dict(type='str', required=True, choices=['admin', 'internal', 'public']), url=dict(type='str', required=True), region=dict(type='str'), enabled=dict(type='bool', default=True), state=dict(type='str', default='present', choices=['absent', 'present']), ) ```
So the main reason for this is that it increases readability. If only the items that are required are listed like this, you can see with a glance which parameters are required. Same for default values. It's useful to easily identify the custom default values. (Just like PEP8, this is purely from a readability point-of-view) For the same reason we prefer lists to be alphabetically sorted, unless the order has a purpose.
So we tend not to specify `required=False` and `default=None` because that is the case by default. (Although we still like to state the type, even the default nowadays is "str") Some of these rules are codified, I would like the sanity tests to enforce some of this.
Allow filters ``` security_groups = cleanProtocol(cloud.list_security_groups(module.params['filters'])) ```
The CloudStack API accepts a resourcetypename parameter in the listResourceLimits endpoint. You could avoid the need to maintain this mapping if you used that instead of the resourcetype parameter. You'd just need to get the list from the docs, have them as choices in your module arguments and pass the chosen one directly.
probably extend the examples a bit to show how to use the return ```diff cs_resourcelimit_facts: type: instance account: moserre domain: customers delegate_to: localhost + register: limit_result + - name: print the result + debug: + var: limit_result ```
not a blocker but default=None is not needed because it is already the default and can be omited.
Perhaps we could add an example to show how to list instances (without filtering).
there is a missing condition for check mode
```suggestion short_description: Uses onesixtyone to find hosts to target ```
```suggestion version_added: "2.8" ```
please check developer docs for how to deal with required libs, this should not give an exception at this point (load) , it should happen at `parse()`
there is 'non AnsibleModule' version in lib/ansible/module_utils/common/process
Empty proxy-init doesn't make sense and should be removed.
I am probably wrong but I swear there was a case where we load the plugin even when it may not be used but I can't for the life of me remember what it could have been. Hopefully bcoca can let me know whether that is true or not. So if the above is true if requests was not in the try/except block and Ansible goes to load the plugin (even when the user didn't request it) then it will bomb out.
```suggestion - In case of Windows VMs, set C(ansible_shell_type) to C(powershell). ``` I am OK with current description as well.
```suggestion - pyvmomi (Python library) ```
```suggestion - Does not work with 'become'. ```
```suggestion - requests (Python library) ```
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If it is not required, you don't have to add `required: false`. This is implicit (and makes it easier to see what is required).
If the whole module was added starting from v2.4, you do not have to add that to every option. The options only required a specific version_added when the options have been added in a newer release.
list_all is not really a state
```suggestion - Allows a pre-defined MAC address to be assigned to the cloned VM. ```
```suggestion - This module creates clones for libvirt. ```
```suggestion - If the clone should be present or started - default present. ```
```suggestion required: false type: str ```
```suggestion - Will also define the VMs hostname. ```
Same, `device-mac` or `device-mac-address`.
I think something like `device-name` would be more descriptive.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
Find a better name.
```suggestion precedence over statically-configured ones. Only C(networkd) backend and C(dhcp4) ```
You don't need to specify `default: null` as that is the default.
```suggestion - When set to true, pool member FQDNs are instead resolved on service engines in this cloud. ```
typo of containing
``` default: true type: bool ```
``` - If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates. ```
Don't return the value as part of `ansible_facts`, this should be reserved for facts about the remote host (executing the module). We are getting facts on another resource that's not necessarily related to the executing host. Because these aren't stored as part of the facts we can shorten the name of the key. This is because there is no need to let them know this is Azure VMs, they already know because they ran an Azure module and registered the result. I would personally use `vms` as the key but up to you if you want to use another name. tldr: just do ``` self.results = dict( changed=False, vms=[] ```
`ansible_facts` are only used for specific host facts and not facts modules in general. The results should be returned under something like `azure_rm_aks` or something similar to that instead.
I would like to use a more python way: list comprehension and a `to_disk` method to construct the list.
You should fail here with `self.fail`. Currently you'll have `account_keys` as undefined if this exception is thrown.
there is no need to set a temp variable for `images`
You'll need: ``` python retries = sorted(list(retries)) ``` sort() is an inplace sort and returns None.
May be worthwhile to make lines 513-528 a method on the class, so strategy sub classes could override it easier. May also make it easier to write tests for.
Could this block (520-528) be a method on the AggregateStats class? something like AggregateStats.aggregate_custom_stats(data=result_item['ansible_stats'], host_list=host_list)
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
I think you need `to_native` here.
Very interesting. I haven't seen this happening for all my `letsencrypt` PRs over the last few weeks. I'll investigate a bit, this made me very curious :)
I found something: https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/dev_guide/testing/sanity/no-underscore-variable.rst Interesting... So the recommended name is `dummy`. I'll create another PR for `letsencrypt`...
This claims support of `check_mode` but then never checks for it in order to call `module.exit_json` without actually making changes.
A message string would good to say that image is not preset or something similar.
Instead of this function, there is Ansible built-in function - `get_bin_path` which does lot of other things and tested.
s/status is/facts are/ Since we are returning the facts, which also includes status.
This description seems redundant to me.
Please add `alias: ['trunk_vlans']` Bit confusing that the primary name is `trunk_allowed_vlans` though you use the aliased `trunk_vlans` in the examples.
If it is not required, you don't have to state it as it's the default.
The default value is "None", so this is not needed.
fail if `scope=user`. (root and scope=user are incompatible)
If we make `enabled` and `masked` mutually exclusive, this section of code is unnecessary.
```suggestion # Run masked_action when enabled param is not provided or service is supposed to be enabled/started. if not module.check_mode and module.params['enabled'] in [None, True]): ```
Line is too long.
Too long line.
I think this may read better: ```suggestion if missing_keys: ```
To apply the side effect, use this: ```suggestion mocker.patch('ansible.module_utils.network.meraki.meraki.fetch_url', side_effect=mocked_fetch_url) ``` You'll also need to update `mocked_fetch_url` to accept args, like: ```python def mocked_fetch_url(*args, **kwargs): ```
Are you only doing this to support Python 2.6? Those keys are already unique.
I think this approach might read simpler: ```suggestion new_galaxy_yml = dict.from_keys(optional_strings) new_galaxy_yml.update(dict.from_keys(optional_lists), []) new_galaxy_yml.update(dict.from_keys(optional_dicts), {}) new_galaxy_yml.update(galaxy_yml) ```
I learned recently that you can use actual separate literals to improve readability: ```suggestion @pytest.mark.parametrize(['url', 'expected'], [ ```
The usual idiom I see with these *Module type of classes is that they hold onto module in an attribute. I happen to think that's the wrong thing to do (as it leads to calling self.module.fail_json() instead of raising exceptions that are then handled at a higher level). But if you aren't going to hold onto module, you shouldn't pass it into the constructor. Instead pass in the specific parameters that you care about: ``` python def __init__(self, path, state, force, check_mode): ```
exception classes should be defined after impotrs and constants and before helper functions.
Are check, dump, and generate always needed? If so, consider making this an abstractbaseclass: https://docs.python.org/2/library/abc.html
I'm not certain that we want to name this *Module. Just from reading this PR it appears that it will be used more for managing keys and certs rather than managing a program (the ansible module).
You probably should do the opposite here. Set self.changed = False on object instantiation and then set self.changed = True when a change is performed.
Ok. We can work an clarifying the description if it is not clear enough. If you have any helpful suggestions as to how it could be less confusing, please share.
Please update the PR with an improved description rather than posting the question in the PR change. Thank you.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
I would return an explicit boolean flag which informs whether the plugin is activated or not (for `state != 'absent'`).
```suggestion for key, value in client.module.params.items(): ```
You should be able to use `self.vmware_test_platform` here.
I suggest: if parser.get('DEFAULT', 'vmware_validate_certs').lower() in ('no', 'false'):
Leftover reference to `vcenter`.
Verifying here that IP address and prefix are in correct format would be good. Look for APIs: `socket.inet_pton(socket.AF_INET, address)` and `socket.inet_pton(socket.AF_INET6, address)`
Missing `=dict` on this and the next few lines
``` auth_key=dict(type='str', no_log=True) ``` -> ``` auth_key=dict(type='str', no_log=True, fallback=(env_fallback, ['MERAKI_KEY']), ```
I prefer this: ```python host=dict(type='str', default='api.meraki.com'), ```
I'd go for: ```python output_level=dict(type='str', default='normal', choices=['normal', 'debug']), ```
Doesn't need to be quoted. We tend to only quote strings when it is required.
Lowercase yes :-)
i'm not sure that makes sense, if handler was not included, it would not be available for notification already. Since it should already add the conditionals inherited (only on import or include + apply) you should not need to check any other conditions.
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
same here, snake case, and convert value to lowercase
real sample value
maybe also should be described
boto3_conn, ec2_argument_spec, get_aws_connection_info are not needed with AnsibleAWSModule
remove `convert_to='int'`as it does not look like it can be converted.
Please change this to 1.1
this was wrong in the previous module, should be `'status': ['preview'],`
supported_by should be `community`
And you don't have to quote it.
The author string should be formated like `<name> (@<githubhandle>)`
AFAIR the flag is `failed`, not `fail`
```suggestion self.container = PodmanContainer(self.module, self.name) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
plz use string interpolation ```suggestion self.module.log("PODMAN-DEBUG: %s" % " ".join(command)) ```
even cleaner ```yaml - include_vars: "{{ item }}" when: item is file loop: - "{{ ansible_os_family | lower }}.yml" - "{{ ansible_distribution | lower }}.yml" - "{{ ansible_distribution | lower }}-{{ ansible_distribution_major_version | lower }}.yml" - "{{ ansible_distribution | lower }}-{{ ansible_distribution_version.replace('.', '-') | lower }}.yml" ```
you have to add 'vars/' to the find then, my option is not meant to work in all the same cases, but it is cleaner (IMHO) for the case presented.
This is not a good example, you don't need a loop if you are just going to do 'first found'. The `vars_files` is better in these kind of contexts as it already has a built in 'first found', which this example is not even using as you are really looking for each file alone and merging them all in the end via the loop.
they always were, most lookups don't take a dict as argument, older lookups, like this one, had created their own interfaces, most others use a 'single string' k=v space separated options (also something we are moving away from)
The `to_bytes` should be on the `self._basedir` instead: ```suggestion b_opath = os.path.realpath(os.path.join(to_bytes(self._basedir), b'r_group_vars')) ```
might as well get rid of any `required: false` and `default: null`s
it would require to have the content into a var e.g like with the slurp module.
Please make this oauth_token instead of api_token. This will provide some value to the end user in which type of api token and stay inline with the other modules. You will need to include the oauth_token below as an alias.
list_all is not really a state
DigitalOcean no longer has the v1 api online, actually this hasn't been online in almost a year. There is no reason to reference it in the notes.
```suggestion _vars_sources = {} ```
Note that we've moved to asking people to use literal notation for empty dict, list, etc a few years ago.
This is actually one reason you want to use `MutableMapping` over subclassing `dict`. `.get()` does not use `.__getitem__()` in `dict`. Both methods duplicate code for performance: ```pycon >>> class VarsWithSources(dict): ... def __getitem__(self, key): ... val = super(VarsWithSources, self).__getitem__(key) ... print(('__getitem__', val)) ... return val ... >>> v = VarsWithSources() >>> v['foo'] = 'bar' >>> v['foo'] ('__getitem__', 'bar') 'bar' >>> v.get('foo') 'bar' ``` Notice that `.get()` doesn't cause the print to happen. As such, your implementation as is will only work with some accesses of keys, and not others.
Cosmetic: ```suggestion ''' Alternate constructor to instantiate class with sources ''' ``` A bit more informative about what the method is intended to be used for.
You set `tr` here but don't do anything with it. The code will just continue along and probably fail at 366 `include_file = templar.template(include_file)` because `include_file` is None.
Well, I am mostly concerned with absent/present because that is a generic option used by other modules. Besides your examples use it as lowercase anyway. For the others, if the casing is important, leave as-is, but ensure you validate using strict casing as well, or users with casing-issues may get an ugly exception.
Please use lower-case for these options. YAML is case-sensitive, so it will appear in the docs as Title-case.
Not needed if you have a default.
No needed if you have a default.
This isn't needed if you have set a default.
Once we have a client, I don't think we need to handle this exception again.
This check is no longer required with AnsibleAWSModule
This should be enforced by the argument_spec, not sure how this would happen.
I worry that this will *cause* throttling as this is going to call repeatedly with no backoff until throttling occurs. Might be worth adding a short sleep before each retry at the very least.
You might want to use `type=ip_network` (then add from `ansible.module_utils.compat.ipaddress import ip_network`) for `ip_range`, in order to validate the value before using it. (value of `type` parameter can be a callback).
My concern about this really needing to be two modules, one for settings_facts and one for settings, has not been addressed.
It looks like the main return values are `id` and `value` from the Tower API, would be nice to have that in the docs here.
*be a string
@jainnikhil30 and I took a look at the tower_cli code which is backing this tonight and decided that tower_cli is trying to coerce the types from a schema that it retrieves from the tower server. So it looks like the module code does not have to worry about this conversion.
supports_check_mode still needs to be toggled to False
I'm ok with this change, however the additional formatting changes should be reverted. The current formatting meets our code standards.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
In other modules that support `authorize` we have some code here to check we are in the right context (privileged shell vs non-privileged). If you were to test the code with a task that requires privileged then one that requires non-privileged then I believe the current code would fail. `ios` supports `authorize` as well: https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/action/ios.py#L72-L86
Not required after above `load_provider()` change
Do we have PEP257 linter in CI? It should've failed here.
this is a property as well
This limits you to 1000 hosts where previously it iterated all the pages.
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
Both [`exit_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2254) and [`fail_json`](https://github.com/ansible/ansible/blob/ebd08d2a01d96d41f8bc1ccf27bc1bbf91060a44/lib/ansible/module_utils/basic.py#L2261) methods call `sys.exit`: the old code checked that `fail_json` has been called and would have failed if `exit_json` were called in `pip.main`.
Plz also use `match` arg here
In Ansible, we are ok with lines that are 160 characters wide. No need to wrap here. ```suggestion executable = module.get_bin_path(module.params['executable'], required=True) ```
I don't think returning `stdout` is necessary. _Maybe_ returning `stderr` could be helpful, but a better approach would be using `fail_json()` when an error is encountered and displaying `stderr` there rather than returning it by default. Also, it'd be nicer to use a literal here rather than a generator. ```python results = { 'changed': False, 'volumes': inspect_results, 'stdout': out, 'stderr': err } ```
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
Yeah, I think we need to improve the logic, to not just strip. But instead normalize the filename by checking if `f[0]` is `*` and then only stripping the first char, while also using `os.path.basename` to strip things like `./`. Maybe this instead: ```diff diff --git a/lib/ansible/modules/get_url.py b/lib/ansible/modules/get_url.py index 94d1d88dcb..574e4fbe63 100644 --- a/lib/ansible/modules/get_url.py +++ b/lib/ansible/modules/get_url.py @@ -514,7 +514,9 @@ def main(): for line in lines: parts = line.split(None, 1) if len(parts) == 2: - checksum_map.append((parts[0], parts[1])) + if parts[1][0] in './*': + parts[1] = parts[1][1:] + checksum_map.append((parts[0], os.path.basename(parts[1]))) filename = url_filename(url) # Look through each line in the checksum file for a hash corresponding to ```
```suggestion # checksum filename ```
I think we should just let this exception propagate. We aren't adding any value by catching it here (and might be removing value if the traceback were useful). This isn't code in ansible itself so we don't have to create a nicer error message either.
Please rewrite as ``` if __name__ == '__main__': main() ```
Kind of a nitpick since this is setup.py... but API-wise I prefer returning a small dict with the dynamic values and letting the caller merge it/copy the static dict if necessary.
you can use get_id_by_name, and don't have care about checking.
Actually someone can sent for example '123213321321321', which isn't valid name nor ID, so it will fail with HTTP 404.
Check this: https://github.com/ansible/ansible/pull/29175/files If you will do it the same we can close that PR.
call create, so we are sure the disk is up to date with parameters provided by user.
%s is not UP"
Please fix the trailing space and it's ok to be merged. Thanks!
Please remove, current devel branch is future 2.8 release, so we don't support plural anymore.
host_storage.type == otypes.StorageType.FCP
I would recommend to add `check_mode` for this module. You can check other modules in VMware space to see how it works for them.
In general your solution is good, but user will always have to specify wait=false, unless we fix it in API. But I am ok with current solution, so let's merge.
Needs a period at end of the description
Spelling. Should be "partition"
```suggestion - Status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - Status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - URLs to retrieve a public I(blob), I(queue), or I(table) object. ```
`default=True` (as it's a bool, not a string)
`default=True` (as it's a bool, not a string)
docs say name is required, spec does not
you just described check mode in general
We might not be able to tell the user that the organization exists, in the event that it does exist and they just don't have permission to see it.
plugins should not error on import, capture the fact that it is missing the library and exit on 'parse' also see ` from ansible.basic import missing_required_lib` which gives users specific information.
We can add this in a second PR. @WojciechowskiPiotr you could also keep this as a branch based on @morph027's with your changes as a new commit, then you can pull and rebase whenever @morph027 adds something, and later (once this PR is merged) create a new PR from your branch. Except, of course, if @morph027 already wants to include TLS support.
User of this inventory plugin should be able to use `v6_main_ip` for value of `ansible_host` (i don't know if it makes sens to be able to use `internal_ip`) or no `ansible_host` at all (meaning that `server['label']` will be used instead).
Rather than str, use to_text from ansible.module_utils._text to ensure compatibility with python 2 and 3: `to_text(option, errors='surrogate_or_strict')` Looks good to me besides that.
add_group creates and returns a 'sanitized' group name, to avoid warnings you might want to use `self._sanitize_group_name(name)`
```suggestion - Name of the package to install, upgrade or remove. - The C(all) package can be used to .... ```
Should have a default set to `present`.
Should become parameter `password` (with a backward-compatible alias). (See #20160 and #25398)
Oops, the following sentence is now redundant and can be removed: > A previous version may be specified C(name-0.9) to downgrade a package.
Yes, but this module doesn't run on machines where ansible is installed...
1) Is this the same as EOS & IOS's privilege mode? 2) Would a password ever be needed 3) In Ansible 2.5 we are moving to using the standard Ansible 'become` system to enter enable mode, though that requires `connection: network_cli`, which I don't believe you are currently using.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove this line. As this is a new module the top-level version_added is the only one needed.
Please remove `force:`
Please remove this line.
Perhaps it would be a good idea to display the actual `message` from `ImportError` also? Then you would actually get a better understanding of what was missing, instead of having to try and install everything.
I would propose to give the json paylod in the error message, as it would help for debugging
Two times boot_mode
This should set self._connected = True (not really needed right now but could have ramifications later) and also use display to print a message. For instance, this is what the docker connect plugin does: ``` def _connect(self, port=None): """ Connect to the container. Nothing to do """ super(Connection, self)._connect() if not self._connected: display.vvv(u"ESTABLISH DOCKER CONNECTION FOR USER: {0}".format( self.actual_user or '?'), host=self._play_context.remote_addr ) self._connected = True ```
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
Remove the "See examples."
Should be removed.
Remove duplicated line
If it's not required, you can leave out `required: false`.
Here's something wrong. If you want to continue a line, you shouldn't start it with a dash.
Remove the `try` block, it is unused.
This statement seems useless.
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
Not sure what exceptions could happen, but it may be easier for the end-user to debug if the exception is being reported to. ```python except: e = get_exception() module.fail_json(msg='Error connecting device. %s' % e) ```
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
Required: false is implicit and not required
This could use more explanation.
This shouldn't be `required: True` since realm may be provided instead.
This seems to be a leftover, there is no state "updated" anywhere else in the code.
When required is false, it can be left out (since it is the default).
How about: ```suggestion if not os.path.exists(file_path): continue ```
This is performing a job match against the artifact name. In order to filter artifacts based on jobs you need to use the timeline results and match the artifact `source` against the timeline `id` for a given job.
This probably reads cleaner ```suggestion return '/'.join(to_text(a).rstrip('/') for a in args + ('', )) ```
It seems like you could simplify things if you had an operator map and do smth like: ```suggestion import operator ... op_map = { '!=': operator.ne, '==': operator.eq, '>=': operator.ge, '>': operator.gt, ... '*': operator.eq, } ... pos = 2 if req[1] == '=' else 1 op_map(req[:pos])(LooseVersion(version), LooseVersion(req[pos:])) ... ```
I'd avoid such double negation + you can save some indentation here as well: ```suggestion if no_deps: return dependency_map ```
This protests if I only specify TargetGroupArn and only uses TargetGroupName (to then get the ARN).
I think this needs to move out one indentation level to match `Field`
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
Add `exception=traceback.format_exc()` here as well please.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
`is not` vs `!=`? I may not be polished enough on my python...
`is` tests identity in python so if statement always produces a change. We need to use `!=` here to compare equality instead of identity.
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
The reason is we don't really want to specifically call out relative paths as what they are relative to is determined by the setup of the remote system rather than anything under ansible's control.
Sorry, a few more minor clarifications after I read the related issue in detail. ```suggestion is equivalent to C(git clone [repo_url] [directory]). The repository named in C(repo) is not appended to this path and the destination directory must be empty. This ```
```suggestion is similar to C(git clone repo_url target_name). The repository ```
If we ever start generating the docs from docstrings, this will be problematic â RST uses double backticks for inline code, unlike Markdown.
You have `git>=2.19.0` in `requirements`
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
Please remove `required=False`.
Please add `, no_log=True`
It would be better if `AnsibleFortios()` was called before: availability of the dependency (pyfg) should be tested first.
It would be better to use another name, `forti_device` is already used in `module_utils/fortios.py` with another type.
Don't align things like this (it violates pep8 and is annoying if a longer thing gets added later)
this shouldn't happen (two succssive brackets at same level). Should be ``` argument_spec.update( dict( group_family=dict( ... ) ) ```
Don't align the parameters (also, as it's a dict, there should be no space between key, `=` and value)
`required=False` is not needed as it's the default
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
Guess you'll have to drop this line
we have existing byte/bit functions in module_utils
222, 223 and 224 can be changed into `elif self.state == 'present' and not snapshot_exists:`
Please add `, no_log=True`
I think this is a big usability problem that users will be upset about, as it's inconsistent with pretty much every other Ansible module (and not very usable in a declarative system), but it's your module. Very difficult to change that behavior later without a separate mode switch or breaking change.
Don't add this, we are deprecating this for modules that predate v2.4. So very soon all modules will have this removed.
All configuration values should not include default values, as that leads to accidental overwriting of existing configs that the end user did not expect.
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
Make this `elif`.
I wonder if this should be a boolean, or a list of options. My worry is that in the future this gets extended to more than two options, and we're stuck with having it as a boolean.
If a parameter is not required, you don't have to add this. This is implied, `required:` is only needed for parameters that are required.
Do this as a list, unquoted: ```yaml author: - Richard Levenberg (@richardcs) ``` Your email can go at the top of the file for the copyright.
This should be `type: bool` IIRC.
Not required ? Don't say so. This is implied.
The double backslashes are not needed here. They are actually unwanted.
How about - ```suggestion for key in ['title', 'description', 'index_prefix', 'creation_date', 'writable', 'default', 'index_analyzer', 'shards', 'replicas', ] if module.params[key] is not None: payload[key] = module.params[key] ```
```suggestion default: False type: bool ```
```suggestion default: False type: bool ```
```suggestion url = "/".join([base_url, index_set_id]) ```
```suggestion default: {'type': 'org.graylog2.indexer.retention.strategies.DeletionRetentionStrategyConfig', 'max_number_of_indices': 14} type: dict ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
This should be a string: ```yaml version_added: '2.4' ```
The description needs to have a trailing dot. (The short_description does not)
Same here, trailing do required.
This can be removed. If a parameter is required, there is no default.
The module has required options, but you don't provide any in this example.
`api_token` parameter is missing.
Other module haved aliased `oauth_token` to `api_token` since `api_token` is what's actually used in the code I think it makes sense to add the alias here.
docs, hint, hint. ~~~diff - "SSHKEYID": "5abf426403479", ~~~
the key is now `id` ~~~ "id": "5abf426403479", ~~~
this is checking the directory on the controller, not on the remote
Same as for other modules, use `Group has been updated`
Note that this won't work in the current forumlation of the modules (because the exception that check_libcloud_or_fail() raises goes uncaught in the module). I'll write more about that in the module, though, as that's probably where it will have to be fixed.
@abadger - is this the kind of thing you're talking about? * [change to module_utils](https://github.com/ansible/ansible/pull/17604/commits/bb8817ac1f7818c895abd51f6aff66d670766250) * [change to module](https://github.com/ansible/ansible/pull/19325/commits/f82888a62a89a42180babb44173d6eb3aab2978e)
@tintoy, yes that's about what I'm talking about. I'd probably put all that logic into a single function, though. So you'd call get_credentials(module) and it would first look in the module parameters, then the environment, and finally in the dot files (returning the first set that it found).
Suggest changing to `if 'tags' in host:`
Also, this results in a traceback for me. I think you want to do ... ``` python if 'ipaddresses' in host and isinstance(host['ipaddresses'], list) and host['ipaddresses']: ```
heads up, `r` is undefined.
Helper functions like this (Ones that don't use self. Ones that could be marked @staticmethod if they were part of the class). should typically be placed at the toplevel. So far I see to_safe, json_format_dict, and push.
I didn't notice this before but you have eval here... What is that for? It's rather dangerous as it means if someone can get code into the config file for the foreman dynamic inventory, they can then execute whatever code they want as the user running ansible. We should get rid of this if at all possible.
botocore.exceptions.PartialCredentialsError can also occur on connection creation.
code changes look good ... some look unneeded like the order of arguments above ... but not show stopper.
I don't think we can fail out on this without a deprecation cycle first.
boto3_conn now handles region problems, no need to do it in the module
Not required with AnsibleAWSModule
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
Values we return are in bytes.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
Please use `C(present)` and `C(absent)`.
Please remove the uppwer case C. We use `vcenter_hostname`, `vcenter_username` and `vcenter_password` in the other modules.
Please use `C(True)` instead of just `true`.
Could you write `Required if I(state=present)` instead.
The condition is a bit long, I would write it this way instead: ```python if perm.principal != self.principal['domain'].upper() + '\\' + self.principal['name']: continue if perm.group != self.principal['isGroup']: continue ``` This way, you avoid an extra level of indent.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive ```
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` mutually_exclusive required_together required_one_of require_if ```
Can be simplified if you do `type='int'`.
There are some options to `AnsibleModule` which you may be able to use to validate options passed in. Look at existing modules for examples: ``` required_together require_if ```
Can be simplified if you do `type='int'`.
same typo here WinTreshold -> WinThreshold
-> WinThreshold here too
We don't support Server 2008 with this module so this line isn't needed.
I'd use "determine if the file is transferred" - "influence" sounds like the setting could be overridden by another paramreter.
I would add a note saying this does not relate to the partitions file system formatting.
That should already be the case except where 'python stringification' takes place, ... which affects fields like Default but not most others. Removing the python stringification would make it match.
I'd like to not pull SEQUENCETYPE into this file but this one is a little tricky. A Mapping is an iterable and we have a separate conditional block to work with those. If we just check for collections.abc.Sequence then we wouldn't catch things like sets and keyview.... I think what we can do is put the Mapping conditional before this one and then change this one to ```if is_iterable(obj)```.
Oh sorry, that's a function that we've written ``` from ansible.module_utils.common.collections import is_iterable ```
~if not keeping encryption, remove the __ansible_vault key, just assign the value directly~ nmvd, misread the if to the opposite ...
It seems like no_log and deprecation are separate things and should be handled in separate functions.
Remove the two extra double-quotes here.
Seems nicer to infer private_zone if vpc_id is set. But not a blocker
`delete` and `create` are not valid states
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
This should succeed, since the goal state of `absent` has been met by the group not existing in the first place.
So if I update some parameter+ change state to running, it won't start, IIUC
Yeah, but does this code works well, when updating some attribute via that? As far as I read it correctly it doesn't.
So we don't wait for empheral VM? I think we should
1. That's issue of creating whole ephemral VM: https://github.com/ansible/ansible/pull/54453 With this patch empheral VMs+waiting works ok again. It was broken by template module, where I had to rewrote most of the things, so it worked, but there was just a bug. 2. Waiting for 404 could work. I used that in other modules. 3. Sure.
Also we should still call this in case of check mode, and say whether it will be changed
should the line start with `gitdir` or should it be in the end of line with smth prefixed? you might want to prefix the regex with `^`. On the other hand, taking into account that regexps are expensive, you could just use str.split or partition with bits of validation on top, like: ```python try: ref_prefix, separate_git_dir = data.split('gitdir: ', 1) if ref_prefix: raise ValueError('.git file has invalid git dir reference format') if not os.path.isdir(separate_git_dir): raise TypeError('%s is not a directory' % separate_git_dir) os.environ['GIT_DIR'] = separate_git_dir except (TypeError, ValueError) as err: """``.git`` file does not have a valid format for detached Git dir.""" module.fail_json( msg='Current repo does not have a valid reference to a ' 'separate Git dir or it refers to the invalid path', details=str(err), ) ```
Please dedent all the following code, so that it would be outside of `with`-block.
Also, in case of not match `gitconfig` would have `None` value, which would've broken this module in some place being executed later.
I would not assign it w/o validation: 1) it might cause errors happening in some other place, which would be hard to spot 2) it might be a weak place, vulnerable to injection attacks (security issue)
Please use `[ ]`: ```python result['changed'] = True ```
Instead of listing here, point at `ansible-doc -t conneciton -l` and maybe link to the connection plugins page, since this can change by installation.
use /latest/ instead of version specific, since we will eventually archive docs for older versions
If it is not required, you don't have to state this explicitly. (Makes it easier to see which parameters are required when skimming the list)
The problem here is that it has to be maintained outside of Ansible. Might be better to leave it as free-form (and make the module fail message give details).
All descriptions (except the short_description) end with a trailing dot.
Should be 2.4 (as we don't backport new modules to older releases).
A lot of the entries here should be in the description of each relevant option. This is for a high level overview of what the module does. The `notes` entry can also be used for info about the module if it doesn't fit in a option.
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
This should be removed an replaced with: ```yaml default: high performance ```
Not needed. The module is new in version 2.4.
this condition, and previous one, are complicated. partly caused by `set_data` asymmetry. can you first compute 2 vars with existing notes and new notes (using None or '' where missing), and then just check `if old_notes != new_notes:`? Also, please open manageiq-api issues for each read vs write format asymmetry in the API. There are too many of these :-(
here again, and below L332, "alert policy" is not alert but typo for alert profile
"new" may sound as "to be added", suggest "desired" instead.
I absolutely did misunderstand then. For the primary use case, I think we do want an Ansible call to create/update profile X with alerts A and B to make sure that only alerts A & B are associated with profile X. There is an edge case where we may want to surgically append/remove alerts from profile X, but I don't think it is critical to support this use case at this time.
as someone using this module, i would be surprised if the behavior when creating a new alert profile A, a separate unrelated profile B disappeared. a different way of saying this is if the product ships with profiles X and Y, then while creating a new profile A, i shouldn't have to provide (or know about) X and Y to the ansible module call when all i want to do is create/edit/delete my own alert profile A.
Not required, we already have method called `connect_to_api`. Also, I would recommend to use `from ansible.module_utils.vmware import PyVmomi` which base class for all VMware_* modules.
Not required as we can use connect_to_api method.
Remove redundant import
Add this at top after License. See example above.
missing import `from ansible.module_utils._text import to_native`
no need to specify required=False or type=str as these are defaults
I dont't have any resource and I get the following error: ``` Traceback (most recent call last): File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 139, in <module> _ansiballz_main() File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 131, in _ansiballz_main invoke_module(zipped_mod, temp_path, ANSIBALLZ_PARAMS) File "/home/goneri/.ansible/tmp/ansible-tmp-1562681655.5490832-209270742247135/AnsiballZ_vmware_content_library_info.py", line 65, in invoke_module spec.loader.exec_module(module) File "<frozen importlib._bootstrap_external>", line 728, in exec_module File "<frozen importlib._bootstrap>", line 219, in _call_with_frames_removed File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 143, in <module> File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 137, in main File "/tmp/ansible_vmware_content_library_info_payload_z7gmsr1d/__main__.py", line 105, in get_content_lib_details File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/com/vmware/content_client.py", line 744, in get 'library_id': library_id, File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 317, in _invoke return self._api_interface.native_invoke(ctx, _method_name, kwargs) File "/home/goneri/.virtualenvs/ansible/lib/python3.7/site-packages/vmware/vapi/bindings/stub.py", line 275, in native_invoke self._rest_converter_mode) com.vmware.vapi.std.errors_client.NotFound: {messages : [LocalizableMessage(id='com.vmware.vdcs.cls-main.validate_id_not_found', default_message='ID content_library of resource type [com.vmware.content.Library] not found.', args=['content_library', 'com.vmware.content.Library'])], data : None} ``` I think it would be more Ansible-ish to return an explicity `msg` key. This way, the users won't have to set `ignore_errors`.
How are the `user_details` used by the caller here? It looks like it's embedded in a string.
Like above, I think this should be `userid, name, password, group, email`
```suggestion datastore_id = self.pyv.find_datastore_by_name(datastore_name=self.datastore_name) if not datastore_id: self.module.fail_json(msg="Failed to find the datastore %s" % self.datastore_name) ```
Actually, my formulation is closer to what happens in Python2 as well. ```objects.items()``` on Python2 creates a list whereas mine creates a tuple. (and the code in this PR creates a new dict).
This may not matter if objects only has a small number of entries in it but this is inefficient. This creates a copy of the dict which includes overhead for the dict's record keeping (hash tables and so forth) when you really only need to have an iterable of the keys and values. So it's better to keep a copy of objects.items() instead of a copy of the dict itself. You can do that like this: ``` python for k, v in tuple(objects.items()): parent_dc = get_parent_datacenter(k) if parent_dc.name != self.dc_name: del objects[k] ``` [*] Note, ```del objects[k]``` should achieve the same thing as ```objects.pop(k, None)``` in this instance. I like del when simply trying to remove a known key from a dictionary and pop when you want the value back. (pop is also useful when you don't know if the key is present in the dictionary to begin with as specifying the default value a the second arg means it won't traceback if the key isn't present). I don't consider this a blocker as I don't know if objects could ever be big enough to be a problem. I'll go ahead and merge this on Monday if I don't hear back from you. (And you can always fix it in devel but not backport it if you like the efficiency but don't think that it's important enough to backport).
It looks like you guys are okay with changing this down the road rather than immediately, tough, so I'll go ahead and merge this for 2.8.4. Thanks for looking at it.
Thanks @abadger, I'm testing the patch that you suggested https://github.com/ansible/ansible/pull/60476.
remove un-used variable.
Thanks, that's the point I want to get. Your code is consistent among 2.x and 3.x, because `for line in f` returns `line` consistent with `r''`.
This portion is wrong. On python3 it doesn't do anything (because line is already text). On python2 it makes a byte string pattern compare to a text string. If there's no nonascii characters I think that will work okay but it will definitely fail to do the right thing if nonascii does creep into the data.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
If it is not required, you don't have to add `'required: False`.
If it is not required, you don't have to add `'required: False`.
I would change this whole block with something like: ```python units = list('b', 'kb', 'mb', 'gb', 'tb', 'pb', 'eb', 'zb', 'yb') try: multiplier = 1000**units.index(unit) except ValueError: units = list(None, 'kib', 'mib', 'gib', 'tib', 'pib', 'eib', 'zib', 'yib') try: multiplier = 1024**units.index(unit) except ValueError: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
Why shouldn't a try/except block not be used ? I'm intrigued.
Both are fine IMO, there's nothing wrong with doing presence-checks either. I'll let you decide.
Make this: ```yaml type: bool default: 'no' ```
ditto about s/no/'no'/
ditto about s/no/'no'/
This needs a trailing dot. The style police is watching...
If the present/installed options are the same, I'd rather just allow present/absent unless there's a compelling reason to support both.
```suggestion version_added: '2.8' ```
Ansible 2.8 isn't supporting Python < 2.6 anymore, so this line is no longer needed.
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Shouldn't have `required: true` for things that have a default.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
It's more about doing it step-by-step. It should be the first step, yes. Yet, it now feels like the entry point got spread out across multiple places. It's fine to keep it here for now. I don't want to be overly nitpicky. It's probably good enough for the first iteration.
1) There's no need in initializing this outside of the `PodmanContainer` class 2) Please use dict literals over the contructor style
Please stop calling `get()`
You could as well just call `exit_json` in `execute()` since you're already not using functional approach.
The functional approach is having functions returning values and not storing a shared state between different parts of the processing flow. It's fine to use the object-oriented style, it just doesn't feel right when you combine different style and it looks like a weird soup mixture. I like the code to be elegant, readable and maintainable. That's why I tend to be so nitpicky...
Is this for Python 3 compatibility? I don't see what might raise a TypeError. It doesn't look like any of the list-type parameters take dict or mixed type elements.
copy-paste issue: we should talk about **realm** object here, not a _client_. To be globally replaced in this file...
ditto `s/client/realm` :wink:
Little :bug: : In **check** mode, the `keycloak_realm` always returns `result['changed']: True` You need to add something like `result['changed'] = (before_realm != updated_realm)` here...
ditto `s/client/realm` :wink:
Please use add `type: bool`
Please add `type: bool`.
Please check if this is still valid for `icx` parameter since current release is 2.9
Please check this.
Please remove this line.
Similarly, this option is highly `network_cli`-specific, so much that I'm pretty sure `netconf` doesn't even need it. This should go back to `network_cli`
@mikewiebe this will only work if command_timeout/connect_timeout is set as ENV var, but won't work if someone sets the timeout in ansible.cfg within `persistent_connection` section. You can do the following instead. ``` + +from ansible import constants as C from ansible.module_utils.network.nxos.nxos import load_config, run_commands from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args from ansible.module_utils.basic import AnsibleModule @@ -131,6 +133,8 @@ from ansible.module_utils.basic import AnsibleModule def check_ansible_timer(module): '''Check Ansible Timer Values''' + command_timer = C.PERSISTENT_COMMAND_TIMEOUT + connect_timer = C.PERSISTENT_CONNECT_TIMEOUT ``` This takes care of both the scenarios.
These will need to be module parameters if they need to be configurable. Constants are not available to modules.
Modules do not have access to get or set configuration values. An action plugin should be able to check the configuration before invoking the module, but I don't think that is something we're doing with any other modules currently. You may want to bring this up in tomorrow's Network Working Group meeting on IRC to see what thoughts the network team has on this.
doc typo, s/funcition/function
Will fail if `self.systems_uri` is not set yet.
Will fail if `self.manager_uri` is not set yet.
Not catching non-200 responses.
Not catching non-200 responses.
This will fail if `self.accounts_uri` is not initialized.
``` from ansible.module_utils.common.process import get_bin_path ```
i would use the find bin function and not assume it is in path
use to_text , as that is more portable and does not make encoding assumptions to convert to unicode strings
This has to be done only once, since the binary is always the same (`docker-machine`).
catchall ignore ....
It might also be no IGWs found here.
facts modules can trivially support check mode (#23107)
Can that raise a ClientError? I don't think boto3 verifies the connection like boto does when it's first created.
To match style in other AWS modules, can you please use `policy` to take a "json" typed argument and a mutually exclusive `policy_file` argument to take a file path? That way users can specify a JSON string, a regular YAML dictionary, or a file from another source so they have the maximum flexibility.
Please add a message like "Failed to connect to AWS due to wrong or missing credentials" rather than just `str(e)`
The grow and shrink booleans are used for allowing to grow and shrink the image. (That is why they default resp. to true and false). So you have to compare the original size against the wanted size, and if it shrinks and shrinking is allowed, only then should it resize (otherwise it needs to escalate). Similar for the grow-case.
The final command should probably return its stdout, stderr and rc back to the playbook.
You could make the unit mandatory (which is what I would do), or you could allow no unit (which means in bytes) and in that case you will have to consider that case as well. (i.e.if unit is a digit)
There is a much easier way to do this, by using the index in the list. Something like: ```python unit = size[-1] units = list('b', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') try: multiplier = 1024**units.index(unit) except ValueError:: e = get_exception() module.fail_json(msg="No valid size unit specified. %s" % e) ```
The mixup to me is that people using incorrect units will silently be using bytes, whereas it should report this as an error.
Why can't we just use `SHOW` to check if the parameter is set to the correct value? Not supporting check mode is a big limitation for this module which for me it would make it useless. Postgres is usually a very I important so I should know what changes are going to be made on it, before they are made.
It's totally fine that it works in check mode, but doesn't work in normal execution. I know that lot of modules work like that. What is important is that it tells you correctly will it change and what will change.
Maybe it's better to return `value` and `value_pretty`? Or `value_bytes` and `value`. We should try to make it as easy as possible on the user. For example in Postgres you usually use byte values with a suffix, so it should be easy to use it like that in the module. For example if I want to compare values I shouldn't bother with units etc, just compare my value to the registered value.
Values we return are in bytes.
I would also detect if the value is a bool and set it accordingly to `on`/`off`.
Ditto about the deprecation notice
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
`required: false` is not needed.
Ditto about the deprecation notice
This will need to be version `2.10`.
needs to be a string, "2.7" otherwise it will be used as a float and not fare well in comparissions
missing ini option for host
`key: write_csv` should be `key: write_files`
`Telemetry data not capture` to `Telemetry data not captured.` as per below.
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
This can be moved to `check_dict` method.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
You are using resetMonitor URL in deleteMonitor API
Lines don't need to be wrapped so short since we allow up to 160 characters.
Use a `main()` function for the body of the test.
Seems like this should either be ```b_missing.append(b_path)``` or ```missing.append(path)```. I don't see missing being compared or combined with any other strings later, so it may be that the latter is fine. Then again, it may be confusing to have a single variable which contains non-byte paths so it might be more readable to use the former.
this is unsafe and can lead to race conditions and data corruption, you should write to a temp file and use `basic`'s `atomic_move` method to finalize changes.
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
Even if you look at it in detail, these things are easy to overlook - when you wrote them yourself. This is why it's good to have someone else read docs as well ;)
```suggestion - List of tables in the publication at the end of runtime. ```
```suggestion sample: false ```
```suggestion """Add 'public.' to names of tables where a schema identifier is absent ```
`module_utils.postgres.HAS_PSYCOPG2` could be used here.
This needs to be addressed.
Not really as there might not be any `[0]` and if there is there might not be any `uuid` in it. The right way of checking that is: ``` if len(json_output) > 0 and 'uuid' in json_out[0]: return ``` There is no need for `else:` as the default return value is `None` which is what we want if it fails.
I would prefer if the function would return `None` instead of empty string. Then do the appropriate test for `is None` on the return value of the function. The same applies to all functions in this module.
The `stderr` should be used in the `exception=stderr` keyword. The same applies to all places where you use `stderr` in this module.
you should use the find_bin function to get vmadm and not rely on it being in PATH
Ok, there are a bunch of these that need addressed, to index your format string for py2.6 support.
`raise` is missing. Call to `str` is useless there.
Isn't `raise` missing there ? Calls to `str` are useless.
`merge_dictionaries` is called twice and each time with 2 dictionaries, this method could be removed and `dict.update` could be used directly.
`default=None` is the default, can be omitted
Please verify, before push. `required_of` -> `required_if`
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
Please remove `required=False`.
That `__metaclass__ = type` line in the top of this module turns all classes into new-style automagically. So you don't need to inherit from `object` explicitly anymore. ```suggestion class PodmanManager: ```
Please use verbs in method names. Like ```suggestion def _perform_action(self, action): ```
I recommend you reversing this into a "guard expression" style: ```suggestion if rc == 0: return json.loads(out)[0] ``` And then you can reduce the nesting of the whole block of code which improves readability.
Maybe ```suggestion return bool(self.info) ```
Please don't use inconsistent return values throughout the function. Currently, you use `NoneType` and `bool`. Use just one type. This is unnecessary. ```suggestion ```
@gforster Beware you broke YAML there ! But I put your suggestion into mine.
Ah! thanks for the catch. I need to be more careful with this editor.
```suggestion -The module installs software using nimclient command, removes software using local commands, and updates all software to latest available version. ``` Oxford comma for clarity
```suggestion - The state of the fileset or nimclient to be. type: str ```
```suggestion choices: [ absent, allocate, commit, deallocate, installed, present, removed, reset ] ```
I don't think the `+` applies, if I read COPYING.
Are both lolcube and bsod your github accounts? If not, please only use lolcube, as otherwise bsod will be informed for every issue and PR related to this module.
`rsa1` is indeed the old, deprecated (but still supported on some platforms...) format for RSA keys.
And out of curiosity: what is `rsa1`? The ssh-keygen on my machine does not know about it (`unknown key type rsa1`); I've got OpenSSH_7.8p1 installed. From searching the internet, it looks like `rsa1` is a SSHv1 RSA key (and thus deprecated, as the whole SSHv1 protocol). If that's correct, you might want to mention that, and that not all implementations support it.
Use `C(ssh-keygen)`, and also `... generate C(rsa), R(dsa), R(rsa1), C(ed25519), or C(ecdsa) private keys.` to improve formatting.
type='str' is a default value, not require to explicitly mention it
Can this be added in agrspec as choices as well? Probably by having this list as a global variable.
`load_config` doesn't return anything https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/ios.py#L121
type='str' is a default value not required to mention in separately.
Why `dict(required=True)` is added here? It is already part of the spec.
Looking through the code more carefully, I think this change is correct. We should only being using `hostnamectl` where we pass it flags to return _only_ the hostname. That is currently the `SystemdStrategy` class. Otherwise the value returned from `self.hostname_cmd` would be not at all what we expect. I don't think having this conditional buys us anything, nor does it help with backward compatibility.
This was kept here for backward compatbility - https://github.com/ansible/ansible/pull/59974/files#r313368633
All these methods can be clubbed into a single method that takes data and pattern string as arguments and returns the match else None
No longer using a temporary file. This issue is resolved
Yeah, a list is fine.
Use `get_bin_path()` to ensure we always can find the command in case the path changes. ```suggestion vm_stat_command = get_bin_path('vm_stat', True) rc, out, err = self.module.run_command(vm_stat_command) ```
Is there a reason to sort this? Since we're just putting it into a set (to uniquify the list I assume) it doesn't seem necessary to sort. Since we're just iterating over sd_instances, a frozenset is more appropriate than a set.
Does the check module.run_command() through the transformation into smbios_dict have to be inside of the loop? It seems liks we could do that outside of the loop to be much more efficient.
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
Right -- it shouldn't be needed because splitlines() will remove all "\n".
This doesn't currently appear resilient to missing collection(s) in the group's list (eg, you only have `amazon.aws` and not `community.aws` available).
I guess this one's not as obvious because of the "pre-chewed" format, so `action_group` isn't the right name for the current impl either...
personal preference, but since we only want to do the work once based on the result of a looped query, I usually write those things as an explicit query predicate, eg: ``` if any(name for name in redirected_names if name in action_group): tmp_args.update(...) ``` this form also stops the iteration once we know there's work to be done. You could accomplish the same in the existing form by adding a `break` after the update, but IMO the existing form is less clear that you're not really looping over the side effect.
Doing this inline is OK for beta- it makes the feature function, but it's a performance problem. Post-beta, we'll want to move most of this to an intermediate lazy indexing process during playbook parsing when a module_defaults clause references a group, where we'd build that global "sieve" I was talking about for O:1 lookup. At that point, we can probably get rid of the transformation in the collection metadata canonicalization phase entirely and just store it plain.
```suggestion 'community.crypto': 'acme', ``` With this, my tests actually work :)
No line break.
Don't need to add the line break here. Line length needs to be less than 160 characters and this is well within.
Don't use `boto.connect_ec2` directly - use `connect_to_aws` - otherwise things like profiles, security tokens etc. don't get properly passed.
Use fail_json_aws for AWS exceptions as the messages contain a lot more info
This will fail for creation of the new subnet group. Shouldn't fail for not finding CacheSubnetGroupgroup, instead it should pass.
disks = self._module.params.get('disks', list())
you can use: ``` storage_domain = self.param('storage_domain') ```
Can we somehow implement behavior of specify storage_domain for all disks? If I understand the code correctly, it not currently.
Better to use ```get_id_by_name``` it get proper error message if storage is not found
Hmm, what if the template will have more disks. We have to somehow distinguish which one should go where...
`Description` (capital letter)
`Bigmon access token. If this isn't set the the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.`
Please remove this line
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
`required: false` is default so you can remove this.
```suggestion changed = False if not module.params.get('size', False): module.fail_json(msg='Size is required to update volume') ```
```suggestion msg = 'Initiator {0} removed.'.format(ini_id) module.log(msg=msg) ```
```suggestion raise Exception ```
```suggestion msg = 'Added initiator {0}'.format(ini['id']) module.log(msg=msg) ```
```suggestion module.fail_json(msg='Initiator {0} remove failed.'.format(ini_id)) ```
Typos, should be: `The ID or Name of the Hetzner Cloud Network.`
This information is redundant, I would remove it
Suggestion: Create, update and __delete__ cloud subnetworks on the Hetzner Cloud.
An `EXAMPLE` of labels maybe good so people know the structure
Suggestion: Manage cloud subnetworks on the Hetzner Cloud.
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
```suggestion return super(cls, new_cls).__new__(new_cls, *args, **kwargs) ```
I'll have to look into this more. I'll find out more tomorrow when the author gets back from PTO.
I don't believe this is correct. `args` and `kwargs` need to be passed to class when it is instantiated. This should probably be `*args, **kwargs`, though.
I know this is what it done in `load_platform_subclass()` but that looks incorrect as well.
We support python-2.6 and python2.7 (and python3.5 and above) in controller code (which this is). For modules we support python-2.4 and above unless there's a dependency that requires a newer version of python.
Yeah, a list is fine.
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
and convert filename to bytes again.
Hm... How about then introducing a prefix for such settings at least for this module? So, if user wants to provide binary data to be stored in property, they'd have to say, e.g. 'B64:blah' (where blah would be base64-encoded data). Caveat being that if users wants to store string which starts with B64:, they'd have to do something along the lines of B64:QjY0Og== (QjY0Og== being base64-encoded B64:, I think you get the picture :) Now, truth be told, not sure if this would be more acceptable for Ansible as project, but I'd see it as more consistent. Maybe second opinions on this could be useful too :)
I would add `check_rc=False` anyway, to make clearer your intention that you accept non-zero return codes.
What will happen if `ssh-keygen` outputs something different (like not a valid file)? This will probably break.
`state=absent` requires a *lot* of additional arguments which are not needed: `{"changed": false, "msg": "missing required arguments: type, signing_key, public_key, valid_from, valid_to"}` These arguments should only be required when `state` is `'present'`. Look at the `required_if` parameter of `AnsibleModule()`.
I created a PR for `openssh_keypair` in #50106.
Move this up to before line 2641 so that the diff is returned in check mode.
```suggestion 'after': '{0} removed\n'.format(user.name), ```
Exception handling here too.
You have the 'check_client' function to figure out if the requirements are present, but never actually use it, so the module fails on in import exception. I recommend you place a call in the class init so you dont have to remember to call it in every module.
Like above, I think this should be `userid, name, password, group, email`
This break will be unnecessary if the loop gets dropped
Why the loop here? `if match` should be sufficient
This is not py2.6 compatible. You will need to index these.
We have recently made a decision that lookup should explicitly enumerate kwargs, instead of accepting splatted `**kwargs`
that won't work with config values
`self._url` is hardcoded (to `"/jsonrpc"`) in `login()`, sent through `to_text()` here, and also stringified on the immediately preceding line of executing code. on the next line of executing code. Is there any particular reason for all this, or would it be just as clear to do this instead? ```suggestion response, response_data = self.connection.send(path='/jsonrpc', data=to_text(data), ```
I'm not sure what the point is to assigning a class with only static methods to an instance variable. (For that matter, it is not clear to me why this is a class at all, but that seems less confusing)
If you're only going to get `APSCOOKIE_` _or_ `ccsrftoken`, then you can just return `None` if you don't find anything and the existing token will be reused. If you are expecting to have both, then I would just dedent the next line to be outside the for loop, so that the token is always added to the dictionary on every run. Then you should be able to at least remove the manual headers building in `send_request`.
The return value is not strictly cookies. The return value is a dictionary of headers
we want want -> we want
I would prefer the syntax `[7, 8]` comma separated can be confusing
please remove logging due security concerns
many modules have the default of `state=present`. consider this as a default if you feel it make sense.
All descriptions should be full sentences, e.g start with a capital letter and end with a full stop.
new_X is a bad pattern, if you have a unique identifier a comparison of account_id supplied vs existing should determine if this changes or not
It'd be good to include a default sleep here so this loop doesn't continuously hit the oVirt endpoint. Even just a one or two second sleep would be fine between tries.
we want want -> we want
Great, thanks for putting this check in here.
Which state the entity should have after executing the action can be specified by passing `wait_condition` parameter. -> State which the entity should be in after execution of the action can be specified by `wait_condition` parameter.
Additional task can be executed before action on entity is executed by passing `pre_action` parameter to method. Another task can be executed after action is executed, by passing `post_action` parameter to method. -> Task executed before an action on entity can optionally be specified in `pre_action` parameter. Task executed after an action on entity can optionally be specified in `post_action` parameter.
@kaneda-fr its a direct network. is there anything in particular you'd like me to pull for you in the config. i will warn you, i'm very new to VCD and pyvcloud so this is me trying to get to where i'm not just using the gui all the time. I did not set this up, it was already configured. are you in the irc channel? if so i am xaeth
So we figured it out. As long as we setup the vapp template to have no network configured in it then it works :)
For this module there are 3 network types supported: * static * pool * dhcp Looking at the pyvcloud.vapp library it appears that the supported modes are: * pool * dhcp * manual * none I tested changing from static (which is what matches the UI) to pool, and it appears to have worked. This block doesn't do anything if network_mode is set to static, which is why mine was failing i think. You may have already covered this in your upcoming patch but i figured it would be good to point it out.
move this line 1028
no need for `.keys()`. `if property_id in vapp_properties_current:` is the same as `if property_id in vapp_properties_current.keys():`
In the code, you enforce setting all 3
I would simplify this by saying the list order is the order of actions to take, i.e. first entry is the first action and so on.
I would omit the 3, it seems like in the internal API you can set as many recovery actions as you want. It's just the GUI that limts to 3.
You could fix #19781 real quick right here :D
Would be good to specify the name of the feature as shown in `Get-WindowsFeature`
Need a space here
Need a space here
How about: ``` if versioning is None: pass elif versioning and versioning_status.get('Versioning') != "Enabled": ... elif not versioning and versioning_status.get('Versioning') == "Enabled": ... ``` To reduce the nesting level a little bit.
I've refactored around here to remove the duplication, which should make this a bit cleaner.
Please add the traceback to this message with `exception=traceback.format_exc()`
What are the properties? * As other modules, we flatten the properties in the ansible module's parameter. * And for the second level of dict type, we can use `options` to specific another spec to define the key-value pairs in the dict. Like ``` py props_spec={ name=dict(type='str') } self.module_arg_spec = { props=dict(type='dict', options=props_spec) } ```
Is 'the name used in the DNS prefix' check required to create the traffic manager? Or the error is already handled by the create API? If so, I don't this this logic is needed here. If it is required, it should be include in check_mode
Make a method to determine constructing dict from which object will be confused
Fail here make the process exit, but we need to create it if the state is present
Duplicate with `get` method? This logic can be handled as `if get_traffic_manager_profile`
Thanks, that's the point I want to get. Your code is consistent among 2.x and 3.x, because `for line in f` returns `line` consistent with `r''`.
This portion is wrong. On python3 it doesn't do anything (because line is already text). On python2 it makes a byte string pattern compare to a text string. If there's no nonascii characters I think that will work okay but it will definitely fail to do the right thing if nonascii does creep into the data.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
Need to `return bind_mounts` here
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
We like to separate out our imports as stdlib imports, stdlib from imports, blank line, 3rd party libs, blank line, ansible.module_utils libs. So it will look like this: ``` import collections import json import logging import os from copy import deepcopy from ansible.module_utils.basic import AnsibleModule ```
Note: We do have a copy of the six library bundled in ansible module_utils so you can use that to aid in py2/py3 compatibility: ``` python from ansible.module_utils import six ```
I think we should avoid usage of the future library. It tends to override the way python works globally which could cause problems for other libraries.
Do not use unicode_literals. It makes it harder to read code rather than easier (because not every file uses unicode_literals and then you have to first check the top of each file for whether it's present and then context switch mentally.)
List of Names & GitHub IDs please ``` author: - Nicolas Thomas (@thomnico) - Miguel Angel Munoz (@mamunozgonzalez) ```
```suggestion b_password_string = b"|".join((br'(\w+\'s )?' + to_bytes(p.format(**self._fields))) for p in prompts) ``` `.format` requires splatting the dict, instead of just the dict itself
This should be `b_output_path` to indicate it is a series of bytes. Even if the caller is sending in bytes, this function should convert it to bytes just like `b_collection_path` at the beginning. That allows our `b_` naming convention to hold, making this code look incorrect (trying to join `bytes` and `str`).
Can this use `b_output_path` from line 291? ```suggestion b_output_path, ```
This should probably be `docker.exec_command()`
It probably makes sense to clean-up flags before exiting this method.
```suggestion array = module.params['force_array'] or (values is not None and len(values) > 1) ``` to avoid ambiguities when reading
Lines 203-205 could be replaced with: ```suggestion current_values = current_values.split("\n")[2:] ```
If config_source is only used in combo with direct, whichs looks to be the case, it may make sense to collapse it into one arg (config_source). Then GConfTool2.__init__ could: ``` python if config_source: self.base_command += ["--direct", "--config-source", config_source] ``` That assumes there won't be a scenario where it makes sense to call 'gconftool-2 --direct' or 'gconftool-2 --config-souce some_config_source' independently.
ditto as `required_if`
I think for this case, this should work: ``` python required_if = [('state', 'present', ('value', 'value_type'))] ``` But haven't tested that...
`Could not recursively set attri...`
This one still needs to be swapped.
```suggestion for modulesubnet in modparams['SubnetIds']: ```
I think `if props is not None` is more conventional :smile:
See elb_application_lb for an example
The comparison doesn't work even for valid values. I've run the following commands: * `openssl x509 -noout -modulus -in m.ansible.com.crt | openssl md5` * `openssl rsa -noout -modulus -in m.ansible.com.pem | openssl md5` * `openssl req -noout -modulus -in m.ansible.com.csr | openssl md5` They all output the same md5 meaning they're all valid for each other yet this test fails. I'd guess the content of the object needs to be compared, not the object themselves
Read operation: ditto
Replace `csr` by `csr_path`, also change the type to `path`
Read operation: ditto
Update type to `path`
Yeah, looking at the code, I remember this.... the output phase was really, really screwed up before (intertwined with the data processing phase) and we were on a deadline so I didn't fully decouple the output phase when I restructured the run() method. There should be another explict phase (processing) here: https://github.com/ansible/ansible/pull/72359/files#diff-9732216f79978750789dbeb4c2ed1280d841c4211306ecb1b5c70e3db3fcb2f7R263 All of the generation of the stuff in the generate extra data section of `format_plugin_doc` should go into that phase.
We use term `mapping` here.
You probably don't need `{}` fallback anymore.
In the end, unsure this should cause an error, the following would fix and continue working: `if metadata and 'removed' in metadata.get('status', []):`
display.error already prepends an `[ERROR]` , so it is redundant to add more
It's more about doing it step-by-step. It should be the first step, yes. Yet, it now feels like the entry point got spread out across multiple places. It's fine to keep it here for now. I don't want to be overly nitpicky. It's probably good enough for the first iteration.
AFAIR the flag is `failed`, not `fail`
Falling back to `None` is not helpful here ```suggestion self.executable = self.module.get_bin_path(module.params['executable'], required=True) ```
I'd maybe even move that outer `if self.image` into this function and this line below. They don't belong to this abstraction layer.
```suggestion self.container = PodmanContainer(self.module, self.name) ```
Please restore, or the module will fail to work in v2.7+
Please restore, or the module will fail to work in v2.7+
This ought to become: ```python route_control=dict(type='list', default=['export'], choices=['export', 'import'], aliases=['route_control_enforcement']), ``` Then check whether the value it not None, and does not equal ['import']. The parameter description then would state that the value is either export, or [ export, import ]
End with a dot.
Do the same for other descriptions.
The term is "Azure Container Service", "instance" is not in the term, no need to capitalize it
Azure Container Service(ACS)
no Instance refer: https://docs.microsoft.com/en-us/azure/container-service/
`required: false` is the default value, we can omit it here
the overall docs `required: yes` should only be set for options that are always required. For ones that are only required based on another option value this should be noted in the description of that option like ``` - This option is required when I(state) is C(present). ```
You could convert things to int right here: ```suggestion requests_version = tuple(map(int, requests.__version__.split('.'))) ```
And then this check would be way more readable: ```suggestion if requests_version < (2, 14): ```
It'd be nice to hint users about what version is not old.
We should probably explicitly `to_text` it ```suggestion self._display.warning(to_text(msg) + u' Disabling the Foreman callback plugin.') ```
So yeah, the callers that I see are fine. You should be able to simply remove to_text() here.
My bad. Didn't see if in later stages.
You are not executing command returned by `modify_conn_disable_ipv4` so I am sure that it has no effect.
My bad. Didn't see if in later stages.
Add an example for this in EXAMPLE section.
Could you please refactor following if block to something which uses dictionary like - ```python options = { 'ipv4.address': self.ip4, 'ipv4.gateway': self.gw4, 'ipv4.dns': self.dns4, 'ipv6.address': self.ip6, 'ipv6.gateway': self.gw6, 'ipv6.dns': self.dns6, 'autoconnect': self.bool_to_string(self.autoconnect), 'ipv4.dns-search': self.dns4_search, 'ipv6.dns-search': self.dns6_search, } for key, value in options.items(): if value is not None: cmd.extend([key, value]) ```
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Again, path concatenation is bad. And in this case it is not needed at all, since we have a path stored in `device["@odata.id"]`.
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
`Name` field does not need to be unique (and on the Lenovo recording I have all the disk firmwares have the same name "Disk firmware"), so this has the potential to overwrite data from previous iterations, returning only the last non-unique entry.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Same here. You are changing behavior. ```suggestion data = host_fh.read() ```
this creates race condition. there is a time between remove and move that the file is unavailable. I see original code did same, but we should just allow move to work as it will be an atomic operation
I think this will fail on py3, as `encoded` will be a list of bytes. ``` TypeError: sequence item 0: expected str instance, bytes found ``` Might make `b''.join` and then use `to_native(data, errors='surrogate_or_strict')`
This introduces a different race condition, file can now be looked at in 'intermediate' state.
Why remove the `SSH Error:` prefix here, but not below? You should probably just leave it here instead of removing it
Please replace with `type: bool`
The file path [should be](http://ansible-docs.readthedocs.io/zh/stable-2.0/rst/developing_modules.html#module-checklist) decorated by `C()`. The same for `software_packing`.
I would put all these variables inside the `main()` function as there is no reason to have them global because you don't share them across multiple functions.
Get rid of this.
Again, this should become: ```yaml type: bool ```
```suggestion the original private key back if you created a new one by accident. ```
```suggestion - name: Replace between the expressions (requires Ansible >= 2.4) ```
```suggestion replace: ```
```suggestion - name: Replace before the expression till the begin of the file (requires Ansible >= 2.4) ```
```suggestion - name: Replace after the expression till the end of the file (requires Ansible >= 2.4) ```
Yeah -- just for info, to_native() is preferable because, with default arguments, it won't traceback if non-ascii values end up in the exception message. In some cases, non-ascii will traceback with str() and with ```'%s' % e```.
I would prefer to see the `to_native()` call done here, rather than as it's passed in below. Fix that and we'll merge this.
yeah, to_native is the way to do this correctly. Otherwise sooner or later we will end up with UnicodeErrors being thrown. Gotta start somewhere so might as well start with new code.
use `str(e)` (this is not the optimal, but that is true for most of this file) cc @abadger
<nod> please open that pr sooner, rather than later (aka, as soon as you are reasonably certain this is the env var name you want.). It is user facing so it would be good to expose the minimal number of people possible to the old name
This should be `'supported_by': 'community'`
This should be 'supported_by': 'community'
This should be 'supported_by': 'community'
This should be ``` 'supported_by': 'community' ```
``` author: - Chad Norgan (@BeardyMcBeards) ```
This can be moved to `check_dict` method.
```suggestion self.headers = { 'Content-Type': "application/json" } ```
Make a common method in class to get url and return json loads response.
```suggestion state = json.loads(to_text(state.read(), errors='surrogate_or_strict')) ``` This makes this call future proof.
You are using resetMonitor URL in deleteMonitor API
Please replace your mail with your github handle (also in cloudscale_server module)
the description looks wrong to me
Not a blocker, but I would append an alias `server_uuid` ~~~diff - server_uuids=dict(type='list'), + server_uuids=dict(type='list', aliases=['server_uuid']), ~~~ This allows to have a bit more syntax sugar for the users for attaching volume to a single server: ~~~yaml # Attach an existing volume to a server - name: Attach volume to server cloudscale_volume: uuid: my_ssd_volume.uuid server_uuid: ea3b39a3-77a8-4d0b-881d-0bb00a1e7f48 api_token: xxxxxx ~~~
not a blocker, I would probably not error out here, instead you could print out a warning message, up to your decision: ~~~python module.warn(warning='Cannot change type of an existing volume.') ~~~
+ type: int
Rename DO to DigitalOcean to avoid acronyms
It may be beneficial to clarify that this is cyberark vault, to avoid confusion where someone may think the error is in reference to ansible vault.
Maybe think about doing: ``` '-o', 'self.output', '-d', 'self.delimiter', ] ``` instead, this is a very long list, and making these changes is likely to make it more readable.
I think this needs to move out one indentation level to match `Field`
`if credential and ...` could be used here. With Python 3.5, the call to `endswith` raises an exception: `TypeError: endswith first arg must be bytes or a tuple of bytes, not str`.
I believe you should be able to update ``` $modules/cloud/amazon/: ignored: erydo seiffert simplesteph nadirollo tedder joshsouza maintainers: $team_aws ``` And add defionscode to the amazon/ ignored list
@defionscode You may want to add changes to [BOTMETA.yml](https://github.com/ansible/ansible/blob/devel/.github/BOTMETA.yml) instead of individual modules. For example - ```yml $modules/cloud/amazon/ec2_vpc_net.py: maintainers: $team_ansible ignored: defionscode ```
I think this would be 2.7.
This is new lookup so no need to add `version_added`
this should be moved into the run method, as we only want this to error on running, not on loading, which will always happen if this is included in ansible. or in the hasivault class init, which gets called from run.
Beware that in your examples, you are actually using `application_profile_name` not `app_profile_name`
Add a trailing dot.
I would simple make this `tenant`. If you still prefer backward-compatibility, you can add `tenant_name` as an alias.
The `notes` is a list of items, and each note must end with a trailing dot. Please also make this an full English sentence: ```yaml notes: - The tenant used must exist before using this module in your playbook. The M(aci_tenant) module can be used for this. ```
Has this actually been tested ? (Also move that list item to the start of the line)
This check would have to be adjusted for `db_all` if you make the above change.
```suggestion module.fail_json(msg="Multiple databases are not supported with state=import") ```
```suggestion module.fail_json(msg="Cannot dump database(s) %r - not found" % (', '.join(non_existence_list))) ```
```suggestion module.exit_json(changed=True, db=db_name, db_list=db) ``` So behavior is the same as without `check_mode`.
```suggestion module.exit_json(changed=bool(non_existence_list), db=db_name, db_list=db) ```
VM or VirtualMachine
not sure if this is useful
you can avoid the try/except if you just test `response_data`: ``` if not response_data.get('value'): raise ConnectionE.... ```
`Name of the datastore cluster from which all child datastores need to be managed`
`Name of the cluster from which all child datastores need to be managed` I find this a bit weird, btw... clusters do not really have datastores directly as children, only datacenters have datastores directly: You can not create a datastore specific to a cluster, you create datastores on the datacenter, and connect hosts to them. I assume the `cluster.datastores` just lists all datastores that are connected to hosts in that cluster. Personally, it would make more sense to use datacenter as a grouping parameter instead of cluster (but that might also be a bit excessive, as that would put all datastores in maintenance mode in a DC, basically preventing any VM to run at all...)
use to_text instead of str()
Going through itertools here ends up creating both a list and a generator so it's likely slower than just returning a list. If the list is very large and your goal is to reduce memory consumption, you can use a generator expresssion instead of a list comprehension on line 322: ``` python expanded_excludes = (self._pattern_to_pkgname(self.base, p) for p in self.base.conf.exclude) ``` However, for iteration over most data, lists are faster than other iterables so it is a time-space tradeoff.
"manual" is a recent occurrence, for older versions it was 'unmarkauto' iirc
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
This needs to be 'rb' so that it's bytes just like the BytesIO above.
CI failure due to: ``` 2017-01-31 20:28:20 ERROR: PEP 8: lib/ansible/module_utils/basic.py:725:18: E121 continuation line under-indented for hanging indent (legacy) ```
Same as in the doc
It seems like no_log and deprecation are separate things and should be handled in separate functions.
still works if you just append
here you should not need to check for deprecated if we are going to mandate deprecated_version
we cannot set remote_addr w/o post_validating first
instead of 'starting connection' here we might want to 'reserve socket path', to create it if it doesn't exist and to 'touch it' if it does (making a-connection timeout reset so we avoid a race condition)
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
Yeah we need to handle all exceptions that would be otherwise handled in `TaskExecutor` (`_execute()`, `run()`) and `Worker.run()`.
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
This condition can be simplified to be more readable ``` if backup_options and backup_options.get('filename'): result['date'] = time.strftime('%Y-%m-%d', time.gmtime(os.stat(result['backup_path']).st_ctime)) result['date'] = time.strftime('%Y-%m-%d', time.gmtime(os.stat(result['backup_path']).st_ctime)) else: result['date'] = tstamp.split('@')[0] result['time'] = tstamp.split('@')[1] result['shortname'] = result['backup_path'][::-1].split('.', 1)[1][::-1] result['filename'] = result['backup_path'].split('/')[-1] ```
this was one of the lookups i missed during 'conversion', it should be "simpleish" to fix to use get_option when setting params[] dict.
and the same for the rest of the params
```diff --git a/lib/ansible/plugins/lookup/password.py b/lib/ansible/plugins/lookup/password.py index 3eb48280ea..fb98d52a3f 100644 --- a/lib/ansible/plugins/lookup/password.py +++ b/lib/ansible/plugins/lookup/password.py @@ -175,7 +175,7 @@ def _parse_parameters(term): params['length'] = int(params.get('length', DEFAULT_LENGTH)) params['encrypt'] = params.get('encrypt', None) params['ident'] = params.get('ident', None) - params['seed'] = params.get('seed', None) + params['seed'] = params.get('seed', self.get_option('seed')) params['chars'] = params.get('chars', None) if params['chars']: @@ -337,6 +337,8 @@ class LookupModule(LookupBase): def run(self, terms, variables, **kwargs): ret = [] + self.set_options(var_options=variables, direct=kwargs) + for term in terms: relpath, params = _parse_parameters(term) path = self._loader.path_dwim(relpath)```
this is incorrect, this example is to specifically show the comma separated method of passing arguments
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
remote_src is a boolean, but you are using it as a path here, I think you have confused how this feature works elsewhere. it is just a flag indicating that project_src is on the target (True) or on the controller (False) look at copy or assemble to get this working right.
If you don't modify the task args then you don't need to copy() them. However, I think we want to add a ```use``` parameter for the action plugin and we will want to delete that parameter before we pass the args on to the module. So this section would look like: ``` python new_module_args = self._task.args.copy() del new_module_args['use'] [...] result.update(self._execute_module(module_name=module, module_args=new_module_args, task_vars=task_vars, wrap_async=self._task.async_val)) ```
this got named use_backend
Add that the user can specify the backend to use via the ```use``` parameter.
This needs to be '2.8' since freeze dates for 2.7 have passed.
Use `C()` for inline code formatting rather that double backticks.
`key: write_csv` should be `key: write_files`
~you don't seem to use 'cli' why import it? also the base class does this already.~ v1 compatibility it seems.
its new in 2.4 so it doesn't apply to older versions
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
Yeah, a list is fine.
No longer using a temporary file. This issue is resolved
We talked on IRC. For other people looking for the information, subprocess.Popen.communicate() returns str type on python 2 which are bytes. On Python 3, it returns bytes type which also represents bytes. We'd only need to use to_bytes here if communicate() was returning the unicode type on python 2 or the str type on python3.
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
This should be a @staticmethod and self removed.
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
Make this a regular function
Note: you don't have to use set explicitly here. The set methods can work with an iterable (which tuple is)
I think this is acceptable for now, but for the future, I think we should see if we can make use of post validating to cover all arguments in a single standard way.
And the same here
Add that the user can specify the backend to use via the ```use``` parameter.
I know, was just wondering if it's intended that it works that way.
Please add docs on what this module returns.
Can you name this a little more verbosely? I can't unsee "get best"
Same here, seems a ValueError would be cleaner.
What do you think about making this required=True and removing the default? I think it would be best to make sure that users are fully aware of which zone they're using. Many users don't use the us-central1-a zone.
Please separate this clause into separate lines for maximum readability (like above).
This condition can be removed
If this is not required it can be removed
Not sure if we need `normalize_interface` when fetching interface names from running-config.
I'm not sure in what sorts of cases this works and isn't just always True or False. If it's always a boolean, you can use it directly, but if the value is not guaranteed to be a boolean, you can do the following instead ```suggestion config["enabled"] = bool(conf["enabled"]) ```
It would be better avoiding changing method signature, you can pass the config and state as a dictionary to the method and unpack the them inside the render_config.
While fixing bugs is important, we typically do not prioritize bugs that are the fault of other software, or software that misuses the Ansible Python API. Ansible itself does not suffer from these problems, thus it sounds like the actual bug is really in ansible-lint that is causing issues. Making these changes, could result in bad behavior of Ansible itself, since we may be handling this differently elsewhere.
There is a missing `os.path.join()` otherwise you get `TypeError: append() takes exactly one argument (2 given)`.
The method name with "sane" suggests quite a broad meaning. It's better to be more specific about what that method does. Also, does it need to be a method? I'd have a pure function instead.
i don't think we want roles in roles
Use a tuple as a the cache key instead of stringifying this. This will likely result in a performance problem later if not resolved now. ```suggestion key = tuple(groups) + (b_opath,) ```
Do we need to do any check on this? Can this fail due to permission issues, or due to the file already existing? I'm fine with this always overwriting the destination file, and coming up `changed=True` every time, i just wonder if there is a risk of exceptions (pretty sure both `fetch_url`, `open` and `write` can throw a bunch of exceptions.)
Same as above, can be done with sub options
This should be `module.fail_json(...`, not an Exception
It people are trying to download a non-exiting file, the execution should fail, because this is unexpected behaviour and should clearly be mentioned.
Use to_native instead of str
Missing full stop
All `description:` (apart from `short_description:`) must be full sentences (capital letters & fullstops)
Hi @Shaita-KrZ you should remove requests from the requirements
Can you please add a `note:` section to say that checkmode isn't supported. Then I think we will be good to merge
Good idea to make all classes new-style objects. You can do that by inheriting from object
No need for this var actually: ```suggestion ```
you don't need another nested statement, just use logical `and` in a single if-clause...
Following PEP 257, this should be: ```suggestion """Return the possibly of a file being consumable by this plugin.""" ``` ref: https://www.python.org/dev/peps/pep-0257/
```suggestion return True ```
```suggestion return False ```
Remove the portion that adds message as a special key. If there's modules returning message expecting it to be treated specially, change then to return msg instead
I suggest: if parser.get('DEFAULT', 'vmware_validate_certs').lower() in ('no', 'false'):
Won't this cause no task to ever be printed? You have nested the 'TASK' banner display under a check that ensures that the task name is 'include' and that the verbosity needs to be greater than 1.
also worthy noting, -G won't show actual ssh options used, just those configured
This syntax is not supported in python2.6. You will need to index your format like {0}
Same for VMs.
```suggestion - To remove only resources that were automatically created while provisioning the VM being removed, set to C(all_autocreated). ```
```suggestion - To remove all resources related to the VM being removed, including auto-created resources, set to C(all). ```
```suggestion - Status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - Status of the primary location of the storage account; either C(available) or C(unavailable). ```
@willthames yep, thats the only way I see of doing that, create in tmp dir, md5sum both of them, if match OK, if different CHANGED. Although that does add some complexity.
This is going to bite people if they run this module twice. Ideally, on second run through, the changed should result in False if the archive hasn't changed, although I'm not sure of a particularly feasible way to do this (other than to generate the new archive in a temporary directory and compare the hashes of the archives)
This is behaving as expected now. :) I noticed one more thing. Since this module [supports check mode](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/source_control/git.py#L903) and archive will always change things (by creating directories, cloning, creating and archive - and replacing if it was pre-existing) lines 1016-1044 should only report the things that will change if check mode is used rather than actually implementing it. [Here](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/source_control/git.py#L1019-L1036) is an example of it being used elsewhere in this module.
This will fail if the destination exists. Is that the desired behavior? Since it is making a directory, maybe it should check if the directory already exists and if not create it? If it does exist, maybe we should be able to continue onto the archiving step. In addition, here's a hypothetical scenario: if this archiving fails the first time because the user uses an invalid URL to archive this part of the operation will succeed and the directory will be created. When the URL is fixed and this operation will run a second time it will fail here and not be readily apparent why. I think importing traceback and then failing with `module.fail_json(msg="Failed to clone source", exception=traceback.format_exc())` would be really helpful here for future debugging.
Why do the clone here and not use the clone/fetch/... code that already exists? The archive option in this way works only with a local checkout, which the module already does, so I'd rather use the existing checkout setup and run archive afterwards.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
We don't need this import of Display since we have it again on line 87.
This example will not work. Use loop with lookup/query/q instead. Any of the following will be fine: ``` loop: '{{ lookup("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true, wantlist=true) }}' loop: '{{ query("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true) }}' loop: '{{ q("aws_ssm", "/TEST/teset-list", region="ap-southeast-2", bypath=true) }}' ```
this could just return ```suggestion return not self._raising ```
Looks like `@contextlib.contextmanager` embeds this behavior and this would be enough: ```python @contextlib.contextmanager def timeout(timeout, raising=False): signal.signal(signal.SIGALRM, _raise_timeout) signal.alarm(timeout) try: yield except TimeoutError: if raising: raise finally: signal.signal(signal.SIGALRM, signal.SIG_IGN) ```
I think we should have an entry-check to protect from reuse: ```suggestion def __enter__(self): assert not self.timed_out ```
The docstring should probably explain that this is to be used in the main thread only... And the implementation should probably do the corresponding runtime checks.
https://docs.python.org/3/library/exceptions.html#TimeoutError says that `TimeoutError` is an `OSError` subclass that's been added in Python 3.3
aws_ip_ranges -> aws_service_ip_ranges
aws_ip_ranges -> aws_service_ip_ranges
I'd probably leave `get_aws_connection_info` as is for backwards compatibility. The new function would be the one you would use.
when using dict you can just do `dict(msg=to_text(body), message_count=....`.
You need to fix up the result so that it is snake_cased format using the ec2.py helper function https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/cloud/amazon/GUIDELINES.md#camel_dict_to_snake_dict
Shouldn't have `required: true` for things that have a default.
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
I think these returns (`deprecated_*`) should be under an object along the lines of: ``` deprecated: state: [one of OBSOLETE, DELETED, DEPRECATED] obsolete_at: [ISO stamp] deprecated_at: [ISO stamp] deleted_at: [ISO stamp] ``` That way users can do checks like `{{ if mything.deprecated }}` and such, instead of the snake-cased returns, and you can return mything.deprecated==None if there's no deprecation yet.
URLs should be in U() to be formatted properly, so `U(https://www.googleapis.com/auth/compute)`. Same for any of the following links.
ack. merging this in since this isn't a blocker.
This condition can be removed
What's the reason for using the shell here? There's no redirection, pipes, or other needs for the shell that I can see.
For this case (no id specified; use the first one), it looks like there is some code missing to read the data from the first URI and then set `target_serial_interface_current_setting` to the data.
Not sure if we need `normalize_interface` when fetching interface names from running-config.
Plz also use `match` arg here
```suggestion (u'1', u'PB', 1125899906842624), (u'1E', 1152921504606846976), (u'1EX', 1152921504606846976), (u'1Z', 1180591620717411303424), (u'1ZB', 1180591620717411303424), (u'1Y', 1208925819614629174706176), (u'1YB', 1208925819614629174706176), ```
You copy-paste a lot. It'd be more resilient if you could just put repeatable parts of data sets into reusable vars.
There's subset of cases which are the same, you could put those into a variable and then merge that with extra cases on per-test basis
I feel like this could be a good place to use hypothesis...
Similar here (and all the other ones, I guess): ```suggestion - Maps C(docker service create)'s C(--constraint) option. ``` or ```suggestion - Corresponds to the C(--constraint) parameter of C(docker service create). ```
This is not a new paragraph :) ```suggestion the container ```
```suggestion The default has been removed so that the user defined in the image is used if no user is specified here. ```
```suggestion - Number of containers instantiated in the service. Valid only if I(mode) is C(replicated). ```
The numbers should be in C(...), I think.
This debug needs to be updated for a few things: 1. Use full YAML syntax, not `key=value` 1. `.pid` should be `.pids` 1. Instead of `','.join` please use the `|join` jinja filter.
You could drop "It return", i.e. change the description to "Process IDs of the given process"
the comma should be before `or`, i.e. `list of none, one, or more process IDs`
add sample of pids like ```yaml sample: [ 10101, 12011 ] ```
The `sys` import is unused. ```suggestion ```
I would insert an empty line in front of every example to separate it a bit.
Use `"""` to unify it with the other blocks above.
I would prefer explicit imports.
Format this like this: ``` remove_content = { 'operation': 'remove', 'address': [ {'deployment': deployment} ], 'json.pretty': 1 } ``` The same anywhere else where you are using ` = \`.
This is never evaluated because you are already in the branch which matches `info['status'] == 200` only.
Remove the portion that adds message as a special key. If there's modules returning message expecting it to be treated specially, change then to return msg instead
Spurious `else:` Breaking the tests.
We're in the controller and this isn't something we're passing to an exception constructor. Therefore use to_text() here.
task_uuid seems unused
Add that the user can specify the backend to use via the ```use``` parameter.
``` - dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in KeyCloak REST API. ``` Example of mentioning the upstream api camel case name.
This argument falls under the same guideline requirements as explained for `protocol_mappers`, this needs to be a more explicit argument, and not an arbitrary field.
This branch can never be hit since the argument_spec defines which states are valid and checks the provided module arguments against it.
This could use more explanation.
'id' is also a python built in, so it may be better to not shadow it here. In this code, it doesn't look like it would cause any problems however. But, then that would also be inconsistent with the rest of the module args and REST api names. So either way is ok with me, just pointing it out. I think if I was going to try to avoid it, I might add a dict or class that maps the local ansible module arg name to the remote rest api name, but that might be overkill, so not suggesting this as required change. But maybe something like: ``` python api_map = {'id': 'id', 'direct_access_grants_enabled': 'directAccessGrantsEnabled', # other names hre } ``` so code could do something like: ``` python if api_map['client_id'] not in updated_client: stuff() ``` Probably overkill, but also might provide some isolation against potential keycloak rest api name changes. Not worried about it now though so not a blocker for merge.
Looks good to me! This is working as expected. A couple minor things I noticed: * Using STS credentials doesn't work with dynamic inventory (it doesn't work on devel either). * I'm also wondering about this bit. I'm reading the removed lines 459-462 as 'if this group_by_thing doesn't have the option provided it defaults to true' - if the file doesn't exist then it seems like the behavior is changing a little. (such as, group_by_aws_account is false by default in the ini but if it isn't provided it defaults to true here; now it defaults to false always). I think that's okay though.
All the boto3 client methods in this module should handle BotoCoreError. There are a number of places that need this added.
These should probably be keyword parameters - a massive length of ordered parameters is an easy source of bugs.
Not required with AnsibleAWSModule
Would it be better to just always run hostnames through the munger? Seems like we could get back other bad values besides just `:` (though I don't remember if it will munge things in other ways like `-` to `_` that might cause problems).
Sorry...nitpicking - I think ``` security_groups = get_ec2_security_group_ids_from_names(module.params.get('security_groups'), ec2_connection=ec2_connect(module), vpc_id=vpc_id, boto3=True) ``` is a lot easier to read. Not a blocker, just my opinion. But boto3 needs to equal to True here.
No need to wrap.
The pep8 line length enforced is 160 - can keep this on one line.
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
It might also be no IGWs found here.
I don't see why this should be changed, it seems like the v6 support shouldn't change this default.
Technically this will never be `None` because of the defaults.
This doesn't seem right to me - you may not need the `catch_extra_error_codes`
It would be good to have some tests for check mode too.
You don't need this conditional, since Ansible enforces that these are the only choices.
Add here that the `key_alias` or `key_arn` are both ways to provide it.
Please import only what you need, rather than `*`.
Can you just catch `AttributeError` here instead.
Another general exception handling that can be removed.
this should really be stdout or stderr
If rc != 0 it is always err. You don't need out or err.
Again, this only works on the primary credential cache. If the ticket is in another, this might not work.
CI failure due to python 2.4 syntax error: ``` 2017-02-07 17:14:00 Compiling ./lib/ansible/modules/network/nsupdate.py ... 2017-02-07 17:14:00 File "./lib/ansible/modules/network/nsupdate.py", line 178 2017-02-07 17:14:00 except binascii_error as e: 2017-02-07 17:14:00 ^ 2017-02-07 17:14:00 SyntaxError: invalid syntax ```
I am a bit scared by this. Because the module indicates it supports check-mode, but if I look at the code it seems to be doing all the stuff and only at the end appear to say there hasn't been a change. That cannot be right (it's dangerous!).
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
It's not a big deal either way, but since import sanity actually has to run on 2.x, it'd be *nice* if the type hint support was getting exercised there as well. Honestly I don't have strong feelings either way- I'm happy to merge as-is and we can go fix it and turn on remote-side stuff later (or not), or we can wait for Matt C to be back late next week and see what he says. There are also a couple other ways to fix this for 2.x (but a bit gnarlier at the import sites). I suspect that having the blanket ignores present for 2.x's benefit could mask potential problems or missing typeshed stuff in 3.x, so we *might* want to look at the fully-inline options if/when we light this up for 2.x.
nit: this is a good place to use a "guard expression" ```suggestion if not loader: return None spec = spec_from_loader(fullname, loader) if spec is not None and hasattr(loader, '_subpackage_search_paths'): spec.submodule_search_locations = loader._subpackage_search_paths return spec ```
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
Typo in `module_utils`.
So, is there a plan later to use include_private ? (as the current patch don't use it)
at this point you are just making a copy of the copy action plugin, this is something we want to avoid, a role that uses both copy and docker_service is more appropriate in this case.
remote_src is a boolean, but you are using it as a path here, I think you have confused how this feature works elsewhere. it is just a flag indicating that project_src is on the target (True) or on the controller (False) look at copy or assemble to get this working right.
Two blank lines between two top-level functions, sorry for not explicitly pointing this out before.
i'm not sure that makes sense, if handler was not included, it would not be available for notification already. Since it should already add the conditionals inherited (only on import or include + apply) you should not need to check any other conditions.
Also, remember we can notify handlers from almost anywhere: ``` yaml pre_tasks: - action: notify: handler_in_role_a roles: - name: a - name: b # notifies handler_in_role_a - name: a when: False tasks: - action: notify: handler_in_role_a - include_role: name=a - action: notify: handler_in_role_a - import_role: name=a when: False - action: notify: handler_in_role_a post_tasks: - action: notify: handler_in_role_a ```
If they really don't want the condition to apply to handlers, they should make it into a block in tasks/main.yml instead of trying to apply to the whole role, possibly setting up vars to deal with it: ```yaml - block .... when: '{{conditions|default([])}}' ```
Since role imports are non conditional, the `when` never applies to the inclusion of the role, the 'fun' part was dealing with `include_role` specifically, in which case that would be applied to the action of including the role itself.
i'm puzzled on why we need to evaluate the conditional on the role, since the handler (as all tasks in role) should inherit any conditionals applied when importing, if that is not the case, then we should fix it to do so.
```suggestion module = AnsibleModule(argument_spec=argument_spec, mutually_exclusive=[['retention', 'purge_retention_policy', 'overwrite']]) ```
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
Not required with AnsibleAWSModule
boto3_conn now handles region problems, no need to do it in the module
```suggestion is_auto_revert=dict(required=False, type='bool', default=None), ```
could be just `if module.params['dns_domain'] is not None:`
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
Allow filters ``` security_groups = cleanProtocol(cloud.list_security_groups(module.params['filters'])) ```
change this `result` key to something useful such as `ovh_billing_status` or `ovh_billing_info`
`class_name_to_type()` has fallthrough return None if it doesn't find (unless I'm reading it wrong)
If there are uncommitted changes on the prompt, this will not exit. Assuming there are no uncommitted changes, you can use `end` instead of `exit` to exit from configure mode. If stale uncommitted changes are expected by any chance; use`abort`. This will abort any uncommitted changes and bring prompt out of configure mode. This may apply to other platforms as well.
If you have an option of `end` command (similar to IOSXR) or an `abort` command (this will take care of any stale uncommitted changes), use those Also, when you exit out of configure mode, I believe you will be in `exec` mode? In that case, you might want to run `enable` command every time and not just in the `else` part? OR even better (however make sure you are in exec mode before doing this) ``` if to_text(out, errors='surrogate_then_replace').strip().endswith('>'): conn.send_command('enable') ```
Since this check-in action plugin ensures the prompt is out of `configure` mode, we can use `exit discard` here as it always ensures the prompt is changed to operational mode.
OK, if we are being consistent with something else that makes sense. I personally find putting the message in quotes can be useful for checking for trailing whitespace, , as well as making the message stand out more.
I wonder if `"$HOME/.ansible/pc"` should move to constants.py, rather than get hardcoded in multiple action plugins.
```suggestion vmware_host_snmp: ```
I think this irrelevant, need to change according to SNMP output.
```suggestion if host_network_info.atBootIpV6Enabled: if host_network_info.ipV6Enabled: ... elif host_network_info.ipV6Enabled is False: ... else ```
```yaml type: bool ```
Double quote around Author name.
```suggestion version_added: '2.8' ```
Ansible 2.8 isn't supporting Python < 2.6 anymore, so this line is no longer needed.
For a paragraph break (which seems like what this line is supposed to be) make the string a new list item.
Shouldn't have `required: true` for things that have a default.
Same here - this return should probably be `{items: [{id: ....}, ....]}`
Drop the extra "Mac" here.
One last thing I thought of: it may be good to catch `AttributeError` and `ValueError` if an invalid value is passed for `namespace`. Otherwise we get a stacktrace. ```suggestion try: uuid_namespace = uuid.UUID(namespace) except (AttributeError, ValueError) as e: raise AnsibleFilterError("Invalid value '%s' for 'namespace': %s" % (to_native(namespace), to_native(e))) ```
Values returned from filters should use `to_tex()` for Python 2/3 compatibility. ```suggestion return to_text(uuid.uuid5(uuid_namespace, str(string))) ```
```suggestion return to_text(uuid.uuid5(uuid_namespace, to_text(string))) ```
Making this change here doesn't work because we aren't guaranteed to have passlib installed. The crypt.crypt() method will require that we have a salt set. You could move salt generation into the conditional for ```not HAS_PASSLIB```.
Please call this only when needed and report change=true/false if it was called and is needed.
please add also `if not self._module.check_mode`
Check this: https://github.com/ansible/ansible/pull/29175/files If you will do it the same we can close that PR.
Actually someone can sent for example '123213321321321', which isn't valid name nor ID, so it will fail with HTTP 404.
Hmm I think this can be simpler, something like this: ```python if module.params.get('template'): entity_name = module.params.get('template') collection_service = connection.system_service().templates_service() elif module.params.get('vm'): entity_name = module.params.get('vm') collection_service = connection.system_service().vms_service() # TODO: We have to modify the search_by_name function to accept raise_error=True/False, entity = search_by_name(collection_service, entity_name) if entity is None: raise Exception("Vm/Template '%s' was not found." % entity_name) service = collection_service.service(entity.id) cluster_id = entity.cluster ```
Apparently, I don't have permissions to push to your branch. I didn't want to hold up merge. Feel free to raise a PR to fix this if you'd like, though don't lose sleep over it
nitpick: you --> your
I would prefer 'true', actually C(true).
I think something like `device-name` would be more descriptive.
If you read the netplan definitions the match: {name: ...} mechanism allows you to specify a specific or glob pattern that can be used to match against system network devices to be able to create a group, e.g. a netplan to setup a bridge using all PCI bus 0 ethernet devices might look like: ```network: version: 2 renderer: networkd ethernets: switchports: match: name: "enp0*" bridges: br0: dhcp4: true interfaces: - switchports parameters: forward-delay: 0 stp: false ``` The match mechanism targetted at devices matching the `enp0*` dynamically defines a logical name/handle, `switchports`, that specifies all of the network device on the first pci bus, which is later used define the `br0` bridge.
Same here. ```suggestion self.cron_file = os.path.join('/etc/cron.d', cron_file) self.b_cron_file = os.path.join(b'/etc/cron.d', to_bytes(cron_file, errors='surrogate_or_strict')) ```
The file is opened in binary mode. So there's no reason to try converting here as data is already bytes.
Instead, please set `self.index = json.load(f)`. The JSON library uses the `.load` function to stream straight from files without needing to `.read()` first. This also avoids pesky encoding issues with Python2/3.
i would add `: %s` and to_text(e)` to the end of msg
get_basedir should not be needed, the ansible_search_path should include the correct one
Can you add: ``` type: bool default: no ```
Can you add: ``` type: path ```
Can you add: ``` type: path ```
That's why I would also say `yes`. If someone thinks this is too much data, that person can simply turn it off with the option.
Please remove the list. `default` specifies one value, not a list. A list is only needed for `choices`.
we try to use 'state' instead of action, as ti keeps with the declarative voice of Ansible vs an imperative approach from programming languages.
I think this should be a separate command option - `delete` or `create`. `state` seems like something different. At a minimum, I think it should be more explicit - like `action: create | delete`
All `description` should start with a capital letter, and end with a fullstop.
shouldn't be required, irrelevant for Amazon providers
Actually with the example you updated, this text is good enough. However we explain it, it won't be clear until one looks at examples... Perhaps slight tweak "A list of list of tags, grouped by category".
```suggestion - Gitlab access token with API permissions. ```
Change this parameter for a more explicite one : `project` This one should handle project `path` or `id`
```suggestion - A list of key value pairs. ``` Descriptions should be complete sentences.
Your module is named `gitlab_project_variable` don't use plural in your example
Since each of your attributes have only one attributes, what's the point of making a list ? Usage of a simple dictionary should be more easier to understand. ```yaml vars: ACCESS_KEY_ID: abc123 SECRET_ACCESS_KEY: 321cba ```
```suggestion - Must be in the same resource group as VPN gateway when specified by name. ```
```suggestion - Can be the resource ID of the virtual network. ```
```suggestion - Can be a dict which contains I(name) and I(resource_group) of the virtual network. ```
```suggestion - Name of the public IP address. Use 'None' to disable the public IP address. ```
I'm sure this is different than the `gateway_type`: ```suggestion - The type of this virtual private network. ```
This option isn't required but is throwing an error for me if not provided (because if not provided it attempts to iterate over a Nonetype). Can you add default=[]? fixes the problem for me.
Could add to the line above rather than lots of line breaks
Unnecessary line break
Running the legacy ec2_asg integration tests that use this module, I think this line should be `if block_device_mapping:` because it doesn't look like it can be None or an empty list. The error: ``` An exception occurred during task execution. To see the full traceback, use -vvv. The error was: Missing required parameter in BlockDeviceMappings[0]: "DeviceName" fatal: [localhost]: FAILED! => {"changed": false, "failed": true, "module_stderr": "Traceback (most recent call last):\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 436, in <module>\n main()\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 430, in main\n create_launch_config(connection, module)\n File \"/var/folders/by/k8_fbl593dlctgqmwq5wzl2c0000gn/T/ansible_g_YCzK/ansible_module_ec2_lc.py\", line 326, in create_launch_config\n connection.create_launch_configuration(**launch_config)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 253, in _api_call\n return self._make_api_call(operation_name, kwargs)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 517, in _make_api_call\n api_params, operation_model, context=request_context)\n File \"/Library/Python/2.7/site-packages/botocore/client.py\", line 572, in _convert_to_request_dict\n api_params, operation_model)\n File \"/Library/Python/2.7/site-packages/botocore/validate.py\", line 270, in serialize_to_request\n raise ParamValidationError(report=report.generate_report())\nbotocore.exceptions.ParamValidationError: Parameter validation failed:\nMissing required parameter in BlockDeviceMappings[0]: \"DeviceName\"\n", "module_stdout": "", "msg": "MODULE FAILURE", "rc": 0} ```
If we get into this else block the lack of an exception is going to throw a traceback. I'm not really sure about this if/else (could it take a few moments to successfully create the launch config?). But you can just fail with the module.fail_json(msg="helpful message") here since there isn't a traceback or an exception to have a .response.
right now, this would need to be version_added: '2.6'
typo: thier -> 'their'
Change to source and remove the alias
This supports more than just URLs, I would add more points talking about what it actually supports.
I'm curious as to whether this needs to be in upper case or if it works in lower case as well.
Please add dot at the end.
The `RepoIDs` is not the module option and therefore it should not be decorated in `C()`.
This is indented only by one character. Please indent it by two chars like elsewhere.
The list of option could be ordered alphabetically.
These two empty lines should be just one.
Same thing here: need `post_reboot_delay_sec` here since `win_reboot` accepts that.
Sorry, I've been staring at this too long. :)
Since this is now common code and `win_reboot` also accepts `post_reboot_delay_sec`, we also need to loo for that key here.
`int()`? Guessing bad copy/paste and no testing- this results in `ValueError: invalid literal for int() with base 10: 'hey d00d gonna reboot'`
Both `reboot_timeout_sec` and `connect_timeout_sec` are valid for `win_reboot`. Since `win_reboot` is using this method, these options need to stay.
no, if the variable is set but empty, you should empty out the options
You should be able to use `self.vmware_test_platform` here.
I feel like this should be moved to `else:`
We've switched from pipes.quote() to six.moves.shlex._quote for python3 compatibility: ``` python from ansible.compat.six.moves import shlex_quote out_path = shlex_quote(self._prefix_login_path(out_path)) ```
We should convert filenames to bytes before passing to open. Like this: ``` python with open(to_bytes(in_path, errors='surrogate_or_strict'), 'rb') as in_file: ```
You're right. I also checked the source at tag `2.1.0`, and it contains that parameter. I guess they did some refactoring between 2.2.x and 2.3.0 which resulted in that commit...
While we're at it: please add a trailing comma, that makes it easier to add another option (if we ever need to) :)
Indeed. Currently, the only way to do that would be to add that information manually, which is somewhat annoying and error-prone. Could you create a Feature Request issue for this (for the docker modules)? Then we can collect ideas how we can improve this in the future.
That's not really necessary since the global minimum is 1.8.0. Shouldn't hurt, though, we just have to remember this when we bump the global version... :)
Hmm, that's pretty inconsistent. So now we got three different choices... :) I guess it's fine to leave it with 1.25.
This method is called with only one argument, but there are no defaults given for the unused arguments. If it is called, the `NotImplementedError` will never be reached.
Oh, I see. `run_commands()` runs list of commands and returns list of results.
It's usually better to use raw-strings for regexps: ```suggestion assert re.match(r'ansible [0-9.a-z]+ .*$', version_lines[0]), 'Incorrect ansible version line in "ansible --version" output' ``` (I'm pretty sure Python 3.6+ will emit warnings if you don't)
Missing `=dict` on this and the next few lines
Don't add stuff in a try-except block that should not fail. If possible also catch specific exceptions with specific error messages. (It is possible not all exceptions provide a workable string the same way, unfortunately)
traditionally, variables is a keyword arg. I don't think it matters in our paticular code base but we should keep it consistent with other lookup plugins.
boto_profile should be aws_profile, but rather than passing these explicitly, it seems like other lookups use **kwargs instead. If you change that to **kwargs and if you use the doc fragment for credentials, then you'd need: `self.set_options(var_options=variables, direct=kwargs)` below and then you can access any of the options with `self.get_option(optionname)`.
So for example, if I didn't specify aws_profile/boto_profile but had the environment variable AWS_PROFILE set, that can be accessed with self.get_option('aws_profile') since aws_profile is the option name: https://github.com/ansible/ansible/blob/devel/lib/ansible/utils/module_docs_fragments/aws_credentials.py#L10.
We don't need this import of Display since we have it again on line 87.
This example will not work. Use loop with lookup/query/q instead. Any of the following will be fine: ``` loop: '{{ lookup("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true, wantlist=true) }}' loop: '{{ query("aws_ssm", "/TEST/test-list", region="ap-southeast-2", bypath=true) }}' loop: '{{ q("aws_ssm", "/TEST/teset-list", region="ap-southeast-2", bypath=true) }}' ```
I'd move this into an example
Not sure if this will get rendered correctly, from the root of your checkout please do `make webdocs` Then check the HTML that's generated
Please delete this line
I would default to 'auto' and not require it, let the command fail if it is not present in fstab (like mount does)
For options, use C(absent) instead of I(absent)
When pytest executes on multiple nodes, each node is required to collect the same tests in the same order. If that does not occur then test collection fails and tests are never executed. This is usually only an issue with parameterized tests that source their items from dicts on older Python versions, although it can occur in other scenarios as well. Thankfully the solution is straightforward. Just make sure parameterized tests use a list or tuple, or if using a dict, that the items are sorted before giving them to pytest.
I guess it's best to remove the version number here (and in all the other copies of the config). Not sure whether that should happen in this PR though :)
I realize this was in the original file, but it can be simplified as well: ```suggestion sys.exit(main(sys.argv)) ```
If it only passes them on anyway, it's probably better to catch them all. I just hope that they don't use fancy line-break support / escaping support. It would really be nice if there would be an easy machine-readable JSON export or something like that...
Is this always avaliable? If not, try ```suggestion tags = self.node_attrs['Driver'].get('Tags') or '' ```
Ah, I see it now. yeah, so just change self to be cls to match convention when using `@classmethod` and it should be fine.
We try and wrap the smallest amount of code possible in a try/except. Our preference would be to only wrap the `_run` and `exec_command` lines in try/except. Once this is done, we'll need to review again, but overall this approach looks correct.
Probably some potential for improved grammar here. > use the equivalent become one instead Maybe something more like: > The %s command line option has been deprecated in favor of the "become" command line arguments
This should probably be `docker.exec_command()`
Typo in the help message
No need to quote strings here.
No need to quote strings here.
```suggestion if not datacenter: ```
```suggestion if not dcpath.endswith("/"): ```
Remove parans for every if ```suggestion if find_vm_by_name(self.content, self.name, folder=folder_obj): ```
Not sure if this piece is doing exactly what you expect in all cases.
This could move even more down. After listing apps.
This whole block should be changed into: ```python module = AnsibleModule( argument_spec=dict( name=dict(type='str', required=True), remote=dict(type='str'), state=dict(type='str', default="present", choices=['absent', 'present']) ), supports_check_mode=True, required_if = ( ('state', 'present', ('repo')), ), ) ``` Assuming that **name** is always required, and **repo** is required when **state == 'present'**
Same here, move it down the stack.
No need to split the line.
Boolean parameters: add default value (`False` is default value for `has_expired`, `extendedKeyUsage_strict`, `subjectAltName_strict`).
Use `C` formatting function for the sample list.
Small nit: ASN.1 TIME, not ASN1.TIME. Otherwise great. :-)
This one will fail, since selfsigned_notBefore and selfsigned_notAfter have changed their meaning from the initial draft and don't have default values any more.
Use `U()` for `acme`.
It's addressed here https://github.com/ansible/ansible/pull/47803/files#diff-4e0a09d18f6dfe19eb9d0b30c0a53bafR16
you are also missing doc fragments for classes using constructable and cacheable
@machacekondra still, it requires the docs also that module would not have passed review, it got merged w/o it so it is not a good example to follow
This variable is never used in the code.
is this per connection or global? some options seem like they are overtly indented
All new modules should include actual RETURN data.
Hi @Shaita-KrZ you should remove requests from the requirements
CI failure due to PEP 8 issue: ``` 2017-02-04 01:35:47 ERROR: PEP 8: lib/ansible/modules/storage/netapp/sf_snapshot_schedule_manager.py:114:161: E501 line too long (171 > 160 characters) (current) ```
not a blocker, but returning schedule information would be 'nice', schedule_id at the least when creating.
@gundalow probably a pattern to trigger for the sanity tests. logging should be avoided due security reasons
tempted to say just use check_opts=True and remove syntax check afterward with remove_option (we do this in ansible-inventory).
I think that makes sense. Right now the fact that we download the collection is an implementation detail. So something indicating `--local-only` or `--no-server-verification`. Just some ideas.
Tell people where we are looking `CONFIG_FILES`
Just to make an attempt at word-smithing > When doing an --list, represent shared variables inside groups or the inventory, > which has a smaller memory footprint but is not Ansible's internal representation
Please fix: '... if it doesn't exist:'
What's the difference between Seeing state `present` and state `update` looks a little strange here. ```yaml - name: Change role type for existing user purefa_user: name: ansible role: storage_admin state: present # <---- fb_url: 10.10.10.2 api_token: e31060a7-21fc-e277-6240-25983c6c4592 ``` ```yaml - name: Change role type for existing user purefa_user: name: ansible role: storage_admin state: update # <---- fb_url: 10.10.10.2 api_token: e31060a7-21fc-e277-6240-25983c6c4592 ```
I think this line needs removing
This doesn't seem to read right with present vs absent
catching a low hanging fruit ~~~python if not module.check_mode: array.set(banner="") changed = True ~~~
Same typo as above
This could have prettier formatting: ``` ANSIBLE_METADATA = { 'status': ['preview'], 'supported_by': 'community', 'version': '1.0' } ```
Please add dot at the end of the description.
Please add dot at the end of the description.
This needs to be addressed.
It would be nice to sort the options alphabetically.
2.5 at this point but i'll fix after merge
It needs to be retested by CI anyways since the CI result is stale.
@bcoca You could push another commit to this PR to fix that before merging.
@mattclay rebuild_merge is supposed to make the bot rerun CI and only merge if it succeeds
not sure why you are changing version here
Spaces ! ```suggestion choices: [ absent, present, query ] ```
So, my personal view here is that if you list items, and the order has no real meaning, it's better to order them alphabetically.
There's also no need to quote the values here. Another rule I abide to is to not quote strings that not need quoting in YAML. Otherwise people will not understand the YAML rules to quoting, and start quoting everything always.
So I am interested to know the difference between PUT and POST. And highlight that here.
Keep a blank line between examples for readability.
```suggestion module.fail_json(msg="The following packages are absent in the currently booted rpm-ostree commit: %s" % ' '.join(pkgs)) ```
Oops, the following sentence is now redundant and can be removed: > A previous version may be specified C(name-0.9) to downgrade a package.
A slightly cleaner version that avoids escaping: ```suggestion sample: ['DROP EXTENSION "acme"'] ```
Since this is more of a special kind of "absent", maybe it would be better to have two "absent" states - absent and purged - since it seems odd to be allowed to specify "present + purged=true".
Well, I suppose you *could* install Solaris in a VM, but I do see why youâd consider than the problem of someone who cares enough about Solaris to already have some Solaris. Thatâs cool. Frankly Iâm impressed you tried to take this on in the first place. So, then, letâs merge what we have. The tests all pass, now, and itâs a step in the right direction.
I think we should guard against an `IndexError`. Even if Linode guarantee us some value, given programming error and such, I'd like to guarantee users of this module error messages that lead them in the right direction.
I don't understand why we would `return False` here. This function is about giving back an instance based on the public IP address or failing gracefully with an error message for the user. If this `return False` is happening, we need to write code to handle that in all places it is called within the module. This can lead to extra `if/else` which we should avoid for maintainability purposes.
Ah, right, got it :+1:
Following PEP 257, this should be: ```suggestion """Return the possibly of a file being consumable by this plugin.""" ``` ref: https://www.python.org/dev/peps/pep-0257/
No need for this var actually: ```suggestion ```
why it's `yum` here, but `pip` in the previous error? be consistent and tell users to use what they have. which can be many more package manager options
instead of a catchall here, you should give more relevant errors in _discovery and _add_device, which you already do in some cases, but then this catchall obscures
you should probably put these check even before `super()` line
this produces an exception when binary cannot be found, you should capture and return parser error
No need to compile explicitly, `re` will hold compiled cache internally anyway.
Hello @resmo Thank you for your feedback. Unfortunately, the 1&1 python SDK is currently throwing a generic `Exception` in `modify_server_status` method, which is why we catch it here.
`default=None` is the default, so doesn't have to be set here
please add a list of choices here: ~~~diff - state=dict(type='str', default='present'), + state=dict(type='str', default='present', choices=['present', 'absent', 'running', 'stopped']), ~~~
please create a list: e.g. ~~~ yaml author: - "Amel Ajdinovic (@aajdinov)" - "Ethan Devenport (@edevenport)" ~~~
set required: false
Format this like this: ``` response_add_content_server_group, info = get_response( add_content_server_group) ```
Format this like this: ``` module.fail_json( msg='Error while performing wildfly operation', details=info['msg']) ``` The same anywhere else in the code.
This is never evaluated because you are already in the branch which matches `info['status'] == 200` only.
If possible, do not use global variables. Pass the module to the function as a parameter if needed.
Format this like this: ``` remove_content = { 'operation': 'remove', 'address': [ {'deployment': deployment} ], 'json.pretty': 1 } ``` The same anywhere else where you are using ` = \`.
This needs removing ``` - This argument specifies to include passwords in the config when retrieving the running-config from the remote device. This includes passwords related to VPN endpoints. This argument is mutually exclusive with I(defaults). ```
`removed_in_version` for `force` should be `2.6`. We follow deprecated version + 4 for removed_in_version.
`validate_certs` and default should be `true`
Don't do this. The old way is much more pythonic. And it's much harder to see *your* changes as a result
Would a required_if for state absent be better? It's weird to require one of these for creation if you might just plan to use vpc_id to then delete it.
`across` has broken into two separate lines.
Typo in `aggressive`
A minor typo in `address`.
This line seems to have been split into two.
Typo in `aggressive`
A trailing comma is preferred.
A trailing comma is preferred.
We tend to sort the various imports, so swap those two lines.
This function is not needed, you can import `bytes_to_human` from module_utils: ```python from ansible.module_utils.basic import bytes_to_human -snip- for store in host.datastore: _tmp = { 'name': store.summary.name, 'total': bytes_to_human(store.summary.capacity), 'free': bytes_to_human(store.summary.freeSpace), } facts['ansible_datastore'].append(_tmp)
If there's no sample, please remove that line.
seems gateway and netmask are only required in case of state=present, are they? In this case i would suggest to: ~~~diff argument_spec.update(dict( network=dict(type='str', required=True), zone=dict(type='str'), start_ip=dict(type='str', required=True), end_ip=dict(type='str'), - gateway=dict(type='str', required=True), - netmask=dict(type='str', required=True), + gateway=dict(type='str'), + netmask=dict(type='str'), start_ipv6=dict(type='str'), end_ipv6=dict(type='str'), gateway_ipv6=dict(type='str'), vlan=dict(type='str'), state=dict(choices=['present', 'absent'], default='present'), domain=dict(type='str'), account=dict(type='str'), project=dict(type='str'), for_virtual_network=dict(type='bool', default=False), for_systemvms=dict(type='bool', default=False), )) module = AnsibleModule( argument_spec=argument_spec, required_together=cs_required_together(), mutually_exclusive=( ['account', 'project'], ), + required_if=(("state", "present", ("gateway", "netmask")),), supports_check_mode=True, ) ~~~
`zone` is returned, but not zoneid
there is a missing condition for check mode
I would suggest to set `type='int' for vlan.
I think it's time to move this method to Cloudstack module utils.
Incorrect description; "If remote gateways can be used on this virtual network."
As above; Separate log exception method for the normal situation where the RT does not exists VS all other errors.
Can you differentiate between the named route not being present in the rout table and other exceptions to avoid log spew in the normal situation in which the route does not exists for that route table.
@Madhura-CSI thanks! I will create PR to your fork soon :-)
can we just merge/update the dict instead of putting it in state, so the return results are on the root level.
Not sure why you need all this complexity ? (And the complexity below) I would have expected this to be much more simple.
Did you know you can do this: ```python self.url = '{protocol}://{host}/api/v0/{path}'.format(path=self.path.lstrip('/'), **self.params) ```
Looking at the code now, it's wrong. You don't have `self.error` anymore. And the KeyError will never hit, so you surely didn't test these failures. (integration tests !) There's also no difference between `>= 300` and `>= 400` so I guess `>= 300` only would do (but I don't know if that is intentional).
This won't work if 'name' is an alias, rather than the parameter name.
This was very specific to ACI, I don't see a good reason to repeat this here.
before continuing here, check that fields is actually populated as a list, or try/except the following code
style note on all of these.. Unless you need lines later, it's more idiomatic python not to allocate a named temporary variable here. Instead use out.splitlines() directly: ``` python for line in out.splitlines(): ```
make this a set to be a bit more efficient. (We're only using it for containment checks.)
Right -- it shouldn't be needed because splitlines() will remove all "\n".
I think you can get rid of the rstrip('\n') here for the same reason as you got rid of it in _find_bind_mounts() (or alternatively, if rstrip is necessary here, then it's probably still needed in _find_bind_mounts() as well).
I've updated `required` to `false`.
set `required: false` please.
Thank you for the review. I've set `required: false`.
Thanks for the tip. It is now set to `required: false`.
I've changed it to `required: false`.
`No reason given` is fine
Indentation doesn't look right here
Please add `type: bool`.
Nowadays, we list the imported functionality at the top of the module, and we explicitly list all the functionality we import. So in your case it would likely become: ```python from ansible.module_utils.basic import AnsibleModule from ansible.module_utils.urls import fetch_url ```
We try to avoid using "_" as an identifier so as not to conflict with gettext should we find a way to localize our code in the future.
Nice! Thanks for remembering this :) Oh, I think you just copied this from below!
should we allow 'run once' tasks? since they affect hosts globally it is kind of counter to 'notify for specific hosts'
instead of 'starting connection' here we might want to 'reserve socket path', to create it if it doesn't exist and to 'touch it' if it does (making a-connection timeout reset so we avoid a race condition)
Why is self._play_context updated instead of the passed in play_context? (where does self._play_context come from? I don't see it set/defined anywhere)
This should probably be `docker.exec_command()`
Commit if changed.
Not required if one of password or api_key is required. Descriptions for password and api_key should both state. "Exactly one of I(password) or I(api_key) is required."
doesn't match actual return string
not needed when `required=True` is specified
not needed when `required=True` is specified
Default mentioned in description but not specified in argspec.
Default value not specified in argspec.
Default value mentioned but not added in argspec.
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value mentioned but not added in argspec.
Would you please change this to type str with choices `[disable, enable]`? This would make bfd type consistent across all the modules.
Instead of having three different parameters, can we add these parameteres as options for bfd? `bfd_options: {bfd: '', echo: '', hsrp: ''}`
```suggestion - Set the link bonding mode used for the interfaces. ```
Rename to something more specific. Perhaps `bonding-mode`, or `aggregation-mode`.
```suggestion type: str ```
Is there a reason to do deepcopies here (and at the top of a few other methods)? deepcopies are slow and it doesn't look like the data is being modified (for which you might want to have a pristine copy and a modified copy) so you can probably discard the deepcopy to improve your speed.
Use to_native() with the parameter errors='surrogate_or_strict' here. (the default error handler is surrogate_or_replace. That is appropriate for informational things as undecodable/encodable values will have a replacement character substituted. For dictionary keys or other data that you would rather throw an error than risk data corruption, surrogate_or_strict is appropriate.)
You don't modify ignore_when_null in this function so it's probably harmless to use [] as its default value but it's a bad habit to get into. You should try to always use a immutable as a default value. In this case, you can do: ```ignore_when_null=tuple()```.
If you're unfamiliar with why that is, you should probably google it. It has to do with python processing the function declaration once when the function is declared and therefore there's only one copy of the default value which is used every time the function is called. If you have a mutable container as a default value, it will not be recreated between invocations so it may not be empty the second time you call the function.
Also note, str can traceback if e contains non-ascii. Better to use the to_native function from ansible.module_utils._text.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Creating paths by concatenating them together is a no-go with Redfish. Paths should always come from the Redfish responses itself (`redfish/v1` being exception here).
Should this be `response` since that is what is returned? I don't see `result` used within this function.
Again, path concatenation is bad. And in this case it is not needed at all, since we have a path stored in `device["@odata.id"]`.
This should be a string: ```yaml version_added: '2.4' ```
And just because we show signs of OCD. The items in `description:` should end with a dot. This is not true for `short_description:`, there we do not allow a dot. Isn't life beautiful like that ? :-P
The description needs to have a trailing dot. (The short_description does not)
Nowadays we do: ```yaml type: bool default: 'yes' ```
Also, it would be better of the description is split up over multiple items. A long blob doesn't make it easier to read. Usually the first item is the "meaning", and subsequent items detail what happens in different cases, explain options, specify the format or add one or more notes.
`Host group` (copy/paste, i guess)
Use `get_vm` API
`Current host '%s' can not be %s...`
idem, but I would have write: ``` rule_obj = self.get_rule_key_by_name(rule_name=self.rule_name) if rule_obj is not None: # Rule already exists, remove and create again # Cluster does not allow editing existing rule existing_rule = self.normalize_rule_spec(rule_obj=rule_obj) if ((existing_rule['rule_vm_group_name'] == self.vm_group_name) or (existing_rule['rule_anti_affine_host_group_name'] == self.host_group_name) or (existing_rule['rule_affine_host_group_name'] == self.host_group_name) or (existing_rule['rule_enabled'] == self.enabled) or (existing_rule['rule_mandatory'] == self.mandatory)): # Rule is same as existing rule, evacuate self.module.exit_json(changed=False, result=existing_rule) # Delete existing rule as we cannot edit it changed, result = self.delete(rule_name=self.rule_name) if not changed: self.module.fail_json(msg="Failed to delete while updating rule %s due to %s" % (self.rule_name, result)) changed, result = self.create_rule_spec() return changed, result ```
One more question on this: The checks are to see if the current VM group name _equals_ the new VM group name? (same for hosts), shouldn't that be if they differ? It would make the code: ``` if ((existing_rule['rule_vm_group_name'] != self.vm_group_name) or (existing_rule['rule_anti_affine_host_group_name'] != self.host_group_name and not self.affinity_rule) or (existing_rule['rule_affine_host_group_name'] != self.host_group_name and self.affinity_rule) or (existing_rule['rule_enabled'] != self.enabled) or (existing_rule['rule_mandatory'] != self.mandatory)) ``` (added check to only check for the right host group name depending on type of rule)
`get_config` is not implemented in the cliconf plugin. This function is not used and will only ever return `"None"` if tried.
You don't need this function
This argument is marked as being removed in the same version it is introduced. This makes no sense.
Since enos cliconf plugin has a specific `get_config()` api is it possible to move L75-83 to cliconf plugin and call `get_config()` api instead of `get()`
From 2.5 onwards network platforms using persistent connection will be using cliconf and netconf plugins. To use cliconf plugin you need to add platform-specific plugin in `lib/ansible/plugins/cliconf/<platform-file>` You can refer `asa` modules as it is implemented using cliconf api's https://github.com/ansible/ansible/blob/devel/lib/ansible/module_utils/asa.py https://github.com/ansible/ansible/blob/devel/lib/ansible/plugins/cliconf/asa.py
You don't have to quote YAML strings. Quote only `yes` or `no` to prevent it to turn into `true` or `false`. Please also unify the quotes to either single or double quotes.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
Please add dot at the end. The same applies to the descriptions bellow.
This could be `elif`.
they don't need to, but can be as long as they are acurate
please add `version_added: 2.5` that's why the build fails
```suggestion matches = [re.search(r'^[ #]+- env: T=(?P<group>[^/]+)/(?P<params>.+)/(?P<number>[1-9][0-9]?)$', line) for line in self.shippable_yml_lines] ```
```suggestion - Due to the B(very) sensitive nature of these credentials, it is B(highly) recommended that you only pass in the minimal credentials ```
there is no need to version params for new modules
there is no need to version params for new modules
Actually... Even better: use a defaultdict instead of this. This is how defaultdicts work: ``` python from collections import defaultdict foo = defaultdict(list) foo[k].append(v) ```
This method doesn't seem to do much. I would merge it into the run() method. * read_settings and parse_cli_args don't seem related. They don't operate on the same instance attributes, for instance. * It's a bit funny to have a private method (_read_settings()) calling public methods (read_settings() and parse_cli_args()) that aren't usable by anything else. * If this is merged into run(), it will only add one more line there and will remove 5 lines overall.
No need for this to be a private method. rename to get_inventory().
This should be a @staticmethod and self removed.
Make this a regular function
When using format, you will need to specify the index `{0}` so this would still work with Python 2.6
Not needed as it is already set to False
No update supported? As far as I know, the `azure-cli` supports update
This shouldn't be set.
My point is the self.credentials may not has a key named 'tenant' if not login
This isn't needed anymore as it is part of the parent class value. **Note**: Default has been set to `False`, so the logique about self.changed needs to be updated in the rest of the code.
The Base64 decoding can be hoisted out of the loop
You probably should do the opposite here. Set self.changed = False on object instantiation and then set self.changed = True when a change is performed.
The usual idiom I see with these *Module type of classes is that they hold onto module in an attribute. I happen to think that's the wrong thing to do (as it leads to calling self.module.fail_json() instead of raising exceptions that are then handled at a higher level). But if you aren't going to hold onto module, you shouldn't pass it into the constructor. Instead pass in the specific parameters that you care about: ``` python def __init__(self, path, state, force, check_mode): ```
- You are producing a hex-encoded digest, decoding it back into binary, then encoding it as hex again. - `encode('hex')` (or rather the `hex` codec) is pretty nasty to use, as codecs as supposed to work with Unicode strings. (I suspect that's why you end up doing the encode/decode/encode dance) What about this: fingerprint[algo] = ':'.join(pubkey_digest[i:i+2] for i in range(0, len(pubkey_digest), 2))
This could be `elif`.
True. I kind of like to store the return value into a var and return at the end of the function/method than from the middle of the code.
This could be `elif`.
What about to create shortcuts for all these `p['...']` variables? It would be easier to read the code then: ``` # Create the object swupd = SwUpd(module) # Create shortcuts update = p['update'] verify = p['verify'] state = p['state'] name = p['name'] # Trigger action if update: swupd.update() elif verify: swupd.verify() elif state == "present": swupd.install(name) elif state == "absent": swupd.remove(name) ``` If you would implement the object approach, then you can create more shortcuts in the `__init__()` method. For example for `p["format"]`, `p["manifest"]`, `p["contenturl"]` and `p["versionurl"]` and then use `self.format`, `self.manifest`, `self.contenturl` and `self.versionurl` instead.
Normally, the success should be reported from the `main()` function. The fuctions above (or the object methods if you decide to implement them) should only return values which are used to compose the `exit_json()`.
```suggestion short_description: retrieve info regarding domain objects of all kinds ```
I would also add to `identity`, `filter`, and `ldap_filter` some form of text saying one of the 3 must be set
This should use the proper LDAP attribute name for DN ```suggestion - This value is either the C(distinguishedName) or C(objectGUID) or the AD object to lookup. ```
Should add a point here saying not allowed with `I(identity)`
Should add a point here saying not allowed with `I(identity)`. Should also say the value is the `C(distinguishedName) of the path to search from.`
Default not set in argspec.
Required not set in argspec
Default not set in argspec.
Default not set in argspec.
Default not set in argspec.
Same - please use `len`
Same - please use `len`
Please use `if len(eg_bdms) > 0` instead of directly calling `__sizeof__`
This would put the account in the creds file *above* the params directly passed to the module. This should probably be reversed, as we try to follow the order of specificity (preferring most specific) as: /etc file, $HOME file, environment variable, direct specification on task parameter.
Instead of manually creating log files such as this, it's preferred to use the `module.debug(.........)` method so that the Ansible controller is in charge of deciding whether the logs should be displayed.
This should probably be `if env_variables is not None` so that a user could pass an empty dictionary and wipe out the existing vars, but if they leave it blank the existing settings won't change.
This will also snakify tags, so someone with a tag `MyThing` would actually see it changed to `my_thing` so we should use the `ignore` option on camel2snake to avoid messing with user tags.
We generally don't mask the usernames, just passwords.
That is correct, argument spec is dynamic. If it is not dynamic, then any change to the API would render this module useless. Also, it would require me to write modules for every single API endpoint. There are some specific modules - https://github.com/willwagner602/ansible/tree/will-devel/lib/ansible/modules/network/fortios but there are a lot more of endpoints. So it made sense to let this core module build dynamic argument spec based on the data received from the API.
And just to clarify - currently the argument spec per API endpoint is being cached locally. So if API changes, the file has to be deleted and then it can be recreated again. Here's an example of this file after running a few playbooks: https://pastebin.com/CcPuMQCu
I would also do `not host` as `''` is both a string and not None, but i would argue still an invalid host
so this is valid ``` - hosts: - mailer - local1, local2 ``` but this is not? ``` - hosts: - mailer - [local1, local2] ```
remove 116 and 117 as dupes
CI failure due to python 2.4 syntax error: ``` 2017-02-03 01:32:20 Compiling ./lib/ansible/module_utils/cloudera.py ... 2017-02-03 01:32:20 File "./lib/ansible/module_utils/cloudera.py", line 149 2017-02-03 01:32:20 dictionary = { value:key for key,value in dictionary.items() } 2017-02-03 01:32:20 ^ 2017-02-03 01:32:20 SyntaxError: invalid syntax ```
missing from docs fragment
Same as for the updated, I'd rather say `has been deleted`
use basic.py's `missing_required_lib` function as it gives details on host and python to avoid user confusion
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_PASSWORD']), ```
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_USER']), ```
```suggestion fallback=(env_fallback, ['ANSIBLE_HWC_DOMAIN']), ```
Default value mentioned but not added in argspec.
If module uses the default value of 1 for this argument, we should add it in the doc and argspec.
Default value mentioned but not added in argspec.
Default value not specified in argspec.
Default value not specified in argspec.
Similarly, this option is highly `network_cli`-specific, so much that I'm pretty sure `netconf` doesn't even need it. This should go back to `network_cli`
Just because requests conflates validation and the source of validation truth doesn't necessarily mean we should- I've always disliked that in requests, as it prevents more granular cert validation behavior in the future (or at least makes it more complicated by requiring more config args). That's why I did the pywinrm one the way I did (left the separate arg for CA path and made validation mode a string/enum-y thing rather than boolean)
"message encryption settings"
Maybe `ignore_env_proxy`? Granted, it's Friday and it's been a long week, but `no_proxy: no` (but ignored if proxy is set) made me a little https://media2.giphy.com/media/l2JegIy7RlfhNVsli/200.webp
should probably be `message_encryption` just to be clear
```suggestion type: list elements: str ```
Required when I(shared_access_key) not defined.
Thanks! Note that that only fixes it for v230, not for versions < v230, so #56571 should still be reopened.
Since this check-in action plugin ensures the prompt is out of `configure` mode, we can use `exit discard` here as it always ensures the prompt is changed to operational mode.
When creating a portgroup in the UI, by default, notify_switches is yes. I think we should stay in line with that.
I think changed needs to be set to True here.
Since this isn't being used in any tests I was wondering if it is right that this is a str, or should it be type='float'? I wondered about this for max_utilization too.
Extra spaces before and after `local-ssd#local_ssd_limits` here too.
What rate limits are there on this API? Any account-wide ones will cause inconsistent failures if many playbooks are run at once. On the AWS modules we have common exponential-backoff code that handles this, and the base class could be extended for GCP.
In the module args, you can set certain arguments as mutually exclusive so users don't specify them together. For this module I think resource_url should be exclusive with the _name, _location, and _type options.
I'm not clear on what conditions would trigger this, or what the user's action should be if it did occur.
another case where it functions properly as-is, but an explicit `else: return None` is probably apropos just in case.
`else` is unnecessary here, you could drop it to decent the block. Not sure why this pylint rule is disabled :man_shrugging:
Just to be safe, we should raise an exception here if `ansible.module_utils.basic` was not found. It shouldn't happen, but if it does, the `ImportError` message will be wrong and confusing.
maybe? ```suggestion mod = sys.modules.get(fullname) or self.load_module(fullname) ```
```suggestion - name: Test VMware Tools Connection Plugin for Linux ```
s/user/caller/ (although user creation really is the only safe method if the file is in a world-writable directory).
```suggestion ansible_vmware_validate_certs: False # default is True ```
Nothing specific, wanted to match other module style.
It is available in PR. Added on https://github.com/ansible/ansible/pull/55059/files#diff-2c15779308a54e8ac33b5eba806f6e5bR84
All our parameters that accept lists, accept single items too. But we never offer both the plural and singular version for parameter name. A one-item list, is still a list :-) So I wouldn't bother. IMO offering both is more confusing as people may assume that: ```yaml ssh_key: my-ssh-key ``` means there is only one SSH key to add. That is why I would only have the plural form and no aliases. It will end up to be more consistent between users/playbooks and it's clear the parameter accepts more than one value.
I would not add this alias. We tend to use aliases for backward compatibility or to add consistency between modules. But there's no value in adding this alias here. Rather stick to one parameter name.
it is a user interface, if users don't read docs it can't be our fault. anyways. not a blocker (that is why I used "would")
ansible has some magic and allows this for type list ~~~yaml ssh_keys: mykey ~~~ which is identical to ~~~yaml ssh_keys: [ mykey ] ~~~ therefore I would put an `aliases: [ ssh_key ]`here and in the arg_spec to make it more conventient: ~~~yaml ssh_key: mykey ~~~
```suggestion - Only required if no server I(id) is given or a server does not exists. ```
Sure, warnings are an option. But if it does work as non-root, I wouldn't add the warning.
Right, I see. But a warning is annoying if you run this on purpose like this. (Although one can surpress warnings on a per-task basis). I will leave this up to you to decide.
Why don't you run `netstat -lnptu` instead and parse everything in one go ? Also beware that if this is run as a normal user, you may not get pid information.
Ok, I see. What we tend to do is pass the module to the function instead. But honestly, don't bother.
Add trailing comma for multi-line dicts. ```suggestion supports_check_mode=True, ```
Please use 'msg' for returned messages, this is a standardized return value.
I would say `Deploy key has been updated` instead of `should have been updated`
So removed `required=False` and add `type='str' instead. Do this for the others as well.
Same as for the updated, I'd rather say `has been deleted`
Please make this oauth_token.
Use `to_native` for wrapping error message.
i would add `: %s` and to_text(e)` to the end of msg
There doesn't appear to be any way for `sha1sum_old` to be `None`.
Also: since you're not closing the file, this might break under strange file systems (such under Windows -- no idea if anyone ever tries to do that, tough :) ).
It probably makes sense to create a new `utils.py` module which has a function `write_to_file_if_different(filename, data)` which does the heavy lifting (and where this is done cleanly), so that all the details are only repeated once.
```suggestion - The URLs to retrieve the public I(blob), I(queue), or I(table) object from the secondary location. ```
```suggestion - The status of the primary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - The status of the primary location of the storage account. Possible values are C(available) or C(unavailable). ```
```suggestion - The status of the secondary location of the storage account; either C(available) or C(unavailable). ```
```suggestion - The URLs to retrieve the public I(blob), I(queue), or I(table) object from the primary location. ```
Instead of `namestr`, `name` would be more apt since it will match rest of the modules.
LUNs 1-4095 for private or shared connections, is what the array supports.
```suggestion - Only relevant when C(vlanid) is supplied. ```
You should add datacenter and register to the example.
according arg spec, required=False
right now, this would need to be version_added: '2.6'
Each option entry should be a full sentence, i.e. it starts with a capital and ends with a full stop.
typo: thier -> 'their'
Change to source and remove the alias
This supports more than just URLs, I would add more points talking about what it actually supports.
This code is pretty incomprehensible, I'd try and avoid map and lambda and use a list/dictionary comprenhension (or a for loop if it's still unreadable)
Definitely want to only do this sleep if changed is true, since we don't have to wait for propagation if no changes were made.
Due to rate limiting, you'll have to add `AWSRetry.backoff` on this call so it doesn't fail the whole module if the security group takes longer than expected to create. AWSRetry is boto3 only, so we may want to hold on this until we can migrate this module to boto3.
"One of your CIDR addresses has host bits set. To get rid of this warning, check the network mask and make sure that only network bits are set. [full boto3 error message]"
yes, this was 'old' way when they were not real imports, now they can be moved to top of file and used like normal python imports.
I like this simplification but I believe that it should done somewhere in the core (suggestion for another PR) and not on per-module bases.
Break the line after the `(` to unify the style across the file.
You should really have at least one example with `state=absent`.
I would name the method `passwd_check`.
I would keep the `HAS_LDAP` local to this package. Just set it to `True` after you import it bellow.
If we can get away with it, I'd like to change this to same so that touch is idempotent by default. But probably need to run it by the other committers. It is backwards incompatible but more sensible API (If the other committers deem backwards compatibility to be that important, then jborean's proposal sounds best. If timestamp is None: use correct default for the state specified)
At yesterday's meeting we didn't quite decide the question of the default value decisively (only three people registered an opinion on it) but of the three there seemed to be more enthusiasm for adding the ability for "state=file" to create files (phased in via a deprecation period because of backwards compatibility concerns) rather than having touch default to keeping the same timestamp. So if you want to be proactive, you should probably update this to have the split defaults as @jborean93 suggested. There was some bikeshedding about the special names as well: * There was a desire to make None mean "same" but I don't think we can do that with the split default (None means, do the default. And since it has two meanings, we need a different special word to mean keep the timestamp the same) * In the end people thought that "preserve" would be better than "same" (since that's used in copy to keep a file source's mode which is somewhat similar.)
Doesn't look like this got merged intime, so `2.8` here (and other places
there is no need to version params for new modules
```suggestion The C(address_list) is a comma-separated list of one or more address/netmask pairs in CIDR format." ```
It would be a nice idea to have return dict. not blocker though.
```suggestion type: str required: True ```
Add a blank after this to notify that these are two separate tasks.
```suggestion - Whether to power on the VM after cloning. ```
```suggestion - The state of Virtual Machine deployed. ```
Will fail if `self.manager_uri` is not set yet.
Will fail if `self.systems_uri` is not set yet.
Not catching non-200 responses.
Not catching non-200 responses.
Useless loop, since it can be merged with the next one.
You don't return this one as well. Only specify things in `RETURN` which you actually return!
You are not returning this.
```suggestion description: JSON parsed response from the server ```
```suggestion description: The error message returned by the Gitlab API ``` The same for the next one.
```suggestion - name: Delete one variable ``` For consistency (compare the other example)
```suggestion - Threshold for defining a lossy connection by packets that time out and get retransmitted. - A connection between client and Avi is considered lossy when more than this percentage of packets are retransmitted due to timeout. ```
Original spelling of `transmitted` was correct: ```suggestion - Threshold for defining a lossy connection by packets not transmitted due to window size. - A client connection is considered lossy when percentage of times a packet could not be transmitted due to TCP zero window is above this threshold. ```
Follow pattern as above. And revert to the correct spelling of `transmitted`.
Here too, I wouldn't capitalize PageLoad (though I would capitalize DNS and HTTP). ```suggestion - A pageload includes the time for DNS lookup, download of all HTTP objects, and page render time. ```
Original spelling was correct: ```suggestion - It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisfied latency. ```
This code will traceback if the dirname component has non-ascii characters in it on Python2. ``` >>> os.path.dirname(os.path.abspath(b'/var/tmp/cafÃ©/test_ios.py')).encode('utf-8') Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 12: ordinal not in range(128) ``` We also have the convdention of using a ```b_``` prefix on any variable which holds byte strings. So, use something like this instead: ``` python from ansible.module_utils._text import to_bytes b_FIXTURE_DIR = b'%s/fixtures/ios' % to_bytes(path.dirname(path.abspath(__file__)), errors='surrogate_or_strict') ```
```suggestion re.compile(br'[\r\n]?<.+>(?:\s*)$'), ``` And so on for all the entries of both `terminal_stdout_re` and `terminal_stderr_re`.
Typo in `module_utils`.
Well you don't need the `if`, you can just run `.replace()` and it'll do the right thing regardless of whether there's a slash in the string.
Right, but `'show_vlan'.replace('2/1', '')` is still `'show_vlan'`. Unless I am missing something painfully obvious, the condition is not needed. (I will admit that I am picking nigh infinitesimal nits here... the rest of this is just fine and you could just merge it if you want)
I've also double checked what happens in the scenario you mentioned, and below is the result I receive. So I actually this this method is fine, and there is no need to change it Apart from ensuring the params are not None before checking if they are an existing file. ``` BotoServerError: 400 Bad Request\n<ErrorResponse xmlns=\"https://iam.amazonaws.com/doc/2010-05-08/\"> <Error> <Type>Sender</Type> <Code>MalformedCertificate</Code> <Message>Unable to parse certificate. Please ensure the certificate is in PEM format.</Message> </Error> ```
And unfortunately it looks like iam doens't require you to have the PEM headers. At least via the gui anyway, so assuming its the same for CLI
No, because someone could fat-finger a path such as `secretsss/cert.pem` when really the directory is called `secrets`. Then the `isfile` would fail and the module would try to upload the *string of the broken path* `secretsss/cert.pem` as the actual cert body (which would fail)
I'm going to add a commit to do `if os.path.exists(module.params.get('cert')):` instead of try/except.
This module doesn't support check mode. I'm not sure if this is the best method to do this either though.
Not required with AnsibleAWSModule
boto3_conn now handles region problems, no need to do it in the module
The line length limit [enforced by CI](https://github.com/ansible/ansible/blob/869449e288cc02986984daec430086f6b6fe656f/test/runner/lib/sanity.py#L317) is 160 characters.
CamelCase for consistency? This one could go either way since it's a new arg, but would depend on if there's a bigger plan to move everything else in this module toward snake_case
This logic seems ignore the use case of removing all tags.
You know you have a real problem when CI fails and people are discussing why that might be :-P
I suspect this line is the problem with the yaml validation failure as \ indicates to yaml a line continuation, I think. To use a \ like this it would need to be inside single quotes. Likely the same issue on lines 72, 74 and 75
The problem is the fact that we are missing an `args:` key.
Typo: exists -> exist (should be singular). I'm not really sure this is an improvement as you lose the explanation of what 'args' can be used for.
The double backslashes are not needed here. They are actually unwanted.
In order to improve readability (meaning the change described below isn't required): * `delete_cert`, `import_pkcs12_path`, `import_cert_path` and `import_cert_url` never return (either `exit_json` or ` fail_json` are called) * it's quite disturbing that `changed` isn't set (and it doesn't need to be set) when `delete_cert` is called then i would rather call `module.exit_json(changed=changed)` here (then keep `module.exit_json(changed=False)` unchanged at the end the file.
```suggestion trust_cacert: True ```
Please keep the blank line
```suggestion - Certificate content to load. One of I(cert_url) or I(cert_path) or I(cert_content) is required to load certificate. ```
Should not that be: ```suggestion msg="Using 'cert_content' argument requires 'cert_alias' argument.") ```
@ShachafGoldstein I think that you inverted the `name` and the `value` parameters here: It should be: ``` name: "1.1.1" ```
There is no state `get`.
CI failure due to python 2.4 syntax error: ``` 2017-02-07 17:14:00 Compiling ./lib/ansible/modules/network/nsupdate.py ... 2017-02-07 17:14:00 File "./lib/ansible/modules/network/nsupdate.py", line 178 2017-02-07 17:14:00 except binascii_error as e: 2017-02-07 17:14:00 ^ 2017-02-07 17:14:00 SyntaxError: invalid syntax ```
Please separate this into separate lines for maximum readability. Something like: ``` if inst.image is not None: image = inst.image.split('/')[-1] else: image = None ```
Please separate this clause into separate lines for maximum readability (like above).
I think this needs to move out one indentation level to match `Field`
I think it was because load_balancer_attributes is being modified while the contents are iterated over. In python2 I think .items() returns a list? Whereas python3 returns an iterator. So list(load_balancer_attributes.items()) makes it works because then the dict isn't part of the iteration process then. Sorry for not including the traceback before. When I retest if I run into any failures I'll remember to share that. I think the Exception was `RuntimeError: dictionary changed size during iteration`
This fails on Python 3. Can you change it to `for k, v in list(load_balancer_attributes.items()):`? Looks good to merge after that.
Please add the kwarg `exception=traceback.format_exc()` to this failure.
Can import HAS_BOTO3 instead from ansible.module_utils.ec2
```suggestion the I(verification_method) will be updated and validation data (if applicable) will be returned. ```
```suggestion - There is a small delay (typically about 5 seconds, but can be as long as 60 seconds) before obtaining the random values when requesting a validation ```
```suggestion - There is a small delay (typically about 5 seconds, but can be as long as 30 seconds) before obtaining the random values when requesting a validation. ```
This is always a tough question, and I'm not sure what's the best solution :) In Ansible, things are usually lower-case. I guess you have to decide what you want in the end :)
How about lower-case? ```suggestion choices: [ 'dns', 'email', 'manual', 'webserver'] ```
```suggestion vmware_host_snmp: ```
I think this irrelevant, need to change according to SNMP output.
We prefer that examples show sensible values, so people understand what is expected. If you add variables like this, there's no clue what the actual content would be.
The aim of having a `vcenter` connection plugin, would be that the connection information of the guest would store the vcenter info/credentials, so that we wouldn't need to repeat this information. And we should probably use the same connection variables for both the `vcenter` and `vmware_tools` connection plugins. cc @dericcrago
Something similar - https://github.com/ansible/ansible/blob/fb72a5424cab097d28670d00cf107fd515cee3f0/lib/ansible/modules/cloud/vmware/vmware_host_lockdown.py#L114
If the file isn't open in binary mode, there is no reason to decode here. ```suggestion line = line.strip() ```
After looking at this some more, I don't see a good reason to open the file in binary mode only to convert each line to native string type for further manipulation. ```suggestion with open(self.USER_ATTR, 'r') as file_handler: ```
Rather than use a `lamdba` here, it would be better to use a generator expression for clarity ```suggestion lines = line.split('::::')[1].split(';') tmp = dict(x.split('=') for x in lines) ```
Can you move this function above main() as per ansible guildelines: " Ansible follows C-style code flow where the caller functions/methods are towards the bottom of the file and the callee implementations are above them. "
In the case of exception print the exception e. Getting self-heal status can fail for various reasons, this error message is wrong. If the status option is wrong ansible takes care of printing it, since we have provided possible options.
You're correctly using `type='list'` in the arg_spec, so probably better if at least one example used the native YAML format and showed multiple values as list elements. The arg validator will properly handle coercion of a single value to a list (as the current examples show).
All the more reason to not use key=value format in the samples; works fine with YAML
@carchi8py it's declared at int below, so this should be a safe change.
that's a good idea. But we're concerned about changing the logic so late. One question. With type: bool, can we still have three values: True, False, and None? We're using None to know whether the user wants a change or does not care about the current state.
@carchi8py : enable/disable UDP protocol It would be nice to have a default of 'enabled'
Please format this like this: ```python repo = { "id": repo_id, "name": repo_name, "url": repo_url, "enabled": True if repo_enabled == '1' else False } ```
i.e freebsd has had 'service' (iirc since 8.0) but it actually uses a rc init system, not sysV.
its more 'esoteric' distros or 'non linuces' that worry me, but ... we can wait for feedback as i hope those targets have 'fixed' their divergences
CI failure due to missing newline at end of file: ``` 2017-02-06 02:26:40 ERROR: PEP 8: lib/ansible/modules/system/java_cert.py:282:11: W292 no newline at end of file (current) ```
Default needs adding to docs
